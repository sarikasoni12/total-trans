/*! For license information please see app.js.LICENSE.txt */
!function (t) {
    var e = {};

    function n(a) {
        if (e[a]) return e[a].exports;
        var i = e[a] = {i: a, l: !1, exports: {}};
        return t[a].call(i.exports, i, i.exports, n), i.l = !0, i.exports
    }

    n.m = t, n.c = e, n.d = function (t, e, a) {
        n.o(t, e) || Object.defineProperty(t, e, {enumerable: !0, get: a})
    }, n.r = function (t) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {value: "Module"}), Object.defineProperty(t, "__esModule", {value: !0})
    }, n.t = function (t, e) {
        if (1 & e && (t = n(t)), 8 & e) return t;
        if (4 & e && "object" == typeof t && t && t.__esModule) return t;
        var a = Object.create(null);
        if (n.r(a), Object.defineProperty(a, "default", {
            enumerable: !0,
            value: t
        }), 2 & e && "string" != typeof t) for (var i in t) n.d(a, i, function (e) {
            return t[e]
        }.bind(null, i));
        return a
    }, n.n = function (t) {
        var e = t && t.__esModule ? function () {
            return t.default
        } : function () {
            return t
        };
        return n.d(e, "a", e), e
    }, n.o = function (t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, n.p = "", n(n.s = 275)
}([function (t, e, n) {
    var a = n(26)("wks"), i = n(21), r = n(1).Symbol, o = "function" == typeof r;
    (t.exports = function (t) {
        return a[t] || (a[t] = o && r[t] || (o ? r : i)("Symbol." + t))
    }).store = a
}, function (t, e) {
    var n = t.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
    "number" == typeof __g && (__g = n)
}, function (t, e, n) {
    var a = n(14);
    t.exports = function (t) {
        if (!a(t)) throw TypeError(t + " is not an object!");
        return t
    }
}, function (t, e) {
    var n;
    n = function () {
        return this
    }();
    try {
        n = n || new Function("return this")()
    } catch (t) {
        "object" == typeof window && (n = window)
    }
    t.exports = n
}, function (t, e, n) {
    var a = n(5), i = n(20);
    t.exports = n(6) ? function (t, e, n) {
        return a.f(t, e, i(1, n))
    } : function (t, e, n) {
        return t[e] = n, t
    }
}, function (t, e, n) {
    var a = n(2), i = n(49), r = n(37), o = Object.defineProperty;
    e.f = n(6) ? Object.defineProperty : function (t, e, n) {
        if (a(t), e = r(e, !0), a(n), i) try {
            return o(t, e, n)
        } catch (t) {
        }
        if ("get" in n || "set" in n) throw TypeError("Accessors not supported!");
        return "value" in n && (t[e] = n.value), t
    }
}, function (t, e, n) {
    t.exports = !n(9)((function () {
        return 7 != Object.defineProperty({}, "a", {
            get: function () {
                return 7
            }
        }).a
    }))
}, function (t, e, n) {
    (function (e) {
        var n = function (t) {
            return t && t.Math == Math && t
        };
        t.exports = n("object" == typeof globalThis && globalThis) || n("object" == typeof window && window) || n("object" == typeof self && self) || n("object" == typeof e && e) || Function("return this")()
    }).call(this, n(3))
}, function (t, e, n) {
    var a = n(1), i = n(17), r = n(4), o = n(12), s = n(61), l = function (t, e, n) {
        var c, d, u, h, p = t & l.F, f = t & l.G, g = t & l.S, m = t & l.P, v = t & l.B,
            b = f ? a : g ? a[e] || (a[e] = {}) : (a[e] || {}).prototype, y = f ? i : i[e] || (i[e] = {}),
            x = y.prototype || (y.prototype = {});
        for (c in f && (n = e), n) u = ((d = !p && b && void 0 !== b[c]) ? b : n)[c], h = v && d ? s(u, a) : m && "function" == typeof u ? s(Function.call, u) : u, b && o(b, c, u, t & l.U), y[c] != u && r(y, c, h), m && x[c] != u && (x[c] = u)
    };
    a.core = i, l.F = 1, l.G = 2, l.S = 4, l.P = 8, l.B = 16, l.W = 32, l.U = 64, l.R = 128, t.exports = l
}, function (t, e) {
    t.exports = function (t) {
        try {
            return !!t()
        } catch (t) {
            return !0
        }
    }
}, function (t, e) {
    var n = {}.hasOwnProperty;
    t.exports = function (t, e) {
        return n.call(t, e)
    }
}, function (t, e, n) {
    var a = n(80), i = n(25);
    t.exports = function (t) {
        return a(i(t))
    }
}, function (t, e, n) {
    var a = n(1), i = n(4), r = n(10), o = n(21)("src"), s = n(79), l = "toString", c = ("" + s).split(l);
    n(17).inspectSource = function (t) {
        return s.call(t)
    }, (t.exports = function (t, e, n, s) {
        var l = "function" == typeof n;
        l && (r(n, "name") || i(n, "name", e)), t[e] !== n && (l && (r(n, o) || i(n, o, t[e] ? "" + t[e] : c.join(String(e)))), t === a ? t[e] = n : s ? t[e] ? t[e] = n : i(t, e, n) : (delete t[e], i(t, e, n)))
    })(Function.prototype, l, (function () {
        return "function" == typeof this && this[o] || s.call(this)
    }))
}, function (t, e) {
    t.exports = function (t) {
        try {
            return !!t()
        } catch (t) {
            return !0
        }
    }
}, function (t, e) {
    t.exports = function (t) {
        return "object" == typeof t ? null !== t : "function" == typeof t
    }
}, function (t, e, n) {
    var a = n(7), i = n(125), r = n(19), o = n(105), s = n(132), l = n(186), c = i("wks"), d = a.Symbol,
        u = l ? d : d && d.withoutSetter || o;
    t.exports = function (t) {
        return r(c, t) || (s && r(d, t) ? c[t] = d[t] : c[t] = u("Symbol." + t)), c[t]
    }
}, function (t, e, n) {
    (function (e) {
        t.exports = e.jQuery = n(159)
    }).call(this, n(3))
}, function (t, e) {
    var n = t.exports = {version: "2.6.5"};
    "number" == typeof __e && (__e = n)
}, function (t, e, n) {
    var a = n(51), i = n(39);
    t.exports = Object.keys || function (t) {
        return a(t, i)
    }
}, function (t, e) {
    var n = {}.hasOwnProperty;
    t.exports = function (t, e) {
        return n.call(t, e)
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return {enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e}
    }
}, function (t, e) {
    var n = 0, a = Math.random();
    t.exports = function (t) {
        return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + a).toString(36))
    }
}, function (t, e) {
    t.exports = function (t) {
        return "object" == typeof t ? null !== t : "function" == typeof t
    }
}, function (t, e, n) {
    var a = n(22);
    t.exports = function (t) {
        if (!a(t)) throw TypeError(String(t) + " is not an object");
        return t
    }
}, function (t, e) {
    t.exports = function (t) {
        function e(t) {
            "undefined" != typeof console && (console.error || console.log)("[Script Loader]", t)
        }

        try {
            "undefined" != typeof execScript && "undefined" != typeof attachEvent && "undefined" == typeof addEventListener ? execScript(t) : "undefined" != typeof eval ? eval.call(null, t) : e("EvalError: No eval function available")
        } catch (t) {
            e(t)
        }
    }
}, function (t, e) {
    t.exports = function (t) {
        if (null == t) throw TypeError("Can't call method on  " + t);
        return t
    }
}, function (t, e, n) {
    var a = n(17), i = n(1), r = "__core-js_shared__", o = i[r] || (i[r] = {});
    (t.exports = function (t, e) {
        return o[t] || (o[t] = void 0 !== e ? e : {})
    })("versions", []).push({
        version: a.version,
        mode: n(27) ? "pure" : "global",
        copyright: "Â© 2019 Denis Pushkarev (zloirock.ru)"
    })
}, function (t, e) {
    t.exports = !1
}, function (t, e) {
    var n = {}.toString;
    t.exports = function (t) {
        return n.call(t).slice(8, -1)
    }
}, function (t, e) {
    var n = Math.ceil, a = Math.floor;
    t.exports = function (t) {
        return isNaN(t = +t) ? 0 : (t > 0 ? a : n)(t)
    }
}, function (t, e) {
    t.exports = {}
}, function (t, e, n) {
    var a = n(25);
    t.exports = function (t) {
        return Object(a(t))
    }
}, function (t, e, n) {
    var a = n(36), i = n(41), r = n(101);
    t.exports = a ? function (t, e, n) {
        return i.f(t, e, r(1, n))
    } : function (t, e, n) {
        return t[e] = n, t
    }
}, function (t, e, n) {
    var a = n(29), i = Math.min;
    t.exports = function (t) {
        return t > 0 ? i(a(t), 9007199254740991) : 0
    }
}, function (t, e) {
    e.f = {}.propertyIsEnumerable
}, function (t, e, n) {
    var a = n(7), i = n(117).f, r = n(32), o = n(47), s = n(102), l = n(178), c = n(128);
    t.exports = function (t, e) {
        var n, d, u, h, p, f = t.target, g = t.global, m = t.stat;
        if (n = g ? a : m ? a[f] || s(f, {}) : (a[f] || {}).prototype) for (d in e) {
            if (h = e[d], u = t.noTargetGet ? (p = i(n, d)) && p.value : n[d], !c(g ? d : f + (m ? "." : "#") + d, t.forced) && void 0 !== u) {
                if (typeof h == typeof u) continue;
                l(h, u)
            }
            (t.sham || u && u.sham) && r(h, "sham", !0), o(n, d, h, t)
        }
    }
}, function (t, e, n) {
    var a = n(13);
    t.exports = !a((function () {
        return 7 != Object.defineProperty({}, 1, {
            get: function () {
                return 7
            }
        })[1]
    }))
}, function (t, e, n) {
    var a = n(14);
    t.exports = function (t, e) {
        if (!a(t)) return t;
        var n, i;
        if (e && "function" == typeof (n = t.toString) && !a(i = n.call(t))) return i;
        if ("function" == typeof (n = t.valueOf) && !a(i = n.call(t))) return i;
        if (!e && "function" == typeof (n = t.toString) && !a(i = n.call(t))) return i;
        throw TypeError("Can't convert object to primitive value")
    }
}, function (t, e, n) {
    var a = n(26)("keys"), i = n(21);
    t.exports = function (t) {
        return a[t] || (a[t] = i(t))
    }
}, function (t, e) {
    t.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
}, function (t, e, n) {
    var a = n(5).f, i = n(10), r = n(0)("toStringTag");
    t.exports = function (t, e, n) {
        t && !i(t = n ? t : t.prototype, r) && a(t, r, {configurable: !0, value: e})
    }
}, function (t, e, n) {
    var a = n(36), i = n(120), r = n(23), o = n(119), s = Object.defineProperty;
    e.f = a ? s : function (t, e, n) {
        if (r(t), e = o(e, !0), r(n), i) try {
            return s(t, e, n)
        } catch (t) {
        }
        if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
        return "value" in n && (t[e] = n.value), t
    }
}, function (t, e, n) {
    var a = n(51), i = n(39).concat("length", "prototype");
    e.f = Object.getOwnPropertyNames || function (t) {
        return a(t, i)
    }
}, function (t, e) {
    e.f = Object.getOwnPropertySymbols
}, function (t, e, n) {
    var a = n(28), i = n(0)("toStringTag"), r = "Arguments" == a(function () {
        return arguments
    }());
    t.exports = function (t) {
        var e, n, o;
        return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) {
            try {
                return t[e]
            } catch (t) {
            }
        }(e = Object(t), i)) ? n : r ? a(e) : "Object" == (o = a(e)) && "function" == typeof e.callee ? "Arguments" : o
    }
}, function (t, e, n) {
    "use strict";
    var a, i, r = n(56), o = RegExp.prototype.exec, s = String.prototype.replace, l = o,
        c = (a = /a/, i = /b*/g, o.call(a, "a"), o.call(i, "a"), 0 !== a.lastIndex || 0 !== i.lastIndex),
        d = void 0 !== /()??/.exec("")[1];
    (c || d) && (l = function (t) {
        var e, n, a, i, l = this;
        return d && (n = new RegExp("^" + l.source + "$(?!\\s)", r.call(l))), c && (e = l.lastIndex), a = o.call(l, t), c && a && (l.lastIndex = l.global ? a.index + a[0].length : e), d && a && a.length > 1 && s.call(a[0], n, (function () {
            for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (a[i] = void 0)
        })), a
    }), t.exports = l
}, function (t, e) {
    t.exports = function (t) {
        if (null == t) throw TypeError("Can't call method on " + t);
        return t
    }
}, function (t, e, n) {
    var a = n(7), i = n(32), r = n(19), o = n(102), s = n(122), l = n(57), c = l.get, d = l.enforce,
        u = String(String).split("String");
    (t.exports = function (t, e, n, s) {
        var l = !!s && !!s.unsafe, c = !!s && !!s.enumerable, h = !!s && !!s.noTargetGet;
        "function" == typeof n && ("string" != typeof e || r(n, "name") || i(n, "name", e), d(n).source = u.join("string" == typeof e ? e : "")), t !== a ? (l ? !h && t[e] && (c = !0) : delete t[e], c ? t[e] = n : i(t, e, n)) : c ? t[e] = n : o(e, n)
    })(Function.prototype, "toString", (function () {
        return "function" == typeof this && c(this).source || s(this)
    }))
}, function (t, e, n) {
    var a = n(76), i = Math.min;
    t.exports = function (t) {
        return t > 0 ? i(a(t), 9007199254740991) : 0
    }
}, function (t, e, n) {
    t.exports = !n(6) && !n(9)((function () {
        return 7 != Object.defineProperty(n(50)("div"), "a", {
            get: function () {
                return 7
            }
        }).a
    }))
}, function (t, e, n) {
    var a = n(14), i = n(1).document, r = a(i) && a(i.createElement);
    t.exports = function (t) {
        return r ? i.createElement(t) : {}
    }
}, function (t, e, n) {
    var a = n(10), i = n(11), r = n(63)(!1), o = n(38)("IE_PROTO");
    t.exports = function (t, e) {
        var n, s = i(t), l = 0, c = [];
        for (n in s) n != o && a(s, n) && c.push(n);
        for (; e.length > l;) a(s, n = e[l++]) && (~r(c, n) || c.push(n));
        return c
    }
}, function (t, e, n) {
    e.f = n(0)
}, function (t, e, n) {
    var a = n(2), i = n(86), r = n(39), o = n(38)("IE_PROTO"), s = function () {
    }, l = function () {
        var t, e = n(50)("iframe"), a = r.length;
        for (e.style.display = "none", n(87).appendChild(e), e.src = "javascript:", (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), l = t.F; a--;) delete l.prototype[r[a]];
        return l()
    };
    t.exports = Object.create || function (t, e) {
        var n;
        return null !== t ? (s.prototype = a(t), n = new s, s.prototype = null, n[o] = t) : n = l(), void 0 === e ? n : i(n, e)
    }
}, function (t, e, n) {
    "use strict";
    var a = n(55), i = n(90), r = n(30), o = n(11);
    t.exports = n(67)(Array, "Array", (function (t, e) {
        this._t = o(t), this._i = 0, this._k = e
    }), (function () {
        var t = this._t, e = this._k, n = this._i++;
        return !t || n >= t.length ? (this._t = void 0, i(1)) : i(0, "keys" == e ? n : "values" == e ? t[n] : [n, t[n]])
    }), "values"), r.Arguments = r.Array, a("keys"), a("values"), a("entries")
}, function (t, e, n) {
    var a = n(0)("unscopables"), i = Array.prototype;
    null == i[a] && n(4)(i, a, {}), t.exports = function (t) {
        i[a][t] = !0
    }
}, function (t, e, n) {
    "use strict";
    var a = n(2);
    t.exports = function () {
        var t = a(this), e = "";
        return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
    }
}, function (t, e, n) {
    var a, i, r, o = n(124), s = n(7), l = n(22), c = n(32), d = n(19), u = n(103), h = n(75), p = s.WeakMap;
    if (o) {
        var f = new p, g = f.get, m = f.has, v = f.set;
        a = function (t, e) {
            return v.call(f, t, e), e
        }, i = function (t) {
            return g.call(f, t) || {}
        }, r = function (t) {
            return m.call(f, t)
        }
    } else {
        var b = u("state");
        h[b] = !0, a = function (t, e) {
            return c(t, b, e), e
        }, i = function (t) {
            return d(t, b) ? t[b] : {}
        }, r = function (t) {
            return d(t, b)
        }
    }
    t.exports = {
        set: a, get: i, has: r, enforce: function (t) {
            return r(t) ? i(t) : a(t, {})
        }, getterFor: function (t) {
            return function (e) {
                var n;
                if (!l(e) || (n = i(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
                return n
            }
        }
    }
}, function (t, e, n) {
    var a = n(46);
    t.exports = function (t) {
        return Object(a(t))
    }
}, function (t, e) {
    t.exports = {}
}, function (t, e, n) {
    t.exports = function (t) {
        "use strict";

        function e(t, e) {
            return t(e = {exports: {}}, e.exports), e.exports
        }

        function n(t) {
            return t && t.default || t
        }

        t = t && t.hasOwnProperty("default") ? t.default : t;
        var a = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
        }, i = e((function (t) {
            var e = {};
            for (var n in a) a.hasOwnProperty(n) && (e[a[n]] = n);
            var i = t.exports = {
                rgb: {channels: 3, labels: "rgb"},
                hsl: {channels: 3, labels: "hsl"},
                hsv: {channels: 3, labels: "hsv"},
                hwb: {channels: 3, labels: "hwb"},
                cmyk: {channels: 4, labels: "cmyk"},
                xyz: {channels: 3, labels: "xyz"},
                lab: {channels: 3, labels: "lab"},
                lch: {channels: 3, labels: "lch"},
                hex: {channels: 1, labels: ["hex"]},
                keyword: {channels: 1, labels: ["keyword"]},
                ansi16: {channels: 1, labels: ["ansi16"]},
                ansi256: {channels: 1, labels: ["ansi256"]},
                hcg: {channels: 3, labels: ["h", "c", "g"]},
                apple: {channels: 3, labels: ["r16", "g16", "b16"]},
                gray: {channels: 1, labels: ["gray"]}
            };
            for (var r in i) if (i.hasOwnProperty(r)) {
                if (!("channels" in i[r])) throw new Error("missing channels property: " + r);
                if (!("labels" in i[r])) throw new Error("missing channel labels property: " + r);
                if (i[r].labels.length !== i[r].channels) throw new Error("channel and label counts mismatch: " + r);
                var o = i[r].channels, s = i[r].labels;
                delete i[r].channels, delete i[r].labels, Object.defineProperty(i[r], "channels", {value: o}), Object.defineProperty(i[r], "labels", {value: s})
            }

            function l(t, e) {
                return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2)
            }

            i.rgb.hsl = function (t) {
                var e, n, a = t[0] / 255, i = t[1] / 255, r = t[2] / 255, o = Math.min(a, i, r), s = Math.max(a, i, r),
                    l = s - o;
                return s === o ? e = 0 : a === s ? e = (i - r) / l : i === s ? e = 2 + (r - a) / l : r === s && (e = 4 + (a - i) / l), (e = Math.min(60 * e, 360)) < 0 && (e += 360), n = (o + s) / 2, [e, 100 * (s === o ? 0 : n <= .5 ? l / (s + o) : l / (2 - s - o)), 100 * n]
            }, i.rgb.hsv = function (t) {
                var e, n, a, i, r, o = t[0] / 255, s = t[1] / 255, l = t[2] / 255, c = Math.max(o, s, l),
                    d = c - Math.min(o, s, l), u = function (t) {
                        return (c - t) / 6 / d + .5
                    };
                return 0 === d ? i = r = 0 : (r = d / c, e = u(o), n = u(s), a = u(l), o === c ? i = a - n : s === c ? i = 1 / 3 + e - a : l === c && (i = 2 / 3 + n - e), i < 0 ? i += 1 : i > 1 && (i -= 1)), [360 * i, 100 * r, 100 * c]
            }, i.rgb.hwb = function (t) {
                var e = t[0], n = t[1], a = t[2];
                return [i.rgb.hsl(t)[0], 1 / 255 * Math.min(e, Math.min(n, a)) * 100, 100 * (a = 1 - 1 / 255 * Math.max(e, Math.max(n, a)))]
            }, i.rgb.cmyk = function (t) {
                var e, n = t[0] / 255, a = t[1] / 255, i = t[2] / 255;
                return [100 * ((1 - n - (e = Math.min(1 - n, 1 - a, 1 - i))) / (1 - e) || 0), 100 * ((1 - a - e) / (1 - e) || 0), 100 * ((1 - i - e) / (1 - e) || 0), 100 * e]
            }, i.rgb.keyword = function (t) {
                var n = e[t];
                if (n) return n;
                var i, r = 1 / 0;
                for (var o in a) if (a.hasOwnProperty(o)) {
                    var s = l(t, a[o]);
                    s < r && (r = s, i = o)
                }
                return i
            }, i.keyword.rgb = function (t) {
                return a[t]
            }, i.rgb.xyz = function (t) {
                var e = t[0] / 255, n = t[1] / 255, a = t[2] / 255;
                return [100 * (.4124 * (e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92) + .3576 * (n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92) + .1805 * (a = a > .04045 ? Math.pow((a + .055) / 1.055, 2.4) : a / 12.92)), 100 * (.2126 * e + .7152 * n + .0722 * a), 100 * (.0193 * e + .1192 * n + .9505 * a)]
            }, i.rgb.lab = function (t) {
                var e = i.rgb.xyz(t), n = e[0], a = e[1], r = e[2];
                return a /= 100, r /= 108.883, n = (n /= 95.047) > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, [116 * (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116) - 16, 500 * (n - a), 200 * (a - (r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116))]
            }, i.hsl.rgb = function (t) {
                var e, n, a, i, r, o = t[0] / 360, s = t[1] / 100, l = t[2] / 100;
                if (0 === s) return [r = 255 * l, r, r];
                e = 2 * l - (n = l < .5 ? l * (1 + s) : l + s - l * s), i = [0, 0, 0];
                for (var c = 0; c < 3; c++) (a = o + 1 / 3 * -(c - 1)) < 0 && a++, a > 1 && a--, r = 6 * a < 1 ? e + 6 * (n - e) * a : 2 * a < 1 ? n : 3 * a < 2 ? e + (n - e) * (2 / 3 - a) * 6 : e, i[c] = 255 * r;
                return i
            }, i.hsl.hsv = function (t) {
                var e = t[0], n = t[1] / 100, a = t[2] / 100, i = n, r = Math.max(a, .01);
                return n *= (a *= 2) <= 1 ? a : 2 - a, i *= r <= 1 ? r : 2 - r, [e, 100 * (0 === a ? 2 * i / (r + i) : 2 * n / (a + n)), (a + n) / 2 * 100]
            }, i.hsv.rgb = function (t) {
                var e = t[0] / 60, n = t[1] / 100, a = t[2] / 100, i = Math.floor(e) % 6, r = e - Math.floor(e),
                    o = 255 * a * (1 - n), s = 255 * a * (1 - n * r), l = 255 * a * (1 - n * (1 - r));
                switch (a *= 255, i) {
                    case 0:
                        return [a, l, o];
                    case 1:
                        return [s, a, o];
                    case 2:
                        return [o, a, l];
                    case 3:
                        return [o, s, a];
                    case 4:
                        return [l, o, a];
                    case 5:
                        return [a, o, s]
                }
            }, i.hsv.hsl = function (t) {
                var e, n, a, i = t[0], r = t[1] / 100, o = t[2] / 100, s = Math.max(o, .01);
                return a = (2 - r) * o, n = r * s, [i, 100 * (n = (n /= (e = (2 - r) * s) <= 1 ? e : 2 - e) || 0), 100 * (a /= 2)]
            }, i.hwb.rgb = function (t) {
                var e, n, a, i, r, o, s, l = t[0] / 360, c = t[1] / 100, d = t[2] / 100, u = c + d;
                switch (u > 1 && (c /= u, d /= u), a = 6 * l - (e = Math.floor(6 * l)), 0 != (1 & e) && (a = 1 - a), i = c + a * ((n = 1 - d) - c), e) {
                    default:
                    case 6:
                    case 0:
                        r = n, o = i, s = c;
                        break;
                    case 1:
                        r = i, o = n, s = c;
                        break;
                    case 2:
                        r = c, o = n, s = i;
                        break;
                    case 3:
                        r = c, o = i, s = n;
                        break;
                    case 4:
                        r = i, o = c, s = n;
                        break;
                    case 5:
                        r = n, o = c, s = i
                }
                return [255 * r, 255 * o, 255 * s]
            }, i.cmyk.rgb = function (t) {
                var e = t[0] / 100, n = t[1] / 100, a = t[2] / 100, i = t[3] / 100;
                return [255 * (1 - Math.min(1, e * (1 - i) + i)), 255 * (1 - Math.min(1, n * (1 - i) + i)), 255 * (1 - Math.min(1, a * (1 - i) + i))]
            }, i.xyz.rgb = function (t) {
                var e, n, a, i = t[0] / 100, r = t[1] / 100, o = t[2] / 100;
                return n = -.9689 * i + 1.8758 * r + .0415 * o, a = .0557 * i + -.204 * r + 1.057 * o, e = (e = 3.2406 * i + -1.5372 * r + -.4986 * o) > .0031308 ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : 12.92 * e, n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, a = a > .0031308 ? 1.055 * Math.pow(a, 1 / 2.4) - .055 : 12.92 * a, [255 * (e = Math.min(Math.max(0, e), 1)), 255 * (n = Math.min(Math.max(0, n), 1)), 255 * (a = Math.min(Math.max(0, a), 1))]
            }, i.xyz.lab = function (t) {
                var e = t[0], n = t[1], a = t[2];
                return n /= 100, a /= 108.883, e = (e /= 95.047) > .008856 ? Math.pow(e, 1 / 3) : 7.787 * e + 16 / 116, [116 * (n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) - 16, 500 * (e - n), 200 * (n - (a = a > .008856 ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116))]
            }, i.lab.xyz = function (t) {
                var e, n, a, i = t[0];
                e = t[1] / 500 + (n = (i + 16) / 116), a = n - t[2] / 200;
                var r = Math.pow(n, 3), o = Math.pow(e, 3), s = Math.pow(a, 3);
                return n = r > .008856 ? r : (n - 16 / 116) / 7.787, e = o > .008856 ? o : (e - 16 / 116) / 7.787, a = s > .008856 ? s : (a - 16 / 116) / 7.787, [e *= 95.047, n *= 100, a *= 108.883]
            }, i.lab.lch = function (t) {
                var e, n = t[0], a = t[1], i = t[2];
                return (e = 360 * Math.atan2(i, a) / 2 / Math.PI) < 0 && (e += 360), [n, Math.sqrt(a * a + i * i), e]
            }, i.lch.lab = function (t) {
                var e, n = t[0], a = t[1];
                return e = t[2] / 360 * 2 * Math.PI, [n, a * Math.cos(e), a * Math.sin(e)]
            }, i.rgb.ansi16 = function (t) {
                var e = t[0], n = t[1], a = t[2], r = 1 in arguments ? arguments[1] : i.rgb.hsv(t)[2];
                if (0 === (r = Math.round(r / 50))) return 30;
                var o = 30 + (Math.round(a / 255) << 2 | Math.round(n / 255) << 1 | Math.round(e / 255));
                return 2 === r && (o += 60), o
            }, i.hsv.ansi16 = function (t) {
                return i.rgb.ansi16(i.hsv.rgb(t), t[2])
            }, i.rgb.ansi256 = function (t) {
                var e = t[0], n = t[1], a = t[2];
                return e === n && n === a ? e < 8 ? 16 : e > 248 ? 231 : Math.round((e - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(e / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(a / 255 * 5)
            }, i.ansi16.rgb = function (t) {
                var e = t % 10;
                if (0 === e || 7 === e) return t > 50 && (e += 3.5), [e = e / 10.5 * 255, e, e];
                var n = .5 * (1 + ~~(t > 50));
                return [(1 & e) * n * 255, (e >> 1 & 1) * n * 255, (e >> 2 & 1) * n * 255]
            }, i.ansi256.rgb = function (t) {
                if (t >= 232) {
                    var e = 10 * (t - 232) + 8;
                    return [e, e, e]
                }
                var n;
                return t -= 16, [Math.floor(t / 36) / 5 * 255, Math.floor((n = t % 36) / 6) / 5 * 255, n % 6 / 5 * 255]
            }, i.rgb.hex = function (t) {
                var e = (((255 & Math.round(t[0])) << 16) + ((255 & Math.round(t[1])) << 8) + (255 & Math.round(t[2]))).toString(16).toUpperCase();
                return "000000".substring(e.length) + e
            }, i.hex.rgb = function (t) {
                var e = t.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                if (!e) return [0, 0, 0];
                var n = e[0];
                3 === e[0].length && (n = n.split("").map((function (t) {
                    return t + t
                })).join(""));
                var a = parseInt(n, 16);
                return [a >> 16 & 255, a >> 8 & 255, 255 & a]
            }, i.rgb.hcg = function (t) {
                var e, n = t[0] / 255, a = t[1] / 255, i = t[2] / 255, r = Math.max(Math.max(n, a), i),
                    o = Math.min(Math.min(n, a), i), s = r - o;
                return e = s <= 0 ? 0 : r === n ? (a - i) / s % 6 : r === a ? 2 + (i - n) / s : 4 + (n - a) / s + 4, e /= 6, [360 * (e %= 1), 100 * s, 100 * (s < 1 ? o / (1 - s) : 0)]
            }, i.hsl.hcg = function (t) {
                var e = t[1] / 100, n = t[2] / 100, a = 1, i = 0;
                return (a = n < .5 ? 2 * e * n : 2 * e * (1 - n)) < 1 && (i = (n - .5 * a) / (1 - a)), [t[0], 100 * a, 100 * i]
            }, i.hsv.hcg = function (t) {
                var e = t[1] / 100, n = t[2] / 100, a = e * n, i = 0;
                return a < 1 && (i = (n - a) / (1 - a)), [t[0], 100 * a, 100 * i]
            }, i.hcg.rgb = function (t) {
                var e = t[0] / 360, n = t[1] / 100, a = t[2] / 100;
                if (0 === n) return [255 * a, 255 * a, 255 * a];
                var i = [0, 0, 0], r = e % 1 * 6, o = r % 1, s = 1 - o, l = 0;
                switch (Math.floor(r)) {
                    case 0:
                        i[0] = 1, i[1] = o, i[2] = 0;
                        break;
                    case 1:
                        i[0] = s, i[1] = 1, i[2] = 0;
                        break;
                    case 2:
                        i[0] = 0, i[1] = 1, i[2] = o;
                        break;
                    case 3:
                        i[0] = 0, i[1] = s, i[2] = 1;
                        break;
                    case 4:
                        i[0] = o, i[1] = 0, i[2] = 1;
                        break;
                    default:
                        i[0] = 1, i[1] = 0, i[2] = s
                }
                return l = (1 - n) * a, [255 * (n * i[0] + l), 255 * (n * i[1] + l), 255 * (n * i[2] + l)]
            }, i.hcg.hsv = function (t) {
                var e = t[1] / 100, n = e + t[2] / 100 * (1 - e), a = 0;
                return n > 0 && (a = e / n), [t[0], 100 * a, 100 * n]
            }, i.hcg.hsl = function (t) {
                var e = t[1] / 100, n = t[2] / 100 * (1 - e) + .5 * e, a = 0;
                return n > 0 && n < .5 ? a = e / (2 * n) : n >= .5 && n < 1 && (a = e / (2 * (1 - n))), [t[0], 100 * a, 100 * n]
            }, i.hcg.hwb = function (t) {
                var e = t[1] / 100, n = e + t[2] / 100 * (1 - e);
                return [t[0], 100 * (n - e), 100 * (1 - n)]
            }, i.hwb.hcg = function (t) {
                var e = t[1] / 100, n = 1 - t[2] / 100, a = n - e, i = 0;
                return a < 1 && (i = (n - a) / (1 - a)), [t[0], 100 * a, 100 * i]
            }, i.apple.rgb = function (t) {
                return [t[0] / 65535 * 255, t[1] / 65535 * 255, t[2] / 65535 * 255]
            }, i.rgb.apple = function (t) {
                return [t[0] / 255 * 65535, t[1] / 255 * 65535, t[2] / 255 * 65535]
            }, i.gray.rgb = function (t) {
                return [t[0] / 100 * 255, t[0] / 100 * 255, t[0] / 100 * 255]
            }, i.gray.hsl = i.gray.hsv = function (t) {
                return [0, 0, t[0]]
            }, i.gray.hwb = function (t) {
                return [0, 100, t[0]]
            }, i.gray.cmyk = function (t) {
                return [0, 0, 0, t[0]]
            }, i.gray.lab = function (t) {
                return [t[0], 0, 0]
            }, i.gray.hex = function (t) {
                var e = 255 & Math.round(t[0] / 100 * 255), n = ((e << 16) + (e << 8) + e).toString(16).toUpperCase();
                return "000000".substring(n.length) + n
            }, i.rgb.gray = function (t) {
                return [(t[0] + t[1] + t[2]) / 3 / 255 * 100]
            }
        }));

        function r() {
            for (var t = {}, e = Object.keys(i), n = e.length, a = 0; a < n; a++) t[e[a]] = {
                distance: -1,
                parent: null
            };
            return t
        }

        function o(t) {
            var e = r(), n = [t];
            for (e[t].distance = 0; n.length;) for (var a = n.pop(), o = Object.keys(i[a]), s = o.length, l = 0; l < s; l++) {
                var c = o[l], d = e[c];
                -1 === d.distance && (d.distance = e[a].distance + 1, d.parent = a, n.unshift(c))
            }
            return e
        }

        function s(t, e) {
            return function (n) {
                return e(t(n))
            }
        }

        function l(t, e) {
            for (var n = [e[t].parent, t], a = i[e[t].parent][t], r = e[t].parent; e[r].parent;) n.unshift(e[r].parent), a = s(i[e[r].parent][r], a), r = e[r].parent;
            return a.conversion = n, a
        }

        i.rgb, i.hsl, i.hsv, i.hwb, i.cmyk, i.xyz, i.lab, i.lch, i.hex, i.keyword, i.ansi16, i.ansi256, i.hcg, i.apple, i.gray;
        var c = function (t) {
            for (var e = o(t), n = {}, a = Object.keys(e), i = a.length, r = 0; r < i; r++) {
                var s = a[r];
                null !== e[s].parent && (n[s] = l(s, e))
            }
            return n
        }, d = {};

        function u(t) {
            var e = function (e) {
                return null == e ? e : (arguments.length > 1 && (e = Array.prototype.slice.call(arguments)), t(e))
            };
            return "conversion" in t && (e.conversion = t.conversion), e
        }

        function h(t) {
            var e = function (e) {
                if (null == e) return e;
                arguments.length > 1 && (e = Array.prototype.slice.call(arguments));
                var n = t(e);
                if ("object" == typeof n) for (var a = n.length, i = 0; i < a; i++) n[i] = Math.round(n[i]);
                return n
            };
            return "conversion" in t && (e.conversion = t.conversion), e
        }

        Object.keys(i).forEach((function (t) {
            d[t] = {}, Object.defineProperty(d[t], "channels", {value: i[t].channels}), Object.defineProperty(d[t], "labels", {value: i[t].labels});
            var e = c(t);
            Object.keys(e).forEach((function (n) {
                var a = e[n];
                d[t][n] = h(a), d[t][n].raw = u(a)
            }))
        }));
        var p = d, f = {
            aliceblue: [240, 248, 255],
            antiquewhite: [250, 235, 215],
            aqua: [0, 255, 255],
            aquamarine: [127, 255, 212],
            azure: [240, 255, 255],
            beige: [245, 245, 220],
            bisque: [255, 228, 196],
            black: [0, 0, 0],
            blanchedalmond: [255, 235, 205],
            blue: [0, 0, 255],
            blueviolet: [138, 43, 226],
            brown: [165, 42, 42],
            burlywood: [222, 184, 135],
            cadetblue: [95, 158, 160],
            chartreuse: [127, 255, 0],
            chocolate: [210, 105, 30],
            coral: [255, 127, 80],
            cornflowerblue: [100, 149, 237],
            cornsilk: [255, 248, 220],
            crimson: [220, 20, 60],
            cyan: [0, 255, 255],
            darkblue: [0, 0, 139],
            darkcyan: [0, 139, 139],
            darkgoldenrod: [184, 134, 11],
            darkgray: [169, 169, 169],
            darkgreen: [0, 100, 0],
            darkgrey: [169, 169, 169],
            darkkhaki: [189, 183, 107],
            darkmagenta: [139, 0, 139],
            darkolivegreen: [85, 107, 47],
            darkorange: [255, 140, 0],
            darkorchid: [153, 50, 204],
            darkred: [139, 0, 0],
            darksalmon: [233, 150, 122],
            darkseagreen: [143, 188, 143],
            darkslateblue: [72, 61, 139],
            darkslategray: [47, 79, 79],
            darkslategrey: [47, 79, 79],
            darkturquoise: [0, 206, 209],
            darkviolet: [148, 0, 211],
            deeppink: [255, 20, 147],
            deepskyblue: [0, 191, 255],
            dimgray: [105, 105, 105],
            dimgrey: [105, 105, 105],
            dodgerblue: [30, 144, 255],
            firebrick: [178, 34, 34],
            floralwhite: [255, 250, 240],
            forestgreen: [34, 139, 34],
            fuchsia: [255, 0, 255],
            gainsboro: [220, 220, 220],
            ghostwhite: [248, 248, 255],
            gold: [255, 215, 0],
            goldenrod: [218, 165, 32],
            gray: [128, 128, 128],
            green: [0, 128, 0],
            greenyellow: [173, 255, 47],
            grey: [128, 128, 128],
            honeydew: [240, 255, 240],
            hotpink: [255, 105, 180],
            indianred: [205, 92, 92],
            indigo: [75, 0, 130],
            ivory: [255, 255, 240],
            khaki: [240, 230, 140],
            lavender: [230, 230, 250],
            lavenderblush: [255, 240, 245],
            lawngreen: [124, 252, 0],
            lemonchiffon: [255, 250, 205],
            lightblue: [173, 216, 230],
            lightcoral: [240, 128, 128],
            lightcyan: [224, 255, 255],
            lightgoldenrodyellow: [250, 250, 210],
            lightgray: [211, 211, 211],
            lightgreen: [144, 238, 144],
            lightgrey: [211, 211, 211],
            lightpink: [255, 182, 193],
            lightsalmon: [255, 160, 122],
            lightseagreen: [32, 178, 170],
            lightskyblue: [135, 206, 250],
            lightslategray: [119, 136, 153],
            lightslategrey: [119, 136, 153],
            lightsteelblue: [176, 196, 222],
            lightyellow: [255, 255, 224],
            lime: [0, 255, 0],
            limegreen: [50, 205, 50],
            linen: [250, 240, 230],
            magenta: [255, 0, 255],
            maroon: [128, 0, 0],
            mediumaquamarine: [102, 205, 170],
            mediumblue: [0, 0, 205],
            mediumorchid: [186, 85, 211],
            mediumpurple: [147, 112, 219],
            mediumseagreen: [60, 179, 113],
            mediumslateblue: [123, 104, 238],
            mediumspringgreen: [0, 250, 154],
            mediumturquoise: [72, 209, 204],
            mediumvioletred: [199, 21, 133],
            midnightblue: [25, 25, 112],
            mintcream: [245, 255, 250],
            mistyrose: [255, 228, 225],
            moccasin: [255, 228, 181],
            navajowhite: [255, 222, 173],
            navy: [0, 0, 128],
            oldlace: [253, 245, 230],
            olive: [128, 128, 0],
            olivedrab: [107, 142, 35],
            orange: [255, 165, 0],
            orangered: [255, 69, 0],
            orchid: [218, 112, 214],
            palegoldenrod: [238, 232, 170],
            palegreen: [152, 251, 152],
            paleturquoise: [175, 238, 238],
            palevioletred: [219, 112, 147],
            papayawhip: [255, 239, 213],
            peachpuff: [255, 218, 185],
            peru: [205, 133, 63],
            pink: [255, 192, 203],
            plum: [221, 160, 221],
            powderblue: [176, 224, 230],
            purple: [128, 0, 128],
            rebeccapurple: [102, 51, 153],
            red: [255, 0, 0],
            rosybrown: [188, 143, 143],
            royalblue: [65, 105, 225],
            saddlebrown: [139, 69, 19],
            salmon: [250, 128, 114],
            sandybrown: [244, 164, 96],
            seagreen: [46, 139, 87],
            seashell: [255, 245, 238],
            sienna: [160, 82, 45],
            silver: [192, 192, 192],
            skyblue: [135, 206, 235],
            slateblue: [106, 90, 205],
            slategray: [112, 128, 144],
            slategrey: [112, 128, 144],
            snow: [255, 250, 250],
            springgreen: [0, 255, 127],
            steelblue: [70, 130, 180],
            tan: [210, 180, 140],
            teal: [0, 128, 128],
            thistle: [216, 191, 216],
            tomato: [255, 99, 71],
            turquoise: [64, 224, 208],
            violet: [238, 130, 238],
            wheat: [245, 222, 179],
            white: [255, 255, 255],
            whitesmoke: [245, 245, 245],
            yellow: [255, 255, 0],
            yellowgreen: [154, 205, 50]
        }, g = {
            getRgba: m,
            getHsla: v,
            getRgb: y,
            getHsl: x,
            getHwb: b,
            getAlpha: _,
            hexString: w,
            rgbString: S,
            rgbaString: C,
            percentString: k,
            percentaString: D,
            hslString: T,
            hslaString: E,
            hwbString: A,
            keyword: I
        };

        function m(t) {
            if (t) {
                var e = /^#([a-fA-F0-9]{3,4})$/i, n = /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
                    a = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                    i = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                    r = /(\w+)/, o = [0, 0, 0], s = 1, l = t.match(e), c = "";
                if (l) {
                    c = (l = l[1])[3];
                    for (var d = 0; d < o.length; d++) o[d] = parseInt(l[d] + l[d], 16);
                    c && (s = Math.round(parseInt(c + c, 16) / 255 * 100) / 100)
                } else if (l = t.match(n)) {
                    for (c = l[2], l = l[1], d = 0; d < o.length; d++) o[d] = parseInt(l.slice(2 * d, 2 * d + 2), 16);
                    c && (s = Math.round(parseInt(c, 16) / 255 * 100) / 100)
                } else if (l = t.match(a)) {
                    for (d = 0; d < o.length; d++) o[d] = parseInt(l[d + 1]);
                    s = parseFloat(l[4])
                } else if (l = t.match(i)) {
                    for (d = 0; d < o.length; d++) o[d] = Math.round(2.55 * parseFloat(l[d + 1]));
                    s = parseFloat(l[4])
                } else if (l = t.match(r)) {
                    if ("transparent" == l[1]) return [0, 0, 0, 0];
                    if (!(o = f[l[1]])) return
                }
                for (d = 0; d < o.length; d++) o[d] = M(o[d], 0, 255);
                return s = s || 0 == s ? M(s, 0, 1) : 1, o[3] = s, o
            }
        }

        function v(t) {
            if (t) {
                var e = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/,
                    n = t.match(e);
                if (n) {
                    var a = parseFloat(n[4]);
                    return [M(parseInt(n[1]), 0, 360), M(parseFloat(n[2]), 0, 100), M(parseFloat(n[3]), 0, 100), M(isNaN(a) ? 1 : a, 0, 1)]
                }
            }
        }

        function b(t) {
            if (t) {
                var e = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/,
                    n = t.match(e);
                if (n) {
                    var a = parseFloat(n[4]);
                    return [M(parseInt(n[1]), 0, 360), M(parseFloat(n[2]), 0, 100), M(parseFloat(n[3]), 0, 100), M(isNaN(a) ? 1 : a, 0, 1)]
                }
            }
        }

        function y(t) {
            var e = m(t);
            return e && e.slice(0, 3)
        }

        function x(t) {
            var e = v(t);
            return e && e.slice(0, 3)
        }

        function _(t) {
            var e = m(t);
            return e || (e = v(t)) || (e = b(t)) ? e[3] : void 0
        }

        function w(t, e) {
            return e = void 0 !== e && 3 === t.length ? e : t[3], "#" + R(t[0]) + R(t[1]) + R(t[2]) + (e >= 0 && e < 1 ? R(Math.round(255 * e)) : "")
        }

        function S(t, e) {
            return e < 1 || t[3] && t[3] < 1 ? C(t, e) : "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")"
        }

        function C(t, e) {
            return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + e + ")"
        }

        function k(t, e) {
            return e < 1 || t[3] && t[3] < 1 ? D(t, e) : "rgb(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%)"
        }

        function D(t, e) {
            return "rgba(" + Math.round(t[0] / 255 * 100) + "%, " + Math.round(t[1] / 255 * 100) + "%, " + Math.round(t[2] / 255 * 100) + "%, " + (e || t[3] || 1) + ")"
        }

        function T(t, e) {
            return e < 1 || t[3] && t[3] < 1 ? E(t, e) : "hsl(" + t[0] + ", " + t[1] + "%, " + t[2] + "%)"
        }

        function E(t, e) {
            return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hsla(" + t[0] + ", " + t[1] + "%, " + t[2] + "%, " + e + ")"
        }

        function A(t, e) {
            return void 0 === e && (e = void 0 !== t[3] ? t[3] : 1), "hwb(" + t[0] + ", " + t[1] + "%, " + t[2] + "%" + (void 0 !== e && 1 !== e ? ", " + e : "") + ")"
        }

        function I(t) {
            return P[t.slice(0, 3)]
        }

        function M(t, e, n) {
            return Math.min(Math.max(e, t), n)
        }

        function R(t) {
            var e = t.toString(16).toUpperCase();
            return e.length < 2 ? "0" + e : e
        }

        var P = {};
        for (var O in f) P[f[O]] = O;
        var j = function (t) {
            return t instanceof j ? t : this instanceof j ? (this.valid = !1, this.values = {
                rgb: [0, 0, 0],
                hsl: [0, 0, 0],
                hsv: [0, 0, 0],
                hwb: [0, 0, 0],
                cmyk: [0, 0, 0, 0],
                alpha: 1
            }, void ("string" == typeof t ? (e = g.getRgba(t)) ? this.setValues("rgb", e) : (e = g.getHsla(t)) ? this.setValues("hsl", e) : (e = g.getHwb(t)) && this.setValues("hwb", e) : "object" == typeof t && (void 0 !== (e = t).r || void 0 !== e.red ? this.setValues("rgb", e) : void 0 !== e.l || void 0 !== e.lightness ? this.setValues("hsl", e) : void 0 !== e.v || void 0 !== e.value ? this.setValues("hsv", e) : void 0 !== e.w || void 0 !== e.whiteness ? this.setValues("hwb", e) : void 0 === e.c && void 0 === e.cyan || this.setValues("cmyk", e)))) : new j(t);
            var e
        };
        j.prototype = {
            isValid: function () {
                return this.valid
            }, rgb: function () {
                return this.setSpace("rgb", arguments)
            }, hsl: function () {
                return this.setSpace("hsl", arguments)
            }, hsv: function () {
                return this.setSpace("hsv", arguments)
            }, hwb: function () {
                return this.setSpace("hwb", arguments)
            }, cmyk: function () {
                return this.setSpace("cmyk", arguments)
            }, rgbArray: function () {
                return this.values.rgb
            }, hslArray: function () {
                return this.values.hsl
            }, hsvArray: function () {
                return this.values.hsv
            }, hwbArray: function () {
                var t = this.values;
                return 1 !== t.alpha ? t.hwb.concat([t.alpha]) : t.hwb
            }, cmykArray: function () {
                return this.values.cmyk
            }, rgbaArray: function () {
                var t = this.values;
                return t.rgb.concat([t.alpha])
            }, hslaArray: function () {
                var t = this.values;
                return t.hsl.concat([t.alpha])
            }, alpha: function (t) {
                return void 0 === t ? this.values.alpha : (this.setValues("alpha", t), this)
            }, red: function (t) {
                return this.setChannel("rgb", 0, t)
            }, green: function (t) {
                return this.setChannel("rgb", 1, t)
            }, blue: function (t) {
                return this.setChannel("rgb", 2, t)
            }, hue: function (t) {
                return t && (t = (t %= 360) < 0 ? 360 + t : t), this.setChannel("hsl", 0, t)
            }, saturation: function (t) {
                return this.setChannel("hsl", 1, t)
            }, lightness: function (t) {
                return this.setChannel("hsl", 2, t)
            }, saturationv: function (t) {
                return this.setChannel("hsv", 1, t)
            }, whiteness: function (t) {
                return this.setChannel("hwb", 1, t)
            }, blackness: function (t) {
                return this.setChannel("hwb", 2, t)
            }, value: function (t) {
                return this.setChannel("hsv", 2, t)
            }, cyan: function (t) {
                return this.setChannel("cmyk", 0, t)
            }, magenta: function (t) {
                return this.setChannel("cmyk", 1, t)
            }, yellow: function (t) {
                return this.setChannel("cmyk", 2, t)
            }, black: function (t) {
                return this.setChannel("cmyk", 3, t)
            }, hexString: function () {
                return g.hexString(this.values.rgb)
            }, rgbString: function () {
                return g.rgbString(this.values.rgb, this.values.alpha)
            }, rgbaString: function () {
                return g.rgbaString(this.values.rgb, this.values.alpha)
            }, percentString: function () {
                return g.percentString(this.values.rgb, this.values.alpha)
            }, hslString: function () {
                return g.hslString(this.values.hsl, this.values.alpha)
            }, hslaString: function () {
                return g.hslaString(this.values.hsl, this.values.alpha)
            }, hwbString: function () {
                return g.hwbString(this.values.hwb, this.values.alpha)
            }, keyword: function () {
                return g.keyword(this.values.rgb, this.values.alpha)
            }, rgbNumber: function () {
                var t = this.values.rgb;
                return t[0] << 16 | t[1] << 8 | t[2]
            }, luminosity: function () {
                for (var t = this.values.rgb, e = [], n = 0; n < t.length; n++) {
                    var a = t[n] / 255;
                    e[n] = a <= .03928 ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4)
                }
                return .2126 * e[0] + .7152 * e[1] + .0722 * e[2]
            }, contrast: function (t) {
                var e = this.luminosity(), n = t.luminosity();
                return e > n ? (e + .05) / (n + .05) : (n + .05) / (e + .05)
            }, level: function (t) {
                var e = this.contrast(t);
                return e >= 7.1 ? "AAA" : e >= 4.5 ? "AA" : ""
            }, dark: function () {
                var t = this.values.rgb;
                return (299 * t[0] + 587 * t[1] + 114 * t[2]) / 1e3 < 128
            }, light: function () {
                return !this.dark()
            }, negate: function () {
                for (var t = [], e = 0; e < 3; e++) t[e] = 255 - this.values.rgb[e];
                return this.setValues("rgb", t), this
            }, lighten: function (t) {
                var e = this.values.hsl;
                return e[2] += e[2] * t, this.setValues("hsl", e), this
            }, darken: function (t) {
                var e = this.values.hsl;
                return e[2] -= e[2] * t, this.setValues("hsl", e), this
            }, saturate: function (t) {
                var e = this.values.hsl;
                return e[1] += e[1] * t, this.setValues("hsl", e), this
            }, desaturate: function (t) {
                var e = this.values.hsl;
                return e[1] -= e[1] * t, this.setValues("hsl", e), this
            }, whiten: function (t) {
                var e = this.values.hwb;
                return e[1] += e[1] * t, this.setValues("hwb", e), this
            }, blacken: function (t) {
                var e = this.values.hwb;
                return e[2] += e[2] * t, this.setValues("hwb", e), this
            }, greyscale: function () {
                var t = this.values.rgb, e = .3 * t[0] + .59 * t[1] + .11 * t[2];
                return this.setValues("rgb", [e, e, e]), this
            }, clearer: function (t) {
                var e = this.values.alpha;
                return this.setValues("alpha", e - e * t), this
            }, opaquer: function (t) {
                var e = this.values.alpha;
                return this.setValues("alpha", e + e * t), this
            }, rotate: function (t) {
                var e = this.values.hsl, n = (e[0] + t) % 360;
                return e[0] = n < 0 ? 360 + n : n, this.setValues("hsl", e), this
            }, mix: function (t, e) {
                var n = this, a = t, i = void 0 === e ? .5 : e, r = 2 * i - 1, o = n.alpha() - a.alpha(),
                    s = ((r * o == -1 ? r : (r + o) / (1 + r * o)) + 1) / 2, l = 1 - s;
                return this.rgb(s * n.red() + l * a.red(), s * n.green() + l * a.green(), s * n.blue() + l * a.blue()).alpha(n.alpha() * i + a.alpha() * (1 - i))
            }, toJSON: function () {
                return this.rgb()
            }, clone: function () {
                var t, e, n = new j, a = this.values, i = n.values;
                for (var r in a) a.hasOwnProperty(r) && (t = a[r], "[object Array]" === (e = {}.toString.call(t)) ? i[r] = t.slice(0) : "[object Number]" === e ? i[r] = t : console.error("unexpected color value:", t));
                return n
            }
        }, j.prototype.spaces = {
            rgb: ["red", "green", "blue"],
            hsl: ["hue", "saturation", "lightness"],
            hsv: ["hue", "saturation", "value"],
            hwb: ["hue", "whiteness", "blackness"],
            cmyk: ["cyan", "magenta", "yellow", "black"]
        }, j.prototype.maxes = {
            rgb: [255, 255, 255],
            hsl: [360, 100, 100],
            hsv: [360, 100, 100],
            hwb: [360, 100, 100],
            cmyk: [100, 100, 100, 100]
        }, j.prototype.getValues = function (t) {
            for (var e = this.values, n = {}, a = 0; a < t.length; a++) n[t.charAt(a)] = e[t][a];
            return 1 !== e.alpha && (n.a = e.alpha), n
        }, j.prototype.setValues = function (t, e) {
            var n, a, i = this.values, r = this.spaces, o = this.maxes, s = 1;
            if (this.valid = !0, "alpha" === t) s = e; else if (e.length) i[t] = e.slice(0, t.length), s = e[t.length]; else if (void 0 !== e[t.charAt(0)]) {
                for (n = 0; n < t.length; n++) i[t][n] = e[t.charAt(n)];
                s = e.a
            } else if (void 0 !== e[r[t][0]]) {
                var l = r[t];
                for (n = 0; n < t.length; n++) i[t][n] = e[l[n]];
                s = e.alpha
            }
            if (i.alpha = Math.max(0, Math.min(1, void 0 === s ? i.alpha : s)), "alpha" === t) return !1;
            for (n = 0; n < t.length; n++) a = Math.max(0, Math.min(o[t][n], i[t][n])), i[t][n] = Math.round(a);
            for (var c in r) c !== t && (i[c] = p[t][c](i[t]));
            return !0
        }, j.prototype.setSpace = function (t, e) {
            var n = e[0];
            return void 0 === n ? this.getValues(t) : ("number" == typeof n && (n = Array.prototype.slice.call(e)), this.setValues(t, n), this)
        }, j.prototype.setChannel = function (t, e, n) {
            var a = this.values[t];
            return void 0 === n ? a[e] : (n === a[e] || (a[e] = n, this.setValues(t, a)), this)
        }, "undefined" != typeof window && (window.Color = j);
        var N = j;

        function L(t) {
            return -1 === ["__proto__", "prototype", "constructor"].indexOf(t)
        }

        var F, H = {
            noop: function () {
            }, uid: (F = 0, function () {
                return F++
            }), isNullOrUndef: function (t) {
                return null == t
            }, isArray: function (t) {
                if (Array.isArray && Array.isArray(t)) return !0;
                var e = Object.prototype.toString.call(t);
                return "[object" === e.substr(0, 7) && "Array]" === e.substr(-6)
            }, isObject: function (t) {
                return null !== t && "[object Object]" === Object.prototype.toString.call(t)
            }, isFinite: function (t) {
                return ("number" == typeof t || t instanceof Number) && isFinite(t)
            }, valueOrDefault: function (t, e) {
                return void 0 === t ? e : t
            }, valueAtIndexOrDefault: function (t, e, n) {
                return H.valueOrDefault(H.isArray(t) ? t[e] : t, n)
            }, callback: function (t, e, n) {
                if (t && "function" == typeof t.call) return t.apply(n, e)
            }, each: function (t, e, n, a) {
                var i, r, o;
                if (H.isArray(t)) if (r = t.length, a) for (i = r - 1; i >= 0; i--) e.call(n, t[i], i); else for (i = 0; i < r; i++) e.call(n, t[i], i); else if (H.isObject(t)) for (r = (o = Object.keys(t)).length, i = 0; i < r; i++) e.call(n, t[o[i]], o[i])
            }, arrayEquals: function (t, e) {
                var n, a, i, r;
                if (!t || !e || t.length !== e.length) return !1;
                for (n = 0, a = t.length; n < a; ++n) if (i = t[n], r = e[n], i instanceof Array && r instanceof Array) {
                    if (!H.arrayEquals(i, r)) return !1
                } else if (i !== r) return !1;
                return !0
            }, clone: function (t) {
                if (H.isArray(t)) return t.map(H.clone);
                if (H.isObject(t)) {
                    for (var e = Object.create(t), n = Object.keys(t), a = n.length, i = 0; i < a; ++i) e[n[i]] = H.clone(t[n[i]]);
                    return e
                }
                return t
            }, _merger: function (t, e, n, a) {
                if (L(t)) {
                    var i = e[t], r = n[t];
                    H.isObject(i) && H.isObject(r) ? H.merge(i, r, a) : e[t] = H.clone(r)
                }
            }, _mergerIf: function (t, e, n) {
                if (L(t)) {
                    var a = e[t], i = n[t];
                    H.isObject(a) && H.isObject(i) ? H.mergeIf(a, i) : e.hasOwnProperty(t) || (e[t] = H.clone(i))
                }
            }, merge: function (t, e, n) {
                var a, i, r, o, s, l = H.isArray(e) ? e : [e], c = l.length;
                if (!H.isObject(t)) return t;
                for (a = (n = n || {}).merger || H._merger, i = 0; i < c; ++i) if (e = l[i], H.isObject(e)) for (s = 0, o = (r = Object.keys(e)).length; s < o; ++s) a(r[s], t, e, n);
                return t
            }, mergeIf: function (t, e) {
                return H.merge(t, e, {merger: H._mergerIf})
            }, extend: Object.assign || function (t) {
                return H.merge(t, [].slice.call(arguments, 1), {
                    merger: function (t, e, n) {
                        e[t] = n[t]
                    }
                })
            }, inherits: function (t) {
                var e = this, n = t && t.hasOwnProperty("constructor") ? t.constructor : function () {
                    return e.apply(this, arguments)
                }, a = function () {
                    this.constructor = n
                };
                return a.prototype = e.prototype, n.prototype = new a, n.extend = H.inherits, t && H.extend(n.prototype, t), n.__super__ = e.prototype, n
            }, _deprecated: function (t, e, n, a) {
                void 0 !== e && console.warn(t + ': "' + n + '" is deprecated. Please use "' + a + '" instead')
            }
        }, B = H;
        H.callCallback = H.callback, H.indexOf = function (t, e, n) {
            return Array.prototype.indexOf.call(t, e, n)
        }, H.getValueOrDefault = H.valueOrDefault, H.getValueAtIndexOrDefault = H.valueAtIndexOrDefault;
        var q = {
            linear: function (t) {
                return t
            }, easeInQuad: function (t) {
                return t * t
            }, easeOutQuad: function (t) {
                return -t * (t - 2)
            }, easeInOutQuad: function (t) {
                return (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
            }, easeInCubic: function (t) {
                return t * t * t
            }, easeOutCubic: function (t) {
                return (t -= 1) * t * t + 1
            }, easeInOutCubic: function (t) {
                return (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
            }, easeInQuart: function (t) {
                return t * t * t * t
            }, easeOutQuart: function (t) {
                return -((t -= 1) * t * t * t - 1)
            }, easeInOutQuart: function (t) {
                return (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
            }, easeInQuint: function (t) {
                return t * t * t * t * t
            }, easeOutQuint: function (t) {
                return (t -= 1) * t * t * t * t + 1
            }, easeInOutQuint: function (t) {
                return (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
            }, easeInSine: function (t) {
                return 1 - Math.cos(t * (Math.PI / 2))
            }, easeOutSine: function (t) {
                return Math.sin(t * (Math.PI / 2))
            }, easeInOutSine: function (t) {
                return -.5 * (Math.cos(Math.PI * t) - 1)
            }, easeInExpo: function (t) {
                return 0 === t ? 0 : Math.pow(2, 10 * (t - 1))
            }, easeOutExpo: function (t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            }, easeInOutExpo: function (t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t /= .5) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * --t))
            }, easeInCirc: function (t) {
                return t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)
            }, easeOutCirc: function (t) {
                return Math.sqrt(1 - (t -= 1) * t)
            }, easeInOutCirc: function (t) {
                return (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            }, easeInElastic: function (t) {
                var e = 1.70158, n = 0, a = 1;
                return 0 === t ? 0 : 1 === t ? 1 : (n || (n = .3), a < 1 ? (a = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / a), -a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n))
            }, easeOutElastic: function (t) {
                var e = 1.70158, n = 0, a = 1;
                return 0 === t ? 0 : 1 === t ? 1 : (n || (n = .3), a < 1 ? (a = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / a), a * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / n) + 1)
            }, easeInOutElastic: function (t) {
                var e = 1.70158, n = 0, a = 1;
                return 0 === t ? 0 : 2 == (t /= .5) ? 1 : (n || (n = .45), a < 1 ? (a = 1, e = n / 4) : e = n / (2 * Math.PI) * Math.asin(1 / a), t < 1 ? a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * -.5 : a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / n) * .5 + 1)
            }, easeInBack: function (t) {
                var e = 1.70158;
                return t * t * ((e + 1) * t - e)
            }, easeOutBack: function (t) {
                var e = 1.70158;
                return (t -= 1) * t * ((e + 1) * t + e) + 1
            }, easeInOutBack: function (t) {
                var e = 1.70158;
                return (t /= .5) < 1 ? t * t * ((1 + (e *= 1.525)) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + (e *= 1.525)) * t + e) + 2)
            }, easeInBounce: function (t) {
                return 1 - q.easeOutBounce(1 - t)
            }, easeOutBounce: function (t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            }, easeInOutBounce: function (t) {
                return t < .5 ? .5 * q.easeInBounce(2 * t) : .5 * q.easeOutBounce(2 * t - 1) + .5
            }
        }, z = {effects: q};
        B.easingEffects = q;
        var W = Math.PI, V = W / 180, $ = 2 * W, Y = W / 2, U = W / 4, G = 2 * W / 3, X = {
            clear: function (t) {
                t.ctx.clearRect(0, 0, t.width, t.height)
            }, roundedRect: function (t, e, n, a, i, r) {
                if (r) {
                    var o = Math.min(r, i / 2, a / 2), s = e + o, l = n + o, c = e + a - o, d = n + i - o;
                    t.moveTo(e, l), s < c && l < d ? (t.arc(s, l, o, -W, -Y), t.arc(c, l, o, -Y, 0), t.arc(c, d, o, 0, Y), t.arc(s, d, o, Y, W)) : s < c ? (t.moveTo(s, n), t.arc(c, l, o, -Y, Y), t.arc(s, l, o, Y, W + Y)) : l < d ? (t.arc(s, l, o, -W, 0), t.arc(s, d, o, 0, W)) : t.arc(s, l, o, -W, W), t.closePath(), t.moveTo(e, n)
                } else t.rect(e, n, a, i)
            }, drawPoint: function (t, e, n, a, i, r) {
                var o, s, l, c, d, u = (r || 0) * V;
                if (e && "object" == typeof e && ("[object HTMLImageElement]" === (o = e.toString()) || "[object HTMLCanvasElement]" === o)) return t.save(), t.translate(a, i), t.rotate(u), t.drawImage(e, -e.width / 2, -e.height / 2, e.width, e.height), void t.restore();
                if (!(isNaN(n) || n <= 0)) {
                    switch (t.beginPath(), e) {
                        default:
                            t.arc(a, i, n, 0, $), t.closePath();
                            break;
                        case"triangle":
                            t.moveTo(a + Math.sin(u) * n, i - Math.cos(u) * n), u += G, t.lineTo(a + Math.sin(u) * n, i - Math.cos(u) * n), u += G, t.lineTo(a + Math.sin(u) * n, i - Math.cos(u) * n), t.closePath();
                            break;
                        case"rectRounded":
                            c = n - (d = .516 * n), s = Math.cos(u + U) * c, l = Math.sin(u + U) * c, t.arc(a - s, i - l, d, u - W, u - Y), t.arc(a + l, i - s, d, u - Y, u), t.arc(a + s, i + l, d, u, u + Y), t.arc(a - l, i + s, d, u + Y, u + W), t.closePath();
                            break;
                        case"rect":
                            if (!r) {
                                c = Math.SQRT1_2 * n, t.rect(a - c, i - c, 2 * c, 2 * c);
                                break
                            }
                            u += U;
                        case"rectRot":
                            s = Math.cos(u) * n, l = Math.sin(u) * n, t.moveTo(a - s, i - l), t.lineTo(a + l, i - s), t.lineTo(a + s, i + l), t.lineTo(a - l, i + s), t.closePath();
                            break;
                        case"crossRot":
                            u += U;
                        case"cross":
                            s = Math.cos(u) * n, l = Math.sin(u) * n, t.moveTo(a - s, i - l), t.lineTo(a + s, i + l), t.moveTo(a + l, i - s), t.lineTo(a - l, i + s);
                            break;
                        case"star":
                            s = Math.cos(u) * n, l = Math.sin(u) * n, t.moveTo(a - s, i - l), t.lineTo(a + s, i + l), t.moveTo(a + l, i - s), t.lineTo(a - l, i + s), u += U, s = Math.cos(u) * n, l = Math.sin(u) * n, t.moveTo(a - s, i - l), t.lineTo(a + s, i + l), t.moveTo(a + l, i - s), t.lineTo(a - l, i + s);
                            break;
                        case"line":
                            s = Math.cos(u) * n, l = Math.sin(u) * n, t.moveTo(a - s, i - l), t.lineTo(a + s, i + l);
                            break;
                        case"dash":
                            t.moveTo(a, i), t.lineTo(a + Math.cos(u) * n, i + Math.sin(u) * n)
                    }
                    t.fill(), t.stroke()
                }
            }, _isPointInArea: function (t, e) {
                var n = 1e-6;
                return t.x > e.left - n && t.x < e.right + n && t.y > e.top - n && t.y < e.bottom + n
            }, clipArea: function (t, e) {
                t.save(), t.beginPath(), t.rect(e.left, e.top, e.right - e.left, e.bottom - e.top), t.clip()
            }, unclipArea: function (t) {
                t.restore()
            }, lineTo: function (t, e, n, a) {
                var i = n.steppedLine;
                if (i) {
                    if ("middle" === i) {
                        var r = (e.x + n.x) / 2;
                        t.lineTo(r, a ? n.y : e.y), t.lineTo(r, a ? e.y : n.y)
                    } else "after" === i && !a || "after" !== i && a ? t.lineTo(e.x, n.y) : t.lineTo(n.x, e.y);
                    t.lineTo(n.x, n.y)
                } else n.tension ? t.bezierCurveTo(a ? e.controlPointPreviousX : e.controlPointNextX, a ? e.controlPointPreviousY : e.controlPointNextY, a ? n.controlPointNextX : n.controlPointPreviousX, a ? n.controlPointNextY : n.controlPointPreviousY, n.x, n.y) : t.lineTo(n.x, n.y)
            }
        }, Z = X;
        B.clear = X.clear, B.drawRoundedRectangle = function (t) {
            t.beginPath(), X.roundedRect.apply(X, arguments)
        };
        var K = {
            _set: function (t, e) {
                return B.merge(this[t] || (this[t] = {}), e)
            }
        };
        K._set("global", {
            defaultColor: "rgba(0,0,0,0.1)",
            defaultFontColor: "#666",
            defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
            defaultFontSize: 12,
            defaultFontStyle: "normal",
            defaultLineHeight: 1.2,
            showLines: !0
        });
        var Q = K, J = B.valueOrDefault;

        function tt(t) {
            return !t || B.isNullOrUndef(t.size) || B.isNullOrUndef(t.family) ? null : (t.style ? t.style + " " : "") + (t.weight ? t.weight + " " : "") + t.size + "px " + t.family
        }

        var et = {
            toLineHeight: function (t, e) {
                var n = ("" + t).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
                if (!n || "normal" === n[1]) return 1.2 * e;
                switch (t = +n[2], n[3]) {
                    case"px":
                        return t;
                    case"%":
                        t /= 100
                }
                return e * t
            }, toPadding: function (t) {
                var e, n, a, i;
                return B.isObject(t) ? (e = +t.top || 0, n = +t.right || 0, a = +t.bottom || 0, i = +t.left || 0) : e = n = a = i = +t || 0, {
                    top: e,
                    right: n,
                    bottom: a,
                    left: i,
                    height: e + a,
                    width: i + n
                }
            }, _parseFont: function (t) {
                var e = Q.global, n = J(t.fontSize, e.defaultFontSize), a = {
                    family: J(t.fontFamily, e.defaultFontFamily),
                    lineHeight: B.options.toLineHeight(J(t.lineHeight, e.defaultLineHeight), n),
                    size: n,
                    style: J(t.fontStyle, e.defaultFontStyle),
                    weight: null,
                    string: ""
                };
                return a.string = tt(a), a
            }, resolve: function (t, e, n, a) {
                var i, r, o, s = !0;
                for (i = 0, r = t.length; i < r; ++i) if (void 0 !== (o = t[i]) && (void 0 !== e && "function" == typeof o && (o = o(e), s = !1), void 0 !== n && B.isArray(o) && (o = o[n], s = !1), void 0 !== o)) return a && !s && (a.cacheable = !1), o
            }
        }, nt = {
            _factorize: function (t) {
                var e, n = [], a = Math.sqrt(t);
                for (e = 1; e < a; e++) t % e == 0 && (n.push(e), n.push(t / e));
                return a === (0 | a) && n.push(a), n.sort((function (t, e) {
                    return t - e
                })).pop(), n
            }, log10: Math.log10 || function (t) {
                var e = Math.log(t) * Math.LOG10E, n = Math.round(e);
                return t === Math.pow(10, n) ? n : e
            }
        }, at = nt;
        B.log10 = nt.log10;
        var it = function (t, e) {
            return {
                x: function (n) {
                    return t + t + e - n
                }, setWidth: function (t) {
                    e = t
                }, textAlign: function (t) {
                    return "center" === t ? t : "right" === t ? "left" : "right"
                }, xPlus: function (t, e) {
                    return t - e
                }, leftForLtr: function (t, e) {
                    return t - e
                }
            }
        }, rt = function () {
            return {
                x: function (t) {
                    return t
                }, setWidth: function (t) {
                }, textAlign: function (t) {
                    return t
                }, xPlus: function (t, e) {
                    return t + e
                }, leftForLtr: function (t, e) {
                    return t
                }
            }
        }, ot = B, st = z, lt = Z, ct = et, dt = at, ut = {
            getRtlAdapter: function (t, e, n) {
                return t ? it(e, n) : rt()
            }, overrideTextDirection: function (t, e) {
                var n, a;
                "ltr" !== e && "rtl" !== e || (a = [(n = t.canvas.style).getPropertyValue("direction"), n.getPropertyPriority("direction")], n.setProperty("direction", e, "important"), t.prevTextDirection = a)
            }, restoreTextDirection: function (t) {
                var e = t.prevTextDirection;
                void 0 !== e && (delete t.prevTextDirection, t.canvas.style.setProperty("direction", e[0], e[1]))
            }
        };

        function ht(t, e, n, a) {
            var i, r, o, s, l, c, d, u, h, p = Object.keys(n);
            for (i = 0, r = p.length; i < r; ++i) if (c = n[o = p[i]], e.hasOwnProperty(o) || (e[o] = c), (s = e[o]) !== c && "_" !== o[0]) {
                if (t.hasOwnProperty(o) || (t[o] = s), (d = typeof c) == typeof (l = t[o])) if ("string" === d) {
                    if ((u = N(l)).valid && (h = N(c)).valid) {
                        e[o] = h.mix(u, a).rgbString();
                        continue
                    }
                } else if (ot.isFinite(l) && ot.isFinite(c)) {
                    e[o] = l + (c - l) * a;
                    continue
                }
                e[o] = c
            }
        }

        ot.easing = st, ot.canvas = lt, ot.options = ct, ot.math = dt, ot.rtl = ut;
        var pt = function (t) {
            ot.extend(this, t), this.initialize.apply(this, arguments)
        };
        ot.extend(pt.prototype, {
            _type: void 0, initialize: function () {
                this.hidden = !1
            }, pivot: function () {
                var t = this;
                return t._view || (t._view = ot.extend({}, t._model)), t._start = {}, t
            }, transition: function (t) {
                var e = this, n = e._model, a = e._start, i = e._view;
                return n && 1 !== t ? (i || (i = e._view = {}), a || (a = e._start = {}), ht(a, i, n, t), e) : (e._view = ot.extend({}, n), e._start = null, e)
            }, tooltipPosition: function () {
                return {x: this._model.x, y: this._model.y}
            }, hasValue: function () {
                return ot.isNumber(this._model.x) && ot.isNumber(this._model.y)
            }
        }), pt.extend = ot.inherits;
        var ft = pt, gt = ft.extend({
            chart: null,
            currentStep: 0,
            numSteps: 60,
            easing: "",
            render: null,
            onAnimationProgress: null,
            onAnimationComplete: null
        }), mt = gt;
        Object.defineProperty(gt.prototype, "animationObject", {
            get: function () {
                return this
            }
        }), Object.defineProperty(gt.prototype, "chartInstance", {
            get: function () {
                return this.chart
            }, set: function (t) {
                this.chart = t
            }
        }), Q._set("global", {
            animation: {
                duration: 1e3,
                easing: "easeOutQuart",
                onProgress: ot.noop,
                onComplete: ot.noop
            }
        });
        var vt = {
            animations: [], request: null, addAnimation: function (t, e, n, a) {
                var i, r, o = this.animations;
                for (e.chart = t, e.startTime = Date.now(), e.duration = n, a || (t.animating = !0), i = 0, r = o.length; i < r; ++i) if (o[i].chart === t) return void (o[i] = e);
                o.push(e), 1 === o.length && this.requestAnimationFrame()
            }, cancelAnimation: function (t) {
                var e = ot.findIndex(this.animations, (function (e) {
                    return e.chart === t
                }));
                -1 !== e && (this.animations.splice(e, 1), t.animating = !1)
            }, requestAnimationFrame: function () {
                var t = this;
                null === t.request && (t.request = ot.requestAnimFrame.call(window, (function () {
                    t.request = null, t.startDigest()
                })))
            }, startDigest: function () {
                var t = this;
                t.advance(), t.animations.length > 0 && t.requestAnimationFrame()
            }, advance: function () {
                for (var t, e, n, a, i = this.animations, r = 0; r < i.length;) e = (t = i[r]).chart, n = t.numSteps, a = Math.floor((Date.now() - t.startTime) / t.duration * n) + 1, t.currentStep = Math.min(a, n), ot.callback(t.render, [e, t], e), ot.callback(t.onAnimationProgress, [t], e), t.currentStep >= n ? (ot.callback(t.onAnimationComplete, [t], e), e.animating = !1, i.splice(r, 1)) : ++r
            }
        }, bt = ot.options.resolve, yt = ["push", "pop", "shift", "splice", "unshift"];

        function xt(t, e) {
            t._chartjs ? t._chartjs.listeners.push(e) : (Object.defineProperty(t, "_chartjs", {
                configurable: !0,
                enumerable: !1,
                value: {listeners: [e]}
            }), yt.forEach((function (e) {
                var n = "onData" + e.charAt(0).toUpperCase() + e.slice(1), a = t[e];
                Object.defineProperty(t, e, {
                    configurable: !0, enumerable: !1, value: function () {
                        var e = Array.prototype.slice.call(arguments), i = a.apply(this, e);
                        return ot.each(t._chartjs.listeners, (function (t) {
                            "function" == typeof t[n] && t[n].apply(t, e)
                        })), i
                    }
                })
            })))
        }

        function _t(t, e) {
            var n = t._chartjs;
            if (n) {
                var a = n.listeners, i = a.indexOf(e);
                -1 !== i && a.splice(i, 1), a.length > 0 || (yt.forEach((function (e) {
                    delete t[e]
                })), delete t._chartjs)
            }
        }

        var wt = function (t, e) {
            this.initialize(t, e)
        };
        ot.extend(wt.prototype, {
            datasetElementType: null,
            dataElementType: null,
            _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth"],
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "pointStyle"],
            initialize: function (t, e) {
                var n = this;
                n.chart = t, n.index = e, n.linkScales(), n.addElements(), n._type = n.getMeta().type
            },
            updateIndex: function (t) {
                this.index = t
            },
            linkScales: function () {
                var t = this, e = t.getMeta(), n = t.chart, a = n.scales, i = t.getDataset(), r = n.options.scales;
                null !== e.xAxisID && e.xAxisID in a && !i.xAxisID || (e.xAxisID = i.xAxisID || r.xAxes[0].id), null !== e.yAxisID && e.yAxisID in a && !i.yAxisID || (e.yAxisID = i.yAxisID || r.yAxes[0].id)
            },
            getDataset: function () {
                return this.chart.data.datasets[this.index]
            },
            getMeta: function () {
                return this.chart.getDatasetMeta(this.index)
            },
            getScaleForId: function (t) {
                return this.chart.scales[t]
            },
            _getValueScaleId: function () {
                return this.getMeta().yAxisID
            },
            _getIndexScaleId: function () {
                return this.getMeta().xAxisID
            },
            _getValueScale: function () {
                return this.getScaleForId(this._getValueScaleId())
            },
            _getIndexScale: function () {
                return this.getScaleForId(this._getIndexScaleId())
            },
            reset: function () {
                this._update(!0)
            },
            destroy: function () {
                this._data && _t(this._data, this)
            },
            createMetaDataset: function () {
                var t = this, e = t.datasetElementType;
                return e && new e({_chart: t.chart, _datasetIndex: t.index})
            },
            createMetaData: function (t) {
                var e = this, n = e.dataElementType;
                return n && new n({_chart: e.chart, _datasetIndex: e.index, _index: t})
            },
            addElements: function () {
                var t, e, n = this, a = n.getMeta(), i = n.getDataset().data || [], r = a.data;
                for (t = 0, e = i.length; t < e; ++t) r[t] = r[t] || n.createMetaData(t);
                a.dataset = a.dataset || n.createMetaDataset()
            },
            addElementAndReset: function (t) {
                var e = this.createMetaData(t);
                this.getMeta().data.splice(t, 0, e), this.updateElement(e, t, !0)
            },
            buildOrUpdateElements: function () {
                var t = this, e = t.getDataset(), n = e.data || (e.data = []);
                t._data !== n && (t._data && _t(t._data, t), n && Object.isExtensible(n) && xt(n, t), t._data = n), t.resyncElements()
            },
            _configure: function () {
                var t = this;
                t._config = ot.merge(Object.create(null), [t.chart.options.datasets[t._type], t.getDataset()], {
                    merger: function (t, e, n) {
                        "_meta" !== t && "data" !== t && ot._merger(t, e, n)
                    }
                })
            },
            _update: function (t) {
                var e = this;
                e._configure(), e._cachedDataOpts = null, e.update(t)
            },
            update: ot.noop,
            transition: function (t) {
                for (var e = this.getMeta(), n = e.data || [], a = n.length, i = 0; i < a; ++i) n[i].transition(t);
                e.dataset && e.dataset.transition(t)
            },
            draw: function () {
                var t = this.getMeta(), e = t.data || [], n = e.length, a = 0;
                for (t.dataset && t.dataset.draw(); a < n; ++a) e[a].draw()
            },
            getStyle: function (t) {
                var e, n = this, a = n.getMeta(), i = a.dataset;
                return n._configure(), i && void 0 === t ? e = n._resolveDatasetElementOptions(i || {}) : (t = t || 0, e = n._resolveDataElementOptions(a.data[t] || {}, t)), !1 !== e.fill && null !== e.fill || (e.backgroundColor = e.borderColor), e
            },
            _resolveDatasetElementOptions: function (t, e) {
                var n, a, i, r, o = this, s = o.chart, l = o._config, c = t.custom || {},
                    d = s.options.elements[o.datasetElementType.prototype._type] || {}, u = o._datasetElementOptions,
                    h = {}, p = {chart: s, dataset: o.getDataset(), datasetIndex: o.index, hover: e};
                for (n = 0, a = u.length; n < a; ++n) i = u[n], r = e ? "hover" + i.charAt(0).toUpperCase() + i.slice(1) : i, h[i] = bt([c[r], l[r], d[r]], p);
                return h
            },
            _resolveDataElementOptions: function (t, e) {
                var n = this, a = t && t.custom, i = n._cachedDataOpts;
                if (i && !a) return i;
                var r, o, s, l, c = n.chart, d = n._config,
                    u = c.options.elements[n.dataElementType.prototype._type] || {}, h = n._dataElementOptions, p = {},
                    f = {chart: c, dataIndex: e, dataset: n.getDataset(), datasetIndex: n.index}, g = {cacheable: !a};
                if (a = a || {}, ot.isArray(h)) for (o = 0, s = h.length; o < s; ++o) p[l = h[o]] = bt([a[l], d[l], u[l]], f, e, g); else for (o = 0, s = (r = Object.keys(h)).length; o < s; ++o) p[l = r[o]] = bt([a[l], d[h[l]], d[l], u[l]], f, e, g);
                return g.cacheable && (n._cachedDataOpts = Object.freeze(p)), p
            },
            removeHoverStyle: function (t) {
                ot.merge(t._model, t.$previousStyle || {}), delete t.$previousStyle
            },
            setHoverStyle: function (t) {
                var e = this.chart.data.datasets[t._datasetIndex], n = t._index, a = t.custom || {}, i = t._model,
                    r = ot.getHoverColor;
                t.$previousStyle = {
                    backgroundColor: i.backgroundColor,
                    borderColor: i.borderColor,
                    borderWidth: i.borderWidth
                }, i.backgroundColor = bt([a.hoverBackgroundColor, e.hoverBackgroundColor, r(i.backgroundColor)], void 0, n), i.borderColor = bt([a.hoverBorderColor, e.hoverBorderColor, r(i.borderColor)], void 0, n), i.borderWidth = bt([a.hoverBorderWidth, e.hoverBorderWidth, i.borderWidth], void 0, n)
            },
            _removeDatasetHoverStyle: function () {
                var t = this.getMeta().dataset;
                t && this.removeHoverStyle(t)
            },
            _setDatasetHoverStyle: function () {
                var t, e, n, a, i, r, o = this.getMeta().dataset, s = {};
                if (o) {
                    for (r = o._model, i = this._resolveDatasetElementOptions(o, !0), t = 0, e = (a = Object.keys(i)).length; t < e; ++t) s[n = a[t]] = r[n], r[n] = i[n];
                    o.$previousStyle = s
                }
            },
            resyncElements: function () {
                var t = this, e = t.getMeta(), n = t.getDataset().data, a = e.data.length, i = n.length;
                i < a ? e.data.splice(i, a - i) : i > a && t.insertElements(a, i - a)
            },
            insertElements: function (t, e) {
                for (var n = 0; n < e; ++n) this.addElementAndReset(t + n)
            },
            onDataPush: function () {
                var t = arguments.length;
                this.insertElements(this.getDataset().data.length - t, t)
            },
            onDataPop: function () {
                this.getMeta().data.pop()
            },
            onDataShift: function () {
                this.getMeta().data.shift()
            },
            onDataSplice: function (t, e) {
                this.getMeta().data.splice(t, e), this.insertElements(t, arguments.length - 2)
            },
            onDataUnshift: function () {
                this.insertElements(0, arguments.length)
            }
        }), wt.extend = ot.inherits;
        var St = wt, Ct = 2 * Math.PI;

        function kt(t, e) {
            var n = e.startAngle, a = e.endAngle, i = e.pixelMargin, r = i / e.outerRadius, o = e.x, s = e.y;
            t.beginPath(), t.arc(o, s, e.outerRadius, n - r, a + r), e.innerRadius > i ? (r = i / e.innerRadius, t.arc(o, s, e.innerRadius - i, a + r, n - r, !0)) : t.arc(o, s, i, a + Math.PI / 2, n - Math.PI / 2), t.closePath(), t.clip()
        }

        function Dt(t, e, n, a) {
            var i, r = n.endAngle;
            for (a && (n.endAngle = n.startAngle + Ct, kt(t, n), n.endAngle = r, n.endAngle === n.startAngle && n.fullCircles && (n.endAngle += Ct, n.fullCircles--)), t.beginPath(), t.arc(n.x, n.y, n.innerRadius, n.startAngle + Ct, n.startAngle, !0), i = 0; i < n.fullCircles; ++i) t.stroke();
            for (t.beginPath(), t.arc(n.x, n.y, e.outerRadius, n.startAngle, n.startAngle + Ct), i = 0; i < n.fullCircles; ++i) t.stroke()
        }

        function Tt(t, e, n) {
            var a = "inner" === e.borderAlign;
            a ? (t.lineWidth = 2 * e.borderWidth, t.lineJoin = "round") : (t.lineWidth = e.borderWidth, t.lineJoin = "bevel"), n.fullCircles && Dt(t, e, n, a), a && kt(t, n), t.beginPath(), t.arc(n.x, n.y, e.outerRadius, n.startAngle, n.endAngle), t.arc(n.x, n.y, n.innerRadius, n.endAngle, n.startAngle, !0), t.closePath(), t.stroke()
        }

        Q._set("global", {
            elements: {
                arc: {
                    backgroundColor: Q.global.defaultColor,
                    borderColor: "#fff",
                    borderWidth: 2,
                    borderAlign: "center"
                }
            }
        });
        var Et = ft.extend({
            _type: "arc", inLabelRange: function (t) {
                var e = this._view;
                return !!e && Math.pow(t - e.x, 2) < Math.pow(e.radius + e.hoverRadius, 2)
            }, inRange: function (t, e) {
                var n = this._view;
                if (n) {
                    for (var a = ot.getAngleFromPoint(n, {
                        x: t,
                        y: e
                    }), i = a.angle, r = a.distance, o = n.startAngle, s = n.endAngle; s < o;) s += Ct;
                    for (; i > s;) i -= Ct;
                    for (; i < o;) i += Ct;
                    var l = i >= o && i <= s, c = r >= n.innerRadius && r <= n.outerRadius;
                    return l && c
                }
                return !1
            }, getCenterPoint: function () {
                var t = this._view, e = (t.startAngle + t.endAngle) / 2, n = (t.innerRadius + t.outerRadius) / 2;
                return {x: t.x + Math.cos(e) * n, y: t.y + Math.sin(e) * n}
            }, getArea: function () {
                var t = this._view;
                return Math.PI * ((t.endAngle - t.startAngle) / (2 * Math.PI)) * (Math.pow(t.outerRadius, 2) - Math.pow(t.innerRadius, 2))
            }, tooltipPosition: function () {
                var t = this._view, e = t.startAngle + (t.endAngle - t.startAngle) / 2,
                    n = (t.outerRadius - t.innerRadius) / 2 + t.innerRadius;
                return {x: t.x + Math.cos(e) * n, y: t.y + Math.sin(e) * n}
            }, draw: function () {
                var t, e = this._chart.ctx, n = this._view, a = "inner" === n.borderAlign ? .33 : 0, i = {
                    x: n.x,
                    y: n.y,
                    innerRadius: n.innerRadius,
                    outerRadius: Math.max(n.outerRadius - a, 0),
                    pixelMargin: a,
                    startAngle: n.startAngle,
                    endAngle: n.endAngle,
                    fullCircles: Math.floor(n.circumference / Ct)
                };
                if (e.save(), e.fillStyle = n.backgroundColor, e.strokeStyle = n.borderColor, i.fullCircles) {
                    for (i.endAngle = i.startAngle + Ct, e.beginPath(), e.arc(i.x, i.y, i.outerRadius, i.startAngle, i.endAngle), e.arc(i.x, i.y, i.innerRadius, i.endAngle, i.startAngle, !0), e.closePath(), t = 0; t < i.fullCircles; ++t) e.fill();
                    i.endAngle = i.startAngle + n.circumference % Ct
                }
                e.beginPath(), e.arc(i.x, i.y, i.outerRadius, i.startAngle, i.endAngle), e.arc(i.x, i.y, i.innerRadius, i.endAngle, i.startAngle, !0), e.closePath(), e.fill(), n.borderWidth && Tt(e, n, i), e.restore()
            }
        }), At = ot.valueOrDefault, It = Q.global.defaultColor;
        Q._set("global", {
            elements: {
                line: {
                    tension: .4,
                    backgroundColor: It,
                    borderWidth: 3,
                    borderColor: It,
                    borderCapStyle: "butt",
                    borderDash: [],
                    borderDashOffset: 0,
                    borderJoinStyle: "miter",
                    capBezierPoints: !0,
                    fill: !0
                }
            }
        });
        var Mt = ft.extend({
            _type: "line", draw: function () {
                var t, e, n, a = this, i = a._view, r = a._chart.ctx, o = i.spanGaps, s = a._children.slice(),
                    l = Q.global, c = l.elements.line, d = -1, u = a._loop;
                if (s.length) {
                    if (a._loop) {
                        for (t = 0; t < s.length; ++t) if (e = ot.previousItem(s, t), !s[t]._view.skip && e._view.skip) {
                            s = s.slice(t).concat(s.slice(0, t)), u = o;
                            break
                        }
                        u && s.push(s[0])
                    }
                    for (r.save(), r.lineCap = i.borderCapStyle || c.borderCapStyle, r.setLineDash && r.setLineDash(i.borderDash || c.borderDash), r.lineDashOffset = At(i.borderDashOffset, c.borderDashOffset), r.lineJoin = i.borderJoinStyle || c.borderJoinStyle, r.lineWidth = At(i.borderWidth, c.borderWidth), r.strokeStyle = i.borderColor || l.defaultColor, r.beginPath(), (n = s[0]._view).skip || (r.moveTo(n.x, n.y), d = 0), t = 1; t < s.length; ++t) n = s[t]._view, e = -1 === d ? ot.previousItem(s, t) : s[d], n.skip || (d !== t - 1 && !o || -1 === d ? r.moveTo(n.x, n.y) : ot.canvas.lineTo(r, e._view, n), d = t);
                    u && r.closePath(), r.stroke(), r.restore()
                }
            }
        }), Rt = ot.valueOrDefault, Pt = Q.global.defaultColor;

        function Ot(t) {
            var e = this._view;
            return !!e && Math.abs(t - e.x) < e.radius + e.hitRadius
        }

        function jt(t) {
            var e = this._view;
            return !!e && Math.abs(t - e.y) < e.radius + e.hitRadius
        }

        Q._set("global", {
            elements: {
                point: {
                    radius: 3,
                    pointStyle: "circle",
                    backgroundColor: Pt,
                    borderColor: Pt,
                    borderWidth: 1,
                    hitRadius: 1,
                    hoverRadius: 4,
                    hoverBorderWidth: 1
                }
            }
        });
        var Nt = ft.extend({
            _type: "point", inRange: function (t, e) {
                var n = this._view;
                return !!n && Math.pow(t - n.x, 2) + Math.pow(e - n.y, 2) < Math.pow(n.hitRadius + n.radius, 2)
            }, inLabelRange: Ot, inXRange: Ot, inYRange: jt, getCenterPoint: function () {
                var t = this._view;
                return {x: t.x, y: t.y}
            }, getArea: function () {
                return Math.PI * Math.pow(this._view.radius, 2)
            }, tooltipPosition: function () {
                var t = this._view;
                return {x: t.x, y: t.y, padding: t.radius + t.borderWidth}
            }, draw: function (t) {
                var e = this._view, n = this._chart.ctx, a = e.pointStyle, i = e.rotation, r = e.radius, o = e.x,
                    s = e.y, l = Q.global, c = l.defaultColor;
                e.skip || (void 0 === t || ot.canvas._isPointInArea(e, t)) && (n.strokeStyle = e.borderColor || c, n.lineWidth = Rt(e.borderWidth, l.elements.point.borderWidth), n.fillStyle = e.backgroundColor || c, ot.canvas.drawPoint(n, a, r, o, s, i))
            }
        }), Lt = Q.global.defaultColor;

        function Ft(t) {
            return t && void 0 !== t.width
        }

        function Ht(t) {
            var e, n, a, i, r;
            return Ft(t) ? (r = t.width / 2, e = t.x - r, n = t.x + r, a = Math.min(t.y, t.base), i = Math.max(t.y, t.base)) : (r = t.height / 2, e = Math.min(t.x, t.base), n = Math.max(t.x, t.base), a = t.y - r, i = t.y + r), {
                left: e,
                top: a,
                right: n,
                bottom: i
            }
        }

        function Bt(t, e, n) {
            return t === e ? n : t === n ? e : t
        }

        function qt(t) {
            var e = t.borderSkipped, n = {};
            return e ? (t.horizontal ? t.base > t.x && (e = Bt(e, "left", "right")) : t.base < t.y && (e = Bt(e, "bottom", "top")), n[e] = !0, n) : n
        }

        function zt(t, e, n) {
            var a, i, r, o, s = t.borderWidth, l = qt(t);
            return ot.isObject(s) ? (a = +s.top || 0, i = +s.right || 0, r = +s.bottom || 0, o = +s.left || 0) : a = i = r = o = +s || 0, {
                t: l.top || a < 0 ? 0 : a > n ? n : a,
                r: l.right || i < 0 ? 0 : i > e ? e : i,
                b: l.bottom || r < 0 ? 0 : r > n ? n : r,
                l: l.left || o < 0 ? 0 : o > e ? e : o
            }
        }

        function Wt(t) {
            var e = Ht(t), n = e.right - e.left, a = e.bottom - e.top, i = zt(t, n / 2, a / 2);
            return {
                outer: {x: e.left, y: e.top, w: n, h: a},
                inner: {x: e.left + i.l, y: e.top + i.t, w: n - i.l - i.r, h: a - i.t - i.b}
            }
        }

        function Vt(t, e, n) {
            var a = null === e, i = null === n, r = !(!t || a && i) && Ht(t);
            return r && (a || e >= r.left && e <= r.right) && (i || n >= r.top && n <= r.bottom)
        }

        Q._set("global", {
            elements: {
                rectangle: {
                    backgroundColor: Lt,
                    borderColor: Lt,
                    borderSkipped: "bottom",
                    borderWidth: 0
                }
            }
        });
        var $t = ft.extend({
            _type: "rectangle", draw: function () {
                var t = this._chart.ctx, e = this._view, n = Wt(e), a = n.outer, i = n.inner;
                t.fillStyle = e.backgroundColor, t.fillRect(a.x, a.y, a.w, a.h), a.w === i.w && a.h === i.h || (t.save(), t.beginPath(), t.rect(a.x, a.y, a.w, a.h), t.clip(), t.fillStyle = e.borderColor, t.rect(i.x, i.y, i.w, i.h), t.fill("evenodd"), t.restore())
            }, height: function () {
                var t = this._view;
                return t.base - t.y
            }, inRange: function (t, e) {
                return Vt(this._view, t, e)
            }, inLabelRange: function (t, e) {
                var n = this._view;
                return Ft(n) ? Vt(n, t, null) : Vt(n, null, e)
            }, inXRange: function (t) {
                return Vt(this._view, t, null)
            }, inYRange: function (t) {
                return Vt(this._view, null, t)
            }, getCenterPoint: function () {
                var t, e, n = this._view;
                return Ft(n) ? (t = n.x, e = (n.y + n.base) / 2) : (t = (n.x + n.base) / 2, e = n.y), {x: t, y: e}
            }, getArea: function () {
                var t = this._view;
                return Ft(t) ? t.width * Math.abs(t.y - t.base) : t.height * Math.abs(t.x - t.base)
            }, tooltipPosition: function () {
                var t = this._view;
                return {x: t.x, y: t.y}
            }
        }), Yt = {}, Ut = Et, Gt = Mt, Xt = Nt, Zt = $t;
        Yt.Arc = Ut, Yt.Line = Gt, Yt.Point = Xt, Yt.Rectangle = Zt;
        var Kt = ot._deprecated, Qt = ot.valueOrDefault;

        function Jt(t, e) {
            var n, a, i, r, o = t._length;
            for (i = 1, r = e.length; i < r; ++i) o = Math.min(o, Math.abs(e[i] - e[i - 1]));
            for (i = 0, r = t.getTicks().length; i < r; ++i) a = t.getPixelForTick(i), o = i > 0 ? Math.min(o, Math.abs(a - n)) : o, n = a;
            return o
        }

        function te(t, e, n) {
            var a, i, r = n.barThickness, o = e.stackCount, s = e.pixels[t],
                l = ot.isNullOrUndef(r) ? Jt(e.scale, e.pixels) : -1;
            return ot.isNullOrUndef(r) ? (a = l * n.categoryPercentage, i = n.barPercentage) : (a = r * o, i = 1), {
                chunk: a / o,
                ratio: i,
                start: s - a / 2
            }
        }

        function ee(t, e, n) {
            var a, i = e.pixels, r = i[t], o = t > 0 ? i[t - 1] : null, s = t < i.length - 1 ? i[t + 1] : null,
                l = n.categoryPercentage;
            return null === o && (o = r - (null === s ? e.end - e.start : s - r)), null === s && (s = r + r - o), a = r - (r - Math.min(o, s)) / 2 * l, {
                chunk: Math.abs(s - o) / 2 * l / e.stackCount,
                ratio: n.barPercentage,
                start: a
            }
        }

        Q._set("bar", {
            hover: {mode: "label"},
            scales: {
                xAxes: [{type: "category", offset: !0, gridLines: {offsetGridLines: !0}}],
                yAxes: [{type: "linear"}]
            }
        }), Q._set("global", {datasets: {bar: {categoryPercentage: .8, barPercentage: .9}}});
        var ne = St.extend({
            dataElementType: Yt.Rectangle,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderSkipped", "borderWidth", "barPercentage", "barThickness", "categoryPercentage", "maxBarThickness", "minBarLength"],
            initialize: function () {
                var t, e, n = this;
                St.prototype.initialize.apply(n, arguments), (t = n.getMeta()).stack = n.getDataset().stack, t.bar = !0, e = n._getIndexScale().options, Kt("bar chart", e.barPercentage, "scales.[x/y]Axes.barPercentage", "dataset.barPercentage"), Kt("bar chart", e.barThickness, "scales.[x/y]Axes.barThickness", "dataset.barThickness"), Kt("bar chart", e.categoryPercentage, "scales.[x/y]Axes.categoryPercentage", "dataset.categoryPercentage"), Kt("bar chart", n._getValueScale().options.minBarLength, "scales.[x/y]Axes.minBarLength", "dataset.minBarLength"), Kt("bar chart", e.maxBarThickness, "scales.[x/y]Axes.maxBarThickness", "dataset.maxBarThickness")
            },
            update: function (t) {
                var e, n, a = this, i = a.getMeta().data;
                for (a._ruler = a.getRuler(), e = 0, n = i.length; e < n; ++e) a.updateElement(i[e], e, t)
            },
            updateElement: function (t, e, n) {
                var a = this, i = a.getMeta(), r = a.getDataset(), o = a._resolveDataElementOptions(t, e);
                t._xScale = a.getScaleForId(i.xAxisID), t._yScale = a.getScaleForId(i.yAxisID), t._datasetIndex = a.index, t._index = e, t._model = {
                    backgroundColor: o.backgroundColor,
                    borderColor: o.borderColor,
                    borderSkipped: o.borderSkipped,
                    borderWidth: o.borderWidth,
                    datasetLabel: r.label,
                    label: a.chart.data.labels[e]
                }, ot.isArray(r.data[e]) && (t._model.borderSkipped = null), a._updateElementGeometry(t, e, n, o), t.pivot()
            },
            _updateElementGeometry: function (t, e, n, a) {
                var i = this, r = t._model, o = i._getValueScale(), s = o.getBasePixel(), l = o.isHorizontal(),
                    c = i._ruler || i.getRuler(), d = i.calculateBarValuePixels(i.index, e, a),
                    u = i.calculateBarIndexPixels(i.index, e, c, a);
                r.horizontal = l, r.base = n ? s : d.base, r.x = l ? n ? s : d.head : u.center, r.y = l ? u.center : n ? s : d.head, r.height = l ? u.size : void 0, r.width = l ? void 0 : u.size
            },
            _getStacks: function (t) {
                var e, n, a = this, i = a._getIndexScale(), r = i._getMatchingVisibleMetas(a._type),
                    o = i.options.stacked, s = r.length, l = [];
                for (e = 0; e < s && (n = r[e], (!1 === o || -1 === l.indexOf(n.stack) || void 0 === o && void 0 === n.stack) && l.push(n.stack), n.index !== t); ++e) ;
                return l
            },
            getStackCount: function () {
                return this._getStacks().length
            },
            getStackIndex: function (t, e) {
                var n = this._getStacks(t), a = void 0 !== e ? n.indexOf(e) : -1;
                return -1 === a ? n.length - 1 : a
            },
            getRuler: function () {
                var t, e, n = this, a = n._getIndexScale(), i = [];
                for (t = 0, e = n.getMeta().data.length; t < e; ++t) i.push(a.getPixelForValue(null, t, n.index));
                return {pixels: i, start: a._startPixel, end: a._endPixel, stackCount: n.getStackCount(), scale: a}
            },
            calculateBarValuePixels: function (t, e, n) {
                var a, i, r, o, s, l, c, d = this, u = d.chart, h = d._getValueScale(), p = h.isHorizontal(),
                    f = u.data.datasets, g = h._getMatchingVisibleMetas(d._type), m = h._parseValue(f[t].data[e]),
                    v = n.minBarLength, b = h.options.stacked, y = d.getMeta().stack,
                    x = void 0 === m.start ? 0 : m.max >= 0 && m.min >= 0 ? m.min : m.max,
                    _ = void 0 === m.start ? m.end : m.max >= 0 && m.min >= 0 ? m.max - m.min : m.min - m.max,
                    w = g.length;
                if (b || void 0 === b && void 0 !== y) for (a = 0; a < w && (i = g[a]).index !== t; ++a) i.stack === y && (r = void 0 === (c = h._parseValue(f[i.index].data[e])).start ? c.end : c.min >= 0 && c.max >= 0 ? c.max : c.min, (m.min < 0 && r < 0 || m.max >= 0 && r > 0) && (x += r));
                return o = h.getPixelForValue(x), l = (s = h.getPixelForValue(x + _)) - o, void 0 !== v && Math.abs(l) < v && (l = v, s = _ >= 0 && !p || _ < 0 && p ? o - v : o + v), {
                    size: l,
                    base: o,
                    head: s,
                    center: s + l / 2
                }
            },
            calculateBarIndexPixels: function (t, e, n, a) {
                var i = this, r = "flex" === a.barThickness ? ee(e, n, a) : te(e, n, a),
                    o = i.getStackIndex(t, i.getMeta().stack), s = r.start + r.chunk * o + r.chunk / 2,
                    l = Math.min(Qt(a.maxBarThickness, 1 / 0), r.chunk * r.ratio);
                return {base: s - l / 2, head: s + l / 2, center: s, size: l}
            },
            draw: function () {
                var t = this, e = t.chart, n = t._getValueScale(), a = t.getMeta().data, i = t.getDataset(),
                    r = a.length, o = 0;
                for (ot.canvas.clipArea(e.ctx, e.chartArea); o < r; ++o) {
                    var s = n._parseValue(i.data[o]);
                    isNaN(s.min) || isNaN(s.max) || a[o].draw()
                }
                ot.canvas.unclipArea(e.ctx)
            },
            _resolveDataElementOptions: function () {
                var t = this, e = ot.extend({}, St.prototype._resolveDataElementOptions.apply(t, arguments)),
                    n = t._getIndexScale().options, a = t._getValueScale().options;
                return e.barPercentage = Qt(n.barPercentage, e.barPercentage), e.barThickness = Qt(n.barThickness, e.barThickness), e.categoryPercentage = Qt(n.categoryPercentage, e.categoryPercentage), e.maxBarThickness = Qt(n.maxBarThickness, e.maxBarThickness), e.minBarLength = Qt(a.minBarLength, e.minBarLength), e
            }
        }), ae = ot.valueOrDefault, ie = ot.options.resolve;
        Q._set("bubble", {
            hover: {mode: "single"},
            scales: {
                xAxes: [{type: "linear", position: "bottom", id: "x-axis-0"}],
                yAxes: [{type: "linear", position: "left", id: "y-axis-0"}]
            },
            tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (t, e) {
                        var n = e.datasets[t.datasetIndex].label || "", a = e.datasets[t.datasetIndex].data[t.index];
                        return n + ": (" + t.xLabel + ", " + t.yLabel + ", " + a.r + ")"
                    }
                }
            }
        });
        var re = St.extend({
            dataElementType: Yt.Point,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth", "hoverRadius", "hitRadius", "pointStyle", "rotation"],
            update: function (t) {
                var e = this, n = e.getMeta().data;
                ot.each(n, (function (n, a) {
                    e.updateElement(n, a, t)
                }))
            },
            updateElement: function (t, e, n) {
                var a = this, i = a.getMeta(), r = t.custom || {}, o = a.getScaleForId(i.xAxisID),
                    s = a.getScaleForId(i.yAxisID), l = a._resolveDataElementOptions(t, e), c = a.getDataset().data[e],
                    d = a.index,
                    u = n ? o.getPixelForDecimal(.5) : o.getPixelForValue("object" == typeof c ? c : NaN, e, d),
                    h = n ? s.getBasePixel() : s.getPixelForValue(c, e, d);
                t._xScale = o, t._yScale = s, t._options = l, t._datasetIndex = d, t._index = e, t._model = {
                    backgroundColor: l.backgroundColor,
                    borderColor: l.borderColor,
                    borderWidth: l.borderWidth,
                    hitRadius: l.hitRadius,
                    pointStyle: l.pointStyle,
                    rotation: l.rotation,
                    radius: n ? 0 : l.radius,
                    skip: r.skip || isNaN(u) || isNaN(h),
                    x: u,
                    y: h
                }, t.pivot()
            },
            setHoverStyle: function (t) {
                var e = t._model, n = t._options, a = ot.getHoverColor;
                t.$previousStyle = {
                    backgroundColor: e.backgroundColor,
                    borderColor: e.borderColor,
                    borderWidth: e.borderWidth,
                    radius: e.radius
                }, e.backgroundColor = ae(n.hoverBackgroundColor, a(n.backgroundColor)), e.borderColor = ae(n.hoverBorderColor, a(n.borderColor)), e.borderWidth = ae(n.hoverBorderWidth, n.borderWidth), e.radius = n.radius + n.hoverRadius
            },
            _resolveDataElementOptions: function (t, e) {
                var n = this, a = n.chart, i = n.getDataset(), r = t.custom || {}, o = i.data[e] || {},
                    s = St.prototype._resolveDataElementOptions.apply(n, arguments),
                    l = {chart: a, dataIndex: e, dataset: i, datasetIndex: n.index};
                return n._cachedDataOpts === s && (s = ot.extend({}, s)), s.radius = ie([r.radius, o.r, n._config.radius, a.options.elements.point.radius], l, e), s
            }
        }), oe = ot.valueOrDefault, se = Math.PI, le = 2 * se, ce = se / 2;
        Q._set("doughnut", {
            animation: {animateRotate: !0, animateScale: !1}, hover: {mode: "single"}, legendCallback: function (t) {
                var e, n, a, i = document.createElement("ul"), r = t.data, o = r.datasets, s = r.labels;
                if (i.setAttribute("class", t.id + "-legend"), o.length) for (e = 0, n = o[0].data.length; e < n; ++e) (a = i.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = o[0].backgroundColor[e], s[e] && a.appendChild(document.createTextNode(s[e]));
                return i.outerHTML
            }, legend: {
                labels: {
                    generateLabels: function (t) {
                        var e = t.data;
                        return e.labels.length && e.datasets.length ? e.labels.map((function (n, a) {
                            var i = t.getDatasetMeta(0), r = i.controller.getStyle(a);
                            return {
                                text: n,
                                fillStyle: r.backgroundColor,
                                strokeStyle: r.borderColor,
                                lineWidth: r.borderWidth,
                                hidden: isNaN(e.datasets[0].data[a]) || i.data[a].hidden,
                                index: a
                            }
                        })) : []
                    }
                }, onClick: function (t, e) {
                    var n, a, i, r = e.index, o = this.chart;
                    for (n = 0, a = (o.data.datasets || []).length; n < a; ++n) (i = o.getDatasetMeta(n)).data[r] && (i.data[r].hidden = !i.data[r].hidden);
                    o.update()
                }
            }, cutoutPercentage: 50, rotation: -ce, circumference: le, tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (t, e) {
                        var n = e.labels[t.index], a = ": " + e.datasets[t.datasetIndex].data[t.index];
                        return ot.isArray(n) ? (n = n.slice())[0] += a : n += a, n
                    }
                }
            }
        });
        var de = St.extend({
            dataElementType: Yt.Arc,
            linkScales: ot.noop,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
            getRingIndex: function (t) {
                for (var e = 0, n = 0; n < t; ++n) this.chart.isDatasetVisible(n) && ++e;
                return e
            },
            update: function (t) {
                var e, n, a, i, r = this, o = r.chart, s = o.chartArea, l = o.options, c = 1, d = 1, u = 0, h = 0,
                    p = r.getMeta(), f = p.data, g = l.cutoutPercentage / 100 || 0, m = l.circumference,
                    v = r._getRingWeight(r.index);
                if (m < le) {
                    var b = l.rotation % le, y = (b += b >= se ? -le : b < -se ? le : 0) + m, x = Math.cos(b),
                        _ = Math.sin(b), w = Math.cos(y), S = Math.sin(y), C = b <= 0 && y >= 0 || y >= le,
                        k = b <= ce && y >= ce || y >= le + ce, D = b <= -ce && y >= -ce || y >= se + ce,
                        T = b === -se || y >= se ? -1 : Math.min(x, x * g, w, w * g),
                        E = D ? -1 : Math.min(_, _ * g, S, S * g), A = C ? 1 : Math.max(x, x * g, w, w * g),
                        I = k ? 1 : Math.max(_, _ * g, S, S * g);
                    c = (A - T) / 2, d = (I - E) / 2, u = -(A + T) / 2, h = -(I + E) / 2
                }
                for (a = 0, i = f.length; a < i; ++a) f[a]._options = r._resolveDataElementOptions(f[a], a);
                for (o.borderWidth = r.getMaxBorderWidth(), e = (s.right - s.left - o.borderWidth) / c, n = (s.bottom - s.top - o.borderWidth) / d, o.outerRadius = Math.max(Math.min(e, n) / 2, 0), o.innerRadius = Math.max(o.outerRadius * g, 0), o.radiusLength = (o.outerRadius - o.innerRadius) / (r._getVisibleDatasetWeightTotal() || 1), o.offsetX = u * o.outerRadius, o.offsetY = h * o.outerRadius, p.total = r.calculateTotal(), r.outerRadius = o.outerRadius - o.radiusLength * r._getRingWeightOffset(r.index), r.innerRadius = Math.max(r.outerRadius - o.radiusLength * v, 0), a = 0, i = f.length; a < i; ++a) r.updateElement(f[a], a, t)
            },
            updateElement: function (t, e, n) {
                var a = this, i = a.chart, r = i.chartArea, o = i.options, s = o.animation, l = (r.left + r.right) / 2,
                    c = (r.top + r.bottom) / 2, d = o.rotation, u = o.rotation, h = a.getDataset(),
                    p = n && s.animateRotate || t.hidden ? 0 : a.calculateCircumference(h.data[e]) * (o.circumference / le),
                    f = n && s.animateScale ? 0 : a.innerRadius, g = n && s.animateScale ? 0 : a.outerRadius,
                    m = t._options || {};
                ot.extend(t, {
                    _datasetIndex: a.index,
                    _index: e,
                    _model: {
                        backgroundColor: m.backgroundColor,
                        borderColor: m.borderColor,
                        borderWidth: m.borderWidth,
                        borderAlign: m.borderAlign,
                        x: l + i.offsetX,
                        y: c + i.offsetY,
                        startAngle: d,
                        endAngle: u,
                        circumference: p,
                        outerRadius: g,
                        innerRadius: f,
                        label: ot.valueAtIndexOrDefault(h.label, e, i.data.labels[e])
                    }
                });
                var v = t._model;
                n && s.animateRotate || (v.startAngle = 0 === e ? o.rotation : a.getMeta().data[e - 1]._model.endAngle, v.endAngle = v.startAngle + v.circumference), t.pivot()
            },
            calculateTotal: function () {
                var t, e = this.getDataset(), n = this.getMeta(), a = 0;
                return ot.each(n.data, (function (n, i) {
                    t = e.data[i], isNaN(t) || n.hidden || (a += Math.abs(t))
                })), a
            },
            calculateCircumference: function (t) {
                var e = this.getMeta().total;
                return e > 0 && !isNaN(t) ? le * (Math.abs(t) / e) : 0
            },
            getMaxBorderWidth: function (t) {
                var e, n, a, i, r, o, s, l, c = this, d = 0, u = c.chart;
                if (!t) for (e = 0, n = u.data.datasets.length; e < n; ++e) if (u.isDatasetVisible(e)) {
                    t = (a = u.getDatasetMeta(e)).data, e !== c.index && (r = a.controller);
                    break
                }
                if (!t) return 0;
                for (e = 0, n = t.length; e < n; ++e) i = t[e], r ? (r._configure(), o = r._resolveDataElementOptions(i, e)) : o = i._options, "inner" !== o.borderAlign && (s = o.borderWidth, d = (l = o.hoverBorderWidth) > (d = s > d ? s : d) ? l : d);
                return d
            },
            setHoverStyle: function (t) {
                var e = t._model, n = t._options, a = ot.getHoverColor;
                t.$previousStyle = {
                    backgroundColor: e.backgroundColor,
                    borderColor: e.borderColor,
                    borderWidth: e.borderWidth
                }, e.backgroundColor = oe(n.hoverBackgroundColor, a(n.backgroundColor)), e.borderColor = oe(n.hoverBorderColor, a(n.borderColor)), e.borderWidth = oe(n.hoverBorderWidth, n.borderWidth)
            },
            _getRingWeightOffset: function (t) {
                for (var e = 0, n = 0; n < t; ++n) this.chart.isDatasetVisible(n) && (e += this._getRingWeight(n));
                return e
            },
            _getRingWeight: function (t) {
                return Math.max(oe(this.chart.data.datasets[t].weight, 1), 0)
            },
            _getVisibleDatasetWeightTotal: function () {
                return this._getRingWeightOffset(this.chart.data.datasets.length)
            }
        });
        Q._set("horizontalBar", {
            hover: {mode: "index", axis: "y"},
            scales: {
                xAxes: [{type: "linear", position: "bottom"}],
                yAxes: [{type: "category", position: "left", offset: !0, gridLines: {offsetGridLines: !0}}]
            },
            elements: {rectangle: {borderSkipped: "left"}},
            tooltips: {mode: "index", axis: "y"}
        }), Q._set("global", {datasets: {horizontalBar: {categoryPercentage: .8, barPercentage: .9}}});
        var ue = ne.extend({
            _getValueScaleId: function () {
                return this.getMeta().xAxisID
            }, _getIndexScaleId: function () {
                return this.getMeta().yAxisID
            }
        }), he = ot.valueOrDefault, pe = ot.options.resolve, fe = ot.canvas._isPointInArea;

        function ge(t, e) {
            var n = t && t.options.ticks || {}, a = n.reverse, i = void 0 === n.min ? e : 0,
                r = void 0 === n.max ? e : 0;
            return {start: a ? r : i, end: a ? i : r}
        }

        function me(t, e, n) {
            var a = n / 2, i = ge(t, a), r = ge(e, a);
            return {top: r.end, right: i.end, bottom: r.start, left: i.start}
        }

        function ve(t) {
            var e, n, a, i;
            return ot.isObject(t) ? (e = t.top, n = t.right, a = t.bottom, i = t.left) : e = n = a = i = t, {
                top: e,
                right: n,
                bottom: a,
                left: i
            }
        }

        Q._set("line", {
            showLines: !0,
            spanGaps: !1,
            hover: {mode: "label"},
            scales: {xAxes: [{type: "category", id: "x-axis-0"}], yAxes: [{type: "linear", id: "y-axis-0"}]}
        });
        var be = St.extend({
            datasetElementType: Yt.Line,
            dataElementType: Yt.Point,
            _datasetElementOptions: ["backgroundColor", "borderCapStyle", "borderColor", "borderDash", "borderDashOffset", "borderJoinStyle", "borderWidth", "cubicInterpolationMode", "fill"],
            _dataElementOptions: {
                backgroundColor: "pointBackgroundColor",
                borderColor: "pointBorderColor",
                borderWidth: "pointBorderWidth",
                hitRadius: "pointHitRadius",
                hoverBackgroundColor: "pointHoverBackgroundColor",
                hoverBorderColor: "pointHoverBorderColor",
                hoverBorderWidth: "pointHoverBorderWidth",
                hoverRadius: "pointHoverRadius",
                pointStyle: "pointStyle",
                radius: "pointRadius",
                rotation: "pointRotation"
            },
            update: function (t) {
                var e, n, a = this, i = a.getMeta(), r = i.dataset, o = i.data || [], s = a.chart.options,
                    l = a._config, c = a._showLine = he(l.showLine, s.showLines);
                for (a._xScale = a.getScaleForId(i.xAxisID), a._yScale = a.getScaleForId(i.yAxisID), c && (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), r._scale = a._yScale, r._datasetIndex = a.index, r._children = o, r._model = a._resolveDatasetElementOptions(r), r.pivot()), e = 0, n = o.length; e < n; ++e) a.updateElement(o[e], e, t);
                for (c && 0 !== r._model.tension && a.updateBezierControlPoints(), e = 0, n = o.length; e < n; ++e) o[e].pivot()
            },
            updateElement: function (t, e, n) {
                var a, i, r = this, o = r.getMeta(), s = t.custom || {}, l = r.getDataset(), c = r.index, d = l.data[e],
                    u = r._xScale, h = r._yScale, p = o.dataset._model, f = r._resolveDataElementOptions(t, e);
                a = u.getPixelForValue("object" == typeof d ? d : NaN, e, c), i = n ? h.getBasePixel() : r.calculatePointY(d, e, c), t._xScale = u, t._yScale = h, t._options = f, t._datasetIndex = c, t._index = e, t._model = {
                    x: a,
                    y: i,
                    skip: s.skip || isNaN(a) || isNaN(i),
                    radius: f.radius,
                    pointStyle: f.pointStyle,
                    rotation: f.rotation,
                    backgroundColor: f.backgroundColor,
                    borderColor: f.borderColor,
                    borderWidth: f.borderWidth,
                    tension: he(s.tension, p ? p.tension : 0),
                    steppedLine: !!p && p.steppedLine,
                    hitRadius: f.hitRadius
                }
            },
            _resolveDatasetElementOptions: function (t) {
                var e = this, n = e._config, a = t.custom || {}, i = e.chart.options, r = i.elements.line,
                    o = St.prototype._resolveDatasetElementOptions.apply(e, arguments);
                return o.spanGaps = he(n.spanGaps, i.spanGaps), o.tension = he(n.lineTension, r.tension), o.steppedLine = pe([a.steppedLine, n.steppedLine, r.stepped]), o.clip = ve(he(n.clip, me(e._xScale, e._yScale, o.borderWidth))), o
            },
            calculatePointY: function (t, e, n) {
                var a, i, r, o, s, l, c, d = this, u = d.chart, h = d._yScale, p = 0, f = 0;
                if (h.options.stacked) {
                    for (s = +h.getRightValue(t), c = (l = u._getSortedVisibleDatasetMetas()).length, a = 0; a < c && (r = l[a]).index !== n; ++a) i = u.data.datasets[r.index], "line" === r.type && r.yAxisID === h.id && ((o = +h.getRightValue(i.data[e])) < 0 ? f += o || 0 : p += o || 0);
                    return s < 0 ? h.getPixelForValue(f + s) : h.getPixelForValue(p + s)
                }
                return h.getPixelForValue(t)
            },
            updateBezierControlPoints: function () {
                var t, e, n, a, i = this, r = i.chart, o = i.getMeta(), s = o.dataset._model, l = r.chartArea,
                    c = o.data || [];

                function d(t, e, n) {
                    return Math.max(Math.min(t, n), e)
                }

                if (s.spanGaps && (c = c.filter((function (t) {
                    return !t._model.skip
                }))), "monotone" === s.cubicInterpolationMode) ot.splineCurveMonotone(c); else for (t = 0, e = c.length; t < e; ++t) n = c[t]._model, a = ot.splineCurve(ot.previousItem(c, t)._model, n, ot.nextItem(c, t)._model, s.tension), n.controlPointPreviousX = a.previous.x, n.controlPointPreviousY = a.previous.y, n.controlPointNextX = a.next.x, n.controlPointNextY = a.next.y;
                if (r.options.elements.line.capBezierPoints) for (t = 0, e = c.length; t < e; ++t) n = c[t]._model, fe(n, l) && (t > 0 && fe(c[t - 1]._model, l) && (n.controlPointPreviousX = d(n.controlPointPreviousX, l.left, l.right), n.controlPointPreviousY = d(n.controlPointPreviousY, l.top, l.bottom)), t < c.length - 1 && fe(c[t + 1]._model, l) && (n.controlPointNextX = d(n.controlPointNextX, l.left, l.right), n.controlPointNextY = d(n.controlPointNextY, l.top, l.bottom)))
            },
            draw: function () {
                var t, e = this, n = e.chart, a = e.getMeta(), i = a.data || [], r = n.chartArea, o = n.canvas, s = 0,
                    l = i.length;
                for (e._showLine && (t = a.dataset._model.clip, ot.canvas.clipArea(n.ctx, {
                    left: !1 === t.left ? 0 : r.left - t.left,
                    right: !1 === t.right ? o.width : r.right + t.right,
                    top: !1 === t.top ? 0 : r.top - t.top,
                    bottom: !1 === t.bottom ? o.height : r.bottom + t.bottom
                }), a.dataset.draw(), ot.canvas.unclipArea(n.ctx)); s < l; ++s) i[s].draw(r)
            },
            setHoverStyle: function (t) {
                var e = t._model, n = t._options, a = ot.getHoverColor;
                t.$previousStyle = {
                    backgroundColor: e.backgroundColor,
                    borderColor: e.borderColor,
                    borderWidth: e.borderWidth,
                    radius: e.radius
                }, e.backgroundColor = he(n.hoverBackgroundColor, a(n.backgroundColor)), e.borderColor = he(n.hoverBorderColor, a(n.borderColor)), e.borderWidth = he(n.hoverBorderWidth, n.borderWidth), e.radius = he(n.hoverRadius, n.radius)
            }
        }), ye = ot.options.resolve;
        Q._set("polarArea", {
            scale: {
                type: "radialLinear",
                angleLines: {display: !1},
                gridLines: {circular: !0},
                pointLabels: {display: !1},
                ticks: {beginAtZero: !0}
            },
            animation: {animateRotate: !0, animateScale: !0},
            startAngle: -.5 * Math.PI,
            legendCallback: function (t) {
                var e, n, a, i = document.createElement("ul"), r = t.data, o = r.datasets, s = r.labels;
                if (i.setAttribute("class", t.id + "-legend"), o.length) for (e = 0, n = o[0].data.length; e < n; ++e) (a = i.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = o[0].backgroundColor[e], s[e] && a.appendChild(document.createTextNode(s[e]));
                return i.outerHTML
            },
            legend: {
                labels: {
                    generateLabels: function (t) {
                        var e = t.data;
                        return e.labels.length && e.datasets.length ? e.labels.map((function (n, a) {
                            var i = t.getDatasetMeta(0), r = i.controller.getStyle(a);
                            return {
                                text: n,
                                fillStyle: r.backgroundColor,
                                strokeStyle: r.borderColor,
                                lineWidth: r.borderWidth,
                                hidden: isNaN(e.datasets[0].data[a]) || i.data[a].hidden,
                                index: a
                            }
                        })) : []
                    }
                }, onClick: function (t, e) {
                    var n, a, i, r = e.index, o = this.chart;
                    for (n = 0, a = (o.data.datasets || []).length; n < a; ++n) (i = o.getDatasetMeta(n)).data[r].hidden = !i.data[r].hidden;
                    o.update()
                }
            },
            tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (t, e) {
                        return e.labels[t.index] + ": " + t.yLabel
                    }
                }
            }
        });
        var xe = St.extend({
            dataElementType: Yt.Arc,
            linkScales: ot.noop,
            _dataElementOptions: ["backgroundColor", "borderColor", "borderWidth", "borderAlign", "hoverBackgroundColor", "hoverBorderColor", "hoverBorderWidth"],
            _getIndexScaleId: function () {
                return this.chart.scale.id
            },
            _getValueScaleId: function () {
                return this.chart.scale.id
            },
            update: function (t) {
                var e, n, a, i = this, r = i.getDataset(), o = i.getMeta(), s = i.chart.options.startAngle || 0,
                    l = i._starts = [], c = i._angles = [], d = o.data;
                for (i._updateRadius(), o.count = i.countVisibleElements(), e = 0, n = r.data.length; e < n; e++) l[e] = s, a = i._computeAngle(e), c[e] = a, s += a;
                for (e = 0, n = d.length; e < n; ++e) d[e]._options = i._resolveDataElementOptions(d[e], e), i.updateElement(d[e], e, t)
            },
            _updateRadius: function () {
                var t = this, e = t.chart, n = e.chartArea, a = e.options,
                    i = Math.min(n.right - n.left, n.bottom - n.top);
                e.outerRadius = Math.max(i / 2, 0), e.innerRadius = Math.max(a.cutoutPercentage ? e.outerRadius / 100 * a.cutoutPercentage : 1, 0), e.radiusLength = (e.outerRadius - e.innerRadius) / e.getVisibleDatasetCount(), t.outerRadius = e.outerRadius - e.radiusLength * t.index, t.innerRadius = t.outerRadius - e.radiusLength
            },
            updateElement: function (t, e, n) {
                var a = this, i = a.chart, r = a.getDataset(), o = i.options, s = o.animation, l = i.scale,
                    c = i.data.labels, d = l.xCenter, u = l.yCenter, h = o.startAngle,
                    p = t.hidden ? 0 : l.getDistanceFromCenterForValue(r.data[e]), f = a._starts[e],
                    g = f + (t.hidden ? 0 : a._angles[e]),
                    m = s.animateScale ? 0 : l.getDistanceFromCenterForValue(r.data[e]), v = t._options || {};
                ot.extend(t, {
                    _datasetIndex: a.index,
                    _index: e,
                    _scale: l,
                    _model: {
                        backgroundColor: v.backgroundColor,
                        borderColor: v.borderColor,
                        borderWidth: v.borderWidth,
                        borderAlign: v.borderAlign,
                        x: d,
                        y: u,
                        innerRadius: 0,
                        outerRadius: n ? m : p,
                        startAngle: n && s.animateRotate ? h : f,
                        endAngle: n && s.animateRotate ? h : g,
                        label: ot.valueAtIndexOrDefault(c, e, c[e])
                    }
                }), t.pivot()
            },
            countVisibleElements: function () {
                var t = this.getDataset(), e = this.getMeta(), n = 0;
                return ot.each(e.data, (function (e, a) {
                    isNaN(t.data[a]) || e.hidden || n++
                })), n
            },
            setHoverStyle: function (t) {
                var e = t._model, n = t._options, a = ot.getHoverColor, i = ot.valueOrDefault;
                t.$previousStyle = {
                    backgroundColor: e.backgroundColor,
                    borderColor: e.borderColor,
                    borderWidth: e.borderWidth
                }, e.backgroundColor = i(n.hoverBackgroundColor, a(n.backgroundColor)), e.borderColor = i(n.hoverBorderColor, a(n.borderColor)), e.borderWidth = i(n.hoverBorderWidth, n.borderWidth)
            },
            _computeAngle: function (t) {
                var e = this, n = this.getMeta().count, a = e.getDataset(), i = e.getMeta();
                if (isNaN(a.data[t]) || i.data[t].hidden) return 0;
                var r = {chart: e.chart, dataIndex: t, dataset: a, datasetIndex: e.index};
                return ye([e.chart.options.elements.arc.angle, 2 * Math.PI / n], r, t)
            }
        });
        Q._set("pie", ot.clone(Q.doughnut)), Q._set("pie", {cutoutPercentage: 0});
        var _e = de, we = ot.valueOrDefault;
        Q._set("radar", {spanGaps: !1, scale: {type: "radialLinear"}, elements: {line: {fill: "start", tension: 0}}});
        var Se = St.extend({
            datasetElementType: Yt.Line,
            dataElementType: Yt.Point,
            linkScales: ot.noop,
            _datasetElementOptions: ["backgroundColor", "borderWidth", "borderColor", "borderCapStyle", "borderDash", "borderDashOffset", "borderJoinStyle", "fill"],
            _dataElementOptions: {
                backgroundColor: "pointBackgroundColor",
                borderColor: "pointBorderColor",
                borderWidth: "pointBorderWidth",
                hitRadius: "pointHitRadius",
                hoverBackgroundColor: "pointHoverBackgroundColor",
                hoverBorderColor: "pointHoverBorderColor",
                hoverBorderWidth: "pointHoverBorderWidth",
                hoverRadius: "pointHoverRadius",
                pointStyle: "pointStyle",
                radius: "pointRadius",
                rotation: "pointRotation"
            },
            _getIndexScaleId: function () {
                return this.chart.scale.id
            },
            _getValueScaleId: function () {
                return this.chart.scale.id
            },
            update: function (t) {
                var e, n, a = this, i = a.getMeta(), r = i.dataset, o = i.data || [], s = a.chart.scale, l = a._config;
                for (void 0 !== l.tension && void 0 === l.lineTension && (l.lineTension = l.tension), r._scale = s, r._datasetIndex = a.index, r._children = o, r._loop = !0, r._model = a._resolveDatasetElementOptions(r), r.pivot(), e = 0, n = o.length; e < n; ++e) a.updateElement(o[e], e, t);
                for (a.updateBezierControlPoints(), e = 0, n = o.length; e < n; ++e) o[e].pivot()
            },
            updateElement: function (t, e, n) {
                var a = this, i = t.custom || {}, r = a.getDataset(), o = a.chart.scale,
                    s = o.getPointPositionForValue(e, r.data[e]), l = a._resolveDataElementOptions(t, e),
                    c = a.getMeta().dataset._model, d = n ? o.xCenter : s.x, u = n ? o.yCenter : s.y;
                t._scale = o, t._options = l, t._datasetIndex = a.index, t._index = e, t._model = {
                    x: d,
                    y: u,
                    skip: i.skip || isNaN(d) || isNaN(u),
                    radius: l.radius,
                    pointStyle: l.pointStyle,
                    rotation: l.rotation,
                    backgroundColor: l.backgroundColor,
                    borderColor: l.borderColor,
                    borderWidth: l.borderWidth,
                    tension: we(i.tension, c ? c.tension : 0),
                    hitRadius: l.hitRadius
                }
            },
            _resolveDatasetElementOptions: function () {
                var t = this, e = t._config, n = t.chart.options,
                    a = St.prototype._resolveDatasetElementOptions.apply(t, arguments);
                return a.spanGaps = we(e.spanGaps, n.spanGaps), a.tension = we(e.lineTension, n.elements.line.tension), a
            },
            updateBezierControlPoints: function () {
                var t, e, n, a, i = this, r = i.getMeta(), o = i.chart.chartArea, s = r.data || [];

                function l(t, e, n) {
                    return Math.max(Math.min(t, n), e)
                }

                for (r.dataset._model.spanGaps && (s = s.filter((function (t) {
                    return !t._model.skip
                }))), t = 0, e = s.length; t < e; ++t) n = s[t]._model, a = ot.splineCurve(ot.previousItem(s, t, !0)._model, n, ot.nextItem(s, t, !0)._model, n.tension), n.controlPointPreviousX = l(a.previous.x, o.left, o.right), n.controlPointPreviousY = l(a.previous.y, o.top, o.bottom), n.controlPointNextX = l(a.next.x, o.left, o.right), n.controlPointNextY = l(a.next.y, o.top, o.bottom)
            },
            setHoverStyle: function (t) {
                var e = t._model, n = t._options, a = ot.getHoverColor;
                t.$previousStyle = {
                    backgroundColor: e.backgroundColor,
                    borderColor: e.borderColor,
                    borderWidth: e.borderWidth,
                    radius: e.radius
                }, e.backgroundColor = we(n.hoverBackgroundColor, a(n.backgroundColor)), e.borderColor = we(n.hoverBorderColor, a(n.borderColor)), e.borderWidth = we(n.hoverBorderWidth, n.borderWidth), e.radius = we(n.hoverRadius, n.radius)
            }
        });
        Q._set("scatter", {
            hover: {mode: "single"},
            scales: {
                xAxes: [{id: "x-axis-1", type: "linear", position: "bottom"}],
                yAxes: [{id: "y-axis-1", type: "linear", position: "left"}]
            },
            tooltips: {
                callbacks: {
                    title: function () {
                        return ""
                    }, label: function (t) {
                        return "(" + t.xLabel + ", " + t.yLabel + ")"
                    }
                }
            }
        }), Q._set("global", {datasets: {scatter: {showLine: !1}}});
        var Ce = {
            bar: ne,
            bubble: re,
            doughnut: de,
            horizontalBar: ue,
            line: be,
            polarArea: xe,
            pie: _e,
            radar: Se,
            scatter: be
        };

        function ke(t, e) {
            return t.native ? {x: t.x, y: t.y} : ot.getRelativePosition(t, e)
        }

        function De(t, e) {
            var n, a, i, r, o, s, l = t._getSortedVisibleDatasetMetas();
            for (a = 0, r = l.length; a < r; ++a) for (i = 0, o = (n = l[a].data).length; i < o; ++i) (s = n[i])._view.skip || e(s)
        }

        function Te(t, e) {
            var n = [];
            return De(t, (function (t) {
                t.inRange(e.x, e.y) && n.push(t)
            })), n
        }

        function Ee(t, e, n, a) {
            var i = Number.POSITIVE_INFINITY, r = [];
            return De(t, (function (t) {
                if (!n || t.inRange(e.x, e.y)) {
                    var o = t.getCenterPoint(), s = a(e, o);
                    s < i ? (r = [t], i = s) : s === i && r.push(t)
                }
            })), r
        }

        function Ae(t) {
            var e = -1 !== t.indexOf("x"), n = -1 !== t.indexOf("y");
            return function (t, a) {
                var i = e ? Math.abs(t.x - a.x) : 0, r = n ? Math.abs(t.y - a.y) : 0;
                return Math.sqrt(Math.pow(i, 2) + Math.pow(r, 2))
            }
        }

        function Ie(t, e, n) {
            var a = ke(e, t);
            n.axis = n.axis || "x";
            var i = Ae(n.axis), r = n.intersect ? Te(t, a) : Ee(t, a, !1, i), o = [];
            return r.length ? (t._getSortedVisibleDatasetMetas().forEach((function (t) {
                var e = t.data[r[0]._index];
                e && !e._view.skip && o.push(e)
            })), o) : []
        }

        var Me = {
            modes: {
                single: function (t, e) {
                    var n = ke(e, t), a = [];
                    return De(t, (function (t) {
                        if (t.inRange(n.x, n.y)) return a.push(t), a
                    })), a.slice(0, 1)
                }, label: Ie, index: Ie, dataset: function (t, e, n) {
                    var a = ke(e, t);
                    n.axis = n.axis || "xy";
                    var i = Ae(n.axis), r = n.intersect ? Te(t, a) : Ee(t, a, !1, i);
                    return r.length > 0 && (r = t.getDatasetMeta(r[0]._datasetIndex).data), r
                }, "x-axis": function (t, e) {
                    return Ie(t, e, {intersect: !1})
                }, point: function (t, e) {
                    return Te(t, ke(e, t))
                }, nearest: function (t, e, n) {
                    var a = ke(e, t);
                    n.axis = n.axis || "xy";
                    var i = Ae(n.axis);
                    return Ee(t, a, n.intersect, i)
                }, x: function (t, e, n) {
                    var a = ke(e, t), i = [], r = !1;
                    return De(t, (function (t) {
                        t.inXRange(a.x) && i.push(t), t.inRange(a.x, a.y) && (r = !0)
                    })), n.intersect && !r && (i = []), i
                }, y: function (t, e, n) {
                    var a = ke(e, t), i = [], r = !1;
                    return De(t, (function (t) {
                        t.inYRange(a.y) && i.push(t), t.inRange(a.x, a.y) && (r = !0)
                    })), n.intersect && !r && (i = []), i
                }
            }
        }, Re = ot.extend;

        function Pe(t, e) {
            return ot.where(t, (function (t) {
                return t.pos === e
            }))
        }

        function Oe(t, e) {
            return t.sort((function (t, n) {
                var a = e ? n : t, i = e ? t : n;
                return a.weight === i.weight ? a.index - i.index : a.weight - i.weight
            }))
        }

        function je(t) {
            var e, n, a, i = [];
            for (e = 0, n = (t || []).length; e < n; ++e) a = t[e], i.push({
                index: e,
                box: a,
                pos: a.position,
                horizontal: a.isHorizontal(),
                weight: a.weight
            });
            return i
        }

        function Ne(t, e) {
            var n, a, i;
            for (n = 0, a = t.length; n < a; ++n) (i = t[n]).width = i.horizontal ? i.box.fullWidth && e.availableWidth : e.vBoxMaxWidth, i.height = i.horizontal && e.hBoxMaxHeight
        }

        function Le(t) {
            var e = je(t), n = Oe(Pe(e, "left"), !0), a = Oe(Pe(e, "right")), i = Oe(Pe(e, "top"), !0),
                r = Oe(Pe(e, "bottom"));
            return {
                leftAndTop: n.concat(i),
                rightAndBottom: a.concat(r),
                chartArea: Pe(e, "chartArea"),
                vertical: n.concat(a),
                horizontal: i.concat(r)
            }
        }

        function Fe(t, e, n, a) {
            return Math.max(t[n], e[n]) + Math.max(t[a], e[a])
        }

        function He(t, e, n) {
            var a, i, r = n.box, o = t.maxPadding;
            if (n.size && (t[n.pos] -= n.size), n.size = n.horizontal ? r.height : r.width, t[n.pos] += n.size, r.getPadding) {
                var s = r.getPadding();
                o.top = Math.max(o.top, s.top), o.left = Math.max(o.left, s.left), o.bottom = Math.max(o.bottom, s.bottom), o.right = Math.max(o.right, s.right)
            }
            if (a = e.outerWidth - Fe(o, t, "left", "right"), i = e.outerHeight - Fe(o, t, "top", "bottom"), a !== t.w || i !== t.h) {
                t.w = a, t.h = i;
                var l = n.horizontal ? [a, t.w] : [i, t.h];
                return !(l[0] === l[1] || isNaN(l[0]) && isNaN(l[1]))
            }
        }

        function Be(t) {
            var e = t.maxPadding;

            function n(n) {
                var a = Math.max(e[n] - t[n], 0);
                return t[n] += a, a
            }

            t.y += n("top"), t.x += n("left"), n("right"), n("bottom")
        }

        function qe(t, e) {
            var n = e.maxPadding;

            function a(t) {
                var a = {left: 0, top: 0, right: 0, bottom: 0};
                return t.forEach((function (t) {
                    a[t] = Math.max(e[t], n[t])
                })), a
            }

            return a(t ? ["left", "right"] : ["top", "bottom"])
        }

        function ze(t, e, n) {
            var a, i, r, o, s, l, c = [];
            for (a = 0, i = t.length; a < i; ++a) (o = (r = t[a]).box).update(r.width || e.w, r.height || e.h, qe(r.horizontal, e)), He(e, n, r) && (l = !0, c.length && (s = !0)), o.fullWidth || c.push(r);
            return s && ze(c, e, n) || l
        }

        function We(t, e, n) {
            var a, i, r, o, s = n.padding, l = e.x, c = e.y;
            for (a = 0, i = t.length; a < i; ++a) o = (r = t[a]).box, r.horizontal ? (o.left = o.fullWidth ? s.left : e.left, o.right = o.fullWidth ? n.outerWidth - s.right : e.left + e.w, o.top = c, o.bottom = c + o.height, o.width = o.right - o.left, c = o.bottom) : (o.left = l, o.right = l + o.width, o.top = e.top, o.bottom = e.top + e.h, o.height = o.bottom - o.top, l = o.right);
            e.x = l, e.y = c
        }

        Q._set("global", {layout: {padding: {top: 0, right: 0, bottom: 0, left: 0}}});
        var Ve = {
                defaults: {}, addBox: function (t, e) {
                    t.boxes || (t.boxes = []), e.fullWidth = e.fullWidth || !1, e.position = e.position || "top", e.weight = e.weight || 0, e._layers = e._layers || function () {
                        return [{
                            z: 0, draw: function () {
                                e.draw.apply(e, arguments)
                            }
                        }]
                    }, t.boxes.push(e)
                }, removeBox: function (t, e) {
                    var n = t.boxes ? t.boxes.indexOf(e) : -1;
                    -1 !== n && t.boxes.splice(n, 1)
                }, configure: function (t, e, n) {
                    for (var a, i = ["fullWidth", "position", "weight"], r = i.length, o = 0; o < r; ++o) a = i[o], n.hasOwnProperty(a) && (e[a] = n[a])
                }, update: function (t, e, n) {
                    if (t) {
                        var a = t.options.layout || {}, i = ot.options.toPadding(a.padding), r = e - i.width,
                            o = n - i.height, s = Le(t.boxes), l = s.vertical, c = s.horizontal, d = Object.freeze({
                                outerWidth: e,
                                outerHeight: n,
                                padding: i,
                                availableWidth: r,
                                vBoxMaxWidth: r / 2 / l.length,
                                hBoxMaxHeight: o / 2
                            }), u = Re({maxPadding: Re({}, i), w: r, h: o, x: i.left, y: i.top}, i);
                        Ne(l.concat(c), d), ze(l, u, d), ze(c, u, d) && ze(l, u, d), Be(u), We(s.leftAndTop, u, d), u.x += u.w, u.y += u.h, We(s.rightAndBottom, u, d), t.chartArea = {
                            left: u.left,
                            top: u.top,
                            right: u.left + u.w,
                            bottom: u.top + u.h
                        }, ot.each(s.chartArea, (function (e) {
                            var n = e.box;
                            Re(n, t.chartArea), n.update(u.w, u.h)
                        }))
                    }
                }
            }, $e = {
                acquireContext: function (t) {
                    return t && t.canvas && (t = t.canvas), t && t.getContext("2d") || null
                }
            },
            Ye = "/*\r\n * DOM element rendering detection\r\n * https://davidwalsh.name/detect-node-insertion\r\n */\r\n@keyframes chartjs-render-animation {\r\n\tfrom { opacity: 0.99; }\r\n\tto { opacity: 1; }\r\n}\r\n\r\n.chartjs-render-monitor {\r\n\tanimation: chartjs-render-animation 0.001s;\r\n}\r\n\r\n/*\r\n * DOM element resizing detection\r\n * https://github.com/marcj/css-element-queries\r\n */\r\n.chartjs-size-monitor,\r\n.chartjs-size-monitor-expand,\r\n.chartjs-size-monitor-shrink {\r\n\tposition: absolute;\r\n\tdirection: ltr;\r\n\tleft: 0;\r\n\ttop: 0;\r\n\tright: 0;\r\n\tbottom: 0;\r\n\toverflow: hidden;\r\n\tpointer-events: none;\r\n\tvisibility: hidden;\r\n\tz-index: -1;\r\n}\r\n\r\n.chartjs-size-monitor-expand > div {\r\n\tposition: absolute;\r\n\twidth: 1000000px;\r\n\theight: 1000000px;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n\r\n.chartjs-size-monitor-shrink > div {\r\n\tposition: absolute;\r\n\twidth: 200%;\r\n\theight: 200%;\r\n\tleft: 0;\r\n\ttop: 0;\r\n}\r\n",
            Ue = n(Object.freeze({__proto__: null, default: Ye})), Ge = "$chartjs", Xe = "chartjs-",
            Ze = Xe + "size-monitor", Ke = Xe + "render-monitor", Qe = Xe + "render-animation",
            Je = ["animationstart", "webkitAnimationStart"], tn = {
                touchstart: "mousedown",
                touchmove: "mousemove",
                touchend: "mouseup",
                pointerenter: "mouseenter",
                pointerdown: "mousedown",
                pointermove: "mousemove",
                pointerup: "mouseup",
                pointerleave: "mouseout",
                pointerout: "mouseout"
            };

        function en(t, e) {
            var n = ot.getStyle(t, e), a = n && n.match(/^(\d+)(\.\d+)?px$/);
            return a ? Number(a[1]) : void 0
        }

        function nn(t, e) {
            var n = t.style, a = t.getAttribute("height"), i = t.getAttribute("width");
            if (t[Ge] = {
                initial: {
                    height: a,
                    width: i,
                    style: {display: n.display, height: n.height, width: n.width}
                }
            }, n.display = n.display || "block", null === i || "" === i) {
                var r = en(t, "width");
                void 0 !== r && (t.width = r)
            }
            if (null === a || "" === a) if ("" === t.style.height) t.height = t.width / (e.options.aspectRatio || 2); else {
                var o = en(t, "height");
                void 0 !== r && (t.height = o)
            }
            return t
        }

        var an = !!function () {
            var t = !1;
            try {
                var e = Object.defineProperty({}, "passive", {
                    get: function () {
                        t = !0
                    }
                });
                window.addEventListener("e", null, e)
            } catch (t) {
            }
            return t
        }() && {passive: !0};

        function rn(t, e, n) {
            t.addEventListener(e, n, an)
        }

        function on(t, e, n) {
            t.removeEventListener(e, n, an)
        }

        function sn(t, e, n, a, i) {
            return {type: t, chart: e, native: i || null, x: void 0 !== n ? n : null, y: void 0 !== a ? a : null}
        }

        function ln(t, e) {
            var n = tn[t.type] || t.type, a = ot.getRelativePosition(t, e);
            return sn(n, e, a.x, a.y, t)
        }

        function cn(t, e) {
            var n = !1, a = [];
            return function () {
                a = Array.prototype.slice.call(arguments), e = e || this, n || (n = !0, ot.requestAnimFrame.call(window, (function () {
                    n = !1, t.apply(e, a)
                })))
            }
        }

        function dn(t) {
            var e = document.createElement("div");
            return e.className = t || "", e
        }

        function un(t) {
            var e = 1e6, n = dn(Ze), a = dn(Ze + "-expand"), i = dn(Ze + "-shrink");
            a.appendChild(dn()), i.appendChild(dn()), n.appendChild(a), n.appendChild(i), n._reset = function () {
                a.scrollLeft = e, a.scrollTop = e, i.scrollLeft = e, i.scrollTop = e
            };
            var r = function () {
                n._reset(), t()
            };
            return rn(a, "scroll", r.bind(a, "expand")), rn(i, "scroll", r.bind(i, "shrink")), n
        }

        function hn(t, e) {
            var n = t[Ge] || (t[Ge] = {}), a = n.renderProxy = function (t) {
                t.animationName === Qe && e()
            };
            ot.each(Je, (function (e) {
                rn(t, e, a)
            })), n.reflow = !!t.offsetParent, t.classList.add(Ke)
        }

        function pn(t) {
            var e = t[Ge] || {}, n = e.renderProxy;
            n && (ot.each(Je, (function (e) {
                on(t, e, n)
            })), delete e.renderProxy), t.classList.remove(Ke)
        }

        function fn(t, e, n) {
            var a = t[Ge] || (t[Ge] = {}), i = a.resizer = un(cn((function () {
                if (a.resizer) {
                    var i = n.options.maintainAspectRatio && t.parentNode, r = i ? i.clientWidth : 0;
                    e(sn("resize", n)), i && i.clientWidth < r && n.canvas && e(sn("resize", n))
                }
            })));
            hn(t, (function () {
                if (a.resizer) {
                    var e = t.parentNode;
                    e && e !== i.parentNode && e.insertBefore(i, e.firstChild), i._reset()
                }
            }))
        }

        function gn(t) {
            var e = t[Ge] || {}, n = e.resizer;
            delete e.resizer, pn(t), n && n.parentNode && n.parentNode.removeChild(n)
        }

        function mn(t, e) {
            var n = t[Ge] || (t[Ge] = {});
            if (!n.containsStyles) {
                n.containsStyles = !0, e = "/* Chart.js */\n" + e;
                var a = document.createElement("style");
                a.setAttribute("type", "text/css"), a.appendChild(document.createTextNode(e)), t.appendChild(a)
            }
        }

        var vn = {
            disableCSSInjection: !1,
            _enabled: "undefined" != typeof window && "undefined" != typeof document,
            _ensureLoaded: function (t) {
                if (!this.disableCSSInjection) {
                    var e = t.getRootNode ? t.getRootNode() : document;
                    mn(e.host ? e : document.head, Ue)
                }
            },
            acquireContext: function (t, e) {
                "string" == typeof t ? t = document.getElementById(t) : t.length && (t = t[0]), t && t.canvas && (t = t.canvas);
                var n = t && t.getContext && t.getContext("2d");
                return n && n.canvas === t ? (this._ensureLoaded(t), nn(t, e), n) : null
            },
            releaseContext: function (t) {
                var e = t.canvas;
                if (e[Ge]) {
                    var n = e[Ge].initial;
                    ["height", "width"].forEach((function (t) {
                        var a = n[t];
                        ot.isNullOrUndef(a) ? e.removeAttribute(t) : e.setAttribute(t, a)
                    })), ot.each(n.style || {}, (function (t, n) {
                        e.style[n] = t
                    })), e.width = e.width, delete e[Ge]
                }
            },
            addEventListener: function (t, e, n) {
                var a = t.canvas;
                if ("resize" !== e) {
                    var i = n[Ge] || (n[Ge] = {});
                    rn(a, e, (i.proxies || (i.proxies = {}))[t.id + "_" + e] = function (e) {
                        n(ln(e, t))
                    })
                } else fn(a, n, t)
            },
            removeEventListener: function (t, e, n) {
                var a = t.canvas;
                if ("resize" !== e) {
                    var i = ((n[Ge] || {}).proxies || {})[t.id + "_" + e];
                    i && on(a, e, i)
                } else gn(a)
            }
        };
        ot.addEvent = rn, ot.removeEvent = on;
        var bn = vn._enabled ? vn : $e, yn = ot.extend({
            initialize: function () {
            }, acquireContext: function () {
            }, releaseContext: function () {
            }, addEventListener: function () {
            }, removeEventListener: function () {
            }
        }, bn);
        Q._set("global", {plugins: {}});
        var xn = {
            _plugins: [], _cacheId: 0, register: function (t) {
                var e = this._plugins;
                [].concat(t).forEach((function (t) {
                    -1 === e.indexOf(t) && e.push(t)
                })), this._cacheId++
            }, unregister: function (t) {
                var e = this._plugins;
                [].concat(t).forEach((function (t) {
                    var n = e.indexOf(t);
                    -1 !== n && e.splice(n, 1)
                })), this._cacheId++
            }, clear: function () {
                this._plugins = [], this._cacheId++
            }, count: function () {
                return this._plugins.length
            }, getAll: function () {
                return this._plugins
            }, notify: function (t, e, n) {
                var a, i, r, o, s, l = this.descriptors(t), c = l.length;
                for (a = 0; a < c; ++a) if ("function" == typeof (s = (r = (i = l[a]).plugin)[e]) && ((o = [t].concat(n || [])).push(i.options), !1 === s.apply(r, o))) return !1;
                return !0
            }, descriptors: function (t) {
                var e = t.$plugins || (t.$plugins = {});
                if (e.id === this._cacheId) return e.descriptors;
                var n = [], a = [], i = t && t.config || {}, r = i.options && i.options.plugins || {};
                return this._plugins.concat(i.plugins || []).forEach((function (t) {
                    if (-1 === n.indexOf(t)) {
                        var e = t.id, i = r[e];
                        !1 !== i && (!0 === i && (i = ot.clone(Q.global.plugins[e])), n.push(t), a.push({
                            plugin: t,
                            options: i || {}
                        }))
                    }
                })), e.descriptors = a, e.id = this._cacheId, a
            }, _invalidate: function (t) {
                delete t.$plugins
            }
        }, _n = {
            constructors: {}, defaults: {}, registerScaleType: function (t, e, n) {
                this.constructors[t] = e, this.defaults[t] = ot.clone(n)
            }, getScaleConstructor: function (t) {
                return this.constructors.hasOwnProperty(t) ? this.constructors[t] : void 0
            }, getScaleDefaults: function (t) {
                return this.defaults.hasOwnProperty(t) ? ot.merge(Object.create(null), [Q.scale, this.defaults[t]]) : {}
            }, updateScaleDefaults: function (t, e) {
                var n = this;
                n.defaults.hasOwnProperty(t) && (n.defaults[t] = ot.extend(n.defaults[t], e))
            }, addScalesToLayout: function (t) {
                ot.each(t.scales, (function (e) {
                    e.fullWidth = e.options.fullWidth, e.position = e.options.position, e.weight = e.options.weight, Ve.addBox(t, e)
                }))
            }
        }, wn = ot.valueOrDefault, Sn = ot.rtl.getRtlAdapter;
        Q._set("global", {
            tooltips: {
                enabled: !0,
                custom: null,
                mode: "nearest",
                position: "average",
                intersect: !0,
                backgroundColor: "rgba(0,0,0,0.8)",
                titleFontStyle: "bold",
                titleSpacing: 2,
                titleMarginBottom: 6,
                titleFontColor: "#fff",
                titleAlign: "left",
                bodySpacing: 2,
                bodyFontColor: "#fff",
                bodyAlign: "left",
                footerFontStyle: "bold",
                footerSpacing: 2,
                footerMarginTop: 6,
                footerFontColor: "#fff",
                footerAlign: "left",
                yPadding: 6,
                xPadding: 6,
                caretPadding: 2,
                caretSize: 5,
                cornerRadius: 6,
                multiKeyBackground: "#fff",
                displayColors: !0,
                borderColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                callbacks: {
                    beforeTitle: ot.noop,
                    title: function (t, e) {
                        var n = "", a = e.labels, i = a ? a.length : 0;
                        if (t.length > 0) {
                            var r = t[0];
                            r.label ? n = r.label : r.xLabel ? n = r.xLabel : i > 0 && r.index < i && (n = a[r.index])
                        }
                        return n
                    },
                    afterTitle: ot.noop,
                    beforeBody: ot.noop,
                    beforeLabel: ot.noop,
                    label: function (t, e) {
                        var n = e.datasets[t.datasetIndex].label || "";
                        return n && (n += ": "), ot.isNullOrUndef(t.value) ? n += t.yLabel : n += t.value, n
                    },
                    labelColor: function (t, e) {
                        var n = e.getDatasetMeta(t.datasetIndex).data[t.index]._view;
                        return {borderColor: n.borderColor, backgroundColor: n.backgroundColor}
                    },
                    labelTextColor: function () {
                        return this._options.bodyFontColor
                    },
                    afterLabel: ot.noop,
                    afterBody: ot.noop,
                    beforeFooter: ot.noop,
                    footer: ot.noop,
                    afterFooter: ot.noop
                }
            }
        });
        var Cn = {
            average: function (t) {
                if (!t.length) return !1;
                var e, n, a = 0, i = 0, r = 0;
                for (e = 0, n = t.length; e < n; ++e) {
                    var o = t[e];
                    if (o && o.hasValue()) {
                        var s = o.tooltipPosition();
                        a += s.x, i += s.y, ++r
                    }
                }
                return {x: a / r, y: i / r}
            }, nearest: function (t, e) {
                var n, a, i, r = e.x, o = e.y, s = Number.POSITIVE_INFINITY;
                for (n = 0, a = t.length; n < a; ++n) {
                    var l = t[n];
                    if (l && l.hasValue()) {
                        var c = l.getCenterPoint(), d = ot.distanceBetweenPoints(e, c);
                        d < s && (s = d, i = l)
                    }
                }
                if (i) {
                    var u = i.tooltipPosition();
                    r = u.x, o = u.y
                }
                return {x: r, y: o}
            }
        };

        function kn(t, e) {
            return e && (ot.isArray(e) ? Array.prototype.push.apply(t, e) : t.push(e)), t
        }

        function Dn(t) {
            return ("string" == typeof t || t instanceof String) && t.indexOf("\n") > -1 ? t.split("\n") : t
        }

        function Tn(t) {
            var e = t._xScale, n = t._yScale || t._scale, a = t._index, i = t._datasetIndex,
                r = t._chart.getDatasetMeta(i).controller, o = r._getIndexScale(), s = r._getValueScale();
            return {
                xLabel: e ? e.getLabelForIndex(a, i) : "",
                yLabel: n ? n.getLabelForIndex(a, i) : "",
                label: o ? "" + o.getLabelForIndex(a, i) : "",
                value: s ? "" + s.getLabelForIndex(a, i) : "",
                index: a,
                datasetIndex: i,
                x: t._model.x,
                y: t._model.y
            }
        }

        function En(t) {
            var e = Q.global;
            return {
                xPadding: t.xPadding,
                yPadding: t.yPadding,
                xAlign: t.xAlign,
                yAlign: t.yAlign,
                rtl: t.rtl,
                textDirection: t.textDirection,
                bodyFontColor: t.bodyFontColor,
                _bodyFontFamily: wn(t.bodyFontFamily, e.defaultFontFamily),
                _bodyFontStyle: wn(t.bodyFontStyle, e.defaultFontStyle),
                _bodyAlign: t.bodyAlign,
                bodyFontSize: wn(t.bodyFontSize, e.defaultFontSize),
                bodySpacing: t.bodySpacing,
                titleFontColor: t.titleFontColor,
                _titleFontFamily: wn(t.titleFontFamily, e.defaultFontFamily),
                _titleFontStyle: wn(t.titleFontStyle, e.defaultFontStyle),
                titleFontSize: wn(t.titleFontSize, e.defaultFontSize),
                _titleAlign: t.titleAlign,
                titleSpacing: t.titleSpacing,
                titleMarginBottom: t.titleMarginBottom,
                footerFontColor: t.footerFontColor,
                _footerFontFamily: wn(t.footerFontFamily, e.defaultFontFamily),
                _footerFontStyle: wn(t.footerFontStyle, e.defaultFontStyle),
                footerFontSize: wn(t.footerFontSize, e.defaultFontSize),
                _footerAlign: t.footerAlign,
                footerSpacing: t.footerSpacing,
                footerMarginTop: t.footerMarginTop,
                caretSize: t.caretSize,
                cornerRadius: t.cornerRadius,
                backgroundColor: t.backgroundColor,
                opacity: 0,
                legendColorBackground: t.multiKeyBackground,
                displayColors: t.displayColors,
                borderColor: t.borderColor,
                borderWidth: t.borderWidth
            }
        }

        function An(t, e) {
            var n = t._chart.ctx, a = 2 * e.yPadding, i = 0, r = e.body, o = r.reduce((function (t, e) {
                return t + e.before.length + e.lines.length + e.after.length
            }), 0);
            o += e.beforeBody.length + e.afterBody.length;
            var s = e.title.length, l = e.footer.length, c = e.titleFontSize, d = e.bodyFontSize, u = e.footerFontSize;
            a += s * c, a += s ? (s - 1) * e.titleSpacing : 0, a += s ? e.titleMarginBottom : 0, a += o * d, a += o ? (o - 1) * e.bodySpacing : 0, a += l ? e.footerMarginTop : 0, a += l * u, a += l ? (l - 1) * e.footerSpacing : 0;
            var h = 0, p = function (t) {
                i = Math.max(i, n.measureText(t).width + h)
            };
            return n.font = ot.fontString(c, e._titleFontStyle, e._titleFontFamily), ot.each(e.title, p), n.font = ot.fontString(d, e._bodyFontStyle, e._bodyFontFamily), ot.each(e.beforeBody.concat(e.afterBody), p), h = e.displayColors ? d + 2 : 0, ot.each(r, (function (t) {
                ot.each(t.before, p), ot.each(t.lines, p), ot.each(t.after, p)
            })), h = 0, n.font = ot.fontString(u, e._footerFontStyle, e._footerFontFamily), ot.each(e.footer, p), {
                width: i += 2 * e.xPadding,
                height: a
            }
        }

        function In(t, e) {
            var n, a, i, r, o, s = t._model, l = t._chart, c = t._chart.chartArea, d = "center", u = "center";
            s.y < e.height ? u = "top" : s.y > l.height - e.height && (u = "bottom");
            var h = (c.left + c.right) / 2, p = (c.top + c.bottom) / 2;
            "center" === u ? (n = function (t) {
                return t <= h
            }, a = function (t) {
                return t > h
            }) : (n = function (t) {
                return t <= e.width / 2
            }, a = function (t) {
                return t >= l.width - e.width / 2
            }), i = function (t) {
                return t + e.width + s.caretSize + s.caretPadding > l.width
            }, r = function (t) {
                return t - e.width - s.caretSize - s.caretPadding < 0
            }, o = function (t) {
                return t <= p ? "top" : "bottom"
            }, n(s.x) ? (d = "left", i(s.x) && (d = "center", u = o(s.y))) : a(s.x) && (d = "right", r(s.x) && (d = "center", u = o(s.y)));
            var f = t._options;
            return {xAlign: f.xAlign ? f.xAlign : d, yAlign: f.yAlign ? f.yAlign : u}
        }

        function Mn(t, e, n, a) {
            var i = t.x, r = t.y, o = t.caretSize, s = t.caretPadding, l = t.cornerRadius, c = n.xAlign, d = n.yAlign,
                u = o + s, h = l + s;
            return "right" === c ? i -= e.width : "center" === c && ((i -= e.width / 2) + e.width > a.width && (i = a.width - e.width), i < 0 && (i = 0)), "top" === d ? r += u : r -= "bottom" === d ? e.height + u : e.height / 2, "center" === d ? "left" === c ? i += u : "right" === c && (i -= u) : "left" === c ? i -= h : "right" === c && (i += h), {
                x: i,
                y: r
            }
        }

        function Rn(t, e) {
            return "center" === e ? t.x + t.width / 2 : "right" === e ? t.x + t.width - t.xPadding : t.x + t.xPadding
        }

        function Pn(t) {
            return kn([], Dn(t))
        }

        var On = ft.extend({
            initialize: function () {
                this._model = En(this._options), this._lastActive = []
            }, getTitle: function () {
                var t = this, e = t._options.callbacks, n = e.beforeTitle.apply(t, arguments),
                    a = e.title.apply(t, arguments), i = e.afterTitle.apply(t, arguments), r = [];
                return r = kn(r, Dn(n)), r = kn(r, Dn(a)), r = kn(r, Dn(i))
            }, getBeforeBody: function () {
                return Pn(this._options.callbacks.beforeBody.apply(this, arguments))
            }, getBody: function (t, e) {
                var n = this, a = n._options.callbacks, i = [];
                return ot.each(t, (function (t) {
                    var r = {before: [], lines: [], after: []};
                    kn(r.before, Dn(a.beforeLabel.call(n, t, e))), kn(r.lines, a.label.call(n, t, e)), kn(r.after, Dn(a.afterLabel.call(n, t, e))), i.push(r)
                })), i
            }, getAfterBody: function () {
                return Pn(this._options.callbacks.afterBody.apply(this, arguments))
            }, getFooter: function () {
                var t = this, e = t._options.callbacks, n = e.beforeFooter.apply(t, arguments),
                    a = e.footer.apply(t, arguments), i = e.afterFooter.apply(t, arguments), r = [];
                return r = kn(r, Dn(n)), r = kn(r, Dn(a)), r = kn(r, Dn(i))
            }, update: function (t) {
                var e, n, a = this, i = a._options, r = a._model, o = a._model = En(i), s = a._active, l = a._data,
                    c = {xAlign: r.xAlign, yAlign: r.yAlign}, d = {x: r.x, y: r.y},
                    u = {width: r.width, height: r.height}, h = {x: r.caretX, y: r.caretY};
                if (s.length) {
                    o.opacity = 1;
                    var p = [], f = [];
                    h = Cn[i.position].call(a, s, a._eventPosition);
                    var g = [];
                    for (e = 0, n = s.length; e < n; ++e) g.push(Tn(s[e]));
                    i.filter && (g = g.filter((function (t) {
                        return i.filter(t, l)
                    }))), i.itemSort && (g = g.sort((function (t, e) {
                        return i.itemSort(t, e, l)
                    }))), ot.each(g, (function (t) {
                        p.push(i.callbacks.labelColor.call(a, t, a._chart)), f.push(i.callbacks.labelTextColor.call(a, t, a._chart))
                    })), o.title = a.getTitle(g, l), o.beforeBody = a.getBeforeBody(g, l), o.body = a.getBody(g, l), o.afterBody = a.getAfterBody(g, l), o.footer = a.getFooter(g, l), o.x = h.x, o.y = h.y, o.caretPadding = i.caretPadding, o.labelColors = p, o.labelTextColors = f, o.dataPoints = g, d = Mn(o, u = An(this, o), c = In(this, u), a._chart)
                } else o.opacity = 0;
                return o.xAlign = c.xAlign, o.yAlign = c.yAlign, o.x = d.x, o.y = d.y, o.width = u.width, o.height = u.height, o.caretX = h.x, o.caretY = h.y, a._model = o, t && i.custom && i.custom.call(a, o), a
            }, drawCaret: function (t, e) {
                var n = this._chart.ctx, a = this._view, i = this.getCaretPosition(t, e, a);
                n.lineTo(i.x1, i.y1), n.lineTo(i.x2, i.y2), n.lineTo(i.x3, i.y3)
            }, getCaretPosition: function (t, e, n) {
                var a, i, r, o, s, l, c = n.caretSize, d = n.cornerRadius, u = n.xAlign, h = n.yAlign, p = t.x, f = t.y,
                    g = e.width, m = e.height;
                if ("center" === h) s = f + m / 2, "left" === u ? (i = (a = p) - c, r = a, o = s + c, l = s - c) : (i = (a = p + g) + c, r = a, o = s - c, l = s + c); else if ("left" === u ? (a = (i = p + d + c) - c, r = i + c) : "right" === u ? (a = (i = p + g - d - c) - c, r = i + c) : (a = (i = n.caretX) - c, r = i + c), "top" === h) s = (o = f) - c, l = o; else {
                    s = (o = f + m) + c, l = o;
                    var v = r;
                    r = a, a = v
                }
                return {x1: a, x2: i, x3: r, y1: o, y2: s, y3: l}
            }, drawTitle: function (t, e, n) {
                var a, i, r, o = e.title, s = o.length;
                if (s) {
                    var l = Sn(e.rtl, e.x, e.width);
                    for (t.x = Rn(e, e._titleAlign), n.textAlign = l.textAlign(e._titleAlign), n.textBaseline = "middle", a = e.titleFontSize, i = e.titleSpacing, n.fillStyle = e.titleFontColor, n.font = ot.fontString(a, e._titleFontStyle, e._titleFontFamily), r = 0; r < s; ++r) n.fillText(o[r], l.x(t.x), t.y + a / 2), t.y += a + i, r + 1 === s && (t.y += e.titleMarginBottom - i)
                }
            }, drawBody: function (t, e, n) {
                var a, i, r, o, s, l, c, d, u = e.bodyFontSize, h = e.bodySpacing, p = e._bodyAlign, f = e.body,
                    g = e.displayColors, m = 0, v = g ? Rn(e, "left") : 0, b = Sn(e.rtl, e.x, e.width),
                    y = function (e) {
                        n.fillText(e, b.x(t.x + m), t.y + u / 2), t.y += u + h
                    }, x = b.textAlign(p);
                for (n.textAlign = p, n.textBaseline = "middle", n.font = ot.fontString(u, e._bodyFontStyle, e._bodyFontFamily), t.x = Rn(e, x), n.fillStyle = e.bodyFontColor, ot.each(e.beforeBody, y), m = g && "right" !== x ? "center" === p ? u / 2 + 1 : u + 2 : 0, s = 0, c = f.length; s < c; ++s) {
                    for (a = f[s], i = e.labelTextColors[s], r = e.labelColors[s], n.fillStyle = i, ot.each(a.before, y), l = 0, d = (o = a.lines).length; l < d; ++l) {
                        if (g) {
                            var _ = b.x(v);
                            n.fillStyle = e.legendColorBackground, n.fillRect(b.leftForLtr(_, u), t.y, u, u), n.lineWidth = 1, n.strokeStyle = r.borderColor, n.strokeRect(b.leftForLtr(_, u), t.y, u, u), n.fillStyle = r.backgroundColor, n.fillRect(b.leftForLtr(b.xPlus(_, 1), u - 2), t.y + 1, u - 2, u - 2), n.fillStyle = i
                        }
                        y(o[l])
                    }
                    ot.each(a.after, y)
                }
                m = 0, ot.each(e.afterBody, y), t.y -= h
            }, drawFooter: function (t, e, n) {
                var a, i, r = e.footer, o = r.length;
                if (o) {
                    var s = Sn(e.rtl, e.x, e.width);
                    for (t.x = Rn(e, e._footerAlign), t.y += e.footerMarginTop, n.textAlign = s.textAlign(e._footerAlign), n.textBaseline = "middle", a = e.footerFontSize, n.fillStyle = e.footerFontColor, n.font = ot.fontString(a, e._footerFontStyle, e._footerFontFamily), i = 0; i < o; ++i) n.fillText(r[i], s.x(t.x), t.y + a / 2), t.y += a + e.footerSpacing
                }
            }, drawBackground: function (t, e, n, a) {
                n.fillStyle = e.backgroundColor, n.strokeStyle = e.borderColor, n.lineWidth = e.borderWidth;
                var i = e.xAlign, r = e.yAlign, o = t.x, s = t.y, l = a.width, c = a.height, d = e.cornerRadius;
                n.beginPath(), n.moveTo(o + d, s), "top" === r && this.drawCaret(t, a), n.lineTo(o + l - d, s), n.quadraticCurveTo(o + l, s, o + l, s + d), "center" === r && "right" === i && this.drawCaret(t, a), n.lineTo(o + l, s + c - d), n.quadraticCurveTo(o + l, s + c, o + l - d, s + c), "bottom" === r && this.drawCaret(t, a), n.lineTo(o + d, s + c), n.quadraticCurveTo(o, s + c, o, s + c - d), "center" === r && "left" === i && this.drawCaret(t, a), n.lineTo(o, s + d), n.quadraticCurveTo(o, s, o + d, s), n.closePath(), n.fill(), e.borderWidth > 0 && n.stroke()
            }, draw: function () {
                var t = this._chart.ctx, e = this._view;
                if (0 !== e.opacity) {
                    var n = {width: e.width, height: e.height}, a = {x: e.x, y: e.y},
                        i = Math.abs(e.opacity < .001) ? 0 : e.opacity,
                        r = e.title.length || e.beforeBody.length || e.body.length || e.afterBody.length || e.footer.length;
                    this._options.enabled && r && (t.save(), t.globalAlpha = i, this.drawBackground(a, e, t, n), a.y += e.yPadding, ot.rtl.overrideTextDirection(t, e.textDirection), this.drawTitle(a, e, t), this.drawBody(a, e, t), this.drawFooter(a, e, t), ot.rtl.restoreTextDirection(t, e.textDirection), t.restore())
                }
            }, handleEvent: function (t) {
                var e = this, n = e._options, a = !1;
                return e._lastActive = e._lastActive || [], "mouseout" === t.type ? e._active = [] : (e._active = e._chart.getElementsAtEventForMode(t, n.mode, n), n.reverse && e._active.reverse()), (a = !ot.arrayEquals(e._active, e._lastActive)) && (e._lastActive = e._active, (n.enabled || n.custom) && (e._eventPosition = {
                    x: t.x,
                    y: t.y
                }, e.update(!0), e.pivot())), a
            }
        }), jn = Cn, Nn = On;
        Nn.positioners = jn;
        var Ln = ot.valueOrDefault;

        function Fn() {
            return ot.merge(Object.create(null), [].slice.call(arguments), {
                merger: function (t, e, n, a) {
                    if ("xAxes" === t || "yAxes" === t) {
                        var i, r, o, s = n[t].length;
                        for (e[t] || (e[t] = []), i = 0; i < s; ++i) o = n[t][i], r = Ln(o.type, "xAxes" === t ? "category" : "linear"), i >= e[t].length && e[t].push({}), !e[t][i].type || o.type && o.type !== e[t][i].type ? ot.merge(e[t][i], [_n.getScaleDefaults(r), o]) : ot.merge(e[t][i], o)
                    } else ot._merger(t, e, n, a)
                }
            })
        }

        function Hn() {
            return ot.merge(Object.create(null), [].slice.call(arguments), {
                merger: function (t, e, n, a) {
                    var i = e[t] || Object.create(null), r = n[t];
                    "scales" === t ? e[t] = Fn(i, r) : "scale" === t ? e[t] = ot.merge(i, [_n.getScaleDefaults(r.type), r]) : ot._merger(t, e, n, a)
                }
            })
        }

        function Bn(t) {
            var e = (t = t || Object.create(null)).data = t.data || {};
            return e.datasets = e.datasets || [], e.labels = e.labels || [], t.options = Hn(Q.global, Q[t.type], t.options || {}), t
        }

        function qn(t) {
            var e = t.options;
            ot.each(t.scales, (function (e) {
                Ve.removeBox(t, e)
            })), e = Hn(Q.global, Q[t.config.type], e), t.options = t.config.options = e, t.ensureScalesHaveIDs(), t.buildOrUpdateScales(), t.tooltip._options = e.tooltips, t.tooltip.initialize()
        }

        function zn(t, e, n) {
            var a, i = function (t) {
                return t.id === a
            };
            do {
                a = e + n++
            } while (ot.findIndex(t, i) >= 0);
            return a
        }

        function Wn(t) {
            return "top" === t || "bottom" === t
        }

        function Vn(t, e) {
            return function (n, a) {
                return n[t] === a[t] ? n[e] - a[e] : n[t] - a[t]
            }
        }

        Q._set("global", {
            elements: {},
            events: ["mousemove", "mouseout", "click", "touchstart", "touchmove"],
            hover: {onHover: null, mode: "nearest", intersect: !0, animationDuration: 400},
            onClick: null,
            maintainAspectRatio: !0,
            responsive: !0,
            responsiveAnimationDuration: 0
        });
        var $n = function (t, e) {
            return this.construct(t, e), this
        };
        ot.extend($n.prototype, {
            construct: function (t, e) {
                var n = this;
                e = Bn(e);
                var a = yn.acquireContext(t, e), i = a && a.canvas, r = i && i.height, o = i && i.width;
                n.id = ot.uid(), n.ctx = a, n.canvas = i, n.config = e, n.width = o, n.height = r, n.aspectRatio = r ? o / r : null, n.options = e.options, n._bufferedRender = !1, n._layers = [], n.chart = n, n.controller = n, $n.instances[n.id] = n, Object.defineProperty(n, "data", {
                    get: function () {
                        return n.config.data
                    }, set: function (t) {
                        n.config.data = t
                    }
                }), a && i ? (n.initialize(), n.update()) : console.error("Failed to create chart: can't acquire context from the given item")
            }, initialize: function () {
                var t = this;
                return xn.notify(t, "beforeInit"), ot.retinaScale(t, t.options.devicePixelRatio), t.bindEvents(), t.options.responsive && t.resize(!0), t.initToolTip(), xn.notify(t, "afterInit"), t
            }, clear: function () {
                return ot.canvas.clear(this), this
            }, stop: function () {
                return vt.cancelAnimation(this), this
            }, resize: function (t) {
                var e = this, n = e.options, a = e.canvas, i = n.maintainAspectRatio && e.aspectRatio || null,
                    r = Math.max(0, Math.floor(ot.getMaximumWidth(a))),
                    o = Math.max(0, Math.floor(i ? r / i : ot.getMaximumHeight(a)));
                if ((e.width !== r || e.height !== o) && (a.width = e.width = r, a.height = e.height = o, a.style.width = r + "px", a.style.height = o + "px", ot.retinaScale(e, n.devicePixelRatio), !t)) {
                    var s = {width: r, height: o};
                    xn.notify(e, "resize", [s]), n.onResize && n.onResize(e, s), e.stop(), e.update({duration: n.responsiveAnimationDuration})
                }
            }, ensureScalesHaveIDs: function () {
                var t = this.options, e = t.scales || {}, n = t.scale;
                ot.each(e.xAxes, (function (t, n) {
                    t.id || (t.id = zn(e.xAxes, "x-axis-", n))
                })), ot.each(e.yAxes, (function (t, n) {
                    t.id || (t.id = zn(e.yAxes, "y-axis-", n))
                })), n && (n.id = n.id || "scale")
            }, buildOrUpdateScales: function () {
                var t = this, e = t.options, n = t.scales || {}, a = [], i = Object.keys(n).reduce((function (t, e) {
                    return t[e] = !1, t
                }), {});
                e.scales && (a = a.concat((e.scales.xAxes || []).map((function (t) {
                    return {options: t, dtype: "category", dposition: "bottom"}
                })), (e.scales.yAxes || []).map((function (t) {
                    return {options: t, dtype: "linear", dposition: "left"}
                })))), e.scale && a.push({
                    options: e.scale,
                    dtype: "radialLinear",
                    isDefault: !0,
                    dposition: "chartArea"
                }), ot.each(a, (function (e) {
                    var a = e.options, r = a.id, o = Ln(a.type, e.dtype);
                    Wn(a.position) !== Wn(e.dposition) && (a.position = e.dposition), i[r] = !0;
                    var s = null;
                    if (r in n && n[r].type === o) (s = n[r]).options = a, s.ctx = t.ctx, s.chart = t; else {
                        var l = _n.getScaleConstructor(o);
                        if (!l) return;
                        s = new l({id: r, type: o, options: a, ctx: t.ctx, chart: t}), n[s.id] = s
                    }
                    s.mergeTicksOptions(), e.isDefault && (t.scale = s)
                })), ot.each(i, (function (t, e) {
                    t || delete n[e]
                })), t.scales = n, _n.addScalesToLayout(this)
            }, buildOrUpdateControllers: function () {
                var t, e, n = this, a = [], i = n.data.datasets;
                for (t = 0, e = i.length; t < e; t++) {
                    var r = i[t], o = n.getDatasetMeta(t), s = r.type || n.config.type;
                    if (o.type && o.type !== s && (n.destroyDatasetMeta(t), o = n.getDatasetMeta(t)), o.type = s, o.order = r.order || 0, o.index = t, o.controller) o.controller.updateIndex(t), o.controller.linkScales(); else {
                        var l = Ce[o.type];
                        if (void 0 === l) throw new Error('"' + o.type + '" is not a chart type.');
                        o.controller = new l(n, t), a.push(o.controller)
                    }
                }
                return a
            }, resetElements: function () {
                var t = this;
                ot.each(t.data.datasets, (function (e, n) {
                    t.getDatasetMeta(n).controller.reset()
                }), t)
            }, reset: function () {
                this.resetElements(), this.tooltip.initialize()
            }, update: function (t) {
                var e, n, a = this;
                if (t && "object" == typeof t || (t = {
                    duration: t,
                    lazy: arguments[1]
                }), qn(a), xn._invalidate(a), !1 !== xn.notify(a, "beforeUpdate")) {
                    a.tooltip._data = a.data;
                    var i = a.buildOrUpdateControllers();
                    for (e = 0, n = a.data.datasets.length; e < n; e++) a.getDatasetMeta(e).controller.buildOrUpdateElements();
                    a.updateLayout(), a.options.animation && a.options.animation.duration && ot.each(i, (function (t) {
                        t.reset()
                    })), a.updateDatasets(), a.tooltip.initialize(), a.lastActive = [], xn.notify(a, "afterUpdate"), a._layers.sort(Vn("z", "_idx")), a._bufferedRender ? a._bufferedRequest = {
                        duration: t.duration,
                        easing: t.easing,
                        lazy: t.lazy
                    } : a.render(t)
                }
            }, updateLayout: function () {
                var t = this;
                !1 !== xn.notify(t, "beforeLayout") && (Ve.update(this, this.width, this.height), t._layers = [], ot.each(t.boxes, (function (e) {
                    e._configure && e._configure(), t._layers.push.apply(t._layers, e._layers())
                }), t), t._layers.forEach((function (t, e) {
                    t._idx = e
                })), xn.notify(t, "afterScaleUpdate"), xn.notify(t, "afterLayout"))
            }, updateDatasets: function () {
                var t = this;
                if (!1 !== xn.notify(t, "beforeDatasetsUpdate")) {
                    for (var e = 0, n = t.data.datasets.length; e < n; ++e) t.updateDataset(e);
                    xn.notify(t, "afterDatasetsUpdate")
                }
            }, updateDataset: function (t) {
                var e = this, n = e.getDatasetMeta(t), a = {meta: n, index: t};
                !1 !== xn.notify(e, "beforeDatasetUpdate", [a]) && (n.controller._update(), xn.notify(e, "afterDatasetUpdate", [a]))
            }, render: function (t) {
                var e = this;
                t && "object" == typeof t || (t = {duration: t, lazy: arguments[1]});
                var n = e.options.animation, a = Ln(t.duration, n && n.duration), i = t.lazy;
                if (!1 !== xn.notify(e, "beforeRender")) {
                    var r = function (t) {
                        xn.notify(e, "afterRender"), ot.callback(n && n.onComplete, [t], e)
                    };
                    if (n && a) {
                        var o = new mt({
                            numSteps: a / 16.66, easing: t.easing || n.easing, render: function (t, e) {
                                var n = ot.easing.effects[e.easing], a = e.currentStep, i = a / e.numSteps;
                                t.draw(n(i), i, a)
                            }, onAnimationProgress: n.onProgress, onAnimationComplete: r
                        });
                        vt.addAnimation(e, o, a, i)
                    } else e.draw(), r(new mt({numSteps: 0, chart: e}));
                    return e
                }
            }, draw: function (t) {
                var e, n, a = this;
                if (a.clear(), ot.isNullOrUndef(t) && (t = 1), a.transition(t), !(a.width <= 0 || a.height <= 0) && !1 !== xn.notify(a, "beforeDraw", [t])) {
                    for (n = a._layers, e = 0; e < n.length && n[e].z <= 0; ++e) n[e].draw(a.chartArea);
                    for (a.drawDatasets(t); e < n.length; ++e) n[e].draw(a.chartArea);
                    a._drawTooltip(t), xn.notify(a, "afterDraw", [t])
                }
            }, transition: function (t) {
                for (var e = this, n = 0, a = (e.data.datasets || []).length; n < a; ++n) e.isDatasetVisible(n) && e.getDatasetMeta(n).controller.transition(t);
                e.tooltip.transition(t)
            }, _getSortedDatasetMetas: function (t) {
                var e, n, a = this, i = [];
                for (e = 0, n = (a.data.datasets || []).length; e < n; ++e) t && !a.isDatasetVisible(e) || i.push(a.getDatasetMeta(e));
                return i.sort(Vn("order", "index")), i
            }, _getSortedVisibleDatasetMetas: function () {
                return this._getSortedDatasetMetas(!0)
            }, drawDatasets: function (t) {
                var e, n, a = this;
                if (!1 !== xn.notify(a, "beforeDatasetsDraw", [t])) {
                    for (n = (e = a._getSortedVisibleDatasetMetas()).length - 1; n >= 0; --n) a.drawDataset(e[n], t);
                    xn.notify(a, "afterDatasetsDraw", [t])
                }
            }, drawDataset: function (t, e) {
                var n = this, a = {meta: t, index: t.index, easingValue: e};
                !1 !== xn.notify(n, "beforeDatasetDraw", [a]) && (t.controller.draw(e), xn.notify(n, "afterDatasetDraw", [a]))
            }, _drawTooltip: function (t) {
                var e = this, n = e.tooltip, a = {tooltip: n, easingValue: t};
                !1 !== xn.notify(e, "beforeTooltipDraw", [a]) && (n.draw(), xn.notify(e, "afterTooltipDraw", [a]))
            }, getElementAtEvent: function (t) {
                return Me.modes.single(this, t)
            }, getElementsAtEvent: function (t) {
                return Me.modes.label(this, t, {intersect: !0})
            }, getElementsAtXAxis: function (t) {
                return Me.modes["x-axis"](this, t, {intersect: !0})
            }, getElementsAtEventForMode: function (t, e, n) {
                var a = Me.modes[e];
                return "function" == typeof a ? a(this, t, n) : []
            }, getDatasetAtEvent: function (t) {
                return Me.modes.dataset(this, t, {intersect: !0})
            }, getDatasetMeta: function (t) {
                var e = this, n = e.data.datasets[t];
                n._meta || (n._meta = {});
                var a = n._meta[e.id];
                return a || (a = n._meta[e.id] = {
                    type: null,
                    data: [],
                    dataset: null,
                    controller: null,
                    hidden: null,
                    xAxisID: null,
                    yAxisID: null,
                    order: n.order || 0,
                    index: t
                }), a
            }, getVisibleDatasetCount: function () {
                for (var t = 0, e = 0, n = this.data.datasets.length; e < n; ++e) this.isDatasetVisible(e) && t++;
                return t
            }, isDatasetVisible: function (t) {
                var e = this.getDatasetMeta(t);
                return "boolean" == typeof e.hidden ? !e.hidden : !this.data.datasets[t].hidden
            }, generateLegend: function () {
                return this.options.legendCallback(this)
            }, destroyDatasetMeta: function (t) {
                var e = this.id, n = this.data.datasets[t], a = n._meta && n._meta[e];
                a && (a.controller.destroy(), delete n._meta[e])
            }, destroy: function () {
                var t, e, n = this, a = n.canvas;
                for (n.stop(), t = 0, e = n.data.datasets.length; t < e; ++t) n.destroyDatasetMeta(t);
                a && (n.unbindEvents(), ot.canvas.clear(n), yn.releaseContext(n.ctx), n.canvas = null, n.ctx = null), xn.notify(n, "destroy"), delete $n.instances[n.id]
            }, toBase64Image: function () {
                return this.canvas.toDataURL.apply(this.canvas, arguments)
            }, initToolTip: function () {
                var t = this;
                t.tooltip = new Nn({_chart: t, _chartInstance: t, _data: t.data, _options: t.options.tooltips}, t)
            }, bindEvents: function () {
                var t = this, e = t._listeners = {}, n = function () {
                    t.eventHandler.apply(t, arguments)
                };
                ot.each(t.options.events, (function (a) {
                    yn.addEventListener(t, a, n), e[a] = n
                })), t.options.responsive && (n = function () {
                    t.resize()
                }, yn.addEventListener(t, "resize", n), e.resize = n)
            }, unbindEvents: function () {
                var t = this, e = t._listeners;
                e && (delete t._listeners, ot.each(e, (function (e, n) {
                    yn.removeEventListener(t, n, e)
                })))
            }, updateHoverStyle: function (t, e, n) {
                var a, i, r, o = n ? "set" : "remove";
                for (i = 0, r = t.length; i < r; ++i) (a = t[i]) && this.getDatasetMeta(a._datasetIndex).controller[o + "HoverStyle"](a);
                "dataset" === e && this.getDatasetMeta(t[0]._datasetIndex).controller["_" + o + "DatasetHoverStyle"]()
            }, eventHandler: function (t) {
                var e = this, n = e.tooltip;
                if (!1 !== xn.notify(e, "beforeEvent", [t])) {
                    e._bufferedRender = !0, e._bufferedRequest = null;
                    var a = e.handleEvent(t);
                    n && (a = n._start ? n.handleEvent(t) : a | n.handleEvent(t)), xn.notify(e, "afterEvent", [t]);
                    var i = e._bufferedRequest;
                    return i ? e.render(i) : a && !e.animating && (e.stop(), e.render({
                        duration: e.options.hover.animationDuration,
                        lazy: !0
                    })), e._bufferedRender = !1, e._bufferedRequest = null, e
                }
            }, handleEvent: function (t) {
                var e = this, n = e.options || {}, a = n.hover, i = !1;
                return e.lastActive = e.lastActive || [], "mouseout" === t.type ? e.active = [] : e.active = e.getElementsAtEventForMode(t, a.mode, a), ot.callback(n.onHover || n.hover.onHover, [t.native, e.active], e), "mouseup" !== t.type && "click" !== t.type || n.onClick && n.onClick.call(e, t.native, e.active), e.lastActive.length && e.updateHoverStyle(e.lastActive, a.mode, !1), e.active.length && a.mode && e.updateHoverStyle(e.active, a.mode, !0), i = !ot.arrayEquals(e.active, e.lastActive), e.lastActive = e.active, i
            }
        }), $n.instances = {};
        var Yn = $n;
        $n.Controller = $n, $n.types = {}, ot.configMerge = Hn, ot.scaleMerge = Fn;
        var Un = function () {
            function t(t, e, n) {
                var a;
                return "string" == typeof t ? (a = parseInt(t, 10), -1 !== t.indexOf("%") && (a = a / 100 * e.parentNode[n])) : a = t, a
            }

            function e(t) {
                return null != t && "none" !== t
            }

            function n(n, a, i) {
                var r = document.defaultView, o = ot._getParentNode(n), s = r.getComputedStyle(n)[a],
                    l = r.getComputedStyle(o)[a], c = e(s), d = e(l), u = Number.POSITIVE_INFINITY;
                return c || d ? Math.min(c ? t(s, n, i) : u, d ? t(l, o, i) : u) : "none"
            }

            ot.where = function (t, e) {
                if (ot.isArray(t) && Array.prototype.filter) return t.filter(e);
                var n = [];
                return ot.each(t, (function (t) {
                    e(t) && n.push(t)
                })), n
            }, ot.findIndex = Array.prototype.findIndex ? function (t, e, n) {
                return t.findIndex(e, n)
            } : function (t, e, n) {
                n = void 0 === n ? t : n;
                for (var a = 0, i = t.length; a < i; ++a) if (e.call(n, t[a], a, t)) return a;
                return -1
            }, ot.findNextWhere = function (t, e, n) {
                ot.isNullOrUndef(n) && (n = -1);
                for (var a = n + 1; a < t.length; a++) {
                    var i = t[a];
                    if (e(i)) return i
                }
            }, ot.findPreviousWhere = function (t, e, n) {
                ot.isNullOrUndef(n) && (n = t.length);
                for (var a = n - 1; a >= 0; a--) {
                    var i = t[a];
                    if (e(i)) return i
                }
            }, ot.isNumber = function (t) {
                return !isNaN(parseFloat(t)) && isFinite(t)
            }, ot.almostEquals = function (t, e, n) {
                return Math.abs(t - e) < n
            }, ot.almostWhole = function (t, e) {
                var n = Math.round(t);
                return n - e <= t && n + e >= t
            }, ot.max = function (t) {
                return t.reduce((function (t, e) {
                    return isNaN(e) ? t : Math.max(t, e)
                }), Number.NEGATIVE_INFINITY)
            }, ot.min = function (t) {
                return t.reduce((function (t, e) {
                    return isNaN(e) ? t : Math.min(t, e)
                }), Number.POSITIVE_INFINITY)
            }, ot.sign = Math.sign ? function (t) {
                return Math.sign(t)
            } : function (t) {
                return 0 == (t = +t) || isNaN(t) ? t : t > 0 ? 1 : -1
            }, ot.toRadians = function (t) {
                return t * (Math.PI / 180)
            }, ot.toDegrees = function (t) {
                return t * (180 / Math.PI)
            }, ot._decimalPlaces = function (t) {
                if (ot.isFinite(t)) {
                    for (var e = 1, n = 0; Math.round(t * e) / e !== t;) e *= 10, n++;
                    return n
                }
            }, ot.getAngleFromPoint = function (t, e) {
                var n = e.x - t.x, a = e.y - t.y, i = Math.sqrt(n * n + a * a), r = Math.atan2(a, n);
                return r < -.5 * Math.PI && (r += 2 * Math.PI), {angle: r, distance: i}
            }, ot.distanceBetweenPoints = function (t, e) {
                return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2))
            }, ot.aliasPixel = function (t) {
                return t % 2 == 0 ? 0 : .5
            }, ot._alignPixel = function (t, e, n) {
                var a = t.currentDevicePixelRatio, i = n / 2;
                return Math.round((e - i) * a) / a + i
            }, ot.splineCurve = function (t, e, n, a) {
                var i = t.skip ? e : t, r = e, o = n.skip ? e : n,
                    s = Math.sqrt(Math.pow(r.x - i.x, 2) + Math.pow(r.y - i.y, 2)),
                    l = Math.sqrt(Math.pow(o.x - r.x, 2) + Math.pow(o.y - r.y, 2)), c = s / (s + l), d = l / (s + l),
                    u = a * (c = isNaN(c) ? 0 : c), h = a * (d = isNaN(d) ? 0 : d);
                return {
                    previous: {x: r.x - u * (o.x - i.x), y: r.y - u * (o.y - i.y)},
                    next: {x: r.x + h * (o.x - i.x), y: r.y + h * (o.y - i.y)}
                }
            }, ot.EPSILON = Number.EPSILON || 1e-14, ot.splineCurveMonotone = function (t) {
                var e, n, a, i, r, o, s, l, c, d = (t || []).map((function (t) {
                    return {model: t._model, deltaK: 0, mK: 0}
                })), u = d.length;
                for (e = 0; e < u; ++e) if (!(a = d[e]).model.skip) {
                    if (n = e > 0 ? d[e - 1] : null, (i = e < u - 1 ? d[e + 1] : null) && !i.model.skip) {
                        var h = i.model.x - a.model.x;
                        a.deltaK = 0 !== h ? (i.model.y - a.model.y) / h : 0
                    }
                    !n || n.model.skip ? a.mK = a.deltaK : !i || i.model.skip ? a.mK = n.deltaK : this.sign(n.deltaK) !== this.sign(a.deltaK) ? a.mK = 0 : a.mK = (n.deltaK + a.deltaK) / 2
                }
                for (e = 0; e < u - 1; ++e) a = d[e], i = d[e + 1], a.model.skip || i.model.skip || (ot.almostEquals(a.deltaK, 0, this.EPSILON) ? a.mK = i.mK = 0 : (r = a.mK / a.deltaK, o = i.mK / a.deltaK, (l = Math.pow(r, 2) + Math.pow(o, 2)) <= 9 || (s = 3 / Math.sqrt(l), a.mK = r * s * a.deltaK, i.mK = o * s * a.deltaK)));
                for (e = 0; e < u; ++e) (a = d[e]).model.skip || (n = e > 0 ? d[e - 1] : null, i = e < u - 1 ? d[e + 1] : null, n && !n.model.skip && (c = (a.model.x - n.model.x) / 3, a.model.controlPointPreviousX = a.model.x - c, a.model.controlPointPreviousY = a.model.y - c * a.mK), i && !i.model.skip && (c = (i.model.x - a.model.x) / 3, a.model.controlPointNextX = a.model.x + c, a.model.controlPointNextY = a.model.y + c * a.mK))
            }, ot.nextItem = function (t, e, n) {
                return n ? e >= t.length - 1 ? t[0] : t[e + 1] : e >= t.length - 1 ? t[t.length - 1] : t[e + 1]
            }, ot.previousItem = function (t, e, n) {
                return n ? e <= 0 ? t[t.length - 1] : t[e - 1] : e <= 0 ? t[0] : t[e - 1]
            }, ot.niceNum = function (t, e) {
                var n = Math.floor(ot.log10(t)), a = t / Math.pow(10, n);
                return (e ? a < 1.5 ? 1 : a < 3 ? 2 : a < 7 ? 5 : 10 : a <= 1 ? 1 : a <= 2 ? 2 : a <= 5 ? 5 : 10) * Math.pow(10, n)
            }, ot.requestAnimFrame = "undefined" == typeof window ? function (t) {
                t()
            } : window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (t) {
                return window.setTimeout(t, 1e3 / 60)
            }, ot.getRelativePosition = function (t, e) {
                var n, a, i = t.originalEvent || t, r = t.target || t.srcElement, o = r.getBoundingClientRect(),
                    s = i.touches;
                s && s.length > 0 ? (n = s[0].clientX, a = s[0].clientY) : (n = i.clientX, a = i.clientY);
                var l = parseFloat(ot.getStyle(r, "padding-left")), c = parseFloat(ot.getStyle(r, "padding-top")),
                    d = parseFloat(ot.getStyle(r, "padding-right")), u = parseFloat(ot.getStyle(r, "padding-bottom")),
                    h = o.right - o.left - l - d, p = o.bottom - o.top - c - u;
                return {
                    x: n = Math.round((n - o.left - l) / h * r.width / e.currentDevicePixelRatio),
                    y: a = Math.round((a - o.top - c) / p * r.height / e.currentDevicePixelRatio)
                }
            }, ot.getConstraintWidth = function (t) {
                return n(t, "max-width", "clientWidth")
            }, ot.getConstraintHeight = function (t) {
                return n(t, "max-height", "clientHeight")
            }, ot._calculatePadding = function (t, e, n) {
                return (e = ot.getStyle(t, e)).indexOf("%") > -1 ? n * parseInt(e, 10) / 100 : parseInt(e, 10)
            }, ot._getParentNode = function (t) {
                var e = t.parentNode;
                return e && "[object ShadowRoot]" === e.toString() && (e = e.host), e
            }, ot.getMaximumWidth = function (t) {
                var e = ot._getParentNode(t);
                if (!e) return t.clientWidth;
                var n = e.clientWidth,
                    a = n - ot._calculatePadding(e, "padding-left", n) - ot._calculatePadding(e, "padding-right", n),
                    i = ot.getConstraintWidth(t);
                return isNaN(i) ? a : Math.min(a, i)
            }, ot.getMaximumHeight = function (t) {
                var e = ot._getParentNode(t);
                if (!e) return t.clientHeight;
                var n = e.clientHeight,
                    a = n - ot._calculatePadding(e, "padding-top", n) - ot._calculatePadding(e, "padding-bottom", n),
                    i = ot.getConstraintHeight(t);
                return isNaN(i) ? a : Math.min(a, i)
            }, ot.getStyle = function (t, e) {
                return t.currentStyle ? t.currentStyle[e] : document.defaultView.getComputedStyle(t, null).getPropertyValue(e)
            }, ot.retinaScale = function (t, e) {
                var n = t.currentDevicePixelRatio = e || "undefined" != typeof window && window.devicePixelRatio || 1;
                if (1 !== n) {
                    var a = t.canvas, i = t.height, r = t.width;
                    a.height = i * n, a.width = r * n, t.ctx.scale(n, n), a.style.height || a.style.width || (a.style.height = i + "px", a.style.width = r + "px")
                }
            }, ot.fontString = function (t, e, n) {
                return e + " " + t + "px " + n
            }, ot.longestText = function (t, e, n, a) {
                var i = (a = a || {}).data = a.data || {}, r = a.garbageCollect = a.garbageCollect || [];
                a.font !== e && (i = a.data = {}, r = a.garbageCollect = [], a.font = e), t.font = e;
                var o, s, l, c, d, u = 0, h = n.length;
                for (o = 0; o < h; o++) if (null != (c = n[o]) && !0 !== ot.isArray(c)) u = ot.measureText(t, i, r, u, c); else if (ot.isArray(c)) for (s = 0, l = c.length; s < l; s++) null == (d = c[s]) || ot.isArray(d) || (u = ot.measureText(t, i, r, u, d));
                var p = r.length / 2;
                if (p > n.length) {
                    for (o = 0; o < p; o++) delete i[r[o]];
                    r.splice(0, p)
                }
                return u
            }, ot.measureText = function (t, e, n, a, i) {
                var r = e[i];
                return r || (r = e[i] = t.measureText(i).width, n.push(i)), r > a && (a = r), a
            }, ot.numberOfLabelLines = function (t) {
                var e = 1;
                return ot.each(t, (function (t) {
                    ot.isArray(t) && t.length > e && (e = t.length)
                })), e
            }, ot.color = N ? function (t) {
                return t instanceof CanvasGradient && (t = Q.global.defaultColor), N(t)
            } : function (t) {
                return console.error("Color.js not found!"), t
            }, ot.getHoverColor = function (t) {
                return t instanceof CanvasPattern || t instanceof CanvasGradient ? t : ot.color(t).saturate(.5).darken(.1).rgbString()
            }
        };

        function Gn() {
            throw new Error("This method is not implemented: either no adapter can be found or an incomplete integration was provided.")
        }

        function Xn(t) {
            this.options = t || {}
        }

        ot.extend(Xn.prototype, {
            formats: Gn,
            parse: Gn,
            format: Gn,
            add: Gn,
            diff: Gn,
            startOf: Gn,
            endOf: Gn,
            _create: function (t) {
                return t
            }
        }), Xn.override = function (t) {
            ot.extend(Xn.prototype, t)
        };
        var Zn = {_date: Xn}, Kn = {
            formatters: {
                values: function (t) {
                    return ot.isArray(t) ? t : "" + t
                }, linear: function (t, e, n) {
                    var a = n.length > 3 ? n[2] - n[1] : n[1] - n[0];
                    Math.abs(a) > 1 && t !== Math.floor(t) && (a = t - Math.floor(t));
                    var i = ot.log10(Math.abs(a)), r = "";
                    if (0 !== t) if (Math.max(Math.abs(n[0]), Math.abs(n[n.length - 1])) < 1e-4) {
                        var o = ot.log10(Math.abs(t)), s = Math.floor(o) - Math.floor(i);
                        s = Math.max(Math.min(s, 20), 0), r = t.toExponential(s)
                    } else {
                        var l = -1 * Math.floor(i);
                        l = Math.max(Math.min(l, 20), 0), r = t.toFixed(l)
                    } else r = "0";
                    return r
                }, logarithmic: function (t, e, n) {
                    var a = t / Math.pow(10, Math.floor(ot.log10(t)));
                    return 0 === t ? "0" : 1 === a || 2 === a || 5 === a || 0 === e || e === n.length - 1 ? t.toExponential() : ""
                }
            }
        }, Qn = ot.isArray, Jn = ot.isNullOrUndef, ta = ot.valueOrDefault, ea = ot.valueAtIndexOrDefault;

        function na(t, e) {
            for (var n = [], a = t.length / e, i = 0, r = t.length; i < r; i += a) n.push(t[Math.floor(i)]);
            return n
        }

        function aa(t, e, n) {
            var a, i = t.getTicks().length, r = Math.min(e, i - 1), o = t.getPixelForTick(r), s = t._startPixel,
                l = t._endPixel, c = 1e-6;
            if (!(n && (a = 1 === i ? Math.max(o - s, l - o) : 0 === e ? (t.getPixelForTick(1) - o) / 2 : (o - t.getPixelForTick(r - 1)) / 2, (o += r < e ? a : -a) < s - c || o > l + c))) return o
        }

        function ia(t, e) {
            ot.each(t, (function (t) {
                var n, a = t.gc, i = a.length / 2;
                if (i > e) {
                    for (n = 0; n < i; ++n) delete t.data[a[n]];
                    a.splice(0, i)
                }
            }))
        }

        function ra(t, e, n, a) {
            var i, r, o, s, l, c, d, u, h, p, f, g, m, v = n.length, b = [], y = [], x = [], _ = 0, w = 0;
            for (i = 0; i < v; ++i) {
                if (s = n[i].label, l = n[i].major ? e.major : e.minor, t.font = c = l.string, d = a[c] = a[c] || {
                    data: {},
                    gc: []
                }, u = l.lineHeight, h = p = 0, Jn(s) || Qn(s)) {
                    if (Qn(s)) for (r = 0, o = s.length; r < o; ++r) f = s[r], Jn(f) || Qn(f) || (h = ot.measureText(t, d.data, d.gc, h, f), p += u)
                } else h = ot.measureText(t, d.data, d.gc, h, s), p = u;
                b.push(h), y.push(p), x.push(u / 2), _ = Math.max(h, _), w = Math.max(p, w)
            }

            function S(t) {
                return {width: b[t] || 0, height: y[t] || 0, offset: x[t] || 0}
            }

            return ia(a, v), g = b.indexOf(_), m = y.indexOf(w), {
                first: S(0),
                last: S(v - 1),
                widest: S(g),
                highest: S(m)
            }
        }

        function oa(t) {
            return t.drawTicks ? t.tickMarkLength : 0
        }

        function sa(t) {
            var e, n;
            return t.display ? (e = ot.options._parseFont(t), n = ot.options.toPadding(t.padding), e.lineHeight + n.height) : 0
        }

        function la(t, e) {
            return ot.extend(ot.options._parseFont({
                fontFamily: ta(e.fontFamily, t.fontFamily),
                fontSize: ta(e.fontSize, t.fontSize),
                fontStyle: ta(e.fontStyle, t.fontStyle),
                lineHeight: ta(e.lineHeight, t.lineHeight)
            }), {color: ot.options.resolve([e.fontColor, t.fontColor, Q.global.defaultFontColor])})
        }

        function ca(t) {
            var e = la(t, t.minor);
            return {minor: e, major: t.major.enabled ? la(t, t.major) : e}
        }

        function da(t) {
            var e, n, a, i = [];
            for (n = 0, a = t.length; n < a; ++n) void 0 !== (e = t[n])._index && i.push(e);
            return i
        }

        function ua(t) {
            var e, n, a = t.length;
            if (a < 2) return !1;
            for (n = t[0], e = 1; e < a; ++e) if (t[e] - t[e - 1] !== n) return !1;
            return n
        }

        function ha(t, e, n, a) {
            var i, r, o, s, l = ua(t), c = (e.length - 1) / a;
            if (!l) return Math.max(c, 1);
            for (o = 0, s = (i = ot.math._factorize(l)).length - 1; o < s; o++) if ((r = i[o]) > c) return r;
            return Math.max(c, 1)
        }

        function pa(t) {
            var e, n, a = [];
            for (e = 0, n = t.length; e < n; e++) t[e].major && a.push(e);
            return a
        }

        function fa(t, e, n) {
            var a, i, r = 0, o = e[0];
            for (n = Math.ceil(n), a = 0; a < t.length; a++) i = t[a], a === o ? (i._index = a, o = e[++r * n]) : delete i.label
        }

        function ga(t, e, n, a) {
            var i, r, o, s, l = ta(n, 0), c = Math.min(ta(a, t.length), t.length), d = 0;
            for (e = Math.ceil(e), a && (e = (i = a - n) / Math.floor(i / e)), s = l; s < 0;) d++, s = Math.round(l + d * e);
            for (r = Math.max(l, 0); r < c; r++) o = t[r], r === s ? (o._index = r, d++, s = Math.round(l + d * e)) : delete o.label
        }

        Q._set("scale", {
            display: !0,
            position: "left",
            offset: !1,
            gridLines: {
                display: !0,
                color: "rgba(0,0,0,0.1)",
                lineWidth: 1,
                drawBorder: !0,
                drawOnChartArea: !0,
                drawTicks: !0,
                tickMarkLength: 10,
                zeroLineWidth: 1,
                zeroLineColor: "rgba(0,0,0,0.25)",
                zeroLineBorderDash: [],
                zeroLineBorderDashOffset: 0,
                offsetGridLines: !1,
                borderDash: [],
                borderDashOffset: 0
            },
            scaleLabel: {display: !1, labelString: "", padding: {top: 4, bottom: 4}},
            ticks: {
                beginAtZero: !1,
                minRotation: 0,
                maxRotation: 50,
                mirror: !1,
                padding: 0,
                reverse: !1,
                display: !0,
                autoSkip: !0,
                autoSkipPadding: 0,
                labelOffset: 0,
                callback: Kn.formatters.values,
                minor: {},
                major: {}
            }
        });
        var ma = ft.extend({
            zeroLineIndex: 0,
            getPadding: function () {
                var t = this;
                return {
                    left: t.paddingLeft || 0,
                    top: t.paddingTop || 0,
                    right: t.paddingRight || 0,
                    bottom: t.paddingBottom || 0
                }
            },
            getTicks: function () {
                return this._ticks
            },
            _getLabels: function () {
                var t = this.chart.data;
                return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || []
            },
            mergeTicksOptions: function () {
            },
            beforeUpdate: function () {
                ot.callback(this.options.beforeUpdate, [this])
            },
            update: function (t, e, n) {
                var a, i, r, o, s, l = this, c = l.options.ticks, d = c.sampleSize;
                if (l.beforeUpdate(), l.maxWidth = t, l.maxHeight = e, l.margins = ot.extend({
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, n), l._ticks = null, l.ticks = null, l._labelSizes = null, l._maxLabelLines = 0, l.longestLabelWidth = 0, l.longestTextCache = l.longestTextCache || {}, l._gridLineItems = null, l._labelItems = null, l.beforeSetDimensions(), l.setDimensions(), l.afterSetDimensions(), l.beforeDataLimits(), l.determineDataLimits(), l.afterDataLimits(), l.beforeBuildTicks(), o = l.buildTicks() || [], (!(o = l.afterBuildTicks(o) || o) || !o.length) && l.ticks) for (o = [], a = 0, i = l.ticks.length; a < i; ++a) o.push({
                    value: l.ticks[a],
                    major: !1
                });
                return l._ticks = o, s = d < o.length, r = l._convertTicksToLabels(s ? na(o, d) : o), l._configure(), l.beforeCalculateTickRotation(), l.calculateTickRotation(), l.afterCalculateTickRotation(), l.beforeFit(), l.fit(), l.afterFit(), l._ticksToDraw = c.display && (c.autoSkip || "auto" === c.source) ? l._autoSkip(o) : o, s && (r = l._convertTicksToLabels(l._ticksToDraw)), l.ticks = r, l.afterUpdate(), l.minSize
            },
            _configure: function () {
                var t, e, n = this, a = n.options.ticks.reverse;
                n.isHorizontal() ? (t = n.left, e = n.right) : (t = n.top, e = n.bottom, a = !a), n._startPixel = t, n._endPixel = e, n._reversePixels = a, n._length = e - t
            },
            afterUpdate: function () {
                ot.callback(this.options.afterUpdate, [this])
            },
            beforeSetDimensions: function () {
                ot.callback(this.options.beforeSetDimensions, [this])
            },
            setDimensions: function () {
                var t = this;
                t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0
            },
            afterSetDimensions: function () {
                ot.callback(this.options.afterSetDimensions, [this])
            },
            beforeDataLimits: function () {
                ot.callback(this.options.beforeDataLimits, [this])
            },
            determineDataLimits: ot.noop,
            afterDataLimits: function () {
                ot.callback(this.options.afterDataLimits, [this])
            },
            beforeBuildTicks: function () {
                ot.callback(this.options.beforeBuildTicks, [this])
            },
            buildTicks: ot.noop,
            afterBuildTicks: function (t) {
                var e = this;
                return Qn(t) && t.length ? ot.callback(e.options.afterBuildTicks, [e, t]) : (e.ticks = ot.callback(e.options.afterBuildTicks, [e, e.ticks]) || e.ticks, t)
            },
            beforeTickToLabelConversion: function () {
                ot.callback(this.options.beforeTickToLabelConversion, [this])
            },
            convertTicksToLabels: function () {
                var t = this, e = t.options.ticks;
                t.ticks = t.ticks.map(e.userCallback || e.callback, this)
            },
            afterTickToLabelConversion: function () {
                ot.callback(this.options.afterTickToLabelConversion, [this])
            },
            beforeCalculateTickRotation: function () {
                ot.callback(this.options.beforeCalculateTickRotation, [this])
            },
            calculateTickRotation: function () {
                var t, e, n, a, i, r, o, s = this, l = s.options, c = l.ticks, d = s.getTicks().length,
                    u = c.minRotation || 0, h = c.maxRotation, p = u;
                !s._isVisible() || !c.display || u >= h || d <= 1 || !s.isHorizontal() ? s.labelRotation = u : (e = (t = s._getLabelSizes()).widest.width, n = t.highest.height - t.highest.offset, a = Math.min(s.maxWidth, s.chart.width - e), e + 6 > (i = l.offset ? s.maxWidth / d : a / (d - 1)) && (i = a / (d - (l.offset ? .5 : 1)), r = s.maxHeight - oa(l.gridLines) - c.padding - sa(l.scaleLabel), o = Math.sqrt(e * e + n * n), p = ot.toDegrees(Math.min(Math.asin(Math.min((t.highest.height + 6) / i, 1)), Math.asin(Math.min(r / o, 1)) - Math.asin(n / o))), p = Math.max(u, Math.min(h, p))), s.labelRotation = p)
            },
            afterCalculateTickRotation: function () {
                ot.callback(this.options.afterCalculateTickRotation, [this])
            },
            beforeFit: function () {
                ot.callback(this.options.beforeFit, [this])
            },
            fit: function () {
                var t = this, e = t.minSize = {width: 0, height: 0}, n = t.chart, a = t.options, i = a.ticks,
                    r = a.scaleLabel, o = a.gridLines, s = t._isVisible(), l = "bottom" === a.position,
                    c = t.isHorizontal();
                if (c ? e.width = t.maxWidth : s && (e.width = oa(o) + sa(r)), c ? s && (e.height = oa(o) + sa(r)) : e.height = t.maxHeight, i.display && s) {
                    var d = ca(i), u = t._getLabelSizes(), h = u.first, p = u.last, f = u.widest, g = u.highest,
                        m = .4 * d.minor.lineHeight, v = i.padding;
                    if (c) {
                        var b = 0 !== t.labelRotation, y = ot.toRadians(t.labelRotation), x = Math.cos(y),
                            _ = Math.sin(y), w = _ * f.width + x * (g.height - (b ? g.offset : 0)) + (b ? 0 : m);
                        e.height = Math.min(t.maxHeight, e.height + w + v);
                        var S, C, k = t.getPixelForTick(0) - t.left,
                            D = t.right - t.getPixelForTick(t.getTicks().length - 1);
                        b ? (S = l ? x * h.width + _ * h.offset : _ * (h.height - h.offset), C = l ? _ * (p.height - p.offset) : x * p.width + _ * p.offset) : (S = h.width / 2, C = p.width / 2), t.paddingLeft = Math.max((S - k) * t.width / (t.width - k), 0) + 3, t.paddingRight = Math.max((C - D) * t.width / (t.width - D), 0) + 3
                    } else {
                        var T = i.mirror ? 0 : f.width + v + m;
                        e.width = Math.min(t.maxWidth, e.width + T), t.paddingTop = h.height / 2, t.paddingBottom = p.height / 2
                    }
                }
                t.handleMargins(), c ? (t.width = t._length = n.width - t.margins.left - t.margins.right, t.height = e.height) : (t.width = e.width, t.height = t._length = n.height - t.margins.top - t.margins.bottom)
            },
            handleMargins: function () {
                var t = this;
                t.margins && (t.margins.left = Math.max(t.paddingLeft, t.margins.left), t.margins.top = Math.max(t.paddingTop, t.margins.top), t.margins.right = Math.max(t.paddingRight, t.margins.right), t.margins.bottom = Math.max(t.paddingBottom, t.margins.bottom))
            },
            afterFit: function () {
                ot.callback(this.options.afterFit, [this])
            },
            isHorizontal: function () {
                var t = this.options.position;
                return "top" === t || "bottom" === t
            },
            isFullWidth: function () {
                return this.options.fullWidth
            },
            getRightValue: function (t) {
                if (Jn(t)) return NaN;
                if (("number" == typeof t || t instanceof Number) && !isFinite(t)) return NaN;
                if (t) if (this.isHorizontal()) {
                    if (void 0 !== t.x) return this.getRightValue(t.x)
                } else if (void 0 !== t.y) return this.getRightValue(t.y);
                return t
            },
            _convertTicksToLabels: function (t) {
                var e, n, a, i = this;
                for (i.ticks = t.map((function (t) {
                    return t.value
                })), i.beforeTickToLabelConversion(), e = i.convertTicksToLabels(t) || i.ticks, i.afterTickToLabelConversion(), n = 0, a = t.length; n < a; ++n) t[n].label = e[n];
                return e
            },
            _getLabelSizes: function () {
                var t = this, e = t._labelSizes;
                return e || (t._labelSizes = e = ra(t.ctx, ca(t.options.ticks), t.getTicks(), t.longestTextCache), t.longestLabelWidth = e.widest.width), e
            },
            _parseValue: function (t) {
                var e, n, a, i;
                return Qn(t) ? (e = +this.getRightValue(t[0]), n = +this.getRightValue(t[1]), a = Math.min(e, n), i = Math.max(e, n)) : (e = void 0, n = t = +this.getRightValue(t), a = t, i = t), {
                    min: a,
                    max: i,
                    start: e,
                    end: n
                }
            },
            _getScaleLabel: function (t) {
                var e = this._parseValue(t);
                return void 0 !== e.start ? "[" + e.start + ", " + e.end + "]" : +this.getRightValue(t)
            },
            getLabelForIndex: ot.noop,
            getPixelForValue: ot.noop,
            getValueForPixel: ot.noop,
            getPixelForTick: function (t) {
                var e = this, n = e.options.offset, a = e._ticks.length, i = 1 / Math.max(a - (n ? 0 : 1), 1);
                return t < 0 || t > a - 1 ? null : e.getPixelForDecimal(t * i + (n ? i / 2 : 0))
            },
            getPixelForDecimal: function (t) {
                var e = this;
                return e._reversePixels && (t = 1 - t), e._startPixel + t * e._length
            },
            getDecimalForPixel: function (t) {
                var e = (t - this._startPixel) / this._length;
                return this._reversePixels ? 1 - e : e
            },
            getBasePixel: function () {
                return this.getPixelForValue(this.getBaseValue())
            },
            getBaseValue: function () {
                var t = this, e = t.min, n = t.max;
                return t.beginAtZero ? 0 : e < 0 && n < 0 ? n : e > 0 && n > 0 ? e : 0
            },
            _autoSkip: function (t) {
                var e, n, a, i, r = this, o = r.options.ticks, s = r._length,
                    l = o.maxTicksLimit || s / r._tickSize() + 1, c = o.major.enabled ? pa(t) : [], d = c.length,
                    u = c[0], h = c[d - 1];
                if (d > l) return fa(t, c, d / l), da(t);
                if (a = ha(c, t, s, l), d > 0) {
                    for (e = 0, n = d - 1; e < n; e++) ga(t, a, c[e], c[e + 1]);
                    return i = d > 1 ? (h - u) / (d - 1) : null, ga(t, a, ot.isNullOrUndef(i) ? 0 : u - i, u), ga(t, a, h, ot.isNullOrUndef(i) ? t.length : h + i), da(t)
                }
                return ga(t, a), da(t)
            },
            _tickSize: function () {
                var t = this, e = t.options.ticks, n = ot.toRadians(t.labelRotation), a = Math.abs(Math.cos(n)),
                    i = Math.abs(Math.sin(n)), r = t._getLabelSizes(), o = e.autoSkipPadding || 0,
                    s = r ? r.widest.width + o : 0, l = r ? r.highest.height + o : 0;
                return t.isHorizontal() ? l * a > s * i ? s / a : l / i : l * i < s * a ? l / a : s / i
            },
            _isVisible: function () {
                var t, e, n, a = this, i = a.chart, r = a.options.display;
                if ("auto" !== r) return !!r;
                for (t = 0, e = i.data.datasets.length; t < e; ++t) if (i.isDatasetVisible(t) && ((n = i.getDatasetMeta(t)).xAxisID === a.id || n.yAxisID === a.id)) return !0;
                return !1
            },
            _computeGridLineItems: function (t) {
                var e, n, a, i, r, o, s, l, c, d, u, h, p, f, g, m, v, b = this, y = b.chart, x = b.options,
                    _ = x.gridLines, w = x.position, S = _.offsetGridLines, C = b.isHorizontal(), k = b._ticksToDraw,
                    D = k.length + (S ? 1 : 0), T = oa(_), E = [], A = _.drawBorder ? ea(_.lineWidth, 0, 0) : 0,
                    I = A / 2, M = ot._alignPixel, R = function (t) {
                        return M(y, t, A)
                    };
                for ("top" === w ? (e = R(b.bottom), s = b.bottom - T, c = e - I, u = R(t.top) + I, p = t.bottom) : "bottom" === w ? (e = R(b.top), u = t.top, p = R(t.bottom) - I, s = e + I, c = b.top + T) : "left" === w ? (e = R(b.right), o = b.right - T, l = e - I, d = R(t.left) + I, h = t.right) : (e = R(b.left), d = t.left, h = R(t.right) - I, o = e + I, l = b.left + T), n = 0; n < D; ++n) a = k[n] || {}, Jn(a.label) && n < k.length || (n === b.zeroLineIndex && x.offset === S ? (f = _.zeroLineWidth, g = _.zeroLineColor, m = _.zeroLineBorderDash || [], v = _.zeroLineBorderDashOffset || 0) : (f = ea(_.lineWidth, n, 1), g = ea(_.color, n, "rgba(0,0,0,0.1)"), m = _.borderDash || [], v = _.borderDashOffset || 0), void 0 !== (i = aa(b, a._index || n, S)) && (r = M(y, i, f), C ? o = l = d = h = r : s = c = u = p = r, E.push({
                    tx1: o,
                    ty1: s,
                    tx2: l,
                    ty2: c,
                    x1: d,
                    y1: u,
                    x2: h,
                    y2: p,
                    width: f,
                    color: g,
                    borderDash: m,
                    borderDashOffset: v
                })));
                return E.ticksLength = D, E.borderValue = e, E
            },
            _computeLabelItems: function () {
                var t, e, n, a, i, r, o, s, l, c, d, u, h = this, p = h.options, f = p.ticks, g = p.position,
                    m = f.mirror, v = h.isHorizontal(), b = h._ticksToDraw, y = ca(f), x = f.padding,
                    _ = oa(p.gridLines), w = -ot.toRadians(h.labelRotation), S = [];
                for ("top" === g ? (r = h.bottom - _ - x, o = w ? "left" : "center") : "bottom" === g ? (r = h.top + _ + x, o = w ? "right" : "center") : "left" === g ? (i = h.right - (m ? 0 : _) - x, o = m ? "left" : "right") : (i = h.left + (m ? 0 : _) + x, o = m ? "right" : "left"), t = 0, e = b.length; t < e; ++t) a = (n = b[t]).label, Jn(a) || (s = h.getPixelForTick(n._index || t) + f.labelOffset, c = (l = n.major ? y.major : y.minor).lineHeight, d = Qn(a) ? a.length : 1, v ? (i = s, u = "top" === g ? ((w ? 1 : .5) - d) * c : (w ? 0 : .5) * c) : (r = s, u = (1 - d) * c / 2), S.push({
                    x: i,
                    y: r,
                    rotation: w,
                    label: a,
                    font: l,
                    textOffset: u,
                    textAlign: o
                }));
                return S
            },
            _drawGrid: function (t) {
                var e = this, n = e.options.gridLines;
                if (n.display) {
                    var a, i, r, o, s, l = e.ctx, c = e.chart, d = ot._alignPixel,
                        u = n.drawBorder ? ea(n.lineWidth, 0, 0) : 0,
                        h = e._gridLineItems || (e._gridLineItems = e._computeGridLineItems(t));
                    for (r = 0, o = h.length; r < o; ++r) a = (s = h[r]).width, i = s.color, a && i && (l.save(), l.lineWidth = a, l.strokeStyle = i, l.setLineDash && (l.setLineDash(s.borderDash), l.lineDashOffset = s.borderDashOffset), l.beginPath(), n.drawTicks && (l.moveTo(s.tx1, s.ty1), l.lineTo(s.tx2, s.ty2)), n.drawOnChartArea && (l.moveTo(s.x1, s.y1), l.lineTo(s.x2, s.y2)), l.stroke(), l.restore());
                    if (u) {
                        var p, f, g, m, v = u, b = ea(n.lineWidth, h.ticksLength - 1, 1), y = h.borderValue;
                        e.isHorizontal() ? (p = d(c, e.left, v) - v / 2, f = d(c, e.right, b) + b / 2, g = m = y) : (g = d(c, e.top, v) - v / 2, m = d(c, e.bottom, b) + b / 2, p = f = y), l.lineWidth = u, l.strokeStyle = ea(n.color, 0), l.beginPath(), l.moveTo(p, g), l.lineTo(f, m), l.stroke()
                    }
                }
            },
            _drawLabels: function () {
                var t = this;
                if (t.options.ticks.display) {
                    var e, n, a, i, r, o, s, l, c = t.ctx,
                        d = t._labelItems || (t._labelItems = t._computeLabelItems());
                    for (e = 0, a = d.length; e < a; ++e) {
                        if (o = (r = d[e]).font, c.save(), c.translate(r.x, r.y), c.rotate(r.rotation), c.font = o.string, c.fillStyle = o.color, c.textBaseline = "middle", c.textAlign = r.textAlign, s = r.label, l = r.textOffset, Qn(s)) for (n = 0, i = s.length; n < i; ++n) c.fillText("" + s[n], 0, l), l += o.lineHeight; else c.fillText(s, 0, l);
                        c.restore()
                    }
                }
            },
            _drawTitle: function () {
                var t = this, e = t.ctx, n = t.options, a = n.scaleLabel;
                if (a.display) {
                    var i, r, o = ta(a.fontColor, Q.global.defaultFontColor), s = ot.options._parseFont(a),
                        l = ot.options.toPadding(a.padding), c = s.lineHeight / 2, d = n.position, u = 0;
                    if (t.isHorizontal()) i = t.left + t.width / 2, r = "bottom" === d ? t.bottom - c - l.bottom : t.top + c + l.top; else {
                        var h = "left" === d;
                        i = h ? t.left + c + l.top : t.right - c - l.top, r = t.top + t.height / 2, u = h ? -.5 * Math.PI : .5 * Math.PI
                    }
                    e.save(), e.translate(i, r), e.rotate(u), e.textAlign = "center", e.textBaseline = "middle", e.fillStyle = o, e.font = s.string, e.fillText(a.labelString, 0, 0), e.restore()
                }
            },
            draw: function (t) {
                var e = this;
                e._isVisible() && (e._drawGrid(t), e._drawTitle(), e._drawLabels())
            },
            _layers: function () {
                var t = this, e = t.options, n = e.ticks && e.ticks.z || 0, a = e.gridLines && e.gridLines.z || 0;
                return t._isVisible() && n !== a && t.draw === t._draw ? [{
                    z: a, draw: function () {
                        t._drawGrid.apply(t, arguments), t._drawTitle.apply(t, arguments)
                    }
                }, {
                    z: n, draw: function () {
                        t._drawLabels.apply(t, arguments)
                    }
                }] : [{
                    z: n, draw: function () {
                        t.draw.apply(t, arguments)
                    }
                }]
            },
            _getMatchingVisibleMetas: function (t) {
                var e = this, n = e.isHorizontal();
                return e.chart._getSortedVisibleDatasetMetas().filter((function (a) {
                    return (!t || a.type === t) && (n ? a.xAxisID === e.id : a.yAxisID === e.id)
                }))
            }
        });
        ma.prototype._draw = ma.prototype.draw;
        var va = ma, ba = ot.isNullOrUndef, ya = {position: "bottom"}, xa = va.extend({
            determineDataLimits: function () {
                var t, e = this, n = e._getLabels(), a = e.options.ticks, i = a.min, r = a.max, o = 0, s = n.length - 1;
                void 0 !== i && (t = n.indexOf(i)) >= 0 && (o = t), void 0 !== r && (t = n.indexOf(r)) >= 0 && (s = t), e.minIndex = o, e.maxIndex = s, e.min = n[o], e.max = n[s]
            }, buildTicks: function () {
                var t = this, e = t._getLabels(), n = t.minIndex, a = t.maxIndex;
                t.ticks = 0 === n && a === e.length - 1 ? e : e.slice(n, a + 1)
            }, getLabelForIndex: function (t, e) {
                var n = this, a = n.chart;
                return a.getDatasetMeta(e).controller._getValueScaleId() === n.id ? n.getRightValue(a.data.datasets[e].data[t]) : n._getLabels()[t]
            }, _configure: function () {
                var t = this, e = t.options.offset, n = t.ticks;
                va.prototype._configure.call(t), t.isHorizontal() || (t._reversePixels = !t._reversePixels), n && (t._startValue = t.minIndex - (e ? .5 : 0), t._valueRange = Math.max(n.length - (e ? 0 : 1), 1))
            }, getPixelForValue: function (t, e, n) {
                var a, i, r, o = this;
                return ba(e) || ba(n) || (t = o.chart.data.datasets[n].data[e]), ba(t) || (a = o.isHorizontal() ? t.x : t.y), (void 0 !== a || void 0 !== t && isNaN(e)) && (i = o._getLabels(), t = ot.valueOrDefault(a, t), e = -1 !== (r = i.indexOf(t)) ? r : e, isNaN(e) && (e = t)), o.getPixelForDecimal((e - o._startValue) / o._valueRange)
            }, getPixelForTick: function (t) {
                var e = this.ticks;
                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t], t + this.minIndex)
            }, getValueForPixel: function (t) {
                var e = this, n = Math.round(e._startValue + e.getDecimalForPixel(t) * e._valueRange);
                return Math.min(Math.max(n, 0), e.ticks.length - 1)
            }, getBasePixel: function () {
                return this.bottom
            }
        }), _a = ya;
        xa._defaults = _a;
        var wa = ot.noop, Sa = ot.isNullOrUndef;

        function Ca(t, e) {
            var n, a, i, r, o = [], s = 1e-14, l = t.stepSize, c = l || 1, d = t.maxTicks - 1, u = t.min, h = t.max,
                p = t.precision, f = e.min, g = e.max, m = ot.niceNum((g - f) / d / c) * c;
            if (m < s && Sa(u) && Sa(h)) return [f, g];
            (r = Math.ceil(g / m) - Math.floor(f / m)) > d && (m = ot.niceNum(r * m / d / c) * c), l || Sa(p) ? n = Math.pow(10, ot._decimalPlaces(m)) : (n = Math.pow(10, p), m = Math.ceil(m * n) / n), a = Math.floor(f / m) * m, i = Math.ceil(g / m) * m, l && (!Sa(u) && ot.almostWhole(u / m, m / 1e3) && (a = u), !Sa(h) && ot.almostWhole(h / m, m / 1e3) && (i = h)), r = (i - a) / m, r = ot.almostEquals(r, Math.round(r), m / 1e3) ? Math.round(r) : Math.ceil(r), a = Math.round(a * n) / n, i = Math.round(i * n) / n, o.push(Sa(u) ? a : u);
            for (var v = 1; v < r; ++v) o.push(Math.round((a + v * m) * n) / n);
            return o.push(Sa(h) ? i : h), o
        }

        var ka = va.extend({
            getRightValue: function (t) {
                return "string" == typeof t ? +t : va.prototype.getRightValue.call(this, t)
            }, handleTickRangeOptions: function () {
                var t = this, e = t.options.ticks;
                if (e.beginAtZero) {
                    var n = ot.sign(t.min), a = ot.sign(t.max);
                    n < 0 && a < 0 ? t.max = 0 : n > 0 && a > 0 && (t.min = 0)
                }
                var i = void 0 !== e.min || void 0 !== e.suggestedMin,
                    r = void 0 !== e.max || void 0 !== e.suggestedMax;
                void 0 !== e.min ? t.min = e.min : void 0 !== e.suggestedMin && (null === t.min ? t.min = e.suggestedMin : t.min = Math.min(t.min, e.suggestedMin)), void 0 !== e.max ? t.max = e.max : void 0 !== e.suggestedMax && (null === t.max ? t.max = e.suggestedMax : t.max = Math.max(t.max, e.suggestedMax)), i !== r && t.min >= t.max && (i ? t.max = t.min + 1 : t.min = t.max - 1), t.min === t.max && (t.max++, e.beginAtZero || t.min--)
            }, getTickLimit: function () {
                var t, e = this, n = e.options.ticks, a = n.stepSize, i = n.maxTicksLimit;
                return a ? t = Math.ceil(e.max / a) - Math.floor(e.min / a) + 1 : (t = e._computeTickLimit(), i = i || 11), i && (t = Math.min(i, t)), t
            }, _computeTickLimit: function () {
                return Number.POSITIVE_INFINITY
            }, handleDirectionalChanges: wa, buildTicks: function () {
                var t = this, e = t.options.ticks, n = t.getTickLimit(), a = {
                    maxTicks: n = Math.max(2, n),
                    min: e.min,
                    max: e.max,
                    precision: e.precision,
                    stepSize: ot.valueOrDefault(e.fixedStepSize, e.stepSize)
                }, i = t.ticks = Ca(a, t);
                t.handleDirectionalChanges(), t.max = ot.max(i), t.min = ot.min(i), e.reverse ? (i.reverse(), t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max)
            }, convertTicksToLabels: function () {
                var t = this;
                t.ticksAsNumbers = t.ticks.slice(), t.zeroLineIndex = t.ticks.indexOf(0), va.prototype.convertTicksToLabels.call(t)
            }, _configure: function () {
                var t, e = this, n = e.getTicks(), a = e.min, i = e.max;
                va.prototype._configure.call(e), e.options.offset && n.length && (a -= t = (i - a) / Math.max(n.length - 1, 1) / 2, i += t), e._startValue = a, e._endValue = i, e._valueRange = i - a
            }
        }), Da = {position: "left", ticks: {callback: Kn.formatters.linear}}, Ta = 0, Ea = 1;

        function Aa(t, e, n) {
            var a = [n.type, void 0 === e && void 0 === n.stack ? n.index : "", n.stack].join(".");
            return void 0 === t[a] && (t[a] = {pos: [], neg: []}), t[a]
        }

        function Ia(t, e, n, a) {
            var i, r, o = t.options, s = Aa(e, o.stacked, n), l = s.pos, c = s.neg, d = a.length;
            for (i = 0; i < d; ++i) r = t._parseValue(a[i]), isNaN(r.min) || isNaN(r.max) || n.data[i].hidden || (l[i] = l[i] || 0, c[i] = c[i] || 0, o.relativePoints ? l[i] = 100 : r.min < 0 || r.max < 0 ? c[i] += r.min : l[i] += r.max)
        }

        function Ma(t, e, n) {
            var a, i, r = n.length;
            for (a = 0; a < r; ++a) i = t._parseValue(n[a]), isNaN(i.min) || isNaN(i.max) || e.data[a].hidden || (t.min = Math.min(t.min, i.min), t.max = Math.max(t.max, i.max))
        }

        var Ra = ka.extend({
            determineDataLimits: function () {
                var t, e, n, a, i = this, r = i.options, o = i.chart.data.datasets, s = i._getMatchingVisibleMetas(),
                    l = r.stacked, c = {}, d = s.length;
                if (i.min = Number.POSITIVE_INFINITY, i.max = Number.NEGATIVE_INFINITY, void 0 === l) for (t = 0; !l && t < d; ++t) l = void 0 !== (e = s[t]).stack;
                for (t = 0; t < d; ++t) n = o[(e = s[t]).index].data, l ? Ia(i, c, e, n) : Ma(i, e, n);
                ot.each(c, (function (t) {
                    a = t.pos.concat(t.neg), i.min = Math.min(i.min, ot.min(a)), i.max = Math.max(i.max, ot.max(a))
                })), i.min = ot.isFinite(i.min) && !isNaN(i.min) ? i.min : Ta, i.max = ot.isFinite(i.max) && !isNaN(i.max) ? i.max : Ea, i.handleTickRangeOptions()
            }, _computeTickLimit: function () {
                var t, e = this;
                return e.isHorizontal() ? Math.ceil(e.width / 40) : (t = ot.options._parseFont(e.options.ticks), Math.ceil(e.height / t.lineHeight))
            }, handleDirectionalChanges: function () {
                this.isHorizontal() || this.ticks.reverse()
            }, getLabelForIndex: function (t, e) {
                return this._getScaleLabel(this.chart.data.datasets[e].data[t])
            }, getPixelForValue: function (t) {
                var e = this;
                return e.getPixelForDecimal((+e.getRightValue(t) - e._startValue) / e._valueRange)
            }, getValueForPixel: function (t) {
                return this._startValue + this.getDecimalForPixel(t) * this._valueRange
            }, getPixelForTick: function (t) {
                var e = this.ticksAsNumbers;
                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t])
            }
        }), Pa = Da;
        Ra._defaults = Pa;
        var Oa = ot.valueOrDefault, ja = ot.math.log10;

        function Na(t, e) {
            var n, a, i = [], r = Oa(t.min, Math.pow(10, Math.floor(ja(e.min)))), o = Math.floor(ja(e.max)),
                s = Math.ceil(e.max / Math.pow(10, o));
            0 === r ? (n = Math.floor(ja(e.minNotZero)), a = Math.floor(e.minNotZero / Math.pow(10, n)), i.push(r), r = a * Math.pow(10, n)) : (n = Math.floor(ja(r)), a = Math.floor(r / Math.pow(10, n)));
            var l = n < 0 ? Math.pow(10, Math.abs(n)) : 1;
            do {
                i.push(r), 10 == ++a && (a = 1, l = ++n >= 0 ? 1 : l), r = Math.round(a * Math.pow(10, n) * l) / l
            } while (n < o || n === o && a < s);
            var c = Oa(t.max, r);
            return i.push(c), i
        }

        var La = {position: "left", ticks: {callback: Kn.formatters.logarithmic}};

        function Fa(t, e) {
            return ot.isFinite(t) && t >= 0 ? t : e
        }

        var Ha = va.extend({
            determineDataLimits: function () {
                var t, e, n, a, i, r, o = this, s = o.options, l = o.chart, c = l.data.datasets, d = o.isHorizontal();

                function u(t) {
                    return d ? t.xAxisID === o.id : t.yAxisID === o.id
                }

                o.min = Number.POSITIVE_INFINITY, o.max = Number.NEGATIVE_INFINITY, o.minNotZero = Number.POSITIVE_INFINITY;
                var h = s.stacked;
                if (void 0 === h) for (t = 0; t < c.length; t++) if (e = l.getDatasetMeta(t), l.isDatasetVisible(t) && u(e) && void 0 !== e.stack) {
                    h = !0;
                    break
                }
                if (s.stacked || h) {
                    var p = {};
                    for (t = 0; t < c.length; t++) {
                        var f = [(e = l.getDatasetMeta(t)).type, void 0 === s.stacked && void 0 === e.stack ? t : "", e.stack].join(".");
                        if (l.isDatasetVisible(t) && u(e)) for (void 0 === p[f] && (p[f] = []), i = 0, r = (a = c[t].data).length; i < r; i++) {
                            var g = p[f];
                            n = o._parseValue(a[i]), isNaN(n.min) || isNaN(n.max) || e.data[i].hidden || n.min < 0 || n.max < 0 || (g[i] = g[i] || 0, g[i] += n.max)
                        }
                    }
                    ot.each(p, (function (t) {
                        if (t.length > 0) {
                            var e = ot.min(t), n = ot.max(t);
                            o.min = Math.min(o.min, e), o.max = Math.max(o.max, n)
                        }
                    }))
                } else for (t = 0; t < c.length; t++) if (e = l.getDatasetMeta(t), l.isDatasetVisible(t) && u(e)) for (i = 0, r = (a = c[t].data).length; i < r; i++) n = o._parseValue(a[i]), isNaN(n.min) || isNaN(n.max) || e.data[i].hidden || n.min < 0 || n.max < 0 || (o.min = Math.min(n.min, o.min), o.max = Math.max(n.max, o.max), 0 !== n.min && (o.minNotZero = Math.min(n.min, o.minNotZero)));
                o.min = ot.isFinite(o.min) ? o.min : null, o.max = ot.isFinite(o.max) ? o.max : null, o.minNotZero = ot.isFinite(o.minNotZero) ? o.minNotZero : null, this.handleTickRangeOptions()
            }, handleTickRangeOptions: function () {
                var t = this, e = t.options.ticks, n = 1, a = 10;
                t.min = Fa(e.min, t.min), t.max = Fa(e.max, t.max), t.min === t.max && (0 !== t.min && null !== t.min ? (t.min = Math.pow(10, Math.floor(ja(t.min)) - 1), t.max = Math.pow(10, Math.floor(ja(t.max)) + 1)) : (t.min = n, t.max = a)), null === t.min && (t.min = Math.pow(10, Math.floor(ja(t.max)) - 1)), null === t.max && (t.max = 0 !== t.min ? Math.pow(10, Math.floor(ja(t.min)) + 1) : a), null === t.minNotZero && (t.min > 0 ? t.minNotZero = t.min : t.max < 1 ? t.minNotZero = Math.pow(10, Math.floor(ja(t.max))) : t.minNotZero = n)
            }, buildTicks: function () {
                var t = this, e = t.options.ticks, n = !t.isHorizontal(), a = {min: Fa(e.min), max: Fa(e.max)},
                    i = t.ticks = Na(a, t);
                t.max = ot.max(i), t.min = ot.min(i), e.reverse ? (n = !n, t.start = t.max, t.end = t.min) : (t.start = t.min, t.end = t.max), n && i.reverse()
            }, convertTicksToLabels: function () {
                this.tickValues = this.ticks.slice(), va.prototype.convertTicksToLabels.call(this)
            }, getLabelForIndex: function (t, e) {
                return this._getScaleLabel(this.chart.data.datasets[e].data[t])
            }, getPixelForTick: function (t) {
                var e = this.tickValues;
                return t < 0 || t > e.length - 1 ? null : this.getPixelForValue(e[t])
            }, _getFirstTickValue: function (t) {
                var e = Math.floor(ja(t));
                return Math.floor(t / Math.pow(10, e)) * Math.pow(10, e)
            }, _configure: function () {
                var t = this, e = t.min, n = 0;
                va.prototype._configure.call(t), 0 === e && (e = t._getFirstTickValue(t.minNotZero), n = Oa(t.options.ticks.fontSize, Q.global.defaultFontSize) / t._length), t._startValue = ja(e), t._valueOffset = n, t._valueRange = (ja(t.max) - ja(e)) / (1 - n)
            }, getPixelForValue: function (t) {
                var e = this, n = 0;
                return (t = +e.getRightValue(t)) > e.min && t > 0 && (n = (ja(t) - e._startValue) / e._valueRange + e._valueOffset), e.getPixelForDecimal(n)
            }, getValueForPixel: function (t) {
                var e = this, n = e.getDecimalForPixel(t);
                return 0 === n && 0 === e.min ? 0 : Math.pow(10, e._startValue + (n - e._valueOffset) * e._valueRange)
            }
        }), Ba = La;
        Ha._defaults = Ba;
        var qa = ot.valueOrDefault, za = ot.valueAtIndexOrDefault, Wa = ot.options.resolve, Va = {
            display: !0,
            animate: !0,
            position: "chartArea",
            angleLines: {display: !0, color: "rgba(0,0,0,0.1)", lineWidth: 1, borderDash: [], borderDashOffset: 0},
            gridLines: {circular: !1},
            ticks: {
                showLabelBackdrop: !0,
                backdropColor: "rgba(255,255,255,0.75)",
                backdropPaddingY: 2,
                backdropPaddingX: 2,
                callback: Kn.formatters.linear
            },
            pointLabels: {
                display: !0, fontSize: 10, callback: function (t) {
                    return t
                }
            }
        };

        function $a(t) {
            var e = t.ticks;
            return e.display && t.display ? qa(e.fontSize, Q.global.defaultFontSize) + 2 * e.backdropPaddingY : 0
        }

        function Ya(t, e, n) {
            return ot.isArray(n) ? {w: ot.longestText(t, t.font, n), h: n.length * e} : {
                w: t.measureText(n).width,
                h: e
            }
        }

        function Ua(t, e, n, a, i) {
            return t === a || t === i ? {start: e - n / 2, end: e + n / 2} : t < a || t > i ? {
                start: e - n,
                end: e
            } : {start: e, end: e + n}
        }

        function Ga(t) {
            var e, n, a, i = ot.options._parseFont(t.options.pointLabels),
                r = {l: 0, r: t.width, t: 0, b: t.height - t.paddingTop}, o = {};
            t.ctx.font = i.string, t._pointLabelSizes = [];
            var s = t.chart.data.labels.length;
            for (e = 0; e < s; e++) {
                a = t.getPointPosition(e, t.drawingArea + 5), n = Ya(t.ctx, i.lineHeight, t.pointLabels[e]), t._pointLabelSizes[e] = n;
                var l = t.getIndexAngle(e), c = ot.toDegrees(l) % 360, d = Ua(c, a.x, n.w, 0, 180),
                    u = Ua(c, a.y, n.h, 90, 270);
                d.start < r.l && (r.l = d.start, o.l = l), d.end > r.r && (r.r = d.end, o.r = l), u.start < r.t && (r.t = u.start, o.t = l), u.end > r.b && (r.b = u.end, o.b = l)
            }
            t.setReductions(t.drawingArea, r, o)
        }

        function Xa(t) {
            return 0 === t || 180 === t ? "center" : t < 180 ? "left" : "right"
        }

        function Za(t, e, n, a) {
            var i, r, o = n.y + a / 2;
            if (ot.isArray(e)) for (i = 0, r = e.length; i < r; ++i) t.fillText(e[i], n.x, o), o += a; else t.fillText(e, n.x, o)
        }

        function Ka(t, e, n) {
            90 === t || 270 === t ? n.y -= e.h / 2 : (t > 270 || t < 90) && (n.y -= e.h)
        }

        function Qa(t) {
            var e = t.ctx, n = t.options, a = n.pointLabels, i = $a(n),
                r = t.getDistanceFromCenterForValue(n.ticks.reverse ? t.min : t.max), o = ot.options._parseFont(a);
            e.save(), e.font = o.string, e.textBaseline = "middle";
            for (var s = t.chart.data.labels.length - 1; s >= 0; s--) {
                var l = 0 === s ? i / 2 : 0, c = t.getPointPosition(s, r + l + 5),
                    d = za(a.fontColor, s, Q.global.defaultFontColor);
                e.fillStyle = d;
                var u = t.getIndexAngle(s), h = ot.toDegrees(u);
                e.textAlign = Xa(h), Ka(h, t._pointLabelSizes[s], c), Za(e, t.pointLabels[s], c, o.lineHeight)
            }
            e.restore()
        }

        function Ja(t, e, n, a) {
            var i, r = t.ctx, o = e.circular, s = t.chart.data.labels.length, l = za(e.color, a - 1),
                c = za(e.lineWidth, a - 1);
            if ((o || s) && l && c) {
                if (r.save(), r.strokeStyle = l, r.lineWidth = c, r.setLineDash && (r.setLineDash(e.borderDash || []), r.lineDashOffset = e.borderDashOffset || 0), r.beginPath(), o) r.arc(t.xCenter, t.yCenter, n, 0, 2 * Math.PI); else {
                    i = t.getPointPosition(0, n), r.moveTo(i.x, i.y);
                    for (var d = 1; d < s; d++) i = t.getPointPosition(d, n), r.lineTo(i.x, i.y)
                }
                r.closePath(), r.stroke(), r.restore()
            }
        }

        function ti(t) {
            return ot.isNumber(t) ? t : 0
        }

        var ei = ka.extend({
            setDimensions: function () {
                var t = this;
                t.width = t.maxWidth, t.height = t.maxHeight, t.paddingTop = $a(t.options) / 2, t.xCenter = Math.floor(t.width / 2), t.yCenter = Math.floor((t.height - t.paddingTop) / 2), t.drawingArea = Math.min(t.height - t.paddingTop, t.width) / 2
            }, determineDataLimits: function () {
                var t = this, e = t.chart, n = Number.POSITIVE_INFINITY, a = Number.NEGATIVE_INFINITY;
                ot.each(e.data.datasets, (function (i, r) {
                    if (e.isDatasetVisible(r)) {
                        var o = e.getDatasetMeta(r);
                        ot.each(i.data, (function (e, i) {
                            var r = +t.getRightValue(e);
                            isNaN(r) || o.data[i].hidden || (n = Math.min(r, n), a = Math.max(r, a))
                        }))
                    }
                })), t.min = n === Number.POSITIVE_INFINITY ? 0 : n, t.max = a === Number.NEGATIVE_INFINITY ? 0 : a, t.handleTickRangeOptions()
            }, _computeTickLimit: function () {
                return Math.ceil(this.drawingArea / $a(this.options))
            }, convertTicksToLabels: function () {
                var t = this;
                ka.prototype.convertTicksToLabels.call(t), t.pointLabels = t.chart.data.labels.map((function () {
                    var e = ot.callback(t.options.pointLabels.callback, arguments, t);
                    return e || 0 === e ? e : ""
                }))
            }, getLabelForIndex: function (t, e) {
                return +this.getRightValue(this.chart.data.datasets[e].data[t])
            }, fit: function () {
                var t = this, e = t.options;
                e.display && e.pointLabels.display ? Ga(t) : t.setCenterPoint(0, 0, 0, 0)
            }, setReductions: function (t, e, n) {
                var a = this, i = e.l / Math.sin(n.l), r = Math.max(e.r - a.width, 0) / Math.sin(n.r),
                    o = -e.t / Math.cos(n.t), s = -Math.max(e.b - (a.height - a.paddingTop), 0) / Math.cos(n.b);
                i = ti(i), r = ti(r), o = ti(o), s = ti(s), a.drawingArea = Math.min(Math.floor(t - (i + r) / 2), Math.floor(t - (o + s) / 2)), a.setCenterPoint(i, r, o, s)
            }, setCenterPoint: function (t, e, n, a) {
                var i = this, r = i.width - e - i.drawingArea, o = t + i.drawingArea, s = n + i.drawingArea,
                    l = i.height - i.paddingTop - a - i.drawingArea;
                i.xCenter = Math.floor((o + r) / 2 + i.left), i.yCenter = Math.floor((s + l) / 2 + i.top + i.paddingTop)
            }, getIndexAngle: function (t) {
                var e = this.chart, n = (t * (360 / e.data.labels.length) + ((e.options || {}).startAngle || 0)) % 360;
                return (n < 0 ? n + 360 : n) * Math.PI * 2 / 360
            }, getDistanceFromCenterForValue: function (t) {
                var e = this;
                if (ot.isNullOrUndef(t)) return NaN;
                var n = e.drawingArea / (e.max - e.min);
                return e.options.ticks.reverse ? (e.max - t) * n : (t - e.min) * n
            }, getPointPosition: function (t, e) {
                var n = this, a = n.getIndexAngle(t) - Math.PI / 2;
                return {x: Math.cos(a) * e + n.xCenter, y: Math.sin(a) * e + n.yCenter}
            }, getPointPositionForValue: function (t, e) {
                return this.getPointPosition(t, this.getDistanceFromCenterForValue(e))
            }, getBasePosition: function (t) {
                var e = this, n = e.min, a = e.max;
                return e.getPointPositionForValue(t || 0, e.beginAtZero ? 0 : n < 0 && a < 0 ? a : n > 0 && a > 0 ? n : 0)
            }, _drawGrid: function () {
                var t, e, n, a = this, i = a.ctx, r = a.options, o = r.gridLines, s = r.angleLines,
                    l = qa(s.lineWidth, o.lineWidth), c = qa(s.color, o.color);
                if (r.pointLabels.display && Qa(a), o.display && ot.each(a.ticks, (function (t, n) {
                    0 !== n && (e = a.getDistanceFromCenterForValue(a.ticksAsNumbers[n]), Ja(a, o, e, n))
                })), s.display && l && c) {
                    for (i.save(), i.lineWidth = l, i.strokeStyle = c, i.setLineDash && (i.setLineDash(Wa([s.borderDash, o.borderDash, []])), i.lineDashOffset = Wa([s.borderDashOffset, o.borderDashOffset, 0])), t = a.chart.data.labels.length - 1; t >= 0; t--) e = a.getDistanceFromCenterForValue(r.ticks.reverse ? a.min : a.max), n = a.getPointPosition(t, e), i.beginPath(), i.moveTo(a.xCenter, a.yCenter), i.lineTo(n.x, n.y), i.stroke();
                    i.restore()
                }
            }, _drawLabels: function () {
                var t = this, e = t.ctx, n = t.options.ticks;
                if (n.display) {
                    var a, i, r = t.getIndexAngle(0), o = ot.options._parseFont(n),
                        s = qa(n.fontColor, Q.global.defaultFontColor);
                    e.save(), e.font = o.string, e.translate(t.xCenter, t.yCenter), e.rotate(r), e.textAlign = "center", e.textBaseline = "middle", ot.each(t.ticks, (function (r, l) {
                        (0 !== l || n.reverse) && (a = t.getDistanceFromCenterForValue(t.ticksAsNumbers[l]), n.showLabelBackdrop && (i = e.measureText(r).width, e.fillStyle = n.backdropColor, e.fillRect(-i / 2 - n.backdropPaddingX, -a - o.size / 2 - n.backdropPaddingY, i + 2 * n.backdropPaddingX, o.size + 2 * n.backdropPaddingY)), e.fillStyle = s, e.fillText(r, 0, -a))
                    })), e.restore()
                }
            }, _drawTitle: ot.noop
        }), ni = Va;
        ei._defaults = ni;
        var ai = ot._deprecated, ii = ot.options.resolve, ri = ot.valueOrDefault,
            oi = Number.MIN_SAFE_INTEGER || -9007199254740991, si = Number.MAX_SAFE_INTEGER || 9007199254740991, li = {
                millisecond: {common: !0, size: 1, steps: 1e3},
                second: {common: !0, size: 1e3, steps: 60},
                minute: {common: !0, size: 6e4, steps: 60},
                hour: {common: !0, size: 36e5, steps: 24},
                day: {common: !0, size: 864e5, steps: 30},
                week: {common: !1, size: 6048e5, steps: 4},
                month: {common: !0, size: 2628e6, steps: 12},
                quarter: {common: !1, size: 7884e6, steps: 4},
                year: {common: !0, size: 3154e7}
            }, ci = Object.keys(li);

        function di(t, e) {
            return t - e
        }

        function ui(t) {
            var e, n, a, i = {}, r = [];
            for (e = 0, n = t.length; e < n; ++e) i[a = t[e]] || (i[a] = !0, r.push(a));
            return r
        }

        function hi(t) {
            return ot.valueOrDefault(t.time.min, t.ticks.min)
        }

        function pi(t) {
            return ot.valueOrDefault(t.time.max, t.ticks.max)
        }

        function fi(t, e, n, a) {
            if ("linear" === a || !t.length) return [{time: e, pos: 0}, {time: n, pos: 1}];
            var i, r, o, s, l, c = [], d = [e];
            for (i = 0, r = t.length; i < r; ++i) (s = t[i]) > e && s < n && d.push(s);
            for (d.push(n), i = 0, r = d.length; i < r; ++i) l = d[i + 1], o = d[i - 1], s = d[i], void 0 !== o && void 0 !== l && Math.round((l + o) / 2) === s || c.push({
                time: s,
                pos: i / (r - 1)
            });
            return c
        }

        function gi(t, e, n) {
            for (var a, i, r, o = 0, s = t.length - 1; o >= 0 && o <= s;) {
                if (i = t[(a = o + s >> 1) - 1] || null, r = t[a], !i) return {lo: null, hi: r};
                if (r[e] < n) o = a + 1; else {
                    if (!(i[e] > n)) return {lo: i, hi: r};
                    s = a - 1
                }
            }
            return {lo: r, hi: null}
        }

        function mi(t, e, n, a) {
            var i = gi(t, e, n), r = i.lo ? i.hi ? i.lo : t[t.length - 2] : t[0],
                o = i.lo ? i.hi ? i.hi : t[t.length - 1] : t[1], s = o[e] - r[e], l = s ? (n - r[e]) / s : 0,
                c = (o[a] - r[a]) * l;
            return r[a] + c
        }

        function vi(t, e) {
            var n = t._adapter, a = t.options.time, i = a.parser, r = i || a.format, o = e;
            return "function" == typeof i && (o = i(o)), ot.isFinite(o) || (o = "string" == typeof r ? n.parse(o, r) : n.parse(o)), null !== o ? +o : (i || "function" != typeof r || (o = r(e), ot.isFinite(o) || (o = n.parse(o))), o)
        }

        function bi(t, e) {
            if (ot.isNullOrUndef(e)) return null;
            var n = t.options.time, a = vi(t, t.getRightValue(e));
            return null === a || n.round && (a = +t._adapter.startOf(a, n.round)), a
        }

        function yi(t, e, n, a) {
            var i, r, o, s = ci.length;
            for (i = ci.indexOf(t); i < s - 1; ++i) if (o = (r = li[ci[i]]).steps ? r.steps : si, r.common && Math.ceil((n - e) / (o * r.size)) <= a) return ci[i];
            return ci[s - 1]
        }

        function xi(t, e, n, a, i) {
            var r, o;
            for (r = ci.length - 1; r >= ci.indexOf(n); r--) if (o = ci[r], li[o].common && t._adapter.diff(i, a, o) >= e - 1) return o;
            return ci[n ? ci.indexOf(n) : 0]
        }

        function _i(t) {
            for (var e = ci.indexOf(t) + 1, n = ci.length; e < n; ++e) if (li[ci[e]].common) return ci[e]
        }

        function wi(t, e, n, a) {
            var i, r = t._adapter, o = t.options, s = o.time, l = s.unit || yi(s.minUnit, e, n, a),
                c = ii([s.stepSize, s.unitStepSize, 1]), d = "week" === l && s.isoWeekday, u = e, h = [];
            if (d && (u = +r.startOf(u, "isoWeek", d)), u = +r.startOf(u, d ? "day" : l), r.diff(n, e, l) > 1e5 * c) throw e + " and " + n + " are too far apart with stepSize of " + c + " " + l;
            for (i = u; i < n; i = +r.add(i, c, l)) h.push(i);
            return i !== n && "ticks" !== o.bounds || h.push(i), h
        }

        function Si(t, e, n, a, i) {
            var r, o, s = 0, l = 0;
            return i.offset && e.length && (r = mi(t, "time", e[0], "pos"), s = 1 === e.length ? 1 - r : (mi(t, "time", e[1], "pos") - r) / 2, o = mi(t, "time", e[e.length - 1], "pos"), l = 1 === e.length ? o : (o - mi(t, "time", e[e.length - 2], "pos")) / 2), {
                start: s,
                end: l,
                factor: 1 / (s + 1 + l)
            }
        }

        function Ci(t, e, n, a) {
            var i, r, o = t._adapter, s = +o.startOf(e[0].value, a), l = e[e.length - 1].value;
            for (i = s; i <= l; i = +o.add(i, 1, a)) (r = n[i]) >= 0 && (e[r].major = !0);
            return e
        }

        function ki(t, e, n) {
            var a, i, r = [], o = {}, s = e.length;
            for (a = 0; a < s; ++a) o[i = e[a]] = a, r.push({value: i, major: !1});
            return 0 !== s && n ? Ci(t, r, o, n) : r
        }

        var Di = {
            position: "bottom",
            distribution: "linear",
            bounds: "data",
            adapters: {},
            time: {
                parser: !1,
                unit: !1,
                round: !1,
                displayFormat: !1,
                isoWeekday: !1,
                minUnit: "millisecond",
                displayFormats: {}
            },
            ticks: {autoSkip: !1, source: "auto", major: {enabled: !1}}
        }, Ti = va.extend({
            initialize: function () {
                this.mergeTicksOptions(), va.prototype.initialize.call(this)
            }, update: function () {
                var t = this, e = t.options, n = e.time || (e.time = {}),
                    a = t._adapter = new Zn._date(e.adapters.date);
                return ai("time scale", n.format, "time.format", "time.parser"), ai("time scale", n.min, "time.min", "ticks.min"), ai("time scale", n.max, "time.max", "ticks.max"), ot.mergeIf(n.displayFormats, a.formats()), va.prototype.update.apply(t, arguments)
            }, getRightValue: function (t) {
                return t && void 0 !== t.t && (t = t.t), va.prototype.getRightValue.call(this, t)
            }, determineDataLimits: function () {
                var t, e, n, a, i, r, o, s = this, l = s.chart, c = s._adapter, d = s.options, u = d.time.unit || "day",
                    h = si, p = oi, f = [], g = [], m = [], v = s._getLabels();
                for (t = 0, n = v.length; t < n; ++t) m.push(bi(s, v[t]));
                for (t = 0, n = (l.data.datasets || []).length; t < n; ++t) if (l.isDatasetVisible(t)) if (i = l.data.datasets[t].data, ot.isObject(i[0])) for (g[t] = [], e = 0, a = i.length; e < a; ++e) r = bi(s, i[e]), f.push(r), g[t][e] = r; else g[t] = m.slice(0), o || (f = f.concat(m), o = !0); else g[t] = [];
                m.length && (h = Math.min(h, m[0]), p = Math.max(p, m[m.length - 1])), f.length && (f = n > 1 ? ui(f).sort(di) : f.sort(di), h = Math.min(h, f[0]), p = Math.max(p, f[f.length - 1])), h = bi(s, hi(d)) || h, p = bi(s, pi(d)) || p, h = h === si ? +c.startOf(Date.now(), u) : h, p = p === oi ? +c.endOf(Date.now(), u) + 1 : p, s.min = Math.min(h, p), s.max = Math.max(h + 1, p), s._table = [], s._timestamps = {
                    data: f,
                    datasets: g,
                    labels: m
                }
            }, buildTicks: function () {
                var t, e, n, a = this, i = a.min, r = a.max, o = a.options, s = o.ticks, l = o.time, c = a._timestamps,
                    d = [], u = a.getLabelCapacity(i), h = s.source, p = o.distribution;
                for (c = "data" === h || "auto" === h && "series" === p ? c.data : "labels" === h ? c.labels : wi(a, i, r, u), "ticks" === o.bounds && c.length && (i = c[0], r = c[c.length - 1]), i = bi(a, hi(o)) || i, r = bi(a, pi(o)) || r, t = 0, e = c.length; t < e; ++t) (n = c[t]) >= i && n <= r && d.push(n);
                return a.min = i, a.max = r, a._unit = l.unit || (s.autoSkip ? yi(l.minUnit, a.min, a.max, u) : xi(a, d.length, l.minUnit, a.min, a.max)), a._majorUnit = s.major.enabled && "year" !== a._unit ? _i(a._unit) : void 0, a._table = fi(a._timestamps.data, i, r, p), a._offsets = Si(a._table, d, i, r, o), s.reverse && d.reverse(), ki(a, d, a._majorUnit)
            }, getLabelForIndex: function (t, e) {
                var n = this, a = n._adapter, i = n.chart.data, r = n.options.time,
                    o = i.labels && t < i.labels.length ? i.labels[t] : "", s = i.datasets[e].data[t];
                return ot.isObject(s) && (o = n.getRightValue(s)), r.tooltipFormat ? a.format(vi(n, o), r.tooltipFormat) : "string" == typeof o ? o : a.format(vi(n, o), r.displayFormats.datetime)
            }, tickFormatFunction: function (t, e, n, a) {
                var i = this, r = i._adapter, o = i.options, s = o.time.displayFormats, l = s[i._unit],
                    c = i._majorUnit, d = s[c], u = n[e], h = o.ticks, p = c && d && u && u.major,
                    f = r.format(t, a || (p ? d : l)), g = p ? h.major : h.minor,
                    m = ii([g.callback, g.userCallback, h.callback, h.userCallback]);
                return m ? m(f, e, n) : f
            }, convertTicksToLabels: function (t) {
                var e, n, a = [];
                for (e = 0, n = t.length; e < n; ++e) a.push(this.tickFormatFunction(t[e].value, e, t));
                return a
            }, getPixelForOffset: function (t) {
                var e = this, n = e._offsets, a = mi(e._table, "time", t, "pos");
                return e.getPixelForDecimal((n.start + a) * n.factor)
            }, getPixelForValue: function (t, e, n) {
                var a = this, i = null;
                if (void 0 !== e && void 0 !== n && (i = a._timestamps.datasets[n][e]), null === i && (i = bi(a, t)), null !== i) return a.getPixelForOffset(i)
            }, getPixelForTick: function (t) {
                var e = this.getTicks();
                return t >= 0 && t < e.length ? this.getPixelForOffset(e[t].value) : null
            }, getValueForPixel: function (t) {
                var e = this, n = e._offsets, a = e.getDecimalForPixel(t) / n.factor - n.end,
                    i = mi(e._table, "pos", a, "time");
                return e._adapter._create(i)
            }, _getLabelSize: function (t) {
                var e = this, n = e.options.ticks, a = e.ctx.measureText(t).width,
                    i = ot.toRadians(e.isHorizontal() ? n.maxRotation : n.minRotation), r = Math.cos(i),
                    o = Math.sin(i), s = ri(n.fontSize, Q.global.defaultFontSize);
                return {w: a * r + s * o, h: a * o + s * r}
            }, getLabelWidth: function (t) {
                return this._getLabelSize(t).w
            }, getLabelCapacity: function (t) {
                var e = this, n = e.options.time, a = n.displayFormats, i = a[n.unit] || a.millisecond,
                    r = e.tickFormatFunction(t, 0, ki(e, [t], e._majorUnit), i), o = e._getLabelSize(r),
                    s = Math.floor(e.isHorizontal() ? e.width / o.w : e.height / o.h);
                return e.options.offset && s--, s > 0 ? s : 1
            }
        }), Ei = Di;
        Ti._defaults = Ei;
        var Ai = {category: xa, linear: Ra, logarithmic: Ha, radialLinear: ei, time: Ti}, Ii = {
            datetime: "MMM D, YYYY, h:mm:ss a",
            millisecond: "h:mm:ss.SSS a",
            second: "h:mm:ss a",
            minute: "h:mm a",
            hour: "hA",
            day: "MMM D",
            week: "ll",
            month: "MMM YYYY",
            quarter: "[Q]Q - YYYY",
            year: "YYYY"
        };
        Zn._date.override("function" == typeof t ? {
            _id: "moment", formats: function () {
                return Ii
            }, parse: function (e, n) {
                return "string" == typeof e && "string" == typeof n ? e = t(e, n) : e instanceof t || (e = t(e)), e.isValid() ? e.valueOf() : null
            }, format: function (e, n) {
                return t(e).format(n)
            }, add: function (e, n, a) {
                return t(e).add(n, a).valueOf()
            }, diff: function (e, n, a) {
                return t(e).diff(t(n), a)
            }, startOf: function (e, n, a) {
                return e = t(e), "isoWeek" === n ? e.isoWeekday(a).valueOf() : e.startOf(n).valueOf()
            }, endOf: function (e, n) {
                return t(e).endOf(n).valueOf()
            }, _create: function (e) {
                return t(e)
            }
        } : {}), Q._set("global", {plugins: {filler: {propagate: !0}}});
        var Mi = {
            dataset: function (t) {
                var e = t.fill, n = t.chart, a = n.getDatasetMeta(e),
                    i = a && n.isDatasetVisible(e) && a.dataset._children || [], r = i.length || 0;
                return r ? function (t, e) {
                    return e < r && i[e]._view || null
                } : null
            }, boundary: function (t) {
                var e = t.boundary, n = e ? e.x : null, a = e ? e.y : null;
                return ot.isArray(e) ? function (t, n) {
                    return e[n]
                } : function (t) {
                    return {x: null === n ? t.x : n, y: null === a ? t.y : a}
                }
            }
        };

        function Ri(t, e, n) {
            var a, i = t._model || {}, r = i.fill;
            if (void 0 === r && (r = !!i.backgroundColor), !1 === r || null === r) return !1;
            if (!0 === r) return "origin";
            if (a = parseFloat(r, 10), isFinite(a) && Math.floor(a) === a) return "-" !== r[0] && "+" !== r[0] || (a = e + a), !(a === e || a < 0 || a >= n) && a;
            switch (r) {
                case"bottom":
                    return "start";
                case"top":
                    return "end";
                case"zero":
                    return "origin";
                case"origin":
                case"start":
                case"end":
                    return r;
                default:
                    return !1
            }
        }

        function Pi(t) {
            var e, n = t.el._model || {}, a = t.el._scale || {}, i = t.fill, r = null;
            if (isFinite(i)) return null;
            if ("start" === i ? r = void 0 === n.scaleBottom ? a.bottom : n.scaleBottom : "end" === i ? r = void 0 === n.scaleTop ? a.top : n.scaleTop : void 0 !== n.scaleZero ? r = n.scaleZero : a.getBasePixel && (r = a.getBasePixel()), null != r) {
                if (void 0 !== r.x && void 0 !== r.y) return r;
                if (ot.isFinite(r)) return {x: (e = a.isHorizontal()) ? r : null, y: e ? null : r}
            }
            return null
        }

        function Oi(t) {
            var e, n, a, i, r, o = t.el._scale, s = o.options, l = o.chart.data.labels.length, c = t.fill, d = [];
            if (!l) return null;
            for (e = s.ticks.reverse ? o.max : o.min, n = s.ticks.reverse ? o.min : o.max, a = o.getPointPositionForValue(0, e), i = 0; i < l; ++i) r = "start" === c || "end" === c ? o.getPointPositionForValue(i, "start" === c ? e : n) : o.getBasePosition(i), s.gridLines.circular && (r.cx = a.x, r.cy = a.y, r.angle = o.getIndexAngle(i) - Math.PI / 2), d.push(r);
            return d
        }

        function ji(t) {
            return (t.el._scale || {}).getPointPositionForValue ? Oi(t) : Pi(t)
        }

        function Ni(t, e, n) {
            var a, i = t[e].fill, r = [e];
            if (!n) return i;
            for (; !1 !== i && -1 === r.indexOf(i);) {
                if (!isFinite(i)) return i;
                if (!(a = t[i])) return !1;
                if (a.visible) return i;
                r.push(i), i = a.fill
            }
            return !1
        }

        function Li(t) {
            var e = t.fill, n = "dataset";
            return !1 === e ? null : (isFinite(e) || (n = "boundary"), Mi[n](t))
        }

        function Fi(t) {
            return t && !t.skip
        }

        function Hi(t, e, n, a, i) {
            var r, o, s, l;
            if (a && i) {
                for (t.moveTo(e[0].x, e[0].y), r = 1; r < a; ++r) ot.canvas.lineTo(t, e[r - 1], e[r]);
                if (void 0 === n[0].angle) for (t.lineTo(n[i - 1].x, n[i - 1].y), r = i - 1; r > 0; --r) ot.canvas.lineTo(t, n[r], n[r - 1], !0); else for (o = n[0].cx, s = n[0].cy, l = Math.sqrt(Math.pow(n[0].x - o, 2) + Math.pow(n[0].y - s, 2)), r = i - 1; r > 0; --r) t.arc(o, s, l, n[r].angle, n[r - 1].angle, !0)
            }
        }

        function Bi(t, e, n, a, i, r) {
            var o, s, l, c, d, u, h, p, f = e.length, g = a.spanGaps, m = [], v = [], b = 0, y = 0;
            for (t.beginPath(), o = 0, s = f; o < s; ++o) d = n(c = e[l = o % f]._view, l, a), u = Fi(c), h = Fi(d), r && void 0 === p && u && (s = f + (p = o + 1)), u && h ? (b = m.push(c), y = v.push(d)) : b && y && (g ? (u && m.push(c), h && v.push(d)) : (Hi(t, m, v, b, y), b = y = 0, m = [], v = []));
            Hi(t, m, v, b, y), t.closePath(), t.fillStyle = i, t.fill()
        }

        var qi = {
            id: "filler", afterDatasetsUpdate: function (t, e) {
                var n, a, i, r, o = (t.data.datasets || []).length, s = e.propagate, l = [];
                for (a = 0; a < o; ++a) r = null, (i = (n = t.getDatasetMeta(a)).dataset) && i._model && i instanceof Yt.Line && (r = {
                    visible: t.isDatasetVisible(a),
                    fill: Ri(i, a, o),
                    chart: t,
                    el: i
                }), n.$filler = r, l.push(r);
                for (a = 0; a < o; ++a) (r = l[a]) && (r.fill = Ni(l, a, s), r.boundary = ji(r), r.mapper = Li(r))
            }, beforeDatasetsDraw: function (t) {
                var e, n, a, i, r, o, s, l = t._getSortedVisibleDatasetMetas(), c = t.ctx;
                for (n = l.length - 1; n >= 0; --n) (e = l[n].$filler) && e.visible && (i = (a = e.el)._view, r = a._children || [], o = e.mapper, s = i.backgroundColor || Q.global.defaultColor, o && s && r.length && (ot.canvas.clipArea(c, t.chartArea), Bi(c, r, o, i, s, a._loop), ot.canvas.unclipArea(c)))
            }
        }, zi = ot.rtl.getRtlAdapter, Wi = ot.noop, Vi = ot.valueOrDefault;

        function $i(t, e) {
            return t.usePointStyle && t.boxWidth > e ? e : t.boxWidth
        }

        Q._set("global", {
            legend: {
                display: !0,
                position: "top",
                align: "center",
                fullWidth: !0,
                reverse: !1,
                weight: 1e3,
                onClick: function (t, e) {
                    var n = e.datasetIndex, a = this.chart, i = a.getDatasetMeta(n);
                    i.hidden = null === i.hidden ? !a.data.datasets[n].hidden : null, a.update()
                },
                onHover: null,
                onLeave: null,
                labels: {
                    boxWidth: 40, padding: 10, generateLabels: function (t) {
                        var e = t.data.datasets, n = t.options.legend || {}, a = n.labels && n.labels.usePointStyle;
                        return t._getSortedDatasetMetas().map((function (n) {
                            var i = n.controller.getStyle(a ? 0 : void 0);
                            return {
                                text: e[n.index].label,
                                fillStyle: i.backgroundColor,
                                hidden: !t.isDatasetVisible(n.index),
                                lineCap: i.borderCapStyle,
                                lineDash: i.borderDash,
                                lineDashOffset: i.borderDashOffset,
                                lineJoin: i.borderJoinStyle,
                                lineWidth: i.borderWidth,
                                strokeStyle: i.borderColor,
                                pointStyle: i.pointStyle,
                                rotation: i.rotation,
                                datasetIndex: n.index
                            }
                        }), this)
                    }
                }
            }, legendCallback: function (t) {
                var e, n, a, i = document.createElement("ul"), r = t.data.datasets;
                for (i.setAttribute("class", t.id + "-legend"), e = 0, n = r.length; e < n; e++) (a = i.appendChild(document.createElement("li"))).appendChild(document.createElement("span")).style.backgroundColor = r[e].backgroundColor, r[e].label && a.appendChild(document.createTextNode(r[e].label));
                return i.outerHTML
            }
        });
        var Yi = ft.extend({
            initialize: function (t) {
                var e = this;
                ot.extend(e, t), e.legendHitBoxes = [], e._hoveredItem = null, e.doughnutMode = !1
            }, beforeUpdate: Wi, update: function (t, e, n) {
                var a = this;
                return a.beforeUpdate(), a.maxWidth = t, a.maxHeight = e, a.margins = n, a.beforeSetDimensions(), a.setDimensions(), a.afterSetDimensions(), a.beforeBuildLabels(), a.buildLabels(), a.afterBuildLabels(), a.beforeFit(), a.fit(), a.afterFit(), a.afterUpdate(), a.minSize
            }, afterUpdate: Wi, beforeSetDimensions: Wi, setDimensions: function () {
                var t = this;
                t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
                    width: 0,
                    height: 0
                }
            }, afterSetDimensions: Wi, beforeBuildLabels: Wi, buildLabels: function () {
                var t = this, e = t.options.labels || {}, n = ot.callback(e.generateLabels, [t.chart], t) || [];
                e.filter && (n = n.filter((function (n) {
                    return e.filter(n, t.chart.data)
                }))), t.options.reverse && n.reverse(), t.legendItems = n
            }, afterBuildLabels: Wi, beforeFit: Wi, fit: function () {
                var t = this, e = t.options, n = e.labels, a = e.display, i = t.ctx, r = ot.options._parseFont(n),
                    o = r.size, s = t.legendHitBoxes = [], l = t.minSize, c = t.isHorizontal();
                if (c ? (l.width = t.maxWidth, l.height = a ? 10 : 0) : (l.width = a ? 10 : 0, l.height = t.maxHeight), a) {
                    if (i.font = r.string, c) {
                        var d = t.lineWidths = [0], u = 0;
                        i.textAlign = "left", i.textBaseline = "middle", ot.each(t.legendItems, (function (t, e) {
                            var a = $i(n, o) + o / 2 + i.measureText(t.text).width;
                            (0 === e || d[d.length - 1] + a + 2 * n.padding > l.width) && (u += o + n.padding, d[d.length - (e > 0 ? 0 : 1)] = 0), s[e] = {
                                left: 0,
                                top: 0,
                                width: a,
                                height: o
                            }, d[d.length - 1] += a + n.padding
                        })), l.height += u
                    } else {
                        var h = n.padding, p = t.columnWidths = [], f = t.columnHeights = [], g = n.padding, m = 0,
                            v = 0;
                        ot.each(t.legendItems, (function (t, e) {
                            var a = $i(n, o) + o / 2 + i.measureText(t.text).width;
                            e > 0 && v + o + 2 * h > l.height && (g += m + n.padding, p.push(m), f.push(v), m = 0, v = 0), m = Math.max(m, a), v += o + h, s[e] = {
                                left: 0,
                                top: 0,
                                width: a,
                                height: o
                            }
                        })), g += m, p.push(m), f.push(v), l.width += g
                    }
                    t.width = l.width, t.height = l.height
                } else t.width = l.width = t.height = l.height = 0
            }, afterFit: Wi, isHorizontal: function () {
                return "top" === this.options.position || "bottom" === this.options.position
            }, draw: function () {
                var t = this, e = t.options, n = e.labels, a = Q.global, i = a.defaultColor, r = a.elements.line,
                    o = t.height, s = t.columnHeights, l = t.width, c = t.lineWidths;
                if (e.display) {
                    var d, u = zi(e.rtl, t.left, t.minSize.width), h = t.ctx, p = Vi(n.fontColor, a.defaultFontColor),
                        f = ot.options._parseFont(n), g = f.size;
                    h.textAlign = u.textAlign("left"), h.textBaseline = "middle", h.lineWidth = .5, h.strokeStyle = p, h.fillStyle = p, h.font = f.string;
                    var m = $i(n, g), v = t.legendHitBoxes, b = function (t, e, a) {
                        if (!(isNaN(m) || m <= 0)) {
                            h.save();
                            var o = Vi(a.lineWidth, r.borderWidth);
                            if (h.fillStyle = Vi(a.fillStyle, i), h.lineCap = Vi(a.lineCap, r.borderCapStyle), h.lineDashOffset = Vi(a.lineDashOffset, r.borderDashOffset), h.lineJoin = Vi(a.lineJoin, r.borderJoinStyle), h.lineWidth = o, h.strokeStyle = Vi(a.strokeStyle, i), h.setLineDash && h.setLineDash(Vi(a.lineDash, r.borderDash)), n && n.usePointStyle) {
                                var s = m * Math.SQRT2 / 2, l = u.xPlus(t, m / 2), c = e + g / 2;
                                ot.canvas.drawPoint(h, a.pointStyle, s, l, c, a.rotation)
                            } else h.fillRect(u.leftForLtr(t, m), e, m, g), 0 !== o && h.strokeRect(u.leftForLtr(t, m), e, m, g);
                            h.restore()
                        }
                    }, y = function (t, e, n, a) {
                        var i = g / 2, r = u.xPlus(t, m + i), o = e + i;
                        h.fillText(n.text, r, o), n.hidden && (h.beginPath(), h.lineWidth = 2, h.moveTo(r, o), h.lineTo(u.xPlus(r, a), o), h.stroke())
                    }, x = function (t, a) {
                        switch (e.align) {
                            case"start":
                                return n.padding;
                            case"end":
                                return t - a;
                            default:
                                return (t - a + n.padding) / 2
                        }
                    }, _ = t.isHorizontal();
                    d = _ ? {x: t.left + x(l, c[0]), y: t.top + n.padding, line: 0} : {
                        x: t.left + n.padding,
                        y: t.top + x(o, s[0]),
                        line: 0
                    }, ot.rtl.overrideTextDirection(t.ctx, e.textDirection);
                    var w = g + n.padding;
                    ot.each(t.legendItems, (function (e, a) {
                        var i = h.measureText(e.text).width, r = m + g / 2 + i, p = d.x, f = d.y;
                        u.setWidth(t.minSize.width), _ ? a > 0 && p + r + n.padding > t.left + t.minSize.width && (f = d.y += w, d.line++, p = d.x = t.left + x(l, c[d.line])) : a > 0 && f + w > t.top + t.minSize.height && (p = d.x = p + t.columnWidths[d.line] + n.padding, d.line++, f = d.y = t.top + x(o, s[d.line]));
                        var S = u.x(p);
                        b(S, f, e), v[a].left = u.leftForLtr(S, v[a].width), v[a].top = f, y(S, f, e, i), _ ? d.x += r + n.padding : d.y += w
                    })), ot.rtl.restoreTextDirection(t.ctx, e.textDirection)
                }
            }, _getLegendItemAt: function (t, e) {
                var n, a, i, r = this;
                if (t >= r.left && t <= r.right && e >= r.top && e <= r.bottom) for (i = r.legendHitBoxes, n = 0; n < i.length; ++n) if (t >= (a = i[n]).left && t <= a.left + a.width && e >= a.top && e <= a.top + a.height) return r.legendItems[n];
                return null
            }, handleEvent: function (t) {
                var e, n = this, a = n.options, i = "mouseup" === t.type ? "click" : t.type;
                if ("mousemove" === i) {
                    if (!a.onHover && !a.onLeave) return
                } else {
                    if ("click" !== i) return;
                    if (!a.onClick) return
                }
                e = n._getLegendItemAt(t.x, t.y), "click" === i ? e && a.onClick && a.onClick.call(n, t.native, e) : (a.onLeave && e !== n._hoveredItem && (n._hoveredItem && a.onLeave.call(n, t.native, n._hoveredItem), n._hoveredItem = e), a.onHover && e && a.onHover.call(n, t.native, e))
            }
        });

        function Ui(t, e) {
            var n = new Yi({ctx: t.ctx, options: e, chart: t});
            Ve.configure(t, n, e), Ve.addBox(t, n), t.legend = n
        }

        var Gi = {
            id: "legend", _element: Yi, beforeInit: function (t) {
                var e = t.options.legend;
                e && Ui(t, e)
            }, beforeUpdate: function (t) {
                var e = t.options.legend, n = t.legend;
                e ? (ot.mergeIf(e, Q.global.legend), n ? (Ve.configure(t, n, e), n.options = e) : Ui(t, e)) : n && (Ve.removeBox(t, n), delete t.legend)
            }, afterEvent: function (t, e) {
                var n = t.legend;
                n && n.handleEvent(e)
            }
        }, Xi = ot.noop;
        Q._set("global", {
            title: {
                display: !1,
                fontStyle: "bold",
                fullWidth: !0,
                padding: 10,
                position: "top",
                text: "",
                weight: 2e3
            }
        });
        var Zi = ft.extend({
            initialize: function (t) {
                var e = this;
                ot.extend(e, t), e.legendHitBoxes = []
            },
            beforeUpdate: Xi,
            update: function (t, e, n) {
                var a = this;
                return a.beforeUpdate(), a.maxWidth = t, a.maxHeight = e, a.margins = n, a.beforeSetDimensions(), a.setDimensions(), a.afterSetDimensions(), a.beforeBuildLabels(), a.buildLabels(), a.afterBuildLabels(), a.beforeFit(), a.fit(), a.afterFit(), a.afterUpdate(), a.minSize
            },
            afterUpdate: Xi,
            beforeSetDimensions: Xi,
            setDimensions: function () {
                var t = this;
                t.isHorizontal() ? (t.width = t.maxWidth, t.left = 0, t.right = t.width) : (t.height = t.maxHeight, t.top = 0, t.bottom = t.height), t.paddingLeft = 0, t.paddingTop = 0, t.paddingRight = 0, t.paddingBottom = 0, t.minSize = {
                    width: 0,
                    height: 0
                }
            },
            afterSetDimensions: Xi,
            beforeBuildLabels: Xi,
            buildLabels: Xi,
            afterBuildLabels: Xi,
            beforeFit: Xi,
            fit: function () {
                var t, e = this, n = e.options, a = e.minSize = {}, i = e.isHorizontal();
                n.display ? (t = (ot.isArray(n.text) ? n.text.length : 1) * ot.options._parseFont(n).lineHeight + 2 * n.padding, e.width = a.width = i ? e.maxWidth : t, e.height = a.height = i ? t : e.maxHeight) : e.width = a.width = e.height = a.height = 0
            },
            afterFit: Xi,
            isHorizontal: function () {
                var t = this.options.position;
                return "top" === t || "bottom" === t
            },
            draw: function () {
                var t = this, e = t.ctx, n = t.options;
                if (n.display) {
                    var a, i, r, o = ot.options._parseFont(n), s = o.lineHeight, l = s / 2 + n.padding, c = 0,
                        d = t.top, u = t.left, h = t.bottom, p = t.right;
                    e.fillStyle = ot.valueOrDefault(n.fontColor, Q.global.defaultFontColor), e.font = o.string, t.isHorizontal() ? (i = u + (p - u) / 2, r = d + l, a = p - u) : (i = "left" === n.position ? u + l : p - l, r = d + (h - d) / 2, a = h - d, c = Math.PI * ("left" === n.position ? -.5 : .5)), e.save(), e.translate(i, r), e.rotate(c), e.textAlign = "center", e.textBaseline = "middle";
                    var f = n.text;
                    if (ot.isArray(f)) for (var g = 0, m = 0; m < f.length; ++m) e.fillText(f[m], 0, g, a), g += s; else e.fillText(f, 0, 0, a);
                    e.restore()
                }
            }
        });

        function Ki(t, e) {
            var n = new Zi({ctx: t.ctx, options: e, chart: t});
            Ve.configure(t, n, e), Ve.addBox(t, n), t.titleBlock = n
        }

        var Qi = {}, Ji = qi, tr = Gi, er = {
            id: "title", _element: Zi, beforeInit: function (t) {
                var e = t.options.title;
                e && Ki(t, e)
            }, beforeUpdate: function (t) {
                var e = t.options.title, n = t.titleBlock;
                e ? (ot.mergeIf(e, Q.global.title), n ? (Ve.configure(t, n, e), n.options = e) : Ki(t, e)) : n && (Ve.removeBox(t, n), delete t.titleBlock)
            }
        };
        for (var nr in Qi.filler = Ji, Qi.legend = tr, Qi.title = er, Yn.helpers = ot, Un(), Yn._adapters = Zn, Yn.Animation = mt, Yn.animationService = vt, Yn.controllers = Ce, Yn.DatasetController = St, Yn.defaults = Q, Yn.Element = ft, Yn.elements = Yt, Yn.Interaction = Me, Yn.layouts = Ve, Yn.platform = yn, Yn.plugins = xn, Yn.Scale = va, Yn.scaleService = _n, Yn.Ticks = Kn, Yn.Tooltip = Nn, Yn.helpers.each(Ai, (function (t, e) {
            Yn.scaleService.registerScaleType(e, t, t._defaults)
        })), Qi) Qi.hasOwnProperty(nr) && Yn.plugins.register(Qi[nr]);
        Yn.platform.initialize();
        var ar = Yn;
        return "undefined" != typeof window && (window.Chart = Yn), Yn.Chart = Yn, Yn.Legend = Qi.legend._element, Yn.Title = Qi.title._element, Yn.pluginService = Yn.plugins, Yn.PluginBase = Yn.Element.extend({}), Yn.canvasHelpers = Yn.helpers.canvas, Yn.layoutService = Yn.layouts, Yn.LinearScaleBase = ka, Yn.helpers.each(["Bar", "Bubble", "Doughnut", "Line", "PolarArea", "Radar", "Scatter"], (function (t) {
            Yn[t] = function (e, n) {
                return new Yn(e, Yn.helpers.merge(n || {}, {type: t.charAt(0).toLowerCase() + t.slice(1)}))
            }
        })), ar
    }(function () {
        try {
            return n(77)
        } catch (t) {
        }
    }())
}, function (t, e, n) {
    var a = n(62);
    t.exports = function (t, e, n) {
        if (a(t), void 0 === e) return t;
        switch (n) {
            case 1:
                return function (n) {
                    return t.call(e, n)
                };
            case 2:
                return function (n, a) {
                    return t.call(e, n, a)
                };
            case 3:
                return function (n, a, i) {
                    return t.call(e, n, a, i)
                }
        }
        return function () {
            return t.apply(e, arguments)
        }
    }
}, function (t, e) {
    t.exports = function (t) {
        if ("function" != typeof t) throw TypeError(t + " is not a function!");
        return t
    }
}, function (t, e, n) {
    var a = n(11), i = n(33), r = n(64);
    t.exports = function (t) {
        return function (e, n, o) {
            var s, l = a(e), c = i(l.length), d = r(o, c);
            if (t && n != n) {
                for (; c > d;) if ((s = l[d++]) != s) return !0
            } else for (; c > d; d++) if ((t || d in l) && l[d] === n) return t || d || 0;
            return !t && -1
        }
    }
}, function (t, e, n) {
    var a = n(29), i = Math.max, r = Math.min;
    t.exports = function (t, e) {
        return (t = a(t)) < 0 ? i(t + e, 0) : r(t, e)
    }
}, function (t, e, n) {
    var a = n(34), i = n(20), r = n(11), o = n(37), s = n(10), l = n(49), c = Object.getOwnPropertyDescriptor;
    e.f = n(6) ? c : function (t, e) {
        if (t = r(t), e = o(e, !0), l) try {
            return c(t, e)
        } catch (t) {
        }
        if (s(t, e)) return i(!a.f.call(t, e), t[e])
    }
}, function (t, e, n) {
    var a = n(1), i = n(17), r = n(27), o = n(52), s = n(5).f;
    t.exports = function (t) {
        var e = i.Symbol || (i.Symbol = r ? {} : a.Symbol || {});
        "_" == t.charAt(0) || t in e || s(e, t, {value: o.f(t)})
    }
}, function (t, e, n) {
    "use strict";
    var a = n(27), i = n(8), r = n(12), o = n(4), s = n(30), l = n(91), c = n(40), d = n(92), u = n(0)("iterator"),
        h = !([].keys && "next" in [].keys()), p = "keys", f = "values", g = function () {
            return this
        };
    t.exports = function (t, e, n, m, v, b, y) {
        l(n, e, m);
        var x, _, w, S = function (t) {
                if (!h && t in T) return T[t];
                switch (t) {
                    case p:
                    case f:
                        return function () {
                            return new n(this, t)
                        }
                }
                return function () {
                    return new n(this, t)
                }
            }, C = e + " Iterator", k = v == f, D = !1, T = t.prototype, E = T[u] || T["@@iterator"] || v && T[v],
            A = E || S(v), I = v ? k ? S("entries") : A : void 0, M = "Array" == e && T.entries || E;
        if (M && (w = d(M.call(new t))) !== Object.prototype && w.next && (c(w, C, !0), a || "function" == typeof w[u] || o(w, u, g)), k && E && E.name !== f && (D = !0, A = function () {
            return E.call(this)
        }), a && !y || !h && !D && T[u] || o(T, u, A), s[e] = A, s[C] = g, v) if (x = {
            values: k ? A : S(f),
            keys: b ? A : S(p),
            entries: I
        }, y) for (_ in x) _ in T || r(T, _, x[_]); else i(i.P + i.F * (h || D), e, x);
        return x
    }
}, function (t, e, n) {
    "use strict";
    var a = n(69)(!0);
    t.exports = function (t, e, n) {
        return e + (n ? a(t, e).length : 1)
    }
}, function (t, e, n) {
    var a = n(29), i = n(25);
    t.exports = function (t) {
        return function (e, n) {
            var r, o, s = String(i(e)), l = a(n), c = s.length;
            return l < 0 || l >= c ? t ? "" : void 0 : (r = s.charCodeAt(l)) < 55296 || r > 56319 || l + 1 === c || (o = s.charCodeAt(l + 1)) < 56320 || o > 57343 ? t ? s.charAt(l) : r : t ? s.slice(l, l + 2) : o - 56320 + (r - 55296 << 10) + 65536
        }
    }
}, function (t, e, n) {
    "use strict";
    var a = n(44), i = RegExp.prototype.exec;
    t.exports = function (t, e) {
        var n = t.exec;
        if ("function" == typeof n) {
            var r = n.call(t, e);
            if ("object" != typeof r) throw new TypeError("RegExp exec method returned something other than an Object or null");
            return r
        }
        if ("RegExp" !== a(t)) throw new TypeError("RegExp#exec called on incompatible receiver");
        return i.call(t, e)
    }
}, function (t, e, n) {
    "use strict";
    n(97);
    var a = n(12), i = n(4), r = n(9), o = n(25), s = n(0), l = n(45), c = s("species"), d = !r((function () {
        var t = /./;
        return t.exec = function () {
            var t = [];
            return t.groups = {a: "7"}, t
        }, "7" !== "".replace(t, "$<a>")
    })), u = function () {
        var t = /(?:)/, e = t.exec;
        t.exec = function () {
            return e.apply(this, arguments)
        };
        var n = "ab".split(t);
        return 2 === n.length && "a" === n[0] && "b" === n[1]
    }();
    t.exports = function (t, e, n) {
        var h = s(t), p = !r((function () {
            var e = {};
            return e[h] = function () {
                return 7
            }, 7 != ""[t](e)
        })), f = p ? !r((function () {
            var e = !1, n = /a/;
            return n.exec = function () {
                return e = !0, null
            }, "split" === t && (n.constructor = {}, n.constructor[c] = function () {
                return n
            }), n[h](""), !e
        })) : void 0;
        if (!p || !f || "replace" === t && !d || "split" === t && !u) {
            var g = /./[h], m = n(o, h, ""[t], (function (t, e, n, a, i) {
                return e.exec === l ? p && !i ? {done: !0, value: g.call(e, n, a)} : {
                    done: !0,
                    value: t.call(n, e, a)
                } : {done: !1}
            })), v = m[0], b = m[1];
            a(String.prototype, t, v), i(RegExp.prototype, h, 2 == e ? function (t, e) {
                return b.call(t, this, e)
            } : function (t) {
                return b.call(t, this)
            })
        }
    }
}, function (t, e, n) {
    var a = n(73), i = n(46);
    t.exports = function (t) {
        return a(i(t))
    }
}, function (t, e, n) {
    var a = n(13), i = n(74), r = "".split;
    t.exports = a((function () {
        return !Object("z").propertyIsEnumerable(0)
    })) ? function (t) {
        return "String" == i(t) ? r.call(t, "") : Object(t)
    } : Object
}, function (t, e) {
    var n = {}.toString;
    t.exports = function (t) {
        return n.call(t).slice(8, -1)
    }
}, function (t, e) {
    t.exports = {}
}, function (t, e) {
    var n = Math.ceil, a = Math.floor;
    t.exports = function (t) {
        return isNaN(t = +t) ? 0 : (t > 0 ? a : n)(t)
    }
}, function (t, e, n) {
    (function (t) {
        t.exports = function () {
            "use strict";
            var e, n;

            function a() {
                return e.apply(null, arguments)
            }

            function i(t) {
                e = t
            }

            function r(t) {
                return t instanceof Array || "[object Array]" === Object.prototype.toString.call(t)
            }

            function o(t) {
                return null != t && "[object Object]" === Object.prototype.toString.call(t)
            }

            function s(t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }

            function l(t) {
                if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(t).length;
                var e;
                for (e in t) if (s(t, e)) return !1;
                return !0
            }

            function c(t) {
                return void 0 === t
            }

            function d(t) {
                return "number" == typeof t || "[object Number]" === Object.prototype.toString.call(t)
            }

            function u(t) {
                return t instanceof Date || "[object Date]" === Object.prototype.toString.call(t)
            }

            function h(t, e) {
                var n, a = [];
                for (n = 0; n < t.length; ++n) a.push(e(t[n], n));
                return a
            }

            function p(t, e) {
                for (var n in e) s(e, n) && (t[n] = e[n]);
                return s(e, "toString") && (t.toString = e.toString), s(e, "valueOf") && (t.valueOf = e.valueOf), t
            }

            function f(t, e, n, a) {
                return Un(t, e, n, a, !0).utc()
            }

            function g() {
                return {
                    empty: !1,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: !1,
                    invalidEra: null,
                    invalidMonth: null,
                    invalidFormat: !1,
                    userInvalidated: !1,
                    iso: !1,
                    parsedDateParts: [],
                    era: null,
                    meridiem: null,
                    rfc2822: !1,
                    weekdayMismatch: !1
                }
            }

            function m(t) {
                return null == t._pf && (t._pf = g()), t._pf
            }

            function v(t) {
                if (null == t._isValid) {
                    var e = m(t), a = n.call(e.parsedDateParts, (function (t) {
                            return null != t
                        })),
                        i = !isNaN(t._d.getTime()) && e.overflow < 0 && !e.empty && !e.invalidEra && !e.invalidMonth && !e.invalidWeekday && !e.weekdayMismatch && !e.nullInput && !e.invalidFormat && !e.userInvalidated && (!e.meridiem || e.meridiem && a);
                    if (t._strict && (i = i && 0 === e.charsLeftOver && 0 === e.unusedTokens.length && void 0 === e.bigHour), null != Object.isFrozen && Object.isFrozen(t)) return i;
                    t._isValid = i
                }
                return t._isValid
            }

            function b(t) {
                var e = f(NaN);
                return null != t ? p(m(e), t) : m(e).userInvalidated = !0, e
            }

            n = Array.prototype.some ? Array.prototype.some : function (t) {
                var e, n = Object(this), a = n.length >>> 0;
                for (e = 0; e < a; e++) if (e in n && t.call(this, n[e], e, n)) return !0;
                return !1
            };
            var y = a.momentProperties = [], x = !1;

            function _(t, e) {
                var n, a, i;
                if (c(e._isAMomentObject) || (t._isAMomentObject = e._isAMomentObject), c(e._i) || (t._i = e._i), c(e._f) || (t._f = e._f), c(e._l) || (t._l = e._l), c(e._strict) || (t._strict = e._strict), c(e._tzm) || (t._tzm = e._tzm), c(e._isUTC) || (t._isUTC = e._isUTC), c(e._offset) || (t._offset = e._offset), c(e._pf) || (t._pf = m(e)), c(e._locale) || (t._locale = e._locale), y.length > 0) for (n = 0; n < y.length; n++) c(i = e[a = y[n]]) || (t[a] = i);
                return t
            }

            function w(t) {
                _(this, t), this._d = new Date(null != t._d ? t._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === x && (x = !0, a.updateOffset(this), x = !1)
            }

            function S(t) {
                return t instanceof w || null != t && null != t._isAMomentObject
            }

            function C(t) {
                !1 === a.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + t)
            }

            function k(t, e) {
                var n = !0;
                return p((function () {
                    if (null != a.deprecationHandler && a.deprecationHandler(null, t), n) {
                        var i, r, o, l = [];
                        for (r = 0; r < arguments.length; r++) {
                            if (i = "", "object" == typeof arguments[r]) {
                                for (o in i += "\n[" + r + "] ", arguments[0]) s(arguments[0], o) && (i += o + ": " + arguments[0][o] + ", ");
                                i = i.slice(0, -2)
                            } else i = arguments[r];
                            l.push(i)
                        }
                        C(t + "\nArguments: " + Array.prototype.slice.call(l).join("") + "\n" + (new Error).stack), n = !1
                    }
                    return e.apply(this, arguments)
                }), e)
            }

            var D, T = {};

            function E(t, e) {
                null != a.deprecationHandler && a.deprecationHandler(t, e), T[t] || (C(e), T[t] = !0)
            }

            function A(t) {
                return "undefined" != typeof Function && t instanceof Function || "[object Function]" === Object.prototype.toString.call(t)
            }

            function I(t) {
                var e, n;
                for (n in t) s(t, n) && (A(e = t[n]) ? this[n] = e : this["_" + n] = e);
                this._config = t, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
            }

            function M(t, e) {
                var n, a = p({}, t);
                for (n in e) s(e, n) && (o(t[n]) && o(e[n]) ? (a[n] = {}, p(a[n], t[n]), p(a[n], e[n])) : null != e[n] ? a[n] = e[n] : delete a[n]);
                for (n in t) s(t, n) && !s(e, n) && o(t[n]) && (a[n] = p({}, a[n]));
                return a
            }

            function R(t) {
                null != t && this.set(t)
            }

            a.suppressDeprecationWarnings = !1, a.deprecationHandler = null, D = Object.keys ? Object.keys : function (t) {
                var e, n = [];
                for (e in t) s(t, e) && n.push(e);
                return n
            };
            var P = {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            };

            function O(t, e, n) {
                var a = this._calendar[t] || this._calendar.sameElse;
                return A(a) ? a.call(e, n) : a
            }

            function j(t, e, n) {
                var a = "" + Math.abs(t), i = e - a.length;
                return (t >= 0 ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, i)).toString().substr(1) + a
            }

            var N = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
                L = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, F = {}, H = {};

            function B(t, e, n, a) {
                var i = a;
                "string" == typeof a && (i = function () {
                    return this[a]()
                }), t && (H[t] = i), e && (H[e[0]] = function () {
                    return j(i.apply(this, arguments), e[1], e[2])
                }), n && (H[n] = function () {
                    return this.localeData().ordinal(i.apply(this, arguments), t)
                })
            }

            function q(t) {
                return t.match(/\[[\s\S]/) ? t.replace(/^\[|\]$/g, "") : t.replace(/\\/g, "")
            }

            function z(t) {
                var e, n, a = t.match(N);
                for (e = 0, n = a.length; e < n; e++) H[a[e]] ? a[e] = H[a[e]] : a[e] = q(a[e]);
                return function (e) {
                    var i, r = "";
                    for (i = 0; i < n; i++) r += A(a[i]) ? a[i].call(e, t) : a[i];
                    return r
                }
            }

            function W(t, e) {
                return t.isValid() ? (e = V(e, t.localeData()), F[e] = F[e] || z(e), F[e](t)) : t.localeData().invalidDate()
            }

            function V(t, e) {
                var n = 5;

                function a(t) {
                    return e.longDateFormat(t) || t
                }

                for (L.lastIndex = 0; n >= 0 && L.test(t);) t = t.replace(L, a), L.lastIndex = 0, n -= 1;
                return t
            }

            var $ = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            };

            function Y(t) {
                var e = this._longDateFormat[t], n = this._longDateFormat[t.toUpperCase()];
                return e || !n ? e : (this._longDateFormat[t] = n.match(N).map((function (t) {
                    return "MMMM" === t || "MM" === t || "DD" === t || "dddd" === t ? t.slice(1) : t
                })).join(""), this._longDateFormat[t])
            }

            var U = "Invalid date";

            function G() {
                return this._invalidDate
            }

            var X = "%d", Z = /\d{1,2}/;

            function K(t) {
                return this._ordinal.replace("%d", t)
            }

            var Q = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                w: "a week",
                ww: "%d weeks",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            };

            function J(t, e, n, a) {
                var i = this._relativeTime[n];
                return A(i) ? i(t, e, n, a) : i.replace(/%d/i, t)
            }

            function tt(t, e) {
                var n = this._relativeTime[t > 0 ? "future" : "past"];
                return A(n) ? n(e) : n.replace(/%s/i, e)
            }

            var et = {};

            function nt(t, e) {
                var n = t.toLowerCase();
                et[n] = et[n + "s"] = et[e] = t
            }

            function at(t) {
                return "string" == typeof t ? et[t] || et[t.toLowerCase()] : void 0
            }

            function it(t) {
                var e, n, a = {};
                for (n in t) s(t, n) && (e = at(n)) && (a[e] = t[n]);
                return a
            }

            var rt = {};

            function ot(t, e) {
                rt[t] = e
            }

            function st(t) {
                var e, n = [];
                for (e in t) s(t, e) && n.push({unit: e, priority: rt[e]});
                return n.sort((function (t, e) {
                    return t.priority - e.priority
                })), n
            }

            function lt(t) {
                return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
            }

            function ct(t) {
                return t < 0 ? Math.ceil(t) || 0 : Math.floor(t)
            }

            function dt(t) {
                var e = +t, n = 0;
                return 0 !== e && isFinite(e) && (n = ct(e)), n
            }

            function ut(t, e) {
                return function (n) {
                    return null != n ? (pt(this, t, n), a.updateOffset(this, e), this) : ht(this, t)
                }
            }

            function ht(t, e) {
                return t.isValid() ? t._d["get" + (t._isUTC ? "UTC" : "") + e]() : NaN
            }

            function pt(t, e, n) {
                t.isValid() && !isNaN(n) && ("FullYear" === e && lt(t.year()) && 1 === t.month() && 29 === t.date() ? (n = dt(n), t._d["set" + (t._isUTC ? "UTC" : "") + e](n, t.month(), Jt(n, t.month()))) : t._d["set" + (t._isUTC ? "UTC" : "") + e](n))
            }

            function ft(t) {
                return A(this[t = at(t)]) ? this[t]() : this
            }

            function gt(t, e) {
                if ("object" == typeof t) {
                    var n, a = st(t = it(t));
                    for (n = 0; n < a.length; n++) this[a[n].unit](t[a[n].unit])
                } else if (A(this[t = at(t)])) return this[t](e);
                return this
            }

            var mt, vt = /\d/, bt = /\d\d/, yt = /\d{3}/, xt = /\d{4}/, _t = /[+-]?\d{6}/, wt = /\d\d?/,
                St = /\d\d\d\d?/, Ct = /\d\d\d\d\d\d?/, kt = /\d{1,3}/, Dt = /\d{1,4}/, Tt = /[+-]?\d{1,6}/, Et = /\d+/,
                At = /[+-]?\d+/, It = /Z|[+-]\d\d:?\d\d/gi, Mt = /Z|[+-]\d\d(?::?\d\d)?/gi, Rt = /[+-]?\d+(\.\d{1,3})?/,
                Pt = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

            function Ot(t, e, n) {
                mt[t] = A(e) ? e : function (t, a) {
                    return t && n ? n : e
                }
            }

            function jt(t, e) {
                return s(mt, t) ? mt[t](e._strict, e._locale) : new RegExp(Nt(t))
            }

            function Nt(t) {
                return Lt(t.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function (t, e, n, a, i) {
                    return e || n || a || i
                })))
            }

            function Lt(t) {
                return t.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
            }

            mt = {};
            var Ft = {};

            function Ht(t, e) {
                var n, a = e;
                for ("string" == typeof t && (t = [t]), d(e) && (a = function (t, n) {
                    n[e] = dt(t)
                }), n = 0; n < t.length; n++) Ft[t[n]] = a
            }

            function Bt(t, e) {
                Ht(t, (function (t, n, a, i) {
                    a._w = a._w || {}, e(t, a._w, a, i)
                }))
            }

            function qt(t, e, n) {
                null != e && s(Ft, t) && Ft[t](e, n._a, n, t)
            }

            var zt, Wt = 0, Vt = 1, $t = 2, Yt = 3, Ut = 4, Gt = 5, Xt = 6, Zt = 7, Kt = 8;

            function Qt(t, e) {
                return (t % e + e) % e
            }

            function Jt(t, e) {
                if (isNaN(t) || isNaN(e)) return NaN;
                var n = Qt(e, 12);
                return t += (e - n) / 12, 1 === n ? lt(t) ? 29 : 28 : 31 - n % 7 % 2
            }

            zt = Array.prototype.indexOf ? Array.prototype.indexOf : function (t) {
                var e;
                for (e = 0; e < this.length; ++e) if (this[e] === t) return e;
                return -1
            }, B("M", ["MM", 2], "Mo", (function () {
                return this.month() + 1
            })), B("MMM", 0, 0, (function (t) {
                return this.localeData().monthsShort(this, t)
            })), B("MMMM", 0, 0, (function (t) {
                return this.localeData().months(this, t)
            })), nt("month", "M"), ot("month", 8), Ot("M", wt), Ot("MM", wt, bt), Ot("MMM", (function (t, e) {
                return e.monthsShortRegex(t)
            })), Ot("MMMM", (function (t, e) {
                return e.monthsRegex(t)
            })), Ht(["M", "MM"], (function (t, e) {
                e[Vt] = dt(t) - 1
            })), Ht(["MMM", "MMMM"], (function (t, e, n, a) {
                var i = n._locale.monthsParse(t, a, n._strict);
                null != i ? e[Vt] = i : m(n).invalidMonth = t
            }));
            var te = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                ee = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), ne = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
                ae = Pt, ie = Pt;

            function re(t, e) {
                return t ? r(this._months) ? this._months[t.month()] : this._months[(this._months.isFormat || ne).test(e) ? "format" : "standalone"][t.month()] : r(this._months) ? this._months : this._months.standalone
            }

            function oe(t, e) {
                return t ? r(this._monthsShort) ? this._monthsShort[t.month()] : this._monthsShort[ne.test(e) ? "format" : "standalone"][t.month()] : r(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
            }

            function se(t, e, n) {
                var a, i, r, o = t.toLocaleLowerCase();
                if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], a = 0; a < 12; ++a) r = f([2e3, a]), this._shortMonthsParse[a] = this.monthsShort(r, "").toLocaleLowerCase(), this._longMonthsParse[a] = this.months(r, "").toLocaleLowerCase();
                return n ? "MMM" === e ? -1 !== (i = zt.call(this._shortMonthsParse, o)) ? i : null : -1 !== (i = zt.call(this._longMonthsParse, o)) ? i : null : "MMM" === e ? -1 !== (i = zt.call(this._shortMonthsParse, o)) || -1 !== (i = zt.call(this._longMonthsParse, o)) ? i : null : -1 !== (i = zt.call(this._longMonthsParse, o)) || -1 !== (i = zt.call(this._shortMonthsParse, o)) ? i : null
            }

            function le(t, e, n) {
                var a, i, r;
                if (this._monthsParseExact) return se.call(this, t, e, n);
                for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), a = 0; a < 12; a++) {
                    if (i = f([2e3, a]), n && !this._longMonthsParse[a] && (this._longMonthsParse[a] = new RegExp("^" + this.months(i, "").replace(".", "") + "$", "i"), this._shortMonthsParse[a] = new RegExp("^" + this.monthsShort(i, "").replace(".", "") + "$", "i")), n || this._monthsParse[a] || (r = "^" + this.months(i, "") + "|^" + this.monthsShort(i, ""), this._monthsParse[a] = new RegExp(r.replace(".", ""), "i")), n && "MMMM" === e && this._longMonthsParse[a].test(t)) return a;
                    if (n && "MMM" === e && this._shortMonthsParse[a].test(t)) return a;
                    if (!n && this._monthsParse[a].test(t)) return a
                }
            }

            function ce(t, e) {
                var n;
                if (!t.isValid()) return t;
                if ("string" == typeof e) if (/^\d+$/.test(e)) e = dt(e); else if (!d(e = t.localeData().monthsParse(e))) return t;
                return n = Math.min(t.date(), Jt(t.year(), e)), t._d["set" + (t._isUTC ? "UTC" : "") + "Month"](e, n), t
            }

            function de(t) {
                return null != t ? (ce(this, t), a.updateOffset(this, !0), this) : ht(this, "Month")
            }

            function ue() {
                return Jt(this.year(), this.month())
            }

            function he(t) {
                return this._monthsParseExact ? (s(this, "_monthsRegex") || fe.call(this), t ? this._monthsShortStrictRegex : this._monthsShortRegex) : (s(this, "_monthsShortRegex") || (this._monthsShortRegex = ae), this._monthsShortStrictRegex && t ? this._monthsShortStrictRegex : this._monthsShortRegex)
            }

            function pe(t) {
                return this._monthsParseExact ? (s(this, "_monthsRegex") || fe.call(this), t ? this._monthsStrictRegex : this._monthsRegex) : (s(this, "_monthsRegex") || (this._monthsRegex = ie), this._monthsStrictRegex && t ? this._monthsStrictRegex : this._monthsRegex)
            }

            function fe() {
                function t(t, e) {
                    return e.length - t.length
                }

                var e, n, a = [], i = [], r = [];
                for (e = 0; e < 12; e++) n = f([2e3, e]), a.push(this.monthsShort(n, "")), i.push(this.months(n, "")), r.push(this.months(n, "")), r.push(this.monthsShort(n, ""));
                for (a.sort(t), i.sort(t), r.sort(t), e = 0; e < 12; e++) a[e] = Lt(a[e]), i[e] = Lt(i[e]);
                for (e = 0; e < 24; e++) r[e] = Lt(r[e]);
                this._monthsRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + a.join("|") + ")", "i")
            }

            function ge(t) {
                return lt(t) ? 366 : 365
            }

            B("Y", 0, 0, (function () {
                var t = this.year();
                return t <= 9999 ? j(t, 4) : "+" + t
            })), B(0, ["YY", 2], 0, (function () {
                return this.year() % 100
            })), B(0, ["YYYY", 4], 0, "year"), B(0, ["YYYYY", 5], 0, "year"), B(0, ["YYYYYY", 6, !0], 0, "year"), nt("year", "y"), ot("year", 1), Ot("Y", At), Ot("YY", wt, bt), Ot("YYYY", Dt, xt), Ot("YYYYY", Tt, _t), Ot("YYYYYY", Tt, _t), Ht(["YYYYY", "YYYYYY"], Wt), Ht("YYYY", (function (t, e) {
                e[Wt] = 2 === t.length ? a.parseTwoDigitYear(t) : dt(t)
            })), Ht("YY", (function (t, e) {
                e[Wt] = a.parseTwoDigitYear(t)
            })), Ht("Y", (function (t, e) {
                e[Wt] = parseInt(t, 10)
            })), a.parseTwoDigitYear = function (t) {
                return dt(t) + (dt(t) > 68 ? 1900 : 2e3)
            };
            var me = ut("FullYear", !0);

            function ve() {
                return lt(this.year())
            }

            function be(t, e, n, a, i, r, o) {
                var s;
                return t < 100 && t >= 0 ? (s = new Date(t + 400, e, n, a, i, r, o), isFinite(s.getFullYear()) && s.setFullYear(t)) : s = new Date(t, e, n, a, i, r, o), s
            }

            function ye(t) {
                var e, n;
                return t < 100 && t >= 0 ? ((n = Array.prototype.slice.call(arguments))[0] = t + 400, e = new Date(Date.UTC.apply(null, n)), isFinite(e.getUTCFullYear()) && e.setUTCFullYear(t)) : e = new Date(Date.UTC.apply(null, arguments)), e
            }

            function xe(t, e, n) {
                var a = 7 + e - n;
                return -(7 + ye(t, 0, a).getUTCDay() - e) % 7 + a - 1
            }

            function _e(t, e, n, a, i) {
                var r, o, s = 1 + 7 * (e - 1) + (7 + n - a) % 7 + xe(t, a, i);
                return s <= 0 ? o = ge(r = t - 1) + s : s > ge(t) ? (r = t + 1, o = s - ge(t)) : (r = t, o = s), {
                    year: r,
                    dayOfYear: o
                }
            }

            function we(t, e, n) {
                var a, i, r = xe(t.year(), e, n), o = Math.floor((t.dayOfYear() - r - 1) / 7) + 1;
                return o < 1 ? a = o + Se(i = t.year() - 1, e, n) : o > Se(t.year(), e, n) ? (a = o - Se(t.year(), e, n), i = t.year() + 1) : (i = t.year(), a = o), {
                    week: a,
                    year: i
                }
            }

            function Se(t, e, n) {
                var a = xe(t, e, n), i = xe(t + 1, e, n);
                return (ge(t) - a + i) / 7
            }

            function Ce(t) {
                return we(t, this._week.dow, this._week.doy).week
            }

            B("w", ["ww", 2], "wo", "week"), B("W", ["WW", 2], "Wo", "isoWeek"), nt("week", "w"), nt("isoWeek", "W"), ot("week", 5), ot("isoWeek", 5), Ot("w", wt), Ot("ww", wt, bt), Ot("W", wt), Ot("WW", wt, bt), Bt(["w", "ww", "W", "WW"], (function (t, e, n, a) {
                e[a.substr(0, 1)] = dt(t)
            }));
            var ke = {dow: 0, doy: 6};

            function De() {
                return this._week.dow
            }

            function Te() {
                return this._week.doy
            }

            function Ee(t) {
                var e = this.localeData().week(this);
                return null == t ? e : this.add(7 * (t - e), "d")
            }

            function Ae(t) {
                var e = we(this, 1, 4).week;
                return null == t ? e : this.add(7 * (t - e), "d")
            }

            function Ie(t, e) {
                return "string" != typeof t ? t : isNaN(t) ? "number" == typeof (t = e.weekdaysParse(t)) ? t : null : parseInt(t, 10)
            }

            function Me(t, e) {
                return "string" == typeof t ? e.weekdaysParse(t) % 7 || 7 : isNaN(t) ? null : t
            }

            function Re(t, e) {
                return t.slice(e, 7).concat(t.slice(0, e))
            }

            B("d", 0, "do", "day"), B("dd", 0, 0, (function (t) {
                return this.localeData().weekdaysMin(this, t)
            })), B("ddd", 0, 0, (function (t) {
                return this.localeData().weekdaysShort(this, t)
            })), B("dddd", 0, 0, (function (t) {
                return this.localeData().weekdays(this, t)
            })), B("e", 0, 0, "weekday"), B("E", 0, 0, "isoWeekday"), nt("day", "d"), nt("weekday", "e"), nt("isoWeekday", "E"), ot("day", 11), ot("weekday", 11), ot("isoWeekday", 11), Ot("d", wt), Ot("e", wt), Ot("E", wt), Ot("dd", (function (t, e) {
                return e.weekdaysMinRegex(t)
            })), Ot("ddd", (function (t, e) {
                return e.weekdaysShortRegex(t)
            })), Ot("dddd", (function (t, e) {
                return e.weekdaysRegex(t)
            })), Bt(["dd", "ddd", "dddd"], (function (t, e, n, a) {
                var i = n._locale.weekdaysParse(t, a, n._strict);
                null != i ? e.d = i : m(n).invalidWeekday = t
            })), Bt(["d", "e", "E"], (function (t, e, n, a) {
                e[a] = dt(t)
            }));
            var Pe = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                Oe = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), je = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Ne = Pt, Le = Pt,
                Fe = Pt;

            function He(t, e) {
                var n = r(this._weekdays) ? this._weekdays : this._weekdays[t && !0 !== t && this._weekdays.isFormat.test(e) ? "format" : "standalone"];
                return !0 === t ? Re(n, this._week.dow) : t ? n[t.day()] : n
            }

            function Be(t) {
                return !0 === t ? Re(this._weekdaysShort, this._week.dow) : t ? this._weekdaysShort[t.day()] : this._weekdaysShort
            }

            function qe(t) {
                return !0 === t ? Re(this._weekdaysMin, this._week.dow) : t ? this._weekdaysMin[t.day()] : this._weekdaysMin
            }

            function ze(t, e, n) {
                var a, i, r, o = t.toLocaleLowerCase();
                if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], a = 0; a < 7; ++a) r = f([2e3, 1]).day(a), this._minWeekdaysParse[a] = this.weekdaysMin(r, "").toLocaleLowerCase(), this._shortWeekdaysParse[a] = this.weekdaysShort(r, "").toLocaleLowerCase(), this._weekdaysParse[a] = this.weekdays(r, "").toLocaleLowerCase();
                return n ? "dddd" === e ? -1 !== (i = zt.call(this._weekdaysParse, o)) ? i : null : "ddd" === e ? -1 !== (i = zt.call(this._shortWeekdaysParse, o)) ? i : null : -1 !== (i = zt.call(this._minWeekdaysParse, o)) ? i : null : "dddd" === e ? -1 !== (i = zt.call(this._weekdaysParse, o)) || -1 !== (i = zt.call(this._shortWeekdaysParse, o)) || -1 !== (i = zt.call(this._minWeekdaysParse, o)) ? i : null : "ddd" === e ? -1 !== (i = zt.call(this._shortWeekdaysParse, o)) || -1 !== (i = zt.call(this._weekdaysParse, o)) || -1 !== (i = zt.call(this._minWeekdaysParse, o)) ? i : null : -1 !== (i = zt.call(this._minWeekdaysParse, o)) || -1 !== (i = zt.call(this._weekdaysParse, o)) || -1 !== (i = zt.call(this._shortWeekdaysParse, o)) ? i : null
            }

            function We(t, e, n) {
                var a, i, r;
                if (this._weekdaysParseExact) return ze.call(this, t, e, n);
                for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), a = 0; a < 7; a++) {
                    if (i = f([2e3, 1]).day(a), n && !this._fullWeekdaysParse[a] && (this._fullWeekdaysParse[a] = new RegExp("^" + this.weekdays(i, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[a] = new RegExp("^" + this.weekdaysShort(i, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[a] = new RegExp("^" + this.weekdaysMin(i, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[a] || (r = "^" + this.weekdays(i, "") + "|^" + this.weekdaysShort(i, "") + "|^" + this.weekdaysMin(i, ""), this._weekdaysParse[a] = new RegExp(r.replace(".", ""), "i")), n && "dddd" === e && this._fullWeekdaysParse[a].test(t)) return a;
                    if (n && "ddd" === e && this._shortWeekdaysParse[a].test(t)) return a;
                    if (n && "dd" === e && this._minWeekdaysParse[a].test(t)) return a;
                    if (!n && this._weekdaysParse[a].test(t)) return a
                }
            }

            function Ve(t) {
                if (!this.isValid()) return null != t ? this : NaN;
                var e = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                return null != t ? (t = Ie(t, this.localeData()), this.add(t - e, "d")) : e
            }

            function $e(t) {
                if (!this.isValid()) return null != t ? this : NaN;
                var e = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return null == t ? e : this.add(t - e, "d")
            }

            function Ye(t) {
                if (!this.isValid()) return null != t ? this : NaN;
                if (null != t) {
                    var e = Me(t, this.localeData());
                    return this.day(this.day() % 7 ? e : e - 7)
                }
                return this.day() || 7
            }

            function Ue(t) {
                return this._weekdaysParseExact ? (s(this, "_weekdaysRegex") || Ze.call(this), t ? this._weekdaysStrictRegex : this._weekdaysRegex) : (s(this, "_weekdaysRegex") || (this._weekdaysRegex = Ne), this._weekdaysStrictRegex && t ? this._weekdaysStrictRegex : this._weekdaysRegex)
            }

            function Ge(t) {
                return this._weekdaysParseExact ? (s(this, "_weekdaysRegex") || Ze.call(this), t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (s(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Le), this._weekdaysShortStrictRegex && t ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
            }

            function Xe(t) {
                return this._weekdaysParseExact ? (s(this, "_weekdaysRegex") || Ze.call(this), t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (s(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = Fe), this._weekdaysMinStrictRegex && t ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
            }

            function Ze() {
                function t(t, e) {
                    return e.length - t.length
                }

                var e, n, a, i, r, o = [], s = [], l = [], c = [];
                for (e = 0; e < 7; e++) n = f([2e3, 1]).day(e), a = Lt(this.weekdaysMin(n, "")), i = Lt(this.weekdaysShort(n, "")), r = Lt(this.weekdays(n, "")), o.push(a), s.push(i), l.push(r), c.push(a), c.push(i), c.push(r);
                o.sort(t), s.sort(t), l.sort(t), c.sort(t), this._weekdaysRegex = new RegExp("^(" + c.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + l.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + s.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + o.join("|") + ")", "i")
            }

            function Ke() {
                return this.hours() % 12 || 12
            }

            function Qe() {
                return this.hours() || 24
            }

            function Je(t, e) {
                B(t, 0, 0, (function () {
                    return this.localeData().meridiem(this.hours(), this.minutes(), e)
                }))
            }

            function tn(t, e) {
                return e._meridiemParse
            }

            function en(t) {
                return "p" === (t + "").toLowerCase().charAt(0)
            }

            B("H", ["HH", 2], 0, "hour"), B("h", ["hh", 2], 0, Ke), B("k", ["kk", 2], 0, Qe), B("hmm", 0, 0, (function () {
                return "" + Ke.apply(this) + j(this.minutes(), 2)
            })), B("hmmss", 0, 0, (function () {
                return "" + Ke.apply(this) + j(this.minutes(), 2) + j(this.seconds(), 2)
            })), B("Hmm", 0, 0, (function () {
                return "" + this.hours() + j(this.minutes(), 2)
            })), B("Hmmss", 0, 0, (function () {
                return "" + this.hours() + j(this.minutes(), 2) + j(this.seconds(), 2)
            })), Je("a", !0), Je("A", !1), nt("hour", "h"), ot("hour", 13), Ot("a", tn), Ot("A", tn), Ot("H", wt), Ot("h", wt), Ot("k", wt), Ot("HH", wt, bt), Ot("hh", wt, bt), Ot("kk", wt, bt), Ot("hmm", St), Ot("hmmss", Ct), Ot("Hmm", St), Ot("Hmmss", Ct), Ht(["H", "HH"], Yt), Ht(["k", "kk"], (function (t, e, n) {
                var a = dt(t);
                e[Yt] = 24 === a ? 0 : a
            })), Ht(["a", "A"], (function (t, e, n) {
                n._isPm = n._locale.isPM(t), n._meridiem = t
            })), Ht(["h", "hh"], (function (t, e, n) {
                e[Yt] = dt(t), m(n).bigHour = !0
            })), Ht("hmm", (function (t, e, n) {
                var a = t.length - 2;
                e[Yt] = dt(t.substr(0, a)), e[Ut] = dt(t.substr(a)), m(n).bigHour = !0
            })), Ht("hmmss", (function (t, e, n) {
                var a = t.length - 4, i = t.length - 2;
                e[Yt] = dt(t.substr(0, a)), e[Ut] = dt(t.substr(a, 2)), e[Gt] = dt(t.substr(i)), m(n).bigHour = !0
            })), Ht("Hmm", (function (t, e, n) {
                var a = t.length - 2;
                e[Yt] = dt(t.substr(0, a)), e[Ut] = dt(t.substr(a))
            })), Ht("Hmmss", (function (t, e, n) {
                var a = t.length - 4, i = t.length - 2;
                e[Yt] = dt(t.substr(0, a)), e[Ut] = dt(t.substr(a, 2)), e[Gt] = dt(t.substr(i))
            }));
            var nn = /[ap]\.?m?\.?/i, an = ut("Hours", !0);

            function rn(t, e, n) {
                return t > 11 ? n ? "pm" : "PM" : n ? "am" : "AM"
            }

            var on, sn = {
                calendar: P,
                longDateFormat: $,
                invalidDate: U,
                ordinal: X,
                dayOfMonthOrdinalParse: Z,
                relativeTime: Q,
                months: te,
                monthsShort: ee,
                week: ke,
                weekdays: Pe,
                weekdaysMin: je,
                weekdaysShort: Oe,
                meridiemParse: nn
            }, ln = {}, cn = {};

            function dn(t, e) {
                var n, a = Math.min(t.length, e.length);
                for (n = 0; n < a; n += 1) if (t[n] !== e[n]) return n;
                return a
            }

            function un(t) {
                return t ? t.toLowerCase().replace("_", "-") : t
            }

            function hn(t) {
                for (var e, n, a, i, r = 0; r < t.length;) {
                    for (e = (i = un(t[r]).split("-")).length, n = (n = un(t[r + 1])) ? n.split("-") : null; e > 0;) {
                        if (a = pn(i.slice(0, e).join("-"))) return a;
                        if (n && n.length >= e && dn(i, n) >= e - 1) break;
                        e--
                    }
                    r++
                }
                return on
            }

            function pn(e) {
                var n = null;
                if (void 0 === ln[e] && void 0 !== t && t && t.exports) try {
                    n = on._abbr, function () {
                        var t = new Error("Cannot find module 'undefined'");
                        throw t.code = "MODULE_NOT_FOUND", t
                    }(), fn(n)
                } catch (t) {
                    ln[e] = null
                }
                return ln[e]
            }

            function fn(t, e) {
                var n;
                return t && ((n = c(e) ? vn(t) : gn(t, e)) ? on = n : "undefined" != typeof console && console.warn && console.warn("Locale " + t + " not found. Did you forget to load it?")), on._abbr
            }

            function gn(t, e) {
                if (null !== e) {
                    var n, a = sn;
                    if (e.abbr = t, null != ln[t]) E("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), a = ln[t]._config; else if (null != e.parentLocale) if (null != ln[e.parentLocale]) a = ln[e.parentLocale]._config; else {
                        if (null == (n = pn(e.parentLocale))) return cn[e.parentLocale] || (cn[e.parentLocale] = []), cn[e.parentLocale].push({
                            name: t,
                            config: e
                        }), null;
                        a = n._config
                    }
                    return ln[t] = new R(M(a, e)), cn[t] && cn[t].forEach((function (t) {
                        gn(t.name, t.config)
                    })), fn(t), ln[t]
                }
                return delete ln[t], null
            }

            function mn(t, e) {
                if (null != e) {
                    var n, a, i = sn;
                    null != ln[t] && null != ln[t].parentLocale ? ln[t].set(M(ln[t]._config, e)) : (null != (a = pn(t)) && (i = a._config), e = M(i, e), null == a && (e.abbr = t), (n = new R(e)).parentLocale = ln[t], ln[t] = n), fn(t)
                } else null != ln[t] && (null != ln[t].parentLocale ? (ln[t] = ln[t].parentLocale, t === fn() && fn(t)) : null != ln[t] && delete ln[t]);
                return ln[t]
            }

            function vn(t) {
                var e;
                if (t && t._locale && t._locale._abbr && (t = t._locale._abbr), !t) return on;
                if (!r(t)) {
                    if (e = pn(t)) return e;
                    t = [t]
                }
                return hn(t)
            }

            function bn() {
                return D(ln)
            }

            function yn(t) {
                var e, n = t._a;
                return n && -2 === m(t).overflow && (e = n[Vt] < 0 || n[Vt] > 11 ? Vt : n[$t] < 1 || n[$t] > Jt(n[Wt], n[Vt]) ? $t : n[Yt] < 0 || n[Yt] > 24 || 24 === n[Yt] && (0 !== n[Ut] || 0 !== n[Gt] || 0 !== n[Xt]) ? Yt : n[Ut] < 0 || n[Ut] > 59 ? Ut : n[Gt] < 0 || n[Gt] > 59 ? Gt : n[Xt] < 0 || n[Xt] > 999 ? Xt : -1, m(t)._overflowDayOfYear && (e < Wt || e > $t) && (e = $t), m(t)._overflowWeeks && -1 === e && (e = Zt), m(t)._overflowWeekday && -1 === e && (e = Kt), m(t).overflow = e), t
            }

            var xn = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                _n = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                wn = /Z|[+-]\d\d(?::?\d\d)?/,
                Sn = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, !1], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, !1], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, !1], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, !1], ["YYYY", /\d{4}/, !1]],
                Cn = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]],
                kn = /^\/?Date\((-?\d+)/i,
                Dn = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
                Tn = {
                    UT: 0,
                    GMT: 0,
                    EDT: -240,
                    EST: -300,
                    CDT: -300,
                    CST: -360,
                    MDT: -360,
                    MST: -420,
                    PDT: -420,
                    PST: -480
                };

            function En(t) {
                var e, n, a, i, r, o, s = t._i, l = xn.exec(s) || _n.exec(s);
                if (l) {
                    for (m(t).iso = !0, e = 0, n = Sn.length; e < n; e++) if (Sn[e][1].exec(l[1])) {
                        i = Sn[e][0], a = !1 !== Sn[e][2];
                        break
                    }
                    if (null == i) return void (t._isValid = !1);
                    if (l[3]) {
                        for (e = 0, n = Cn.length; e < n; e++) if (Cn[e][1].exec(l[3])) {
                            r = (l[2] || " ") + Cn[e][0];
                            break
                        }
                        if (null == r) return void (t._isValid = !1)
                    }
                    if (!a && null != r) return void (t._isValid = !1);
                    if (l[4]) {
                        if (!wn.exec(l[4])) return void (t._isValid = !1);
                        o = "Z"
                    }
                    t._f = i + (r || "") + (o || ""), Bn(t)
                } else t._isValid = !1
            }

            function An(t, e, n, a, i, r) {
                var o = [In(t), ee.indexOf(e), parseInt(n, 10), parseInt(a, 10), parseInt(i, 10)];
                return r && o.push(parseInt(r, 10)), o
            }

            function In(t) {
                var e = parseInt(t, 10);
                return e <= 49 ? 2e3 + e : e <= 999 ? 1900 + e : e
            }

            function Mn(t) {
                return t.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
            }

            function Rn(t, e, n) {
                return !t || Oe.indexOf(t) === new Date(e[0], e[1], e[2]).getDay() || (m(n).weekdayMismatch = !0, n._isValid = !1, !1)
            }

            function Pn(t, e, n) {
                if (t) return Tn[t];
                if (e) return 0;
                var a = parseInt(n, 10), i = a % 100;
                return (a - i) / 100 * 60 + i
            }

            function On(t) {
                var e, n = Dn.exec(Mn(t._i));
                if (n) {
                    if (e = An(n[4], n[3], n[2], n[5], n[6], n[7]), !Rn(n[1], e, t)) return;
                    t._a = e, t._tzm = Pn(n[8], n[9], n[10]), t._d = ye.apply(null, t._a), t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), m(t).rfc2822 = !0
                } else t._isValid = !1
            }

            function jn(t) {
                var e = kn.exec(t._i);
                null === e ? (En(t), !1 === t._isValid && (delete t._isValid, On(t), !1 === t._isValid && (delete t._isValid, t._strict ? t._isValid = !1 : a.createFromInputFallback(t)))) : t._d = new Date(+e[1])
            }

            function Nn(t, e, n) {
                return null != t ? t : null != e ? e : n
            }

            function Ln(t) {
                var e = new Date(a.now());
                return t._useUTC ? [e.getUTCFullYear(), e.getUTCMonth(), e.getUTCDate()] : [e.getFullYear(), e.getMonth(), e.getDate()]
            }

            function Fn(t) {
                var e, n, a, i, r, o = [];
                if (!t._d) {
                    for (a = Ln(t), t._w && null == t._a[$t] && null == t._a[Vt] && Hn(t), null != t._dayOfYear && (r = Nn(t._a[Wt], a[Wt]), (t._dayOfYear > ge(r) || 0 === t._dayOfYear) && (m(t)._overflowDayOfYear = !0), n = ye(r, 0, t._dayOfYear), t._a[Vt] = n.getUTCMonth(), t._a[$t] = n.getUTCDate()), e = 0; e < 3 && null == t._a[e]; ++e) t._a[e] = o[e] = a[e];
                    for (; e < 7; e++) t._a[e] = o[e] = null == t._a[e] ? 2 === e ? 1 : 0 : t._a[e];
                    24 === t._a[Yt] && 0 === t._a[Ut] && 0 === t._a[Gt] && 0 === t._a[Xt] && (t._nextDay = !0, t._a[Yt] = 0), t._d = (t._useUTC ? ye : be).apply(null, o), i = t._useUTC ? t._d.getUTCDay() : t._d.getDay(), null != t._tzm && t._d.setUTCMinutes(t._d.getUTCMinutes() - t._tzm), t._nextDay && (t._a[Yt] = 24), t._w && void 0 !== t._w.d && t._w.d !== i && (m(t).weekdayMismatch = !0)
                }
            }

            function Hn(t) {
                var e, n, a, i, r, o, s, l, c;
                null != (e = t._w).GG || null != e.W || null != e.E ? (r = 1, o = 4, n = Nn(e.GG, t._a[Wt], we(Gn(), 1, 4).year), a = Nn(e.W, 1), ((i = Nn(e.E, 1)) < 1 || i > 7) && (l = !0)) : (r = t._locale._week.dow, o = t._locale._week.doy, c = we(Gn(), r, o), n = Nn(e.gg, t._a[Wt], c.year), a = Nn(e.w, c.week), null != e.d ? ((i = e.d) < 0 || i > 6) && (l = !0) : null != e.e ? (i = e.e + r, (e.e < 0 || e.e > 6) && (l = !0)) : i = r), a < 1 || a > Se(n, r, o) ? m(t)._overflowWeeks = !0 : null != l ? m(t)._overflowWeekday = !0 : (s = _e(n, a, i, r, o), t._a[Wt] = s.year, t._dayOfYear = s.dayOfYear)
            }

            function Bn(t) {
                if (t._f !== a.ISO_8601) if (t._f !== a.RFC_2822) {
                    t._a = [], m(t).empty = !0;
                    var e, n, i, r, o, s, l = "" + t._i, c = l.length, d = 0;
                    for (i = V(t._f, t._locale).match(N) || [], e = 0; e < i.length; e++) r = i[e], (n = (l.match(jt(r, t)) || [])[0]) && ((o = l.substr(0, l.indexOf(n))).length > 0 && m(t).unusedInput.push(o), l = l.slice(l.indexOf(n) + n.length), d += n.length), H[r] ? (n ? m(t).empty = !1 : m(t).unusedTokens.push(r), qt(r, n, t)) : t._strict && !n && m(t).unusedTokens.push(r);
                    m(t).charsLeftOver = c - d, l.length > 0 && m(t).unusedInput.push(l), t._a[Yt] <= 12 && !0 === m(t).bigHour && t._a[Yt] > 0 && (m(t).bigHour = void 0), m(t).parsedDateParts = t._a.slice(0), m(t).meridiem = t._meridiem, t._a[Yt] = qn(t._locale, t._a[Yt], t._meridiem), null !== (s = m(t).era) && (t._a[Wt] = t._locale.erasConvertYear(s, t._a[Wt])), Fn(t), yn(t)
                } else On(t); else En(t)
            }

            function qn(t, e, n) {
                var a;
                return null == n ? e : null != t.meridiemHour ? t.meridiemHour(e, n) : null != t.isPM ? ((a = t.isPM(n)) && e < 12 && (e += 12), a || 12 !== e || (e = 0), e) : e
            }

            function zn(t) {
                var e, n, a, i, r, o, s = !1;
                if (0 === t._f.length) return m(t).invalidFormat = !0, void (t._d = new Date(NaN));
                for (i = 0; i < t._f.length; i++) r = 0, o = !1, e = _({}, t), null != t._useUTC && (e._useUTC = t._useUTC), e._f = t._f[i], Bn(e), v(e) && (o = !0), r += m(e).charsLeftOver, r += 10 * m(e).unusedTokens.length, m(e).score = r, s ? r < a && (a = r, n = e) : (null == a || r < a || o) && (a = r, n = e, o && (s = !0));
                p(t, n || e)
            }

            function Wn(t) {
                if (!t._d) {
                    var e = it(t._i), n = void 0 === e.day ? e.date : e.day;
                    t._a = h([e.year, e.month, n, e.hour, e.minute, e.second, e.millisecond], (function (t) {
                        return t && parseInt(t, 10)
                    })), Fn(t)
                }
            }

            function Vn(t) {
                var e = new w(yn($n(t)));
                return e._nextDay && (e.add(1, "d"), e._nextDay = void 0), e
            }

            function $n(t) {
                var e = t._i, n = t._f;
                return t._locale = t._locale || vn(t._l), null === e || void 0 === n && "" === e ? b({nullInput: !0}) : ("string" == typeof e && (t._i = e = t._locale.preparse(e)), S(e) ? new w(yn(e)) : (u(e) ? t._d = e : r(n) ? zn(t) : n ? Bn(t) : Yn(t), v(t) || (t._d = null), t))
            }

            function Yn(t) {
                var e = t._i;
                c(e) ? t._d = new Date(a.now()) : u(e) ? t._d = new Date(e.valueOf()) : "string" == typeof e ? jn(t) : r(e) ? (t._a = h(e.slice(0), (function (t) {
                    return parseInt(t, 10)
                })), Fn(t)) : o(e) ? Wn(t) : d(e) ? t._d = new Date(e) : a.createFromInputFallback(t)
            }

            function Un(t, e, n, a, i) {
                var s = {};
                return !0 !== e && !1 !== e || (a = e, e = void 0), !0 !== n && !1 !== n || (a = n, n = void 0), (o(t) && l(t) || r(t) && 0 === t.length) && (t = void 0), s._isAMomentObject = !0, s._useUTC = s._isUTC = i, s._l = n, s._i = t, s._f = e, s._strict = a, Vn(s)
            }

            function Gn(t, e, n, a) {
                return Un(t, e, n, a, !1)
            }

            a.createFromInputFallback = k("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function (t) {
                t._d = new Date(t._i + (t._useUTC ? " UTC" : ""))
            })), a.ISO_8601 = function () {
            }, a.RFC_2822 = function () {
            };
            var Xn = k("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
                    var t = Gn.apply(null, arguments);
                    return this.isValid() && t.isValid() ? t < this ? this : t : b()
                })),
                Zn = k("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function () {
                    var t = Gn.apply(null, arguments);
                    return this.isValid() && t.isValid() ? t > this ? this : t : b()
                }));

            function Kn(t, e) {
                var n, a;
                if (1 === e.length && r(e[0]) && (e = e[0]), !e.length) return Gn();
                for (n = e[0], a = 1; a < e.length; ++a) e[a].isValid() && !e[a][t](n) || (n = e[a]);
                return n
            }

            function Qn() {
                return Kn("isBefore", [].slice.call(arguments, 0))
            }

            function Jn() {
                return Kn("isAfter", [].slice.call(arguments, 0))
            }

            var ta = function () {
                return Date.now ? Date.now() : +new Date
            }, ea = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

            function na(t) {
                var e, n, a = !1;
                for (e in t) if (s(t, e) && (-1 === zt.call(ea, e) || null != t[e] && isNaN(t[e]))) return !1;
                for (n = 0; n < ea.length; ++n) if (t[ea[n]]) {
                    if (a) return !1;
                    parseFloat(t[ea[n]]) !== dt(t[ea[n]]) && (a = !0)
                }
                return !0
            }

            function aa() {
                return this._isValid
            }

            function ia() {
                return Ta(NaN)
            }

            function ra(t) {
                var e = it(t), n = e.year || 0, a = e.quarter || 0, i = e.month || 0, r = e.week || e.isoWeek || 0,
                    o = e.day || 0, s = e.hour || 0, l = e.minute || 0, c = e.second || 0, d = e.millisecond || 0;
                this._isValid = na(e), this._milliseconds = +d + 1e3 * c + 6e4 * l + 1e3 * s * 60 * 60, this._days = +o + 7 * r, this._months = +i + 3 * a + 12 * n, this._data = {}, this._locale = vn(), this._bubble()
            }

            function oa(t) {
                return t instanceof ra
            }

            function sa(t) {
                return t < 0 ? -1 * Math.round(-1 * t) : Math.round(t)
            }

            function la(t, e, n) {
                var a, i = Math.min(t.length, e.length), r = Math.abs(t.length - e.length), o = 0;
                for (a = 0; a < i; a++) (n && t[a] !== e[a] || !n && dt(t[a]) !== dt(e[a])) && o++;
                return o + r
            }

            function ca(t, e) {
                B(t, 0, 0, (function () {
                    var t = this.utcOffset(), n = "+";
                    return t < 0 && (t = -t, n = "-"), n + j(~~(t / 60), 2) + e + j(~~t % 60, 2)
                }))
            }

            ca("Z", ":"), ca("ZZ", ""), Ot("Z", Mt), Ot("ZZ", Mt), Ht(["Z", "ZZ"], (function (t, e, n) {
                n._useUTC = !0, n._tzm = ua(Mt, t)
            }));
            var da = /([\+\-]|\d\d)/gi;

            function ua(t, e) {
                var n, a, i = (e || "").match(t);
                return null === i ? null : 0 === (a = 60 * (n = ((i[i.length - 1] || []) + "").match(da) || ["-", 0, 0])[1] + dt(n[2])) ? 0 : "+" === n[0] ? a : -a
            }

            function ha(t, e) {
                var n, i;
                return e._isUTC ? (n = e.clone(), i = (S(t) || u(t) ? t.valueOf() : Gn(t).valueOf()) - n.valueOf(), n._d.setTime(n._d.valueOf() + i), a.updateOffset(n, !1), n) : Gn(t).local()
            }

            function pa(t) {
                return -Math.round(t._d.getTimezoneOffset())
            }

            function fa(t, e, n) {
                var i, r = this._offset || 0;
                if (!this.isValid()) return null != t ? this : NaN;
                if (null != t) {
                    if ("string" == typeof t) {
                        if (null === (t = ua(Mt, t))) return this
                    } else Math.abs(t) < 16 && !n && (t *= 60);
                    return !this._isUTC && e && (i = pa(this)), this._offset = t, this._isUTC = !0, null != i && this.add(i, "m"), r !== t && (!e || this._changeInProgress ? Ra(this, Ta(t - r, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, a.updateOffset(this, !0), this._changeInProgress = null)), this
                }
                return this._isUTC ? r : pa(this)
            }

            function ga(t, e) {
                return null != t ? ("string" != typeof t && (t = -t), this.utcOffset(t, e), this) : -this.utcOffset()
            }

            function ma(t) {
                return this.utcOffset(0, t)
            }

            function va(t) {
                return this._isUTC && (this.utcOffset(0, t), this._isUTC = !1, t && this.subtract(pa(this), "m")), this
            }

            function ba() {
                if (null != this._tzm) this.utcOffset(this._tzm, !1, !0); else if ("string" == typeof this._i) {
                    var t = ua(It, this._i);
                    null != t ? this.utcOffset(t) : this.utcOffset(0, !0)
                }
                return this
            }

            function ya(t) {
                return !!this.isValid() && (t = t ? Gn(t).utcOffset() : 0, (this.utcOffset() - t) % 60 == 0)
            }

            function xa() {
                return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
            }

            function _a() {
                if (!c(this._isDSTShifted)) return this._isDSTShifted;
                var t, e = {};
                return _(e, this), (e = $n(e))._a ? (t = e._isUTC ? f(e._a) : Gn(e._a), this._isDSTShifted = this.isValid() && la(e._a, t.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted
            }

            function wa() {
                return !!this.isValid() && !this._isUTC
            }

            function Sa() {
                return !!this.isValid() && this._isUTC
            }

            function Ca() {
                return !!this.isValid() && this._isUTC && 0 === this._offset
            }

            a.updateOffset = function () {
            };
            var ka = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
                Da = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

            function Ta(t, e) {
                var n, a, i, r = t, o = null;
                return oa(t) ? r = {
                    ms: t._milliseconds,
                    d: t._days,
                    M: t._months
                } : d(t) || !isNaN(+t) ? (r = {}, e ? r[e] = +t : r.milliseconds = +t) : (o = ka.exec(t)) ? (n = "-" === o[1] ? -1 : 1, r = {
                    y: 0,
                    d: dt(o[$t]) * n,
                    h: dt(o[Yt]) * n,
                    m: dt(o[Ut]) * n,
                    s: dt(o[Gt]) * n,
                    ms: dt(sa(1e3 * o[Xt])) * n
                }) : (o = Da.exec(t)) ? (n = "-" === o[1] ? -1 : 1, r = {
                    y: Ea(o[2], n),
                    M: Ea(o[3], n),
                    w: Ea(o[4], n),
                    d: Ea(o[5], n),
                    h: Ea(o[6], n),
                    m: Ea(o[7], n),
                    s: Ea(o[8], n)
                }) : null == r ? r = {} : "object" == typeof r && ("from" in r || "to" in r) && (i = Ia(Gn(r.from), Gn(r.to)), (r = {}).ms = i.milliseconds, r.M = i.months), a = new ra(r), oa(t) && s(t, "_locale") && (a._locale = t._locale), oa(t) && s(t, "_isValid") && (a._isValid = t._isValid), a
            }

            function Ea(t, e) {
                var n = t && parseFloat(t.replace(",", "."));
                return (isNaN(n) ? 0 : n) * e
            }

            function Aa(t, e) {
                var n = {};
                return n.months = e.month() - t.month() + 12 * (e.year() - t.year()), t.clone().add(n.months, "M").isAfter(e) && --n.months, n.milliseconds = +e - +t.clone().add(n.months, "M"), n
            }

            function Ia(t, e) {
                var n;
                return t.isValid() && e.isValid() ? (e = ha(e, t), t.isBefore(e) ? n = Aa(t, e) : ((n = Aa(e, t)).milliseconds = -n.milliseconds, n.months = -n.months), n) : {
                    milliseconds: 0,
                    months: 0
                }
            }

            function Ma(t, e) {
                return function (n, a) {
                    var i;
                    return null === a || isNaN(+a) || (E(e, "moment()." + e + "(period, number) is deprecated. Please use moment()." + e + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), i = n, n = a, a = i), Ra(this, Ta(n, a), t), this
                }
            }

            function Ra(t, e, n, i) {
                var r = e._milliseconds, o = sa(e._days), s = sa(e._months);
                t.isValid() && (i = null == i || i, s && ce(t, ht(t, "Month") + s * n), o && pt(t, "Date", ht(t, "Date") + o * n), r && t._d.setTime(t._d.valueOf() + r * n), i && a.updateOffset(t, o || s))
            }

            Ta.fn = ra.prototype, Ta.invalid = ia;
            var Pa = Ma(1, "add"), Oa = Ma(-1, "subtract");

            function ja(t) {
                return "string" == typeof t || t instanceof String
            }

            function Na(t) {
                return S(t) || u(t) || ja(t) || d(t) || Fa(t) || La(t) || null == t
            }

            function La(t) {
                var e, n, a = o(t) && !l(t), i = !1,
                    r = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"];
                for (e = 0; e < r.length; e += 1) n = r[e], i = i || s(t, n);
                return a && i
            }

            function Fa(t) {
                var e = r(t), n = !1;
                return e && (n = 0 === t.filter((function (e) {
                    return !d(e) && ja(t)
                })).length), e && n
            }

            function Ha(t) {
                var e, n, a = o(t) && !l(t), i = !1,
                    r = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
                for (e = 0; e < r.length; e += 1) n = r[e], i = i || s(t, n);
                return a && i
            }

            function Ba(t, e) {
                var n = t.diff(e, "days", !0);
                return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse"
            }

            function qa(t, e) {
                1 === arguments.length && (arguments[0] ? Na(arguments[0]) ? (t = arguments[0], e = void 0) : Ha(arguments[0]) && (e = arguments[0], t = void 0) : (t = void 0, e = void 0));
                var n = t || Gn(), i = ha(n, this).startOf("day"), r = a.calendarFormat(this, i) || "sameElse",
                    o = e && (A(e[r]) ? e[r].call(this, n) : e[r]);
                return this.format(o || this.localeData().calendar(r, this, Gn(n)))
            }

            function za() {
                return new w(this)
            }

            function Wa(t, e) {
                var n = S(t) ? t : Gn(t);
                return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = at(e) || "millisecond") ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(e).valueOf())
            }

            function Va(t, e) {
                var n = S(t) ? t : Gn(t);
                return !(!this.isValid() || !n.isValid()) && ("millisecond" === (e = at(e) || "millisecond") ? this.valueOf() < n.valueOf() : this.clone().endOf(e).valueOf() < n.valueOf())
            }

            function $a(t, e, n, a) {
                var i = S(t) ? t : Gn(t), r = S(e) ? e : Gn(e);
                return !!(this.isValid() && i.isValid() && r.isValid()) && ("(" === (a = a || "()")[0] ? this.isAfter(i, n) : !this.isBefore(i, n)) && (")" === a[1] ? this.isBefore(r, n) : !this.isAfter(r, n))
            }

            function Ya(t, e) {
                var n, a = S(t) ? t : Gn(t);
                return !(!this.isValid() || !a.isValid()) && ("millisecond" === (e = at(e) || "millisecond") ? this.valueOf() === a.valueOf() : (n = a.valueOf(), this.clone().startOf(e).valueOf() <= n && n <= this.clone().endOf(e).valueOf()))
            }

            function Ua(t, e) {
                return this.isSame(t, e) || this.isAfter(t, e)
            }

            function Ga(t, e) {
                return this.isSame(t, e) || this.isBefore(t, e)
            }

            function Xa(t, e, n) {
                var a, i, r;
                if (!this.isValid()) return NaN;
                if (!(a = ha(t, this)).isValid()) return NaN;
                switch (i = 6e4 * (a.utcOffset() - this.utcOffset()), e = at(e)) {
                    case"year":
                        r = Za(this, a) / 12;
                        break;
                    case"month":
                        r = Za(this, a);
                        break;
                    case"quarter":
                        r = Za(this, a) / 3;
                        break;
                    case"second":
                        r = (this - a) / 1e3;
                        break;
                    case"minute":
                        r = (this - a) / 6e4;
                        break;
                    case"hour":
                        r = (this - a) / 36e5;
                        break;
                    case"day":
                        r = (this - a - i) / 864e5;
                        break;
                    case"week":
                        r = (this - a - i) / 6048e5;
                        break;
                    default:
                        r = this - a
                }
                return n ? r : ct(r)
            }

            function Za(t, e) {
                if (t.date() < e.date()) return -Za(e, t);
                var n = 12 * (e.year() - t.year()) + (e.month() - t.month()), a = t.clone().add(n, "months");
                return -(n + (e - a < 0 ? (e - a) / (a - t.clone().add(n - 1, "months")) : (e - a) / (t.clone().add(n + 1, "months") - a))) || 0
            }

            function Ka() {
                return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
            }

            function Qa(t) {
                if (!this.isValid()) return null;
                var e = !0 !== t, n = e ? this.clone().utc() : this;
                return n.year() < 0 || n.year() > 9999 ? W(n, e ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : A(Date.prototype.toISOString) ? e ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", W(n, "Z")) : W(n, e ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
            }

            function Ja() {
                if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
                var t, e, n, a, i = "moment", r = "";
                return this.isLocal() || (i = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", r = "Z"), t = "[" + i + '("]', e = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", n = "-MM-DD[T]HH:mm:ss.SSS", a = r + '[")]', this.format(t + e + n + a)
            }

            function ti(t) {
                t || (t = this.isUtc() ? a.defaultFormatUtc : a.defaultFormat);
                var e = W(this, t);
                return this.localeData().postformat(e)
            }

            function ei(t, e) {
                return this.isValid() && (S(t) && t.isValid() || Gn(t).isValid()) ? Ta({
                    to: this,
                    from: t
                }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
            }

            function ni(t) {
                return this.from(Gn(), t)
            }

            function ai(t, e) {
                return this.isValid() && (S(t) && t.isValid() || Gn(t).isValid()) ? Ta({
                    from: this,
                    to: t
                }).locale(this.locale()).humanize(!e) : this.localeData().invalidDate()
            }

            function ii(t) {
                return this.to(Gn(), t)
            }

            function ri(t) {
                var e;
                return void 0 === t ? this._locale._abbr : (null != (e = vn(t)) && (this._locale = e), this)
            }

            a.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", a.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
            var oi = k("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function (t) {
                return void 0 === t ? this.localeData() : this.locale(t)
            }));

            function si() {
                return this._locale
            }

            var li = 1e3, ci = 60 * li, di = 60 * ci, ui = 3506328 * di;

            function hi(t, e) {
                return (t % e + e) % e
            }

            function pi(t, e, n) {
                return t < 100 && t >= 0 ? new Date(t + 400, e, n) - ui : new Date(t, e, n).valueOf()
            }

            function fi(t, e, n) {
                return t < 100 && t >= 0 ? Date.UTC(t + 400, e, n) - ui : Date.UTC(t, e, n)
            }

            function gi(t) {
                var e, n;
                if (void 0 === (t = at(t)) || "millisecond" === t || !this.isValid()) return this;
                switch (n = this._isUTC ? fi : pi, t) {
                    case"year":
                        e = n(this.year(), 0, 1);
                        break;
                    case"quarter":
                        e = n(this.year(), this.month() - this.month() % 3, 1);
                        break;
                    case"month":
                        e = n(this.year(), this.month(), 1);
                        break;
                    case"week":
                        e = n(this.year(), this.month(), this.date() - this.weekday());
                        break;
                    case"isoWeek":
                        e = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                        break;
                    case"day":
                    case"date":
                        e = n(this.year(), this.month(), this.date());
                        break;
                    case"hour":
                        e = this._d.valueOf(), e -= hi(e + (this._isUTC ? 0 : this.utcOffset() * ci), di);
                        break;
                    case"minute":
                        e = this._d.valueOf(), e -= hi(e, ci);
                        break;
                    case"second":
                        e = this._d.valueOf(), e -= hi(e, li)
                }
                return this._d.setTime(e), a.updateOffset(this, !0), this
            }

            function mi(t) {
                var e, n;
                if (void 0 === (t = at(t)) || "millisecond" === t || !this.isValid()) return this;
                switch (n = this._isUTC ? fi : pi, t) {
                    case"year":
                        e = n(this.year() + 1, 0, 1) - 1;
                        break;
                    case"quarter":
                        e = n(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                        break;
                    case"month":
                        e = n(this.year(), this.month() + 1, 1) - 1;
                        break;
                    case"week":
                        e = n(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                        break;
                    case"isoWeek":
                        e = n(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                        break;
                    case"day":
                    case"date":
                        e = n(this.year(), this.month(), this.date() + 1) - 1;
                        break;
                    case"hour":
                        e = this._d.valueOf(), e += di - hi(e + (this._isUTC ? 0 : this.utcOffset() * ci), di) - 1;
                        break;
                    case"minute":
                        e = this._d.valueOf(), e += ci - hi(e, ci) - 1;
                        break;
                    case"second":
                        e = this._d.valueOf(), e += li - hi(e, li) - 1
                }
                return this._d.setTime(e), a.updateOffset(this, !0), this
            }

            function vi() {
                return this._d.valueOf() - 6e4 * (this._offset || 0)
            }

            function bi() {
                return Math.floor(this.valueOf() / 1e3)
            }

            function yi() {
                return new Date(this.valueOf())
            }

            function xi() {
                var t = this;
                return [t.year(), t.month(), t.date(), t.hour(), t.minute(), t.second(), t.millisecond()]
            }

            function _i() {
                var t = this;
                return {
                    years: t.year(),
                    months: t.month(),
                    date: t.date(),
                    hours: t.hours(),
                    minutes: t.minutes(),
                    seconds: t.seconds(),
                    milliseconds: t.milliseconds()
                }
            }

            function wi() {
                return this.isValid() ? this.toISOString() : null
            }

            function Si() {
                return v(this)
            }

            function Ci() {
                return p({}, m(this))
            }

            function ki() {
                return m(this).overflow
            }

            function Di() {
                return {input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict}
            }

            function Ti(t, e) {
                var n, i, r, o = this._eras || vn("en")._eras;
                for (n = 0, i = o.length; n < i; ++n) {
                    switch (typeof o[n].since) {
                        case"string":
                            r = a(o[n].since).startOf("day"), o[n].since = r.valueOf()
                    }
                    switch (typeof o[n].until) {
                        case"undefined":
                            o[n].until = 1 / 0;
                            break;
                        case"string":
                            r = a(o[n].until).startOf("day").valueOf(), o[n].until = r.valueOf()
                    }
                }
                return o
            }

            function Ei(t, e, n) {
                var a, i, r, o, s, l = this.eras();
                for (t = t.toUpperCase(), a = 0, i = l.length; a < i; ++a) if (r = l[a].name.toUpperCase(), o = l[a].abbr.toUpperCase(), s = l[a].narrow.toUpperCase(), n) switch (e) {
                    case"N":
                    case"NN":
                    case"NNN":
                        if (o === t) return l[a];
                        break;
                    case"NNNN":
                        if (r === t) return l[a];
                        break;
                    case"NNNNN":
                        if (s === t) return l[a]
                } else if ([r, o, s].indexOf(t) >= 0) return l[a]
            }

            function Ai(t, e) {
                var n = t.since <= t.until ? 1 : -1;
                return void 0 === e ? a(t.since).year() : a(t.since).year() + (e - t.offset) * n
            }

            function Ii() {
                var t, e, n, a = this.localeData().eras();
                for (t = 0, e = a.length; t < e; ++t) {
                    if (n = this.clone().startOf("day").valueOf(), a[t].since <= n && n <= a[t].until) return a[t].name;
                    if (a[t].until <= n && n <= a[t].since) return a[t].name
                }
                return ""
            }

            function Mi() {
                var t, e, n, a = this.localeData().eras();
                for (t = 0, e = a.length; t < e; ++t) {
                    if (n = this.clone().startOf("day").valueOf(), a[t].since <= n && n <= a[t].until) return a[t].narrow;
                    if (a[t].until <= n && n <= a[t].since) return a[t].narrow
                }
                return ""
            }

            function Ri() {
                var t, e, n, a = this.localeData().eras();
                for (t = 0, e = a.length; t < e; ++t) {
                    if (n = this.clone().startOf("day").valueOf(), a[t].since <= n && n <= a[t].until) return a[t].abbr;
                    if (a[t].until <= n && n <= a[t].since) return a[t].abbr
                }
                return ""
            }

            function Pi() {
                var t, e, n, i, r = this.localeData().eras();
                for (t = 0, e = r.length; t < e; ++t) if (n = r[t].since <= r[t].until ? 1 : -1, i = this.clone().startOf("day").valueOf(), r[t].since <= i && i <= r[t].until || r[t].until <= i && i <= r[t].since) return (this.year() - a(r[t].since).year()) * n + r[t].offset;
                return this.year()
            }

            function Oi(t) {
                return s(this, "_erasNameRegex") || qi.call(this), t ? this._erasNameRegex : this._erasRegex
            }

            function ji(t) {
                return s(this, "_erasAbbrRegex") || qi.call(this), t ? this._erasAbbrRegex : this._erasRegex
            }

            function Ni(t) {
                return s(this, "_erasNarrowRegex") || qi.call(this), t ? this._erasNarrowRegex : this._erasRegex
            }

            function Li(t, e) {
                return e.erasAbbrRegex(t)
            }

            function Fi(t, e) {
                return e.erasNameRegex(t)
            }

            function Hi(t, e) {
                return e.erasNarrowRegex(t)
            }

            function Bi(t, e) {
                return e._eraYearOrdinalRegex || Et
            }

            function qi() {
                var t, e, n = [], a = [], i = [], r = [], o = this.eras();
                for (t = 0, e = o.length; t < e; ++t) a.push(Lt(o[t].name)), n.push(Lt(o[t].abbr)), i.push(Lt(o[t].narrow)), r.push(Lt(o[t].name)), r.push(Lt(o[t].abbr)), r.push(Lt(o[t].narrow));
                this._erasRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + a.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + i.join("|") + ")", "i")
            }

            function zi(t, e) {
                B(0, [t, t.length], 0, e)
            }

            function Wi(t) {
                return Xi.call(this, t, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
            }

            function Vi(t) {
                return Xi.call(this, t, this.isoWeek(), this.isoWeekday(), 1, 4)
            }

            function $i() {
                return Se(this.year(), 1, 4)
            }

            function Yi() {
                return Se(this.isoWeekYear(), 1, 4)
            }

            function Ui() {
                var t = this.localeData()._week;
                return Se(this.year(), t.dow, t.doy)
            }

            function Gi() {
                var t = this.localeData()._week;
                return Se(this.weekYear(), t.dow, t.doy)
            }

            function Xi(t, e, n, a, i) {
                var r;
                return null == t ? we(this, a, i).year : (e > (r = Se(t, a, i)) && (e = r), Zi.call(this, t, e, n, a, i))
            }

            function Zi(t, e, n, a, i) {
                var r = _e(t, e, n, a, i), o = ye(r.year, 0, r.dayOfYear);
                return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this
            }

            function Ki(t) {
                return null == t ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (t - 1) + this.month() % 3)
            }

            B("N", 0, 0, "eraAbbr"), B("NN", 0, 0, "eraAbbr"), B("NNN", 0, 0, "eraAbbr"), B("NNNN", 0, 0, "eraName"), B("NNNNN", 0, 0, "eraNarrow"), B("y", ["y", 1], "yo", "eraYear"), B("y", ["yy", 2], 0, "eraYear"), B("y", ["yyy", 3], 0, "eraYear"), B("y", ["yyyy", 4], 0, "eraYear"), Ot("N", Li), Ot("NN", Li), Ot("NNN", Li), Ot("NNNN", Fi), Ot("NNNNN", Hi), Ht(["N", "NN", "NNN", "NNNN", "NNNNN"], (function (t, e, n, a) {
                var i = n._locale.erasParse(t, a, n._strict);
                i ? m(n).era = i : m(n).invalidEra = t
            })), Ot("y", Et), Ot("yy", Et), Ot("yyy", Et), Ot("yyyy", Et), Ot("yo", Bi), Ht(["y", "yy", "yyy", "yyyy"], Wt), Ht(["yo"], (function (t, e, n, a) {
                var i;
                n._locale._eraYearOrdinalRegex && (i = t.match(n._locale._eraYearOrdinalRegex)), n._locale.eraYearOrdinalParse ? e[Wt] = n._locale.eraYearOrdinalParse(t, i) : e[Wt] = parseInt(t, 10)
            })), B(0, ["gg", 2], 0, (function () {
                return this.weekYear() % 100
            })), B(0, ["GG", 2], 0, (function () {
                return this.isoWeekYear() % 100
            })), zi("gggg", "weekYear"), zi("ggggg", "weekYear"), zi("GGGG", "isoWeekYear"), zi("GGGGG", "isoWeekYear"), nt("weekYear", "gg"), nt("isoWeekYear", "GG"), ot("weekYear", 1), ot("isoWeekYear", 1), Ot("G", At), Ot("g", At), Ot("GG", wt, bt), Ot("gg", wt, bt), Ot("GGGG", Dt, xt), Ot("gggg", Dt, xt), Ot("GGGGG", Tt, _t), Ot("ggggg", Tt, _t), Bt(["gggg", "ggggg", "GGGG", "GGGGG"], (function (t, e, n, a) {
                e[a.substr(0, 2)] = dt(t)
            })), Bt(["gg", "GG"], (function (t, e, n, i) {
                e[i] = a.parseTwoDigitYear(t)
            })), B("Q", 0, "Qo", "quarter"), nt("quarter", "Q"), ot("quarter", 7), Ot("Q", vt), Ht("Q", (function (t, e) {
                e[Vt] = 3 * (dt(t) - 1)
            })), B("D", ["DD", 2], "Do", "date"), nt("date", "D"), ot("date", 9), Ot("D", wt), Ot("DD", wt, bt), Ot("Do", (function (t, e) {
                return t ? e._dayOfMonthOrdinalParse || e._ordinalParse : e._dayOfMonthOrdinalParseLenient
            })), Ht(["D", "DD"], $t), Ht("Do", (function (t, e) {
                e[$t] = dt(t.match(wt)[0])
            }));
            var Qi = ut("Date", !0);

            function Ji(t) {
                var e = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                return null == t ? e : this.add(t - e, "d")
            }

            B("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), nt("dayOfYear", "DDD"), ot("dayOfYear", 4), Ot("DDD", kt), Ot("DDDD", yt), Ht(["DDD", "DDDD"], (function (t, e, n) {
                n._dayOfYear = dt(t)
            })), B("m", ["mm", 2], 0, "minute"), nt("minute", "m"), ot("minute", 14), Ot("m", wt), Ot("mm", wt, bt), Ht(["m", "mm"], Ut);
            var tr = ut("Minutes", !1);
            B("s", ["ss", 2], 0, "second"), nt("second", "s"), ot("second", 15), Ot("s", wt), Ot("ss", wt, bt), Ht(["s", "ss"], Gt);
            var er, nr, ar = ut("Seconds", !1);
            for (B("S", 0, 0, (function () {
                return ~~(this.millisecond() / 100)
            })), B(0, ["SS", 2], 0, (function () {
                return ~~(this.millisecond() / 10)
            })), B(0, ["SSS", 3], 0, "millisecond"), B(0, ["SSSS", 4], 0, (function () {
                return 10 * this.millisecond()
            })), B(0, ["SSSSS", 5], 0, (function () {
                return 100 * this.millisecond()
            })), B(0, ["SSSSSS", 6], 0, (function () {
                return 1e3 * this.millisecond()
            })), B(0, ["SSSSSSS", 7], 0, (function () {
                return 1e4 * this.millisecond()
            })), B(0, ["SSSSSSSS", 8], 0, (function () {
                return 1e5 * this.millisecond()
            })), B(0, ["SSSSSSSSS", 9], 0, (function () {
                return 1e6 * this.millisecond()
            })), nt("millisecond", "ms"), ot("millisecond", 16), Ot("S", kt, vt), Ot("SS", kt, bt), Ot("SSS", kt, yt), er = "SSSS"; er.length <= 9; er += "S") Ot(er, Et);

            function ir(t, e) {
                e[Xt] = dt(1e3 * ("0." + t))
            }

            for (er = "S"; er.length <= 9; er += "S") Ht(er, ir);

            function rr() {
                return this._isUTC ? "UTC" : ""
            }

            function or() {
                return this._isUTC ? "Coordinated Universal Time" : ""
            }

            nr = ut("Milliseconds", !1), B("z", 0, 0, "zoneAbbr"), B("zz", 0, 0, "zoneName");
            var sr = w.prototype;

            function lr(t) {
                return Gn(1e3 * t)
            }

            function cr() {
                return Gn.apply(null, arguments).parseZone()
            }

            function dr(t) {
                return t
            }

            sr.add = Pa, sr.calendar = qa, sr.clone = za, sr.diff = Xa, sr.endOf = mi, sr.format = ti, sr.from = ei, sr.fromNow = ni, sr.to = ai, sr.toNow = ii, sr.get = ft, sr.invalidAt = ki, sr.isAfter = Wa, sr.isBefore = Va, sr.isBetween = $a, sr.isSame = Ya, sr.isSameOrAfter = Ua, sr.isSameOrBefore = Ga, sr.isValid = Si, sr.lang = oi, sr.locale = ri, sr.localeData = si, sr.max = Zn, sr.min = Xn, sr.parsingFlags = Ci, sr.set = gt, sr.startOf = gi, sr.subtract = Oa, sr.toArray = xi, sr.toObject = _i, sr.toDate = yi, sr.toISOString = Qa, sr.inspect = Ja, "undefined" != typeof Symbol && null != Symbol.for && (sr[Symbol.for("nodejs.util.inspect.custom")] = function () {
                return "Moment<" + this.format() + ">"
            }), sr.toJSON = wi, sr.toString = Ka, sr.unix = bi, sr.valueOf = vi, sr.creationData = Di, sr.eraName = Ii, sr.eraNarrow = Mi, sr.eraAbbr = Ri, sr.eraYear = Pi, sr.year = me, sr.isLeapYear = ve, sr.weekYear = Wi, sr.isoWeekYear = Vi, sr.quarter = sr.quarters = Ki, sr.month = de, sr.daysInMonth = ue, sr.week = sr.weeks = Ee, sr.isoWeek = sr.isoWeeks = Ae, sr.weeksInYear = Ui, sr.weeksInWeekYear = Gi, sr.isoWeeksInYear = $i, sr.isoWeeksInISOWeekYear = Yi, sr.date = Qi, sr.day = sr.days = Ve, sr.weekday = $e, sr.isoWeekday = Ye, sr.dayOfYear = Ji, sr.hour = sr.hours = an, sr.minute = sr.minutes = tr, sr.second = sr.seconds = ar, sr.millisecond = sr.milliseconds = nr, sr.utcOffset = fa, sr.utc = ma, sr.local = va, sr.parseZone = ba, sr.hasAlignedHourOffset = ya, sr.isDST = xa, sr.isLocal = wa, sr.isUtcOffset = Sa, sr.isUtc = Ca, sr.isUTC = Ca, sr.zoneAbbr = rr, sr.zoneName = or, sr.dates = k("dates accessor is deprecated. Use date instead.", Qi), sr.months = k("months accessor is deprecated. Use month instead", de), sr.years = k("years accessor is deprecated. Use year instead", me), sr.zone = k("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", ga), sr.isDSTShifted = k("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", _a);
            var ur = R.prototype;

            function hr(t, e, n, a) {
                var i = vn(), r = f().set(a, e);
                return i[n](r, t)
            }

            function pr(t, e, n) {
                if (d(t) && (e = t, t = void 0), t = t || "", null != e) return hr(t, e, n, "month");
                var a, i = [];
                for (a = 0; a < 12; a++) i[a] = hr(t, a, n, "month");
                return i
            }

            function fr(t, e, n, a) {
                "boolean" == typeof t ? (d(e) && (n = e, e = void 0), e = e || "") : (n = e = t, t = !1, d(e) && (n = e, e = void 0), e = e || "");
                var i, r = vn(), o = t ? r._week.dow : 0, s = [];
                if (null != n) return hr(e, (n + o) % 7, a, "day");
                for (i = 0; i < 7; i++) s[i] = hr(e, (i + o) % 7, a, "day");
                return s
            }

            function gr(t, e) {
                return pr(t, e, "months")
            }

            function mr(t, e) {
                return pr(t, e, "monthsShort")
            }

            function vr(t, e, n) {
                return fr(t, e, n, "weekdays")
            }

            function br(t, e, n) {
                return fr(t, e, n, "weekdaysShort")
            }

            function yr(t, e, n) {
                return fr(t, e, n, "weekdaysMin")
            }

            ur.calendar = O, ur.longDateFormat = Y, ur.invalidDate = G, ur.ordinal = K, ur.preparse = dr, ur.postformat = dr, ur.relativeTime = J, ur.pastFuture = tt, ur.set = I, ur.eras = Ti, ur.erasParse = Ei, ur.erasConvertYear = Ai, ur.erasAbbrRegex = ji, ur.erasNameRegex = Oi, ur.erasNarrowRegex = Ni, ur.months = re, ur.monthsShort = oe, ur.monthsParse = le, ur.monthsRegex = pe, ur.monthsShortRegex = he, ur.week = Ce, ur.firstDayOfYear = Te, ur.firstDayOfWeek = De, ur.weekdays = He, ur.weekdaysMin = qe, ur.weekdaysShort = Be, ur.weekdaysParse = We, ur.weekdaysRegex = Ue, ur.weekdaysShortRegex = Ge, ur.weekdaysMinRegex = Xe, ur.isPM = en, ur.meridiem = rn, fn("en", {
                eras: [{
                    since: "0001-01-01",
                    until: 1 / 0,
                    offset: 1,
                    name: "Anno Domini",
                    narrow: "AD",
                    abbr: "AD"
                }, {since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC"}],
                dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function (t) {
                    var e = t % 10;
                    return t + (1 === dt(t % 100 / 10) ? "th" : 1 === e ? "st" : 2 === e ? "nd" : 3 === e ? "rd" : "th")
                }
            }), a.lang = k("moment.lang is deprecated. Use moment.locale instead.", fn), a.langData = k("moment.langData is deprecated. Use moment.localeData instead.", vn);
            var xr = Math.abs;

            function _r() {
                var t = this._data;
                return this._milliseconds = xr(this._milliseconds), this._days = xr(this._days), this._months = xr(this._months), t.milliseconds = xr(t.milliseconds), t.seconds = xr(t.seconds), t.minutes = xr(t.minutes), t.hours = xr(t.hours), t.months = xr(t.months), t.years = xr(t.years), this
            }

            function wr(t, e, n, a) {
                var i = Ta(e, n);
                return t._milliseconds += a * i._milliseconds, t._days += a * i._days, t._months += a * i._months, t._bubble()
            }

            function Sr(t, e) {
                return wr(this, t, e, 1)
            }

            function Cr(t, e) {
                return wr(this, t, e, -1)
            }

            function kr(t) {
                return t < 0 ? Math.floor(t) : Math.ceil(t)
            }

            function Dr() {
                var t, e, n, a, i, r = this._milliseconds, o = this._days, s = this._months, l = this._data;
                return r >= 0 && o >= 0 && s >= 0 || r <= 0 && o <= 0 && s <= 0 || (r += 864e5 * kr(Er(s) + o), o = 0, s = 0), l.milliseconds = r % 1e3, t = ct(r / 1e3), l.seconds = t % 60, e = ct(t / 60), l.minutes = e % 60, n = ct(e / 60), l.hours = n % 24, o += ct(n / 24), s += i = ct(Tr(o)), o -= kr(Er(i)), a = ct(s / 12), s %= 12, l.days = o, l.months = s, l.years = a, this
            }

            function Tr(t) {
                return 4800 * t / 146097
            }

            function Er(t) {
                return 146097 * t / 4800
            }

            function Ar(t) {
                if (!this.isValid()) return NaN;
                var e, n, a = this._milliseconds;
                if ("month" === (t = at(t)) || "quarter" === t || "year" === t) switch (e = this._days + a / 864e5, n = this._months + Tr(e), t) {
                    case"month":
                        return n;
                    case"quarter":
                        return n / 3;
                    case"year":
                        return n / 12
                } else switch (e = this._days + Math.round(Er(this._months)), t) {
                    case"week":
                        return e / 7 + a / 6048e5;
                    case"day":
                        return e + a / 864e5;
                    case"hour":
                        return 24 * e + a / 36e5;
                    case"minute":
                        return 1440 * e + a / 6e4;
                    case"second":
                        return 86400 * e + a / 1e3;
                    case"millisecond":
                        return Math.floor(864e5 * e) + a;
                    default:
                        throw new Error("Unknown unit " + t)
                }
            }

            function Ir() {
                return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * dt(this._months / 12) : NaN
            }

            function Mr(t) {
                return function () {
                    return this.as(t)
                }
            }

            var Rr = Mr("ms"), Pr = Mr("s"), Or = Mr("m"), jr = Mr("h"), Nr = Mr("d"), Lr = Mr("w"), Fr = Mr("M"),
                Hr = Mr("Q"), Br = Mr("y");

            function qr() {
                return Ta(this)
            }

            function zr(t) {
                return t = at(t), this.isValid() ? this[t + "s"]() : NaN
            }

            function Wr(t) {
                return function () {
                    return this.isValid() ? this._data[t] : NaN
                }
            }

            var Vr = Wr("milliseconds"), $r = Wr("seconds"), Yr = Wr("minutes"), Ur = Wr("hours"), Gr = Wr("days"),
                Xr = Wr("months"), Zr = Wr("years");

            function Kr() {
                return ct(this.days() / 7)
            }

            var Qr = Math.round, Jr = {ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11};

            function to(t, e, n, a, i) {
                return i.relativeTime(e || 1, !!n, t, a)
            }

            function eo(t, e, n, a) {
                var i = Ta(t).abs(), r = Qr(i.as("s")), o = Qr(i.as("m")), s = Qr(i.as("h")), l = Qr(i.as("d")),
                    c = Qr(i.as("M")), d = Qr(i.as("w")), u = Qr(i.as("y")),
                    h = r <= n.ss && ["s", r] || r < n.s && ["ss", r] || o <= 1 && ["m"] || o < n.m && ["mm", o] || s <= 1 && ["h"] || s < n.h && ["hh", s] || l <= 1 && ["d"] || l < n.d && ["dd", l];
                return null != n.w && (h = h || d <= 1 && ["w"] || d < n.w && ["ww", d]), (h = h || c <= 1 && ["M"] || c < n.M && ["MM", c] || u <= 1 && ["y"] || ["yy", u])[2] = e, h[3] = +t > 0, h[4] = a, to.apply(null, h)
            }

            function no(t) {
                return void 0 === t ? Qr : "function" == typeof t && (Qr = t, !0)
            }

            function ao(t, e) {
                return void 0 !== Jr[t] && (void 0 === e ? Jr[t] : (Jr[t] = e, "s" === t && (Jr.ss = e - 1), !0))
            }

            function io(t, e) {
                if (!this.isValid()) return this.localeData().invalidDate();
                var n, a, i = !1, r = Jr;
                return "object" == typeof t && (e = t, t = !1), "boolean" == typeof t && (i = t), "object" == typeof e && (r = Object.assign({}, Jr, e), null != e.s && null == e.ss && (r.ss = e.s - 1)), a = eo(this, !i, r, n = this.localeData()), i && (a = n.pastFuture(+this, a)), n.postformat(a)
            }

            var ro = Math.abs;

            function oo(t) {
                return (t > 0) - (t < 0) || +t
            }

            function so() {
                if (!this.isValid()) return this.localeData().invalidDate();
                var t, e, n, a, i, r, o, s, l = ro(this._milliseconds) / 1e3, c = ro(this._days), d = ro(this._months),
                    u = this.asSeconds();
                return u ? (t = ct(l / 60), e = ct(t / 60), l %= 60, t %= 60, n = ct(d / 12), d %= 12, a = l ? l.toFixed(3).replace(/\.?0+$/, "") : "", i = u < 0 ? "-" : "", r = oo(this._months) !== oo(u) ? "-" : "", o = oo(this._days) !== oo(u) ? "-" : "", s = oo(this._milliseconds) !== oo(u) ? "-" : "", i + "P" + (n ? r + n + "Y" : "") + (d ? r + d + "M" : "") + (c ? o + c + "D" : "") + (e || t || l ? "T" : "") + (e ? s + e + "H" : "") + (t ? s + t + "M" : "") + (l ? s + a + "S" : "")) : "P0D"
            }

            var lo = ra.prototype;
            return lo.isValid = aa, lo.abs = _r, lo.add = Sr, lo.subtract = Cr, lo.as = Ar, lo.asMilliseconds = Rr, lo.asSeconds = Pr, lo.asMinutes = Or, lo.asHours = jr, lo.asDays = Nr, lo.asWeeks = Lr, lo.asMonths = Fr, lo.asQuarters = Hr, lo.asYears = Br, lo.valueOf = Ir, lo._bubble = Dr, lo.clone = qr, lo.get = zr, lo.milliseconds = Vr, lo.seconds = $r, lo.minutes = Yr, lo.hours = Ur, lo.days = Gr, lo.weeks = Kr, lo.months = Xr, lo.years = Zr, lo.humanize = io, lo.toISOString = so, lo.toString = so, lo.toJSON = so, lo.locale = ri, lo.localeData = si, lo.toIsoString = k("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", so), lo.lang = oi, B("X", 0, 0, "unix"), B("x", 0, 0, "valueOf"), Ot("x", At), Ot("X", Rt), Ht("X", (function (t, e, n) {
                n._d = new Date(1e3 * parseFloat(t))
            })), Ht("x", (function (t, e, n) {
                n._d = new Date(dt(t))
            })), a.version = "2.29.1", i(Gn), a.fn = sr, a.min = Qn, a.max = Jn, a.now = ta, a.utc = f, a.unix = lr, a.months = gr, a.isDate = u, a.locale = fn, a.invalid = b, a.duration = Ta, a.isMoment = S, a.weekdays = vr, a.parseZone = cr, a.localeData = vn, a.isDuration = oa, a.monthsShort = mr, a.weekdaysMin = yr, a.defineLocale = gn, a.updateLocale = mn, a.locales = bn, a.weekdaysShort = br, a.normalizeUnits = at, a.relativeTimeRounding = no, a.relativeTimeThreshold = ao, a.calendarFormat = Ba, a.prototype = sr, a.HTML5_FMT = {
                DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                DATE: "YYYY-MM-DD",
                TIME: "HH:mm",
                TIME_SECONDS: "HH:mm:ss",
                TIME_MS: "HH:mm:ss.SSS",
                WEEK: "GGGG-[W]WW",
                MONTH: "YYYY-MM"
            }, a
        }()
    }).call(this, n(100)(t))
}, function (t, e) {
    var n = !("undefined" == typeof window || !window.document || !window.document.createElement);
    t.exports = n
}, function (t, e, n) {
    t.exports = n(26)("native-function-to-string", Function.toString)
}, function (t, e, n) {
    var a = n(28);
    t.exports = Object("z").propertyIsEnumerable(0) ? Object : function (t) {
        return "String" == a(t) ? t.split("") : Object(t)
    }
}, function (t, e, n) {
    "use strict";
    var a = n(5), i = n(20);
    t.exports = function (t, e, n) {
        e in t ? a.f(t, e, i(0, n)) : t[e] = n
    }
}, function (t, e, n) {
    "use strict";
    var a = n(1), i = n(10), r = n(6), o = n(8), s = n(12), l = n(83).KEY, c = n(9), d = n(26), u = n(40), h = n(21),
        p = n(0), f = n(52), g = n(66), m = n(84), v = n(85), b = n(2), y = n(14), x = n(11), _ = n(37), w = n(20),
        S = n(53), C = n(88), k = n(65), D = n(5), T = n(18), E = k.f, A = D.f, I = C.f, M = a.Symbol, R = a.JSON,
        P = R && R.stringify, O = p("_hidden"), j = p("toPrimitive"), N = {}.propertyIsEnumerable,
        L = d("symbol-registry"), F = d("symbols"), H = d("op-symbols"), B = Object.prototype,
        q = "function" == typeof M, z = a.QObject, W = !z || !z.prototype || !z.prototype.findChild,
        V = r && c((function () {
            return 7 != S(A({}, "a", {
                get: function () {
                    return A(this, "a", {value: 7}).a
                }
            })).a
        })) ? function (t, e, n) {
            var a = E(B, e);
            a && delete B[e], A(t, e, n), a && t !== B && A(B, e, a)
        } : A, $ = function (t) {
            var e = F[t] = S(M.prototype);
            return e._k = t, e
        }, Y = q && "symbol" == typeof M.iterator ? function (t) {
            return "symbol" == typeof t
        } : function (t) {
            return t instanceof M
        }, U = function (t, e, n) {
            return t === B && U(H, e, n), b(t), e = _(e, !0), b(n), i(F, e) ? (n.enumerable ? (i(t, O) && t[O][e] && (t[O][e] = !1), n = S(n, {enumerable: w(0, !1)})) : (i(t, O) || A(t, O, w(1, {})), t[O][e] = !0), V(t, e, n)) : A(t, e, n)
        }, G = function (t, e) {
            b(t);
            for (var n, a = m(e = x(e)), i = 0, r = a.length; r > i;) U(t, n = a[i++], e[n]);
            return t
        }, X = function (t) {
            var e = N.call(this, t = _(t, !0));
            return !(this === B && i(F, t) && !i(H, t)) && (!(e || !i(this, t) || !i(F, t) || i(this, O) && this[O][t]) || e)
        }, Z = function (t, e) {
            if (t = x(t), e = _(e, !0), t !== B || !i(F, e) || i(H, e)) {
                var n = E(t, e);
                return !n || !i(F, e) || i(t, O) && t[O][e] || (n.enumerable = !0), n
            }
        }, K = function (t) {
            for (var e, n = I(x(t)), a = [], r = 0; n.length > r;) i(F, e = n[r++]) || e == O || e == l || a.push(e);
            return a
        }, Q = function (t) {
            for (var e, n = t === B, a = I(n ? H : x(t)), r = [], o = 0; a.length > o;) !i(F, e = a[o++]) || n && !i(B, e) || r.push(F[e]);
            return r
        };
    q || (s((M = function () {
        if (this instanceof M) throw TypeError("Symbol is not a constructor!");
        var t = h(arguments.length > 0 ? arguments[0] : void 0), e = function (n) {
            this === B && e.call(H, n), i(this, O) && i(this[O], t) && (this[O][t] = !1), V(this, t, w(1, n))
        };
        return r && W && V(B, t, {configurable: !0, set: e}), $(t)
    }).prototype, "toString", (function () {
        return this._k
    })), k.f = Z, D.f = U, n(42).f = C.f = K, n(34).f = X, n(43).f = Q, r && !n(27) && s(B, "propertyIsEnumerable", X, !0), f.f = function (t) {
        return $(p(t))
    }), o(o.G + o.W + o.F * !q, {Symbol: M});
    for (var J = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), tt = 0; J.length > tt;) p(J[tt++]);
    for (var et = T(p.store), nt = 0; et.length > nt;) g(et[nt++]);
    o(o.S + o.F * !q, "Symbol", {
        for: function (t) {
            return i(L, t += "") ? L[t] : L[t] = M(t)
        }, keyFor: function (t) {
            if (!Y(t)) throw TypeError(t + " is not a symbol!");
            for (var e in L) if (L[e] === t) return e
        }, useSetter: function () {
            W = !0
        }, useSimple: function () {
            W = !1
        }
    }), o(o.S + o.F * !q, "Object", {
        create: function (t, e) {
            return void 0 === e ? S(t) : G(S(t), e)
        },
        defineProperty: U,
        defineProperties: G,
        getOwnPropertyDescriptor: Z,
        getOwnPropertyNames: K,
        getOwnPropertySymbols: Q
    }), R && o(o.S + o.F * (!q || c((function () {
        var t = M();
        return "[null]" != P([t]) || "{}" != P({a: t}) || "{}" != P(Object(t))
    }))), "JSON", {
        stringify: function (t) {
            for (var e, n, a = [t], i = 1; arguments.length > i;) a.push(arguments[i++]);
            if (n = e = a[1], (y(e) || void 0 !== t) && !Y(t)) return v(e) || (e = function (t, e) {
                if ("function" == typeof n && (e = n.call(this, t, e)), !Y(e)) return e
            }), a[1] = e, P.apply(R, a)
        }
    }), M.prototype[j] || n(4)(M.prototype, j, M.prototype.valueOf), u(M, "Symbol"), u(Math, "Math", !0), u(a.JSON, "JSON", !0)
}, function (t, e, n) {
    var a = n(21)("meta"), i = n(14), r = n(10), o = n(5).f, s = 0, l = Object.isExtensible || function () {
        return !0
    }, c = !n(9)((function () {
        return l(Object.preventExtensions({}))
    })), d = function (t) {
        o(t, a, {value: {i: "O" + ++s, w: {}}})
    }, u = t.exports = {
        KEY: a, NEED: !1, fastKey: function (t, e) {
            if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
            if (!r(t, a)) {
                if (!l(t)) return "F";
                if (!e) return "E";
                d(t)
            }
            return t[a].i
        }, getWeak: function (t, e) {
            if (!r(t, a)) {
                if (!l(t)) return !0;
                if (!e) return !1;
                d(t)
            }
            return t[a].w
        }, onFreeze: function (t) {
            return c && u.NEED && l(t) && !r(t, a) && d(t), t
        }
    }
}, function (t, e, n) {
    var a = n(18), i = n(43), r = n(34);
    t.exports = function (t) {
        var e = a(t), n = i.f;
        if (n) for (var o, s = n(t), l = r.f, c = 0; s.length > c;) l.call(t, o = s[c++]) && e.push(o);
        return e
    }
}, function (t, e, n) {
    var a = n(28);
    t.exports = Array.isArray || function (t) {
        return "Array" == a(t)
    }
}, function (t, e, n) {
    var a = n(5), i = n(2), r = n(18);
    t.exports = n(6) ? Object.defineProperties : function (t, e) {
        i(t);
        for (var n, o = r(e), s = o.length, l = 0; s > l;) a.f(t, n = o[l++], e[n]);
        return t
    }
}, function (t, e, n) {
    var a = n(1).document;
    t.exports = a && a.documentElement
}, function (t, e, n) {
    var a = n(11), i = n(42).f, r = {}.toString,
        o = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    t.exports.f = function (t) {
        return o && "[object Window]" == r.call(t) ? function (t) {
            try {
                return i(t)
            } catch (t) {
                return o.slice()
            }
        }(t) : i(a(t))
    }
}, function (t, e, n) {
    for (var a = n(54), i = n(18), r = n(12), o = n(1), s = n(4), l = n(30), c = n(0), d = c("iterator"), u = c("toStringTag"), h = l.Array, p = {
        CSSRuleList: !0,
        CSSStyleDeclaration: !1,
        CSSValueList: !1,
        ClientRectList: !1,
        DOMRectList: !1,
        DOMStringList: !1,
        DOMTokenList: !0,
        DataTransferItemList: !1,
        FileList: !1,
        HTMLAllCollection: !1,
        HTMLCollection: !1,
        HTMLFormElement: !1,
        HTMLSelectElement: !1,
        MediaList: !0,
        MimeTypeArray: !1,
        NamedNodeMap: !1,
        NodeList: !0,
        PaintRequestList: !1,
        Plugin: !1,
        PluginArray: !1,
        SVGLengthList: !1,
        SVGNumberList: !1,
        SVGPathSegList: !1,
        SVGPointList: !1,
        SVGStringList: !1,
        SVGTransformList: !1,
        SourceBufferList: !1,
        StyleSheetList: !0,
        TextTrackCueList: !1,
        TextTrackList: !1,
        TouchList: !1
    }, f = i(p), g = 0; g < f.length; g++) {
        var m, v = f[g], b = p[v], y = o[v], x = y && y.prototype;
        if (x && (x[d] || s(x, d, h), x[u] || s(x, u, v), l[v] = h, b)) for (m in a) x[m] || r(x, m, a[m], !0)
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return {value: e, done: !!t}
    }
}, function (t, e, n) {
    "use strict";
    var a = n(53), i = n(20), r = n(40), o = {};
    n(4)(o, n(0)("iterator"), (function () {
        return this
    })), t.exports = function (t, e, n) {
        t.prototype = a(o, {next: i(1, n)}), r(t, e + " Iterator")
    }
}, function (t, e, n) {
    var a = n(10), i = n(31), r = n(38)("IE_PROTO"), o = Object.prototype;
    t.exports = Object.getPrototypeOf || function (t) {
        return t = i(t), a(t, r) ? t[r] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? o : null
    }
}, function (t, e, n) {
    "use strict";
    var a = n(44), i = {};
    i[n(0)("toStringTag")] = "z", i + "" != "[object z]" && n(12)(Object.prototype, "toString", (function () {
        return "[object " + a(this) + "]"
    }), !0)
}, function (t, e, n) {
    var a = n(31), i = n(18);
    n(95)("keys", (function () {
        return function (t) {
            return i(a(t))
        }
    }))
}, function (t, e, n) {
    var a = n(8), i = n(17), r = n(9);
    t.exports = function (t, e) {
        var n = (i.Object || {})[t] || Object[t], o = {};
        o[t] = e(n), a(a.S + a.F * r((function () {
            n(1)
        })), "Object", o)
    }
}, function (t, e, n) {
    var a = n(14), i = n(28), r = n(0)("match");
    t.exports = function (t) {
        var e;
        return a(t) && (void 0 !== (e = t[r]) ? !!e : "RegExp" == i(t))
    }
}, function (t, e, n) {
    "use strict";
    var a = n(45);
    n(8)({target: "RegExp", proto: !0, forced: a !== /./.exec}, {exec: a})
}, function (t, e) {
    var n, a, i = t.exports = {};

    function r() {
        throw new Error("setTimeout has not been defined")
    }

    function o() {
        throw new Error("clearTimeout has not been defined")
    }

    function s(t) {
        if (n === setTimeout) return setTimeout(t, 0);
        if ((n === r || !n) && setTimeout) return n = setTimeout, setTimeout(t, 0);
        try {
            return n(t, 0)
        } catch (e) {
            try {
                return n.call(null, t, 0)
            } catch (e) {
                return n.call(this, t, 0)
            }
        }
    }

    !function () {
        try {
            n = "function" == typeof setTimeout ? setTimeout : r
        } catch (t) {
            n = r
        }
        try {
            a = "function" == typeof clearTimeout ? clearTimeout : o
        } catch (t) {
            a = o
        }
    }();
    var l, c = [], d = !1, u = -1;

    function h() {
        d && l && (d = !1, l.length ? c = l.concat(c) : u = -1, c.length && p())
    }

    function p() {
        if (!d) {
            var t = s(h);
            d = !0;
            for (var e = c.length; e;) {
                for (l = c, c = []; ++u < e;) l && l[u].run();
                u = -1, e = c.length
            }
            l = null, d = !1, function (t) {
                if (a === clearTimeout) return clearTimeout(t);
                if ((a === o || !a) && clearTimeout) return a = clearTimeout, clearTimeout(t);
                try {
                    a(t)
                } catch (e) {
                    try {
                        return a.call(null, t)
                    } catch (e) {
                        return a.call(this, t)
                    }
                }
            }(t)
        }
    }

    function f(t, e) {
        this.fun = t, this.array = e
    }

    function g() {
    }

    i.nextTick = function (t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
        c.push(new f(t, e)), 1 !== c.length || d || s(p)
    }, f.prototype.run = function () {
        this.fun.apply(null, this.array)
    }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function (t) {
        return []
    }, i.binding = function (t) {
        throw new Error("process.binding is not supported")
    }, i.cwd = function () {
        return "/"
    }, i.chdir = function (t) {
        throw new Error("process.chdir is not supported")
    }, i.umask = function () {
        return 0
    }
}, function (t, e, n) {
    "use strict";
    var a = n(2), i = n(31), r = n(33), o = n(29), s = n(68), l = n(70), c = Math.max, d = Math.min, u = Math.floor,
        h = /\$([$&`']|\d\d?|<[^>]*>)/g, p = /\$([$&`']|\d\d?)/g;
    n(71)("replace", 2, (function (t, e, n, f) {
        return [function (a, i) {
            var r = t(this), o = null == a ? void 0 : a[e];
            return void 0 !== o ? o.call(a, r, i) : n.call(String(r), a, i)
        }, function (t, e) {
            var i = f(n, t, this, e);
            if (i.done) return i.value;
            var u = a(t), h = String(this), p = "function" == typeof e;
            p || (e = String(e));
            var m = u.global;
            if (m) {
                var v = u.unicode;
                u.lastIndex = 0
            }
            for (var b = []; ;) {
                var y = l(u, h);
                if (null === y) break;
                if (b.push(y), !m) break;
                "" === String(y[0]) && (u.lastIndex = s(h, r(u.lastIndex), v))
            }
            for (var x, _ = "", w = 0, S = 0; S < b.length; S++) {
                y = b[S];
                for (var C = String(y[0]), k = c(d(o(y.index), h.length), 0), D = [], T = 1; T < y.length; T++) D.push(void 0 === (x = y[T]) ? x : String(x));
                var E = y.groups;
                if (p) {
                    var A = [C].concat(D, k, h);
                    void 0 !== E && A.push(E);
                    var I = String(e.apply(void 0, A))
                } else I = g(C, h, k, D, E, e);
                k >= w && (_ += h.slice(w, k) + I, w = k + C.length)
            }
            return _ + h.slice(w)
        }];

        function g(t, e, a, r, o, s) {
            var l = a + t.length, c = r.length, d = p;
            return void 0 !== o && (o = i(o), d = h), n.call(s, d, (function (n, i) {
                var s;
                switch (i.charAt(0)) {
                    case"$":
                        return "$";
                    case"&":
                        return t;
                    case"`":
                        return e.slice(0, a);
                    case"'":
                        return e.slice(l);
                    case"<":
                        s = o[i.slice(1, -1)];
                        break;
                    default:
                        var d = +i;
                        if (0 === d) return n;
                        if (d > c) {
                            var h = u(d / 10);
                            return 0 === h ? n : h <= c ? void 0 === r[h - 1] ? i.charAt(1) : r[h - 1] + i.charAt(1) : n
                        }
                        s = r[d - 1]
                }
                return void 0 === s ? "" : s
            }))
        }
    }))
}, function (t, e) {
    t.exports = function (t) {
        return t.webpackPolyfill || (t.deprecate = function () {
        }, t.paths = [], t.children || (t.children = []), Object.defineProperty(t, "loaded", {
            enumerable: !0,
            get: function () {
                return t.l
            }
        }), Object.defineProperty(t, "id", {
            enumerable: !0, get: function () {
                return t.i
            }
        }), t.webpackPolyfill = 1), t
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return {enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e}
    }
}, function (t, e, n) {
    var a = n(7), i = n(32);
    t.exports = function (t, e) {
        try {
            i(a, t, e)
        } catch (n) {
            a[t] = e
        }
        return e
    }
}, function (t, e, n) {
    var a = n(125), i = n(105), r = a("keys");
    t.exports = function (t) {
        return r[t] || (r[t] = i(t))
    }
}, function (t, e) {
    t.exports = !1
}, function (t, e) {
    var n = 0, a = Math.random();
    t.exports = function (t) {
        return "Symbol(" + String(void 0 === t ? "" : t) + ")_" + (++n + a).toString(36)
    }
}, function (t, e, n) {
    var a = n(180), i = n(7), r = function (t) {
        return "function" == typeof t ? t : void 0
    };
    t.exports = function (t, e) {
        return arguments.length < 2 ? r(a[t]) || r(i[t]) : a[t] && a[t][e] || i[t] && i[t][e]
    }
}, function (t, e) {
    t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
}, function (t, e, n) {
    var a = n(130), i = n(73), r = n(58), o = n(48), s = n(184), l = [].push, c = function (t) {
        var e = 1 == t, n = 2 == t, c = 3 == t, d = 4 == t, u = 6 == t, h = 5 == t || u;
        return function (p, f, g, m) {
            for (var v, b, y = r(p), x = i(y), _ = a(f, g, 3), w = o(x.length), S = 0, C = m || s, k = e ? C(p, w) : n ? C(p, 0) : void 0; w > S; S++) if ((h || S in x) && (b = _(v = x[S], S, y), t)) if (e) k[S] = b; else if (b) switch (t) {
                case 3:
                    return !0;
                case 5:
                    return v;
                case 6:
                    return S;
                case 2:
                    l.call(k, v)
            } else if (d) return !1;
            return u ? -1 : c || d ? d : k
        }
    };
    t.exports = {forEach: c(0), map: c(1), filter: c(2), some: c(3), every: c(4), find: c(5), findIndex: c(6)}
}, function (t, e, n) {
    var a = n(36), i = n(13), r = n(19), o = Object.defineProperty, s = {}, l = function (t) {
        throw t
    };
    t.exports = function (t, e) {
        if (r(s, t)) return s[t];
        e || (e = {});
        var n = [][t], c = !!r(e, "ACCESSORS") && e.ACCESSORS, d = r(e, 0) ? e[0] : l, u = r(e, 1) ? e[1] : void 0;
        return s[t] = !!n && !i((function () {
            if (c && !a) return !0;
            var t = {length: -1};
            c ? o(t, 1, {enumerable: !0, get: l}) : t[1] = 1, n.call(t, d, u)
        }))
    }
}, function (t, e, n) {
    var a = n(41).f, i = n(19), r = n(15)("toStringTag");
    t.exports = function (t, e, n) {
        t && !i(t = n ? t : t.prototype, r) && a(t, r, {configurable: !0, value: e})
    }
}, function (t, e, n) {
    var a = {};
    a[n(15)("toStringTag")] = "z", t.exports = "[object z]" === String(a)
}, function (t, e, n) {
    var a = n(75), i = n(22), r = n(19), o = n(41).f, s = n(105), l = n(207), c = s("meta"), d = 0,
        u = Object.isExtensible || function () {
            return !0
        }, h = function (t) {
            o(t, c, {value: {objectID: "O" + ++d, weakData: {}}})
        }, p = t.exports = {
            REQUIRED: !1, fastKey: function (t, e) {
                if (!i(t)) return "symbol" == typeof t ? t : ("string" == typeof t ? "S" : "P") + t;
                if (!r(t, c)) {
                    if (!u(t)) return "F";
                    if (!e) return "E";
                    h(t)
                }
                return t[c].objectID
            }, getWeakData: function (t, e) {
                if (!r(t, c)) {
                    if (!u(t)) return !0;
                    if (!e) return !1;
                    h(t)
                }
                return t[c].weakData
            }, onFreeze: function (t) {
                return l && p.REQUIRED && u(t) && !r(t, c) && h(t), t
            }
        };
    a[c] = !0
}, function (t, e, n) {
    "use strict";
    var a, i, r = n(219), o = n(220), s = RegExp.prototype.exec, l = String.prototype.replace, c = s,
        d = (a = /a/, i = /b*/g, s.call(a, "a"), s.call(i, "a"), 0 !== a.lastIndex || 0 !== i.lastIndex),
        u = o.UNSUPPORTED_Y || o.BROKEN_CARET, h = void 0 !== /()??/.exec("")[1];
    (d || h || u) && (c = function (t) {
        var e, n, a, i, o = this, c = u && o.sticky, p = r.call(o), f = o.source, g = 0, m = t;
        return c && (-1 === (p = p.replace("y", "")).indexOf("g") && (p += "g"), m = String(t).slice(o.lastIndex), o.lastIndex > 0 && (!o.multiline || o.multiline && "\n" !== t[o.lastIndex - 1]) && (f = "(?: " + f + ")", m = " " + m, g++), n = new RegExp("^(?:" + f + ")", p)), h && (n = new RegExp("^" + f + "$(?!\\s)", p)), d && (e = o.lastIndex), a = s.call(c ? n : o, m), c ? a ? (a.input = a.input.slice(g), a[0] = a[0].slice(g), a.index = o.lastIndex, o.lastIndex += a[0].length) : o.lastIndex = 0 : d && a && (o.lastIndex = o.global ? a.index + a[0].length : e), h && a && a.length > 1 && l.call(a[0], n, (function () {
            for (i = 1; i < arguments.length - 2; i++) void 0 === arguments[i] && (a[i] = void 0)
        })), a
    }), t.exports = c
}, function (t, e, n) {
    var a;
    "undefined" != typeof self && self, a = function () {
        return function (t) {
            var e = {};

            function n(a) {
                if (e[a]) return e[a].exports;
                var i = e[a] = {i: a, l: !1, exports: {}};
                return t[a].call(i.exports, i, i.exports, n), i.l = !0, i.exports
            }

            return n.m = t, n.c = e, n.d = function (t, e, a) {
                n.o(t, e) || Object.defineProperty(t, e, {configurable: !1, enumerable: !0, get: a})
            }, n.r = function (t) {
                Object.defineProperty(t, "__esModule", {value: !0})
            }, n.n = function (t) {
                var e = t && t.__esModule ? function () {
                    return t.default
                } : function () {
                    return t
                };
                return n.d(e, "a", e), e
            }, n.o = function (t, e) {
                return Object.prototype.hasOwnProperty.call(t, e)
            }, n.p = "", n(n.s = 0)
        }({
            "./dist/icons.json": function (t) {
                t.exports = {
                    activity: '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>',
                    airplay: '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>',
                    "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
                    "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>',
                    "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>',
                    "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>',
                    "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>',
                    "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>',
                    "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>',
                    anchor: '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>',
                    aperture: '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>',
                    archive: '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>',
                    "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>',
                    "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>',
                    "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>',
                    "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>',
                    "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>',
                    "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>',
                    "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>',
                    "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>',
                    "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>',
                    "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>',
                    "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>',
                    "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>',
                    "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>',
                    award: '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>',
                    "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>',
                    "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>',
                    "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>',
                    battery: '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>',
                    "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    bell: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>',
                    bluetooth: '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>',
                    bold: '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>',
                    "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>',
                    book: '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>',
                    bookmark: '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>',
                    box: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
                    briefcase: '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>',
                    calendar: '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>',
                    "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>',
                    camera: '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>',
                    cast: '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>',
                    "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>',
                    "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>',
                    check: '<polyline points="20 6 9 17 4 12"></polyline>',
                    "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>',
                    "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>',
                    "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>',
                    "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>',
                    "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>',
                    "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>',
                    "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>',
                    "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>',
                    chrome: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>',
                    circle: '<circle cx="12" cy="12" r="10"></circle>',
                    clipboard: '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>',
                    clock: '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>',
                    "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
                    "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>',
                    "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>',
                    "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>',
                    cloud: '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>',
                    code: '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>',
                    codepen: '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>',
                    codesandbox: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
                    coffee: '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>',
                    columns: '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>',
                    command: '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>',
                    compass: '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>',
                    copy: '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>',
                    "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>',
                    "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>',
                    "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>',
                    "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>',
                    "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>',
                    "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>',
                    "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>',
                    "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>',
                    cpu: '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>',
                    "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>',
                    crop: '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>',
                    crosshair: '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>',
                    database: '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>',
                    delete: '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>',
                    disc: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>',
                    "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>',
                    "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>',
                    divide: '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>',
                    "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>',
                    "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>',
                    download: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>',
                    dribbble: '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>',
                    droplet: '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>',
                    "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>',
                    "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>',
                    edit: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>',
                    "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>',
                    "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    eye: '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>',
                    facebook: '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>',
                    "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>',
                    feather: '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>',
                    figma: '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>',
                    "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>',
                    "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>',
                    "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>',
                    file: '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>',
                    film: '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>',
                    filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>',
                    flag: '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>',
                    "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>',
                    "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>',
                    folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>',
                    framer: '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>',
                    frown: '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
                    gift: '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>',
                    "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>',
                    "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>',
                    "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>',
                    "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>',
                    github: '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>',
                    gitlab: '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>',
                    globe: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>',
                    grid: '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>',
                    "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>',
                    hash: '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>',
                    headphones: '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>',
                    heart: '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>',
                    "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>',
                    hexagon: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>',
                    home: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>',
                    image: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>',
                    inbox: '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>',
                    info: '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>',
                    instagram: '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>',
                    italic: '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>',
                    key: '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>',
                    layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>',
                    layout: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>',
                    "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>',
                    "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>',
                    link: '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>',
                    linkedin: '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>',
                    list: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>',
                    loader: '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>',
                    lock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>',
                    "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>',
                    "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>',
                    mail: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>',
                    "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>',
                    map: '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>',
                    "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
                    maximize: '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>',
                    meh: '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
                    menu: '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>',
                    "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>',
                    "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>',
                    "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
                    mic: '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>',
                    "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>',
                    minimize: '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>',
                    "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>',
                    "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>',
                    minus: '<line x1="5" y1="12" x2="19" y2="12"></line>',
                    monitor: '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>',
                    moon: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>',
                    "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>',
                    "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>',
                    "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>',
                    move: '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>',
                    music: '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>',
                    "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>',
                    navigation: '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>',
                    octagon: '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>',
                    package: '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>',
                    paperclip: '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>',
                    "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>',
                    pause: '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>',
                    "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>',
                    percent: '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>',
                    "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>',
                    "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    phone: '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>',
                    "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>',
                    "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>',
                    play: '<polygon points="5 3 19 12 5 21 5 3"></polygon>',
                    "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
                    "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>',
                    plus: '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>',
                    pocket: '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>',
                    power: '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>',
                    printer: '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>',
                    radio: '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>',
                    "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>',
                    "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>',
                    repeat: '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>',
                    rewind: '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>',
                    "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>',
                    "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>',
                    rss: '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>',
                    save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>',
                    scissors: '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>',
                    search: '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>',
                    send: '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>',
                    server: '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>',
                    settings: '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>',
                    "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>',
                    share: '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>',
                    "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>',
                    "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>',
                    "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>',
                    shuffle: '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>',
                    sidebar: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>',
                    "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>',
                    "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>',
                    slack: '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>',
                    slash: '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>',
                    sliders: '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>',
                    smartphone: '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
                    smile: '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>',
                    speaker: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>',
                    square: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>',
                    star: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>',
                    "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>',
                    sun: '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>',
                    sunrise: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>',
                    sunset: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>',
                    tablet: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>',
                    tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>',
                    target: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>',
                    terminal: '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>',
                    thermometer: '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>',
                    "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>',
                    "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>',
                    "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>',
                    "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>',
                    tool: '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>',
                    "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>',
                    trash: '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>',
                    trello: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>',
                    "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>',
                    "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>',
                    triangle: '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>',
                    truck: '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>',
                    tv: '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>',
                    twitch: '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>',
                    twitter: '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>',
                    type: '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>',
                    umbrella: '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>',
                    underline: '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>',
                    unlock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>',
                    "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>',
                    upload: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>',
                    "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>',
                    "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>',
                    "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>',
                    "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>',
                    user: '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>',
                    users: '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>',
                    "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>',
                    video: '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>',
                    voicemail: '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>',
                    "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
                    "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>',
                    "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>',
                    volume: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>',
                    watch: '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>',
                    "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
                    wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>',
                    wind: '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>',
                    "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
                    "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>',
                    "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>',
                    x: '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>',
                    youtube: '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>',
                    "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>',
                    zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>',
                    "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>',
                    "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>'
                }
            }, "./node_modules/classnames/dedupe.js": function (t, e, n) {
                var a;
                !function () {
                    "use strict";
                    var n = function () {
                        function t() {
                        }

                        function e(t, e) {
                            for (var n = e.length, a = 0; a < n; ++a) i(t, e[a])
                        }

                        t.prototype = Object.create(null);
                        var n = {}.hasOwnProperty, a = /\s+/;

                        function i(t, i) {
                            if (i) {
                                var r = typeof i;
                                "string" === r ? function (t, e) {
                                    for (var n = e.split(a), i = n.length, r = 0; r < i; ++r) t[n[r]] = !0
                                }(t, i) : Array.isArray(i) ? e(t, i) : "object" === r ? function (t, e) {
                                    for (var a in e) n.call(e, a) && (t[a] = !!e[a])
                                }(t, i) : "number" === r && function (t, e) {
                                    t[e] = !0
                                }(t, i)
                            }
                        }

                        return function () {
                            for (var n = arguments.length, a = Array(n), i = 0; i < n; i++) a[i] = arguments[i];
                            var r = new t;
                            e(r, a);
                            var o = [];
                            for (var s in r) r[s] && o.push(s);
                            return o.join(" ")
                        }
                    }();
                    void 0 !== t && t.exports ? t.exports = n : void 0 === (a = function () {
                        return n
                    }.apply(e, [])) || (t.exports = a)
                }()
            }, "./node_modules/core-js/es/array/from.js": function (t, e, n) {
                n("./node_modules/core-js/modules/es.string.iterator.js"), n("./node_modules/core-js/modules/es.array.from.js");
                var a = n("./node_modules/core-js/internals/path.js");
                t.exports = a.Array.from
            }, "./node_modules/core-js/internals/a-function.js": function (t, e) {
                t.exports = function (t) {
                    if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
                    return t
                }
            }, "./node_modules/core-js/internals/an-object.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/is-object.js");
                t.exports = function (t) {
                    if (!a(t)) throw TypeError(String(t) + " is not an object");
                    return t
                }
            }, "./node_modules/core-js/internals/array-from.js": function (t, e, n) {
                "use strict";
                var a = n("./node_modules/core-js/internals/bind-context.js"),
                    i = n("./node_modules/core-js/internals/to-object.js"),
                    r = n("./node_modules/core-js/internals/call-with-safe-iteration-closing.js"),
                    o = n("./node_modules/core-js/internals/is-array-iterator-method.js"),
                    s = n("./node_modules/core-js/internals/to-length.js"),
                    l = n("./node_modules/core-js/internals/create-property.js"),
                    c = n("./node_modules/core-js/internals/get-iterator-method.js");
                t.exports = function (t) {
                    var e, n, d, u, h = i(t), p = "function" == typeof this ? this : Array, f = arguments.length,
                        g = f > 1 ? arguments[1] : void 0, m = void 0 !== g, v = 0, b = c(h);
                    if (m && (g = a(g, f > 2 ? arguments[2] : void 0, 2)), null == b || p == Array && o(b)) for (n = new p(e = s(h.length)); e > v; v++) l(n, v, m ? g(h[v], v) : h[v]); else for (u = b.call(h), n = new p; !(d = u.next()).done; v++) l(n, v, m ? r(u, g, [d.value, v], !0) : d.value);
                    return n.length = v, n
                }
            }, "./node_modules/core-js/internals/array-includes.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/to-indexed-object.js"),
                    i = n("./node_modules/core-js/internals/to-length.js"),
                    r = n("./node_modules/core-js/internals/to-absolute-index.js");
                t.exports = function (t) {
                    return function (e, n, o) {
                        var s, l = a(e), c = i(l.length), d = r(o, c);
                        if (t && n != n) {
                            for (; c > d;) if ((s = l[d++]) != s) return !0
                        } else for (; c > d; d++) if ((t || d in l) && l[d] === n) return t || d || 0;
                        return !t && -1
                    }
                }
            }, "./node_modules/core-js/internals/bind-context.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/a-function.js");
                t.exports = function (t, e, n) {
                    if (a(t), void 0 === e) return t;
                    switch (n) {
                        case 0:
                            return function () {
                                return t.call(e)
                            };
                        case 1:
                            return function (n) {
                                return t.call(e, n)
                            };
                        case 2:
                            return function (n, a) {
                                return t.call(e, n, a)
                            };
                        case 3:
                            return function (n, a, i) {
                                return t.call(e, n, a, i)
                            }
                    }
                    return function () {
                        return t.apply(e, arguments)
                    }
                }
            }, "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/an-object.js");
                t.exports = function (t, e, n, i) {
                    try {
                        return i ? e(a(n)[0], n[1]) : e(n)
                    } catch (e) {
                        var r = t.return;
                        throw void 0 !== r && a(r.call(t)), e
                    }
                }
            }, "./node_modules/core-js/internals/check-correctness-of-iteration.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/well-known-symbol.js")("iterator"), i = !1;
                try {
                    var r = 0, o = {
                        next: function () {
                            return {done: !!r++}
                        }, return: function () {
                            i = !0
                        }
                    };
                    o[a] = function () {
                        return this
                    }, Array.from(o, (function () {
                        throw 2
                    }))
                } catch (t) {
                }
                t.exports = function (t, e) {
                    if (!e && !i) return !1;
                    var n = !1;
                    try {
                        var r = {};
                        r[a] = function () {
                            return {
                                next: function () {
                                    return {done: n = !0}
                                }
                            }
                        }, t(r)
                    } catch (t) {
                    }
                    return n
                }
            }, "./node_modules/core-js/internals/classof-raw.js": function (t, e) {
                var n = {}.toString;
                t.exports = function (t) {
                    return n.call(t).slice(8, -1)
                }
            }, "./node_modules/core-js/internals/classof.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/classof-raw.js"),
                    i = n("./node_modules/core-js/internals/well-known-symbol.js")("toStringTag"),
                    r = "Arguments" == a(function () {
                        return arguments
                    }());
                t.exports = function (t) {
                    var e, n, o;
                    return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) {
                        try {
                            return t[e]
                        } catch (t) {
                        }
                    }(e = Object(t), i)) ? n : r ? a(e) : "Object" == (o = a(e)) && "function" == typeof e.callee ? "Arguments" : o
                }
            }, "./node_modules/core-js/internals/copy-constructor-properties.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/has.js"),
                    i = n("./node_modules/core-js/internals/own-keys.js"),
                    r = n("./node_modules/core-js/internals/object-get-own-property-descriptor.js"),
                    o = n("./node_modules/core-js/internals/object-define-property.js");
                t.exports = function (t, e) {
                    for (var n = i(e), s = o.f, l = r.f, c = 0; c < n.length; c++) {
                        var d = n[c];
                        a(t, d) || s(t, d, l(e, d))
                    }
                }
            }, "./node_modules/core-js/internals/correct-prototype-getter.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/fails.js");
                t.exports = !a((function () {
                    function t() {
                    }

                    return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
                }))
            }, "./node_modules/core-js/internals/create-iterator-constructor.js": function (t, e, n) {
                "use strict";
                var a = n("./node_modules/core-js/internals/iterators-core.js").IteratorPrototype,
                    i = n("./node_modules/core-js/internals/object-create.js"),
                    r = n("./node_modules/core-js/internals/create-property-descriptor.js"),
                    o = n("./node_modules/core-js/internals/set-to-string-tag.js"),
                    s = n("./node_modules/core-js/internals/iterators.js"), l = function () {
                        return this
                    };
                t.exports = function (t, e, n) {
                    var c = e + " Iterator";
                    return t.prototype = i(a, {next: r(1, n)}), o(t, c, !1, !0), s[c] = l, t
                }
            }, "./node_modules/core-js/internals/create-property-descriptor.js": function (t, e) {
                t.exports = function (t, e) {
                    return {enumerable: !(1 & t), configurable: !(2 & t), writable: !(4 & t), value: e}
                }
            }, "./node_modules/core-js/internals/create-property.js": function (t, e, n) {
                "use strict";
                var a = n("./node_modules/core-js/internals/to-primitive.js"),
                    i = n("./node_modules/core-js/internals/object-define-property.js"),
                    r = n("./node_modules/core-js/internals/create-property-descriptor.js");
                t.exports = function (t, e, n) {
                    var o = a(e);
                    o in t ? i.f(t, o, r(0, n)) : t[o] = n
                }
            }, "./node_modules/core-js/internals/define-iterator.js": function (t, e, n) {
                "use strict";
                var a = n("./node_modules/core-js/internals/export.js"),
                    i = n("./node_modules/core-js/internals/create-iterator-constructor.js"),
                    r = n("./node_modules/core-js/internals/object-get-prototype-of.js"),
                    o = n("./node_modules/core-js/internals/object-set-prototype-of.js"),
                    s = n("./node_modules/core-js/internals/set-to-string-tag.js"),
                    l = n("./node_modules/core-js/internals/hide.js"),
                    c = n("./node_modules/core-js/internals/redefine.js"),
                    d = n("./node_modules/core-js/internals/well-known-symbol.js"),
                    u = n("./node_modules/core-js/internals/is-pure.js"),
                    h = n("./node_modules/core-js/internals/iterators.js"),
                    p = n("./node_modules/core-js/internals/iterators-core.js"), f = p.IteratorPrototype,
                    g = p.BUGGY_SAFARI_ITERATORS, m = d("iterator"), v = "keys", b = "values", y = "entries",
                    x = function () {
                        return this
                    };
                t.exports = function (t, e, n, d, p, _, w) {
                    i(n, e, d);
                    var S, C, k, D = function (t) {
                            if (t === p && M) return M;
                            if (!g && t in A) return A[t];
                            switch (t) {
                                case v:
                                case b:
                                case y:
                                    return function () {
                                        return new n(this, t)
                                    }
                            }
                            return function () {
                                return new n(this)
                            }
                        }, T = e + " Iterator", E = !1, A = t.prototype, I = A[m] || A["@@iterator"] || p && A[p],
                        M = !g && I || D(p), R = "Array" == e && A.entries || I;
                    if (R && (S = r(R.call(new t)), f !== Object.prototype && S.next && (u || r(S) === f || (o ? o(S, f) : "function" != typeof S[m] && l(S, m, x)), s(S, T, !0, !0), u && (h[T] = x))), p == b && I && I.name !== b && (E = !0, M = function () {
                        return I.call(this)
                    }), u && !w || A[m] === M || l(A, m, M), h[e] = M, p) if (C = {
                        values: D(b),
                        keys: _ ? M : D(v),
                        entries: D(y)
                    }, w) for (k in C) (g || E || !(k in A)) && c(A, k, C[k]); else a({
                        target: e,
                        proto: !0,
                        forced: g || E
                    }, C);
                    return C
                }
            }, "./node_modules/core-js/internals/descriptors.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/fails.js");
                t.exports = !a((function () {
                    return 7 != Object.defineProperty({}, "a", {
                        get: function () {
                            return 7
                        }
                    }).a
                }))
            }, "./node_modules/core-js/internals/document-create-element.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/is-object.js"), r = a.document,
                    o = i(r) && i(r.createElement);
                t.exports = function (t) {
                    return o ? r.createElement(t) : {}
                }
            }, "./node_modules/core-js/internals/enum-bug-keys.js": function (t, e) {
                t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
            }, "./node_modules/core-js/internals/export.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f,
                    r = n("./node_modules/core-js/internals/hide.js"),
                    o = n("./node_modules/core-js/internals/redefine.js"),
                    s = n("./node_modules/core-js/internals/set-global.js"),
                    l = n("./node_modules/core-js/internals/copy-constructor-properties.js"),
                    c = n("./node_modules/core-js/internals/is-forced.js");
                t.exports = function (t, e) {
                    var n, d, u, h, p, f = t.target, g = t.global, m = t.stat;
                    if (n = g ? a : m ? a[f] || s(f, {}) : (a[f] || {}).prototype) for (d in e) {
                        if (h = e[d], u = t.noTargetGet ? (p = i(n, d)) && p.value : n[d], !c(g ? d : f + (m ? "." : "#") + d, t.forced) && void 0 !== u) {
                            if (typeof h == typeof u) continue;
                            l(h, u)
                        }
                        (t.sham || u && u.sham) && r(h, "sham", !0), o(n, d, h, t)
                    }
                }
            }, "./node_modules/core-js/internals/fails.js": function (t, e) {
                t.exports = function (t) {
                    try {
                        return !!t()
                    } catch (t) {
                        return !0
                    }
                }
            }, "./node_modules/core-js/internals/function-to-string.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/shared.js");
                t.exports = a("native-function-to-string", Function.toString)
            }, "./node_modules/core-js/internals/get-iterator-method.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/classof.js"),
                    i = n("./node_modules/core-js/internals/iterators.js"),
                    r = n("./node_modules/core-js/internals/well-known-symbol.js")("iterator");
                t.exports = function (t) {
                    if (null != t) return t[r] || t["@@iterator"] || i[a(t)]
                }
            }, "./node_modules/core-js/internals/global.js": function (t, e, n) {
                (function (e) {
                    var n = "object", a = function (t) {
                        return t && t.Math == Math && t
                    };
                    t.exports = a(typeof globalThis == n && globalThis) || a(typeof window == n && window) || a(typeof self == n && self) || a(typeof e == n && e) || Function("return this")()
                }).call(this, n("./node_modules/webpack/buildin/global.js"))
            }, "./node_modules/core-js/internals/has.js": function (t, e) {
                var n = {}.hasOwnProperty;
                t.exports = function (t, e) {
                    return n.call(t, e)
                }
            }, "./node_modules/core-js/internals/hidden-keys.js": function (t, e) {
                t.exports = {}
            }, "./node_modules/core-js/internals/hide.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/descriptors.js"),
                    i = n("./node_modules/core-js/internals/object-define-property.js"),
                    r = n("./node_modules/core-js/internals/create-property-descriptor.js");
                t.exports = a ? function (t, e, n) {
                    return i.f(t, e, r(1, n))
                } : function (t, e, n) {
                    return t[e] = n, t
                }
            }, "./node_modules/core-js/internals/html.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js").document;
                t.exports = a && a.documentElement
            }, "./node_modules/core-js/internals/ie8-dom-define.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/descriptors.js"),
                    i = n("./node_modules/core-js/internals/fails.js"),
                    r = n("./node_modules/core-js/internals/document-create-element.js");
                t.exports = !a && !i((function () {
                    return 7 != Object.defineProperty(r("div"), "a", {
                        get: function () {
                            return 7
                        }
                    }).a
                }))
            }, "./node_modules/core-js/internals/indexed-object.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/fails.js"),
                    i = n("./node_modules/core-js/internals/classof-raw.js"), r = "".split;
                t.exports = a((function () {
                    return !Object("z").propertyIsEnumerable(0)
                })) ? function (t) {
                    return "String" == i(t) ? r.call(t, "") : Object(t)
                } : Object
            }, "./node_modules/core-js/internals/internal-state.js": function (t, e, n) {
                var a, i, r, o = n("./node_modules/core-js/internals/native-weak-map.js"),
                    s = n("./node_modules/core-js/internals/global.js"),
                    l = n("./node_modules/core-js/internals/is-object.js"),
                    c = n("./node_modules/core-js/internals/hide.js"), d = n("./node_modules/core-js/internals/has.js"),
                    u = n("./node_modules/core-js/internals/shared-key.js"),
                    h = n("./node_modules/core-js/internals/hidden-keys.js"), p = s.WeakMap;
                if (o) {
                    var f = new p, g = f.get, m = f.has, v = f.set;
                    a = function (t, e) {
                        return v.call(f, t, e), e
                    }, i = function (t) {
                        return g.call(f, t) || {}
                    }, r = function (t) {
                        return m.call(f, t)
                    }
                } else {
                    var b = u("state");
                    h[b] = !0, a = function (t, e) {
                        return c(t, b, e), e
                    }, i = function (t) {
                        return d(t, b) ? t[b] : {}
                    }, r = function (t) {
                        return d(t, b)
                    }
                }
                t.exports = {
                    set: a, get: i, has: r, enforce: function (t) {
                        return r(t) ? i(t) : a(t, {})
                    }, getterFor: function (t) {
                        return function (e) {
                            var n;
                            if (!l(e) || (n = i(e)).type !== t) throw TypeError("Incompatible receiver, " + t + " required");
                            return n
                        }
                    }
                }
            }, "./node_modules/core-js/internals/is-array-iterator-method.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/well-known-symbol.js"),
                    i = n("./node_modules/core-js/internals/iterators.js"), r = a("iterator"), o = Array.prototype;
                t.exports = function (t) {
                    return void 0 !== t && (i.Array === t || o[r] === t)
                }
            }, "./node_modules/core-js/internals/is-forced.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/fails.js"), i = /#|\.prototype\./, r = function (t, e) {
                    var n = s[o(t)];
                    return n == c || n != l && ("function" == typeof e ? a(e) : !!e)
                }, o = r.normalize = function (t) {
                    return String(t).replace(i, ".").toLowerCase()
                }, s = r.data = {}, l = r.NATIVE = "N", c = r.POLYFILL = "P";
                t.exports = r
            }, "./node_modules/core-js/internals/is-object.js": function (t, e) {
                t.exports = function (t) {
                    return "object" == typeof t ? null !== t : "function" == typeof t
                }
            }, "./node_modules/core-js/internals/is-pure.js": function (t, e) {
                t.exports = !1
            }, "./node_modules/core-js/internals/iterators-core.js": function (t, e, n) {
                "use strict";
                var a, i, r, o = n("./node_modules/core-js/internals/object-get-prototype-of.js"),
                    s = n("./node_modules/core-js/internals/hide.js"), l = n("./node_modules/core-js/internals/has.js"),
                    c = n("./node_modules/core-js/internals/well-known-symbol.js"),
                    d = n("./node_modules/core-js/internals/is-pure.js"), u = c("iterator"), h = !1;
                [].keys && ("next" in (r = [].keys()) ? (i = o(o(r))) !== Object.prototype && (a = i) : h = !0), null == a && (a = {}), d || l(a, u) || s(a, u, (function () {
                    return this
                })), t.exports = {IteratorPrototype: a, BUGGY_SAFARI_ITERATORS: h}
            }, "./node_modules/core-js/internals/iterators.js": function (t, e) {
                t.exports = {}
            }, "./node_modules/core-js/internals/native-symbol.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/fails.js");
                t.exports = !!Object.getOwnPropertySymbols && !a((function () {
                    return !String(Symbol())
                }))
            }, "./node_modules/core-js/internals/native-weak-map.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/function-to-string.js"), r = a.WeakMap;
                t.exports = "function" == typeof r && /native code/.test(i.call(r))
            }, "./node_modules/core-js/internals/object-create.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/an-object.js"),
                    i = n("./node_modules/core-js/internals/object-define-properties.js"),
                    r = n("./node_modules/core-js/internals/enum-bug-keys.js"),
                    o = n("./node_modules/core-js/internals/hidden-keys.js"),
                    s = n("./node_modules/core-js/internals/html.js"),
                    l = n("./node_modules/core-js/internals/document-create-element.js"),
                    c = n("./node_modules/core-js/internals/shared-key.js")("IE_PROTO"), d = function () {
                    }, u = function () {
                        var t, e = l("iframe"), n = r.length;
                        for (e.style.display = "none", s.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write("<script>document.F=Object<\/script>"), t.close(), u = t.F; n--;) delete u.prototype[r[n]];
                        return u()
                    };
                t.exports = Object.create || function (t, e) {
                    var n;
                    return null !== t ? (d.prototype = a(t), n = new d, d.prototype = null, n[c] = t) : n = u(), void 0 === e ? n : i(n, e)
                }, o[c] = !0
            }, "./node_modules/core-js/internals/object-define-properties.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/descriptors.js"),
                    i = n("./node_modules/core-js/internals/object-define-property.js"),
                    r = n("./node_modules/core-js/internals/an-object.js"),
                    o = n("./node_modules/core-js/internals/object-keys.js");
                t.exports = a ? Object.defineProperties : function (t, e) {
                    r(t);
                    for (var n, a = o(e), s = a.length, l = 0; s > l;) i.f(t, n = a[l++], e[n]);
                    return t
                }
            }, "./node_modules/core-js/internals/object-define-property.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/descriptors.js"),
                    i = n("./node_modules/core-js/internals/ie8-dom-define.js"),
                    r = n("./node_modules/core-js/internals/an-object.js"),
                    o = n("./node_modules/core-js/internals/to-primitive.js"), s = Object.defineProperty;
                e.f = a ? s : function (t, e, n) {
                    if (r(t), e = o(e, !0), r(n), i) try {
                        return s(t, e, n)
                    } catch (t) {
                    }
                    if ("get" in n || "set" in n) throw TypeError("Accessors not supported");
                    return "value" in n && (t[e] = n.value), t
                }
            }, "./node_modules/core-js/internals/object-get-own-property-descriptor.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/descriptors.js"),
                    i = n("./node_modules/core-js/internals/object-property-is-enumerable.js"),
                    r = n("./node_modules/core-js/internals/create-property-descriptor.js"),
                    o = n("./node_modules/core-js/internals/to-indexed-object.js"),
                    s = n("./node_modules/core-js/internals/to-primitive.js"),
                    l = n("./node_modules/core-js/internals/has.js"),
                    c = n("./node_modules/core-js/internals/ie8-dom-define.js"), d = Object.getOwnPropertyDescriptor;
                e.f = a ? d : function (t, e) {
                    if (t = o(t), e = s(e, !0), c) try {
                        return d(t, e)
                    } catch (t) {
                    }
                    if (l(t, e)) return r(!i.f.call(t, e), t[e])
                }
            }, "./node_modules/core-js/internals/object-get-own-property-names.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/object-keys-internal.js"),
                    i = n("./node_modules/core-js/internals/enum-bug-keys.js").concat("length", "prototype");
                e.f = Object.getOwnPropertyNames || function (t) {
                    return a(t, i)
                }
            }, "./node_modules/core-js/internals/object-get-own-property-symbols.js": function (t, e) {
                e.f = Object.getOwnPropertySymbols
            }, "./node_modules/core-js/internals/object-get-prototype-of.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/has.js"),
                    i = n("./node_modules/core-js/internals/to-object.js"),
                    r = n("./node_modules/core-js/internals/shared-key.js"),
                    o = n("./node_modules/core-js/internals/correct-prototype-getter.js"), s = r("IE_PROTO"),
                    l = Object.prototype;
                t.exports = o ? Object.getPrototypeOf : function (t) {
                    return t = i(t), a(t, s) ? t[s] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? l : null
                }
            }, "./node_modules/core-js/internals/object-keys-internal.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/has.js"),
                    i = n("./node_modules/core-js/internals/to-indexed-object.js"),
                    r = n("./node_modules/core-js/internals/array-includes.js"),
                    o = n("./node_modules/core-js/internals/hidden-keys.js"), s = r(!1);
                t.exports = function (t, e) {
                    var n, r = i(t), l = 0, c = [];
                    for (n in r) !a(o, n) && a(r, n) && c.push(n);
                    for (; e.length > l;) a(r, n = e[l++]) && (~s(c, n) || c.push(n));
                    return c
                }
            }, "./node_modules/core-js/internals/object-keys.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/object-keys-internal.js"),
                    i = n("./node_modules/core-js/internals/enum-bug-keys.js");
                t.exports = Object.keys || function (t) {
                    return a(t, i)
                }
            }, "./node_modules/core-js/internals/object-property-is-enumerable.js": function (t, e, n) {
                "use strict";
                var a = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, r = i && !a.call({1: 2}, 1);
                e.f = r ? function (t) {
                    var e = i(this, t);
                    return !!e && e.enumerable
                } : a
            }, "./node_modules/core-js/internals/object-set-prototype-of.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/validate-set-prototype-of-arguments.js");
                t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () {
                    var t, e = !1, n = {};
                    try {
                        (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), e = n instanceof Array
                    } catch (t) {
                    }
                    return function (n, i) {
                        return a(n, i), e ? t.call(n, i) : n.__proto__ = i, n
                    }
                }() : void 0)
            }, "./node_modules/core-js/internals/own-keys.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/object-get-own-property-names.js"),
                    r = n("./node_modules/core-js/internals/object-get-own-property-symbols.js"),
                    o = n("./node_modules/core-js/internals/an-object.js"), s = a.Reflect;
                t.exports = s && s.ownKeys || function (t) {
                    var e = i.f(o(t)), n = r.f;
                    return n ? e.concat(n(t)) : e
                }
            }, "./node_modules/core-js/internals/path.js": function (t, e, n) {
                t.exports = n("./node_modules/core-js/internals/global.js")
            }, "./node_modules/core-js/internals/redefine.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/shared.js"),
                    r = n("./node_modules/core-js/internals/hide.js"), o = n("./node_modules/core-js/internals/has.js"),
                    s = n("./node_modules/core-js/internals/set-global.js"),
                    l = n("./node_modules/core-js/internals/function-to-string.js"),
                    c = n("./node_modules/core-js/internals/internal-state.js"), d = c.get, u = c.enforce,
                    h = String(l).split("toString");
                i("inspectSource", (function (t) {
                    return l.call(t)
                })), (t.exports = function (t, e, n, i) {
                    var l = !!i && !!i.unsafe, c = !!i && !!i.enumerable, d = !!i && !!i.noTargetGet;
                    "function" == typeof n && ("string" != typeof e || o(n, "name") || r(n, "name", e), u(n).source = h.join("string" == typeof e ? e : "")), t !== a ? (l ? !d && t[e] && (c = !0) : delete t[e], c ? t[e] = n : r(t, e, n)) : c ? t[e] = n : s(e, n)
                })(Function.prototype, "toString", (function () {
                    return "function" == typeof this && d(this).source || l.call(this)
                }))
            }, "./node_modules/core-js/internals/require-object-coercible.js": function (t, e) {
                t.exports = function (t) {
                    if (null == t) throw TypeError("Can't call method on " + t);
                    return t
                }
            }, "./node_modules/core-js/internals/set-global.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/hide.js");
                t.exports = function (t, e) {
                    try {
                        i(a, t, e)
                    } catch (n) {
                        a[t] = e
                    }
                    return e
                }
            }, "./node_modules/core-js/internals/set-to-string-tag.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/object-define-property.js").f,
                    i = n("./node_modules/core-js/internals/has.js"),
                    r = n("./node_modules/core-js/internals/well-known-symbol.js")("toStringTag");
                t.exports = function (t, e, n) {
                    t && !i(t = n ? t : t.prototype, r) && a(t, r, {configurable: !0, value: e})
                }
            }, "./node_modules/core-js/internals/shared-key.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/shared.js"),
                    i = n("./node_modules/core-js/internals/uid.js"), r = a("keys");
                t.exports = function (t) {
                    return r[t] || (r[t] = i(t))
                }
            }, "./node_modules/core-js/internals/shared.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/set-global.js"),
                    r = n("./node_modules/core-js/internals/is-pure.js"), o = "__core-js_shared__",
                    s = a[o] || i(o, {});
                (t.exports = function (t, e) {
                    return s[t] || (s[t] = void 0 !== e ? e : {})
                })("versions", []).push({
                    version: "3.1.3",
                    mode: r ? "pure" : "global",
                    copyright: "Â© 2019 Denis Pushkarev (zloirock.ru)"
                })
            }, "./node_modules/core-js/internals/string-at.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/to-integer.js"),
                    i = n("./node_modules/core-js/internals/require-object-coercible.js");
                t.exports = function (t, e, n) {
                    var r, o, s = String(i(t)), l = a(e), c = s.length;
                    return l < 0 || l >= c ? n ? "" : void 0 : (r = s.charCodeAt(l)) < 55296 || r > 56319 || l + 1 === c || (o = s.charCodeAt(l + 1)) < 56320 || o > 57343 ? n ? s.charAt(l) : r : n ? s.slice(l, l + 2) : o - 56320 + (r - 55296 << 10) + 65536
                }
            }, "./node_modules/core-js/internals/to-absolute-index.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/to-integer.js"), i = Math.max, r = Math.min;
                t.exports = function (t, e) {
                    var n = a(t);
                    return n < 0 ? i(n + e, 0) : r(n, e)
                }
            }, "./node_modules/core-js/internals/to-indexed-object.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/indexed-object.js"),
                    i = n("./node_modules/core-js/internals/require-object-coercible.js");
                t.exports = function (t) {
                    return a(i(t))
                }
            }, "./node_modules/core-js/internals/to-integer.js": function (t, e) {
                var n = Math.ceil, a = Math.floor;
                t.exports = function (t) {
                    return isNaN(t = +t) ? 0 : (t > 0 ? a : n)(t)
                }
            }, "./node_modules/core-js/internals/to-length.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/to-integer.js"), i = Math.min;
                t.exports = function (t) {
                    return t > 0 ? i(a(t), 9007199254740991) : 0
                }
            }, "./node_modules/core-js/internals/to-object.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/require-object-coercible.js");
                t.exports = function (t) {
                    return Object(a(t))
                }
            }, "./node_modules/core-js/internals/to-primitive.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/is-object.js");
                t.exports = function (t, e) {
                    if (!a(t)) return t;
                    var n, i;
                    if (e && "function" == typeof (n = t.toString) && !a(i = n.call(t))) return i;
                    if ("function" == typeof (n = t.valueOf) && !a(i = n.call(t))) return i;
                    if (!e && "function" == typeof (n = t.toString) && !a(i = n.call(t))) return i;
                    throw TypeError("Can't convert object to primitive value")
                }
            }, "./node_modules/core-js/internals/uid.js": function (t, e) {
                var n = 0, a = Math.random();
                t.exports = function (t) {
                    return "Symbol(".concat(void 0 === t ? "" : t, ")_", (++n + a).toString(36))
                }
            }, "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/is-object.js"),
                    i = n("./node_modules/core-js/internals/an-object.js");
                t.exports = function (t, e) {
                    if (i(t), !a(e) && null !== e) throw TypeError("Can't set " + String(e) + " as a prototype")
                }
            }, "./node_modules/core-js/internals/well-known-symbol.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/global.js"),
                    i = n("./node_modules/core-js/internals/shared.js"),
                    r = n("./node_modules/core-js/internals/uid.js"),
                    o = n("./node_modules/core-js/internals/native-symbol.js"), s = a.Symbol, l = i("wks");
                t.exports = function (t) {
                    return l[t] || (l[t] = o && s[t] || (o ? s : r)("Symbol." + t))
                }
            }, "./node_modules/core-js/modules/es.array.from.js": function (t, e, n) {
                var a = n("./node_modules/core-js/internals/export.js"),
                    i = n("./node_modules/core-js/internals/array-from.js");
                a({
                    target: "Array",
                    stat: !0,
                    forced: !n("./node_modules/core-js/internals/check-correctness-of-iteration.js")((function (t) {
                        Array.from(t)
                    }))
                }, {from: i})
            }, "./node_modules/core-js/modules/es.string.iterator.js": function (t, e, n) {
                "use strict";
                var a = n("./node_modules/core-js/internals/string-at.js"),
                    i = n("./node_modules/core-js/internals/internal-state.js"),
                    r = n("./node_modules/core-js/internals/define-iterator.js"), o = "String Iterator", s = i.set,
                    l = i.getterFor(o);
                r(String, "String", (function (t) {
                    s(this, {type: o, string: String(t), index: 0})
                }), (function () {
                    var t, e = l(this), n = e.string, i = e.index;
                    return i >= n.length ? {value: void 0, done: !0} : (t = a(n, i, !0), e.index += t.length, {
                        value: t,
                        done: !1
                    })
                }))
            }, "./node_modules/webpack/buildin/global.js": function (t, e) {
                var n;
                n = function () {
                    return this
                }();
                try {
                    n = n || Function("return this")() || (0, eval)("this")
                } catch (t) {
                    "object" == typeof window && (n = window)
                }
                t.exports = n
            }, "./src/default-attrs.json": function (t) {
                t.exports = {
                    xmlns: "http://www.w3.org/2000/svg",
                    width: 24,
                    height: 24,
                    viewBox: "0 0 24 24",
                    fill: "none",
                    stroke: "currentColor",
                    "stroke-width": 2,
                    "stroke-linecap": "round",
                    "stroke-linejoin": "round"
                }
            }, "./src/icon.js": function (t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {value: !0});
                var a = Object.assign || function (t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var n = arguments[e];
                        for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
                    }
                    return t
                }, i = function () {
                    function t(t, e) {
                        for (var n = 0; n < e.length; n++) {
                            var a = e[n];
                            a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
                        }
                    }

                    return function (e, n, a) {
                        return n && t(e.prototype, n), a && t(e, a), e
                    }
                }(), r = s(n("./node_modules/classnames/dedupe.js")), o = s(n("./src/default-attrs.json"));

                function s(t) {
                    return t && t.__esModule ? t : {default: t}
                }

                function l(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                var c = function () {
                    function t(e, n) {
                        var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [];
                        l(this, t), this.name = e, this.contents = n, this.tags = i, this.attrs = a({}, o.default, {class: "feather feather-" + e})
                    }

                    return i(t, [{
                        key: "toSvg", value: function () {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                e = a({}, this.attrs, t, {class: (0, r.default)(this.attrs.class, t.class)});
                            return "<svg " + d(e) + ">" + this.contents + "</svg>"
                        }
                    }, {
                        key: "toString", value: function () {
                            return this.contents
                        }
                    }]), t
                }();

                function d(t) {
                    return Object.keys(t).map((function (e) {
                        return e + '="' + t[e] + '"'
                    })).join(" ")
                }

                e.default = c
            }, "./src/icons.js": function (t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {value: !0});
                var a = o(n("./src/icon.js")), i = o(n("./dist/icons.json")), r = o(n("./src/tags.json"));

                function o(t) {
                    return t && t.__esModule ? t : {default: t}
                }

                e.default = Object.keys(i.default).map((function (t) {
                    return new a.default(t, i.default[t], r.default[t])
                })).reduce((function (t, e) {
                    return t[e.name] = e, t
                }), {})
            }, "./src/index.js": function (t, e, n) {
                "use strict";
                var a = o(n("./src/icons.js")), i = o(n("./src/to-svg.js")), r = o(n("./src/replace.js"));

                function o(t) {
                    return t && t.__esModule ? t : {default: t}
                }

                t.exports = {icons: a.default, toSvg: i.default, replace: r.default}
            }, "./src/replace.js": function (t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {value: !0});
                var a = Object.assign || function (t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var n = arguments[e];
                        for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
                    }
                    return t
                }, i = o(n("./node_modules/classnames/dedupe.js")), r = o(n("./src/icons.js"));

                function o(t) {
                    return t && t.__esModule ? t : {default: t}
                }

                function s(t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = l(t),
                        o = n["data-feather"];
                    delete n["data-feather"];
                    var s = r.default[o].toSvg(a({}, e, n, {class: (0, i.default)(e.class, n.class)})),
                        c = (new DOMParser).parseFromString(s, "image/svg+xml"), d = c.querySelector("svg");
                    t.parentNode.replaceChild(d, t)
                }

                function l(t) {
                    return Array.from(t.attributes).reduce((function (t, e) {
                        return t[e.name] = e.value, t
                    }), {})
                }

                e.default = function () {
                    var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    if ("undefined" == typeof document) throw new Error("`feather.replace()` only works in a browser environment.");
                    var e = document.querySelectorAll("[data-feather]");
                    Array.from(e).forEach((function (e) {
                        return s(e, t)
                    }))
                }
            }, "./src/tags.json": function (t) {
                t.exports = {
                    activity: ["pulse", "health", "action", "motion"],
                    airplay: ["stream", "cast", "mirroring"],
                    "alert-circle": ["warning", "alert", "danger"],
                    "alert-octagon": ["warning", "alert", "danger"],
                    "alert-triangle": ["warning", "alert", "danger"],
                    "align-center": ["text alignment", "center"],
                    "align-justify": ["text alignment", "justified"],
                    "align-left": ["text alignment", "left"],
                    "align-right": ["text alignment", "right"],
                    anchor: [],
                    archive: ["index", "box"],
                    "at-sign": ["mention", "at", "email", "message"],
                    award: ["achievement", "badge"],
                    aperture: ["camera", "photo"],
                    "bar-chart": ["statistics", "diagram", "graph"],
                    "bar-chart-2": ["statistics", "diagram", "graph"],
                    battery: ["power", "electricity"],
                    "battery-charging": ["power", "electricity"],
                    bell: ["alarm", "notification", "sound"],
                    "bell-off": ["alarm", "notification", "silent"],
                    bluetooth: ["wireless"],
                    "book-open": ["read", "library"],
                    book: ["read", "dictionary", "booklet", "magazine", "library"],
                    bookmark: ["read", "clip", "marker", "tag"],
                    box: ["cube"],
                    briefcase: ["work", "bag", "baggage", "folder"],
                    calendar: ["date"],
                    camera: ["photo"],
                    cast: ["chromecast", "airplay"],
                    circle: ["off", "zero", "record"],
                    clipboard: ["copy"],
                    clock: ["time", "watch", "alarm"],
                    "cloud-drizzle": ["weather", "shower"],
                    "cloud-lightning": ["weather", "bolt"],
                    "cloud-rain": ["weather"],
                    "cloud-snow": ["weather", "blizzard"],
                    cloud: ["weather"],
                    codepen: ["logo"],
                    codesandbox: ["logo"],
                    code: ["source", "programming"],
                    coffee: ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"],
                    columns: ["layout"],
                    command: ["keyboard", "cmd", "terminal", "prompt"],
                    compass: ["navigation", "safari", "travel", "direction"],
                    copy: ["clone", "duplicate"],
                    "corner-down-left": ["arrow", "return"],
                    "corner-down-right": ["arrow"],
                    "corner-left-down": ["arrow"],
                    "corner-left-up": ["arrow"],
                    "corner-right-down": ["arrow"],
                    "corner-right-up": ["arrow"],
                    "corner-up-left": ["arrow"],
                    "corner-up-right": ["arrow"],
                    cpu: ["processor", "technology"],
                    "credit-card": ["purchase", "payment", "cc"],
                    crop: ["photo", "image"],
                    crosshair: ["aim", "target"],
                    database: ["storage", "memory"],
                    delete: ["remove"],
                    disc: ["album", "cd", "dvd", "music"],
                    "dollar-sign": ["currency", "money", "payment"],
                    droplet: ["water"],
                    edit: ["pencil", "change"],
                    "edit-2": ["pencil", "change"],
                    "edit-3": ["pencil", "change"],
                    eye: ["view", "watch"],
                    "eye-off": ["view", "watch", "hide", "hidden"],
                    "external-link": ["outbound"],
                    facebook: ["logo", "social"],
                    "fast-forward": ["music"],
                    figma: ["logo", "design", "tool"],
                    "file-minus": ["delete", "remove", "erase"],
                    "file-plus": ["add", "create", "new"],
                    "file-text": ["data", "txt", "pdf"],
                    film: ["movie", "video"],
                    filter: ["funnel", "hopper"],
                    flag: ["report"],
                    "folder-minus": ["directory"],
                    "folder-plus": ["directory"],
                    folder: ["directory"],
                    framer: ["logo", "design", "tool"],
                    frown: ["emoji", "face", "bad", "sad", "emotion"],
                    gift: ["present", "box", "birthday", "party"],
                    "git-branch": ["code", "version control"],
                    "git-commit": ["code", "version control"],
                    "git-merge": ["code", "version control"],
                    "git-pull-request": ["code", "version control"],
                    github: ["logo", "version control"],
                    gitlab: ["logo", "version control"],
                    globe: ["world", "browser", "language", "translate"],
                    "hard-drive": ["computer", "server", "memory", "data"],
                    hash: ["hashtag", "number", "pound"],
                    headphones: ["music", "audio", "sound"],
                    heart: ["like", "love", "emotion"],
                    "help-circle": ["question mark"],
                    hexagon: ["shape", "node.js", "logo"],
                    home: ["house", "living"],
                    image: ["picture"],
                    inbox: ["email"],
                    instagram: ["logo", "camera"],
                    key: ["password", "login", "authentication", "secure"],
                    layers: ["stack"],
                    layout: ["window", "webpage"],
                    "life-bouy": ["help", "life ring", "support"],
                    link: ["chain", "url"],
                    "link-2": ["chain", "url"],
                    linkedin: ["logo", "social media"],
                    list: ["options"],
                    lock: ["security", "password", "secure"],
                    "log-in": ["sign in", "arrow", "enter"],
                    "log-out": ["sign out", "arrow", "exit"],
                    mail: ["email", "message"],
                    "map-pin": ["location", "navigation", "travel", "marker"],
                    map: ["location", "navigation", "travel"],
                    maximize: ["fullscreen"],
                    "maximize-2": ["fullscreen", "arrows", "expand"],
                    meh: ["emoji", "face", "neutral", "emotion"],
                    menu: ["bars", "navigation", "hamburger"],
                    "message-circle": ["comment", "chat"],
                    "message-square": ["comment", "chat"],
                    "mic-off": ["record", "sound", "mute"],
                    mic: ["record", "sound", "listen"],
                    minimize: ["exit fullscreen", "close"],
                    "minimize-2": ["exit fullscreen", "arrows", "close"],
                    minus: ["subtract"],
                    monitor: ["tv", "screen", "display"],
                    moon: ["dark", "night"],
                    "more-horizontal": ["ellipsis"],
                    "more-vertical": ["ellipsis"],
                    "mouse-pointer": ["arrow", "cursor"],
                    move: ["arrows"],
                    music: ["note"],
                    navigation: ["location", "travel"],
                    "navigation-2": ["location", "travel"],
                    octagon: ["stop"],
                    package: ["box", "container"],
                    paperclip: ["attachment"],
                    pause: ["music", "stop"],
                    "pause-circle": ["music", "audio", "stop"],
                    "pen-tool": ["vector", "drawing"],
                    percent: ["discount"],
                    "phone-call": ["ring"],
                    "phone-forwarded": ["call"],
                    "phone-incoming": ["call"],
                    "phone-missed": ["call"],
                    "phone-off": ["call", "mute"],
                    "phone-outgoing": ["call"],
                    phone: ["call"],
                    play: ["music", "start"],
                    "pie-chart": ["statistics", "diagram"],
                    "play-circle": ["music", "start"],
                    plus: ["add", "new"],
                    "plus-circle": ["add", "new"],
                    "plus-square": ["add", "new"],
                    pocket: ["logo", "save"],
                    power: ["on", "off"],
                    printer: ["fax", "office", "device"],
                    radio: ["signal"],
                    "refresh-cw": ["synchronise", "arrows"],
                    "refresh-ccw": ["arrows"],
                    repeat: ["loop", "arrows"],
                    rewind: ["music"],
                    "rotate-ccw": ["arrow"],
                    "rotate-cw": ["arrow"],
                    rss: ["feed", "subscribe"],
                    save: ["floppy disk"],
                    scissors: ["cut"],
                    search: ["find", "magnifier", "magnifying glass"],
                    send: ["message", "mail", "email", "paper airplane", "paper aeroplane"],
                    settings: ["cog", "edit", "gear", "preferences"],
                    "share-2": ["network", "connections"],
                    shield: ["security", "secure"],
                    "shield-off": ["security", "insecure"],
                    "shopping-bag": ["ecommerce", "cart", "purchase", "store"],
                    "shopping-cart": ["ecommerce", "cart", "purchase", "store"],
                    shuffle: ["music"],
                    "skip-back": ["music"],
                    "skip-forward": ["music"],
                    slack: ["logo"],
                    slash: ["ban", "no"],
                    sliders: ["settings", "controls"],
                    smartphone: ["cellphone", "device"],
                    smile: ["emoji", "face", "happy", "good", "emotion"],
                    speaker: ["audio", "music"],
                    star: ["bookmark", "favorite", "like"],
                    "stop-circle": ["media", "music"],
                    sun: ["brightness", "weather", "light"],
                    sunrise: ["weather", "time", "morning", "day"],
                    sunset: ["weather", "time", "evening", "night"],
                    tablet: ["device"],
                    tag: ["label"],
                    target: ["logo", "bullseye"],
                    terminal: ["code", "command line", "prompt"],
                    thermometer: ["temperature", "celsius", "fahrenheit", "weather"],
                    "thumbs-down": ["dislike", "bad", "emotion"],
                    "thumbs-up": ["like", "good", "emotion"],
                    "toggle-left": ["on", "off", "switch"],
                    "toggle-right": ["on", "off", "switch"],
                    tool: ["settings", "spanner"],
                    trash: ["garbage", "delete", "remove", "bin"],
                    "trash-2": ["garbage", "delete", "remove", "bin"],
                    triangle: ["delta"],
                    truck: ["delivery", "van", "shipping", "transport", "lorry"],
                    tv: ["television", "stream"],
                    twitch: ["logo"],
                    twitter: ["logo", "social"],
                    type: ["text"],
                    umbrella: ["rain", "weather"],
                    unlock: ["security"],
                    "user-check": ["followed", "subscribed"],
                    "user-minus": ["delete", "remove", "unfollow", "unsubscribe"],
                    "user-plus": ["new", "add", "create", "follow", "subscribe"],
                    "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"],
                    user: ["person", "account"],
                    users: ["group"],
                    "video-off": ["camera", "movie", "film"],
                    video: ["camera", "movie", "film"],
                    voicemail: ["phone"],
                    volume: ["music", "sound", "mute"],
                    "volume-1": ["music", "sound"],
                    "volume-2": ["music", "sound"],
                    "volume-x": ["music", "sound", "mute"],
                    watch: ["clock", "time"],
                    "wifi-off": ["disabled"],
                    wifi: ["connection", "signal", "wireless"],
                    wind: ["weather", "air"],
                    "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"],
                    "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"],
                    "x-square": ["cancel", "close", "delete", "remove", "times", "clear"],
                    x: ["cancel", "close", "delete", "remove", "times", "clear"],
                    youtube: ["logo", "video", "play"],
                    "zap-off": ["flash", "camera", "lightning"],
                    zap: ["flash", "camera", "lightning"],
                    "zoom-in": ["magnifying glass"],
                    "zoom-out": ["magnifying glass"]
                }
            }, "./src/to-svg.js": function (t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {value: !0});
                var a, i = n("./src/icons.js"), r = (a = i) && a.__esModule ? a : {default: a};
                e.default = function (t) {
                    var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                    if (console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead."), !t) throw new Error("The required `key` (icon name) parameter is missing.");
                    if (!r.default[t]) throw new Error("No icon matching '" + t + "'. See the complete list of icons at https://feathericons.com");
                    return r.default[t].toSvg(e)
                }
            }, 0: function (t, e, n) {
                n("./node_modules/core-js/es/array/from.js"), t.exports = n("./src/index.js")
            }
        })
    }, t.exports = a()
}, function (t, e, n) {
    (function (e) {
        var n = "Expected a function", a = /^\s+|\s+$/g, i = /^[-+]0x[0-9a-f]+$/i, r = /^0b[01]+$/i, o = /^0o[0-7]+$/i,
            s = parseInt, l = "object" == typeof e && e && e.Object === Object && e,
            c = "object" == typeof self && self && self.Object === Object && self,
            d = l || c || Function("return this")(), u = Object.prototype.toString, h = Math.max, p = Math.min,
            f = function () {
                return d.Date.now()
            };

        function g(t, e, a) {
            var i, r, o, s, l, c, d = 0, u = !1, g = !1, b = !0;
            if ("function" != typeof t) throw new TypeError(n);

            function y(e) {
                var n = i, a = r;
                return i = r = void 0, d = e, s = t.apply(a, n)
            }

            function x(t) {
                return d = t, l = setTimeout(w, e), u ? y(t) : s
            }

            function _(t) {
                var n = t - c;
                return void 0 === c || n >= e || n < 0 || g && t - d >= o
            }

            function w() {
                var t = f();
                if (_(t)) return S(t);
                l = setTimeout(w, function (t) {
                    var n = e - (t - c);
                    return g ? p(n, o - (t - d)) : n
                }(t))
            }

            function S(t) {
                return l = void 0, b && i ? y(t) : (i = r = void 0, s)
            }

            function C() {
                var t = f(), n = _(t);
                if (i = arguments, r = this, c = t, n) {
                    if (void 0 === l) return x(c);
                    if (g) return l = setTimeout(w, e), y(c)
                }
                return void 0 === l && (l = setTimeout(w, e)), s
            }

            return e = v(e) || 0, m(a) && (u = !!a.leading, o = (g = "maxWait" in a) ? h(v(a.maxWait) || 0, e) : o, b = "trailing" in a ? !!a.trailing : b), C.cancel = function () {
                void 0 !== l && clearTimeout(l), d = 0, i = c = r = l = void 0
            }, C.flush = function () {
                return void 0 === l ? s : S(f())
            }, C
        }

        function m(t) {
            var e = typeof t;
            return !!t && ("object" == e || "function" == e)
        }

        function v(t) {
            if ("number" == typeof t) return t;
            if (function (t) {
                return "symbol" == typeof t || function (t) {
                    return !!t && "object" == typeof t
                }(t) && "[object Symbol]" == u.call(t)
            }(t)) return NaN;
            if (m(t)) {
                var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                t = m(e) ? e + "" : e
            }
            if ("string" != typeof t) return 0 === t ? t : +t;
            t = t.replace(a, "");
            var n = r.test(t);
            return n || o.test(t) ? s(t.slice(2), n ? 2 : 8) : i.test(t) ? NaN : +t
        }

        t.exports = function (t, e, a) {
            var i = !0, r = !0;
            if ("function" != typeof t) throw new TypeError(n);
            return m(a) && (i = "leading" in a ? !!a.leading : i, r = "trailing" in a ? !!a.trailing : r), g(t, e, {
                leading: i,
                maxWait: e,
                trailing: r
            })
        }
    }).call(this, n(3))
}, function (t, e, n) {
    (function (e) {
        var n = /^\s+|\s+$/g, a = /^[-+]0x[0-9a-f]+$/i, i = /^0b[01]+$/i, r = /^0o[0-7]+$/i, o = parseInt,
            s = "object" == typeof e && e && e.Object === Object && e,
            l = "object" == typeof self && self && self.Object === Object && self,
            c = s || l || Function("return this")(), d = Object.prototype.toString, u = Math.max, h = Math.min,
            p = function () {
                return c.Date.now()
            };

        function f(t) {
            var e = typeof t;
            return !!t && ("object" == e || "function" == e)
        }

        function g(t) {
            if ("number" == typeof t) return t;
            if (function (t) {
                return "symbol" == typeof t || function (t) {
                    return !!t && "object" == typeof t
                }(t) && "[object Symbol]" == d.call(t)
            }(t)) return NaN;
            if (f(t)) {
                var e = "function" == typeof t.valueOf ? t.valueOf() : t;
                t = f(e) ? e + "" : e
            }
            if ("string" != typeof t) return 0 === t ? t : +t;
            t = t.replace(n, "");
            var s = i.test(t);
            return s || r.test(t) ? o(t.slice(2), s ? 2 : 8) : a.test(t) ? NaN : +t
        }

        t.exports = function (t, e, n) {
            var a, i, r, o, s, l, c = 0, d = !1, m = !1, v = !0;
            if ("function" != typeof t) throw new TypeError("Expected a function");

            function b(e) {
                var n = a, r = i;
                return a = i = void 0, c = e, o = t.apply(r, n)
            }

            function y(t) {
                return c = t, s = setTimeout(_, e), d ? b(t) : o
            }

            function x(t) {
                var n = t - l;
                return void 0 === l || n >= e || n < 0 || m && t - c >= r
            }

            function _() {
                var t = p();
                if (x(t)) return w(t);
                s = setTimeout(_, function (t) {
                    var n = e - (t - l);
                    return m ? h(n, r - (t - c)) : n
                }(t))
            }

            function w(t) {
                return s = void 0, v && a ? b(t) : (a = i = void 0, o)
            }

            function S() {
                var t = p(), n = x(t);
                if (a = arguments, i = this, l = t, n) {
                    if (void 0 === s) return y(l);
                    if (m) return s = setTimeout(_, e), b(l)
                }
                return void 0 === s && (s = setTimeout(_, e)), o
            }

            return e = g(e) || 0, f(n) && (d = !!n.leading, r = (m = "maxWait" in n) ? u(g(n.maxWait) || 0, e) : r, v = "trailing" in n ? !!n.trailing : v), S.cancel = function () {
                void 0 !== s && clearTimeout(s), c = 0, a = l = i = s = void 0
            }, S.flush = function () {
                return void 0 === s ? o : w(p())
            }, S
        }
    }).call(this, n(3))
}, function (t, e, n) {
    var a = n(36), i = n(118), r = n(101), o = n(72), s = n(119), l = n(19), c = n(120),
        d = Object.getOwnPropertyDescriptor;
    e.f = a ? d : function (t, e) {
        if (t = o(t), e = s(e, !0), c) try {
            return d(t, e)
        } catch (t) {
        }
        if (l(t, e)) return r(!i.f.call(t, e), t[e])
    }
}, function (t, e, n) {
    "use strict";
    var a = {}.propertyIsEnumerable, i = Object.getOwnPropertyDescriptor, r = i && !a.call({1: 2}, 1);
    e.f = r ? function (t) {
        var e = i(this, t);
        return !!e && e.enumerable
    } : a
}, function (t, e, n) {
    var a = n(22);
    t.exports = function (t, e) {
        if (!a(t)) return t;
        var n, i;
        if (e && "function" == typeof (n = t.toString) && !a(i = n.call(t))) return i;
        if ("function" == typeof (n = t.valueOf) && !a(i = n.call(t))) return i;
        if (!e && "function" == typeof (n = t.toString) && !a(i = n.call(t))) return i;
        throw TypeError("Can't convert object to primitive value")
    }
}, function (t, e, n) {
    var a = n(36), i = n(13), r = n(121);
    t.exports = !a && !i((function () {
        return 7 != Object.defineProperty(r("div"), "a", {
            get: function () {
                return 7
            }
        }).a
    }))
}, function (t, e, n) {
    var a = n(7), i = n(22), r = a.document, o = i(r) && i(r.createElement);
    t.exports = function (t) {
        return o ? r.createElement(t) : {}
    }
}, function (t, e, n) {
    var a = n(123), i = Function.toString;
    "function" != typeof a.inspectSource && (a.inspectSource = function (t) {
        return i.call(t)
    }), t.exports = a.inspectSource
}, function (t, e, n) {
    var a = n(7), i = n(102), r = "__core-js_shared__", o = a[r] || i(r, {});
    t.exports = o
}, function (t, e, n) {
    var a = n(7), i = n(122), r = a.WeakMap;
    t.exports = "function" == typeof r && /native code/.test(i(r))
}, function (t, e, n) {
    var a = n(104), i = n(123);
    (t.exports = function (t, e) {
        return i[t] || (i[t] = void 0 !== e ? e : {})
    })("versions", []).push({
        version: "3.6.5",
        mode: a ? "pure" : "global",
        copyright: "Â© 2020 Denis Pushkarev (zloirock.ru)"
    })
}, function (t, e, n) {
    var a = n(19), i = n(72), r = n(182).indexOf, o = n(75);
    t.exports = function (t, e) {
        var n, s = i(t), l = 0, c = [];
        for (n in s) !a(o, n) && a(s, n) && c.push(n);
        for (; e.length > l;) a(s, n = e[l++]) && (~r(c, n) || c.push(n));
        return c
    }
}, function (t, e) {
    e.f = Object.getOwnPropertySymbols
}, function (t, e, n) {
    var a = n(13), i = /#|\.prototype\./, r = function (t, e) {
        var n = s[o(t)];
        return n == c || n != l && ("function" == typeof e ? a(e) : !!e)
    }, o = r.normalize = function (t) {
        return String(t).replace(i, ".").toLowerCase()
    }, s = r.data = {}, l = r.NATIVE = "N", c = r.POLYFILL = "P";
    t.exports = r
}, function (t, e, n) {
    "use strict";
    var a = n(108).forEach, i = n(133), r = n(109), o = i("forEach"), s = r("forEach");
    t.exports = o && s ? [].forEach : function (t) {
        return a(this, t, arguments.length > 1 ? arguments[1] : void 0)
    }
}, function (t, e, n) {
    var a = n(131);
    t.exports = function (t, e, n) {
        if (a(t), void 0 === e) return t;
        switch (n) {
            case 0:
                return function () {
                    return t.call(e)
                };
            case 1:
                return function (n) {
                    return t.call(e, n)
                };
            case 2:
                return function (n, a) {
                    return t.call(e, n, a)
                };
            case 3:
                return function (n, a, i) {
                    return t.call(e, n, a, i)
                }
        }
        return function () {
            return t.apply(e, arguments)
        }
    }
}, function (t, e) {
    t.exports = function (t) {
        if ("function" != typeof t) throw TypeError(String(t) + " is not a function");
        return t
    }
}, function (t, e, n) {
    var a = n(13);
    t.exports = !!Object.getOwnPropertySymbols && !a((function () {
        return !String(Symbol())
    }))
}, function (t, e, n) {
    "use strict";
    var a = n(13);
    t.exports = function (t, e) {
        var n = [][t];
        return !!n && a((function () {
            n.call(null, e || function () {
                throw 1
            }, 1)
        }))
    }
}, function (t, e) {
    t.exports = {
        CSSRuleList: 0,
        CSSStyleDeclaration: 0,
        CSSValueList: 0,
        ClientRectList: 0,
        DOMRectList: 0,
        DOMStringList: 0,
        DOMTokenList: 1,
        DataTransferItemList: 0,
        FileList: 0,
        HTMLAllCollection: 0,
        HTMLCollection: 0,
        HTMLFormElement: 0,
        HTMLSelectElement: 0,
        MediaList: 0,
        MimeTypeArray: 0,
        NamedNodeMap: 0,
        NodeList: 1,
        PaintRequestList: 0,
        Plugin: 0,
        PluginArray: 0,
        SVGLengthList: 0,
        SVGNumberList: 0,
        SVGPathSegList: 0,
        SVGPointList: 0,
        SVGStringList: 0,
        SVGTransformList: 0,
        SourceBufferList: 0,
        StyleSheetList: 0,
        TextTrackCueList: 0,
        TextTrackList: 0,
        TouchList: 0
    }
}, function (t, e, n) {
    "use strict";
    var a = n(72), i = n(192), r = n(59), o = n(57), s = n(138), l = "Array Iterator", c = o.set, d = o.getterFor(l);
    t.exports = s(Array, "Array", (function (t, e) {
        c(this, {type: l, target: a(t), index: 0, kind: e})
    }), (function () {
        var t = d(this), e = t.target, n = t.kind, a = t.index++;
        return !e || a >= e.length ? (t.target = void 0, {value: void 0, done: !0}) : "keys" == n ? {
            value: a,
            done: !1
        } : "values" == n ? {value: e[a], done: !1} : {value: [a, e[a]], done: !1}
    }), "values"), r.Arguments = r.Array, i("keys"), i("values"), i("entries")
}, function (t, e, n) {
    var a, i = n(23), r = n(193), o = n(107), s = n(75), l = n(194), c = n(121), d = n(103), u = d("IE_PROTO"),
        h = function () {
        }, p = function (t) {
            return "<script>" + t + "</" + "script>"
        }, f = function () {
            try {
                a = document.domain && new ActiveXObject("htmlfile")
            } catch (t) {
            }
            var t, e;
            f = a ? function (t) {
                t.write(p("")), t.close();
                var e = t.parentWindow.Object;
                return t = null, e
            }(a) : ((e = c("iframe")).style.display = "none", l.appendChild(e), e.src = String("javascript:"), (t = e.contentWindow.document).open(), t.write(p("document.F=Object")), t.close(), t.F);
            for (var n = o.length; n--;) delete f.prototype[o[n]];
            return f()
        };
    s[u] = !0, t.exports = Object.create || function (t, e) {
        var n;
        return null !== t ? (h.prototype = i(t), n = new h, h.prototype = null, n[u] = t) : n = f(), void 0 === e ? n : r(n, e)
    }
}, function (t, e, n) {
    var a = n(126), i = n(107);
    t.exports = Object.keys || function (t) {
        return a(t, i)
    }
}, function (t, e, n) {
    "use strict";
    var a = n(35), i = n(195), r = n(140), o = n(141), s = n(110), l = n(32), c = n(47), d = n(15), u = n(104),
        h = n(59), p = n(139), f = p.IteratorPrototype, g = p.BUGGY_SAFARI_ITERATORS, m = d("iterator"), v = "keys",
        b = "values", y = "entries", x = function () {
            return this
        };
    t.exports = function (t, e, n, d, p, _, w) {
        i(n, e, d);
        var S, C, k, D = function (t) {
                if (t === p && M) return M;
                if (!g && t in A) return A[t];
                switch (t) {
                    case v:
                    case b:
                    case y:
                        return function () {
                            return new n(this, t)
                        }
                }
                return function () {
                    return new n(this)
                }
            }, T = e + " Iterator", E = !1, A = t.prototype, I = A[m] || A["@@iterator"] || p && A[p], M = !g && I || D(p),
            R = "Array" == e && A.entries || I;
        if (R && (S = r(R.call(new t)), f !== Object.prototype && S.next && (u || r(S) === f || (o ? o(S, f) : "function" != typeof S[m] && l(S, m, x)), s(S, T, !0, !0), u && (h[T] = x))), p == b && I && I.name !== b && (E = !0, M = function () {
            return I.call(this)
        }), u && !w || A[m] === M || l(A, m, M), h[e] = M, p) if (C = {
            values: D(b),
            keys: _ ? M : D(v),
            entries: D(y)
        }, w) for (k in C) (g || E || !(k in A)) && c(A, k, C[k]); else a({target: e, proto: !0, forced: g || E}, C);
        return C
    }
}, function (t, e, n) {
    "use strict";
    var a, i, r, o = n(140), s = n(32), l = n(19), c = n(15), d = n(104), u = c("iterator"), h = !1;
    [].keys && ("next" in (r = [].keys()) ? (i = o(o(r))) !== Object.prototype && (a = i) : h = !0), null == a && (a = {}), d || l(a, u) || s(a, u, (function () {
        return this
    })), t.exports = {IteratorPrototype: a, BUGGY_SAFARI_ITERATORS: h}
}, function (t, e, n) {
    var a = n(19), i = n(58), r = n(103), o = n(196), s = r("IE_PROTO"), l = Object.prototype;
    t.exports = o ? Object.getPrototypeOf : function (t) {
        return t = i(t), a(t, s) ? t[s] : "function" == typeof t.constructor && t instanceof t.constructor ? t.constructor.prototype : t instanceof Object ? l : null
    }
}, function (t, e, n) {
    var a = n(23), i = n(197);
    t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () {
        var t, e = !1, n = {};
        try {
            (t = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set).call(n, []), e = n instanceof Array
        } catch (t) {
        }
        return function (n, r) {
            return a(n), i(r), e ? t.call(n, r) : n.__proto__ = r, n
        }
    }() : void 0)
}, function (t, e, n) {
    var a = n(111), i = n(74), r = n(15)("toStringTag"), o = "Arguments" == i(function () {
        return arguments
    }());
    t.exports = a ? i : function (t) {
        var e, n, a;
        return void 0 === t ? "Undefined" : null === t ? "Null" : "string" == typeof (n = function (t, e) {
            try {
                return t[e]
            } catch (t) {
            }
        }(e = Object(t), r)) ? n : o ? i(e) : "Object" == (a = i(e)) && "function" == typeof e.callee ? "Arguments" : a
    }
}, function (t, e) {
    t.exports = "\t\n\v\f\r Â áš€â€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€¯âŸã€€\u2028\u2029\ufeff"
}, function (t, e, n) {
    var a = n(76), i = n(46), r = function (t) {
        return function (e, n) {
            var r, o, s = String(i(e)), l = a(n), c = s.length;
            return l < 0 || l >= c ? t ? "" : void 0 : (r = s.charCodeAt(l)) < 55296 || r > 56319 || l + 1 === c || (o = s.charCodeAt(l + 1)) < 56320 || o > 57343 ? t ? s.charAt(l) : r : t ? s.slice(l, l + 2) : o - 56320 + (r - 55296 << 10) + 65536
        }
    };
    t.exports = {codeAt: r(!1), charAt: r(!0)}
}, function (t, e, n) {
    var a = n(47);
    t.exports = function (t, e, n) {
        for (var i in e) a(t, i, e[i], n);
        return t
    }
}, function (t, e, n) {
    var a = n(23), i = n(209), r = n(48), o = n(130), s = n(210), l = n(211), c = function (t, e) {
        this.stopped = t, this.result = e
    };
    (t.exports = function (t, e, n, d, u) {
        var h, p, f, g, m, v, b, y = o(e, n, d ? 2 : 1);
        if (u) h = t; else {
            if ("function" != typeof (p = s(t))) throw TypeError("Target is not iterable");
            if (i(p)) {
                for (f = 0, g = r(t.length); g > f; f++) if ((m = d ? y(a(b = t[f])[0], b[1]) : y(t[f])) && m instanceof c) return m;
                return new c(!1)
            }
            h = p.call(t)
        }
        for (v = h.next; !(b = v.call(h)).done;) if ("object" == typeof (m = l(h, y, b.value, d)) && m && m instanceof c) return m;
        return new c(!1)
    }).stop = function (t) {
        return new c(!0, t)
    }
}, function (t, e) {
    t.exports = function (t, e, n) {
        if (!(t instanceof e)) throw TypeError("Incorrect " + (n ? n + " " : "") + "invocation");
        return t
    }
}, function (t, e, n) {
    "use strict";
    var a = n(35), i = n(113);
    a({target: "RegExp", proto: !0, forced: /./.exec !== i}, {exec: i})
}, function (t, e, n) {
    "use strict";
    n(148);
    var a = n(47), i = n(13), r = n(15), o = n(113), s = n(32), l = r("species"), c = !i((function () {
            var t = /./;
            return t.exec = function () {
                var t = [];
                return t.groups = {a: "7"}, t
            }, "7" !== "".replace(t, "$<a>")
        })), d = "$0" === "a".replace(/./, "$0"), u = r("replace"), h = !!/./[u] && "" === /./[u]("a", "$0"),
        p = !i((function () {
            var t = /(?:)/, e = t.exec;
            t.exec = function () {
                return e.apply(this, arguments)
            };
            var n = "ab".split(t);
            return 2 !== n.length || "a" !== n[0] || "b" !== n[1]
        }));
    t.exports = function (t, e, n, u) {
        var f = r(t), g = !i((function () {
            var e = {};
            return e[f] = function () {
                return 7
            }, 7 != ""[t](e)
        })), m = g && !i((function () {
            var e = !1, n = /a/;
            return "split" === t && ((n = {}).constructor = {}, n.constructor[l] = function () {
                return n
            }, n.flags = "", n[f] = /./[f]), n.exec = function () {
                return e = !0, null
            }, n[f](""), !e
        }));
        if (!g || !m || "replace" === t && (!c || !d || h) || "split" === t && !p) {
            var v = /./[f], b = n(f, ""[t], (function (t, e, n, a, i) {
                return e.exec === o ? g && !i ? {done: !0, value: v.call(e, n, a)} : {
                    done: !0,
                    value: t.call(n, e, a)
                } : {done: !1}
            }), {REPLACE_KEEPS_$0: d, REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: h}), y = b[0], x = b[1];
            a(String.prototype, t, y), a(RegExp.prototype, f, 2 == e ? function (t, e) {
                return x.call(t, this, e)
            } : function (t) {
                return x.call(t, this)
            })
        }
        u && s(RegExp.prototype[f], "sham", !0)
    }
}, function (t, e, n) {
    "use strict";
    var a = n(144).charAt;
    t.exports = function (t, e, n) {
        return e + (n ? a(t, e).length : 1)
    }
}, function (t, e, n) {
    var a = n(74), i = n(113);
    t.exports = function (t, e) {
        var n = t.exec;
        if ("function" == typeof n) {
            var r = n.call(t, e);
            if ("object" != typeof r) throw TypeError("RegExp exec method returned something other than an Object or null");
            return r
        }
        if ("RegExp" !== a(t)) throw TypeError("RegExp#exec called on incompatible receiver");
        return i.call(t, e)
    }
}, function (t, e, n) {
    var a, i, r;
    i = [n(16)], void 0 === (r = "function" == typeof (a = function (t) {
        t.extend(t.fn, {
            validate: function (e) {
                if (this.length) {
                    var n = t.data(this[0], "validator");
                    return n || (this.attr("novalidate", "novalidate"), n = new t.validator(e, this[0]), t.data(this[0], "validator", n), n.settings.onsubmit && (this.on("click.validate", ":submit", (function (e) {
                        n.submitButton = e.currentTarget, t(this).hasClass("cancel") && (n.cancelSubmit = !0), void 0 !== t(this).attr("formnovalidate") && (n.cancelSubmit = !0)
                    })), this.on("submit.validate", (function (e) {
                        function a() {
                            var a, i;
                            return n.submitButton && (n.settings.submitHandler || n.formSubmitted) && (a = t("<input type='hidden'/>").attr("name", n.submitButton.name).val(t(n.submitButton).val()).appendTo(n.currentForm)), !(n.settings.submitHandler && !n.settings.debug) || (i = n.settings.submitHandler.call(n, n.currentForm, e), a && a.remove(), void 0 !== i && i)
                        }

                        return n.settings.debug && e.preventDefault(), n.cancelSubmit ? (n.cancelSubmit = !1, a()) : n.form() ? n.pendingRequest ? (n.formSubmitted = !0, !1) : a() : (n.focusInvalid(), !1)
                    }))), n)
                }
                e && e.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing.")
            }, valid: function () {
                var e, n, a;
                return t(this[0]).is("form") ? e = this.validate().form() : (a = [], e = !0, n = t(this[0].form).validate(), this.each((function () {
                    (e = n.element(this) && e) || (a = a.concat(n.errorList))
                })), n.errorList = a), e
            }, rules: function (e, n) {
                var a, i, r, o, s, l, c = this[0],
                    d = void 0 !== this.attr("contenteditable") && "false" !== this.attr("contenteditable");
                if (null != c && (!c.form && d && (c.form = this.closest("form")[0], c.name = this.attr("name")), null != c.form)) {
                    if (e) switch (i = (a = t.data(c.form, "validator").settings).rules, r = t.validator.staticRules(c), e) {
                        case"add":
                            t.extend(r, t.validator.normalizeRule(n)), delete r.messages, i[c.name] = r, n.messages && (a.messages[c.name] = t.extend(a.messages[c.name], n.messages));
                            break;
                        case"remove":
                            return n ? (l = {}, t.each(n.split(/\s/), (function (t, e) {
                                l[e] = r[e], delete r[e]
                            })), l) : (delete i[c.name], r)
                    }
                    return (o = t.validator.normalizeRules(t.extend({}, t.validator.classRules(c), t.validator.attributeRules(c), t.validator.dataRules(c), t.validator.staticRules(c)), c)).required && (s = o.required, delete o.required, o = t.extend({required: s}, o)), o.remote && (s = o.remote, delete o.remote, o = t.extend(o, {remote: s})), o
                }
            }
        });
        var e, n = function (t) {
            return t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
        };
        t.extend(t.expr.pseudos || t.expr[":"], {
            blank: function (e) {
                return !n("" + t(e).val())
            }, filled: function (e) {
                var a = t(e).val();
                return null !== a && !!n("" + a)
            }, unchecked: function (e) {
                return !t(e).prop("checked")
            }
        }), t.validator = function (e, n) {
            this.settings = t.extend(!0, {}, t.validator.defaults, e), this.currentForm = n, this.init()
        }, t.validator.format = function (e, n) {
            return 1 === arguments.length ? function () {
                var n = t.makeArray(arguments);
                return n.unshift(e), t.validator.format.apply(this, n)
            } : (void 0 === n || (arguments.length > 2 && n.constructor !== Array && (n = t.makeArray(arguments).slice(1)), n.constructor !== Array && (n = [n]), t.each(n, (function (t, n) {
                e = e.replace(new RegExp("\\{" + t + "\\}", "g"), (function () {
                    return n
                }))
            }))), e)
        }, t.extend(t.validator, {
            defaults: {
                messages: {},
                groups: {},
                rules: {},
                errorClass: "error",
                pendingClass: "pending",
                validClass: "valid",
                errorElement: "label",
                focusCleanup: !1,
                focusInvalid: !0,
                errorContainer: t([]),
                errorLabelContainer: t([]),
                onsubmit: !0,
                ignore: ":hidden",
                ignoreTitle: !1,
                onfocusin: function (t) {
                    this.lastActive = t, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, t, this.settings.errorClass, this.settings.validClass), this.hideThese(this.errorsFor(t)))
                },
                onfocusout: function (t) {
                    this.checkable(t) || !(t.name in this.submitted) && this.optional(t) || this.element(t)
                },
                onkeyup: function (e, n) {
                    var a = [16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225];
                    9 === n.which && "" === this.elementValue(e) || -1 !== t.inArray(n.keyCode, a) || (e.name in this.submitted || e.name in this.invalid) && this.element(e)
                },
                onclick: function (t) {
                    t.name in this.submitted ? this.element(t) : t.parentNode.name in this.submitted && this.element(t.parentNode)
                },
                highlight: function (e, n, a) {
                    "radio" === e.type ? this.findByName(e.name).addClass(n).removeClass(a) : t(e).addClass(n).removeClass(a)
                },
                unhighlight: function (e, n, a) {
                    "radio" === e.type ? this.findByName(e.name).removeClass(n).addClass(a) : t(e).removeClass(n).addClass(a)
                }
            },
            setDefaults: function (e) {
                t.extend(t.validator.defaults, e)
            },
            messages: {
                required: "This field is required.",
                remote: "Please fix this field.",
                email: "Please enter a valid email address.",
                url: "Please enter a valid URL.",
                date: "Please enter a valid date.",
                dateISO: "Please enter a valid date (ISO).",
                number: "Please enter a valid number.",
                digits: "Please enter only digits.",
                equalTo: "Please enter the same value again.",
                maxlength: t.validator.format("Please enter no more than {0} characters."),
                minlength: t.validator.format("Please enter at least {0} characters."),
                rangelength: t.validator.format("Please enter a value between {0} and {1} characters long."),
                range: t.validator.format("Please enter a value between {0} and {1}."),
                max: t.validator.format("Please enter a value less than or equal to {0}."),
                min: t.validator.format("Please enter a value greater than or equal to {0}."),
                step: t.validator.format("Please enter a multiple of {0}.")
            },
            autoCreateRanges: !1,
            prototype: {
                init: function () {
                    this.labelContainer = t(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || t(this.currentForm), this.containers = t(this.settings.errorContainer).add(this.settings.errorLabelContainer), this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, this.invalid = {}, this.reset();
                    var e, n = this.currentForm, a = this.groups = {};

                    function i(e) {
                        var a = void 0 !== t(this).attr("contenteditable") && "false" !== t(this).attr("contenteditable");
                        if (!this.form && a && (this.form = t(this).closest("form")[0], this.name = t(this).attr("name")), n === this.form) {
                            var i = t.data(this.form, "validator"), r = "on" + e.type.replace(/^validate/, ""),
                                o = i.settings;
                            o[r] && !t(this).is(o.ignore) && o[r].call(i, this, e)
                        }
                    }

                    t.each(this.settings.groups, (function (e, n) {
                        "string" == typeof n && (n = n.split(/\s/)), t.each(n, (function (t, n) {
                            a[n] = e
                        }))
                    })), e = this.settings.rules, t.each(e, (function (n, a) {
                        e[n] = t.validator.normalizeRule(a)
                    })), t(this.currentForm).on("focusin.validate focusout.validate keyup.validate", ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']", i).on("click.validate", "select, option, [type='radio'], [type='checkbox']", i), this.settings.invalidHandler && t(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler)
                }, form: function () {
                    return this.checkForm(), t.extend(this.submitted, this.errorMap), this.invalid = t.extend({}, this.errorMap), this.valid() || t(this.currentForm).triggerHandler("invalid-form", [this]), this.showErrors(), this.valid()
                }, checkForm: function () {
                    this.prepareForm();
                    for (var t = 0, e = this.currentElements = this.elements(); e[t]; t++) this.check(e[t]);
                    return this.valid()
                }, element: function (e) {
                    var n, a, i = this.clean(e), r = this.validationTargetFor(i), o = this, s = !0;
                    return void 0 === r ? delete this.invalid[i.name] : (this.prepareElement(r), this.currentElements = t(r), (a = this.groups[r.name]) && t.each(this.groups, (function (t, e) {
                        e === a && t !== r.name && (i = o.validationTargetFor(o.clean(o.findByName(t)))) && i.name in o.invalid && (o.currentElements.push(i), s = o.check(i) && s)
                    })), n = !1 !== this.check(r), s = s && n, this.invalid[r.name] = !n, this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), t(e).attr("aria-invalid", !n)), s
                }, showErrors: function (e) {
                    if (e) {
                        var n = this;
                        t.extend(this.errorMap, e), this.errorList = t.map(this.errorMap, (function (t, e) {
                            return {message: t, element: n.findByName(e)[0]}
                        })), this.successList = t.grep(this.successList, (function (t) {
                            return !(t.name in e)
                        }))
                    }
                    this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors()
                }, resetForm: function () {
                    t.fn.resetForm && t(this.currentForm).resetForm(), this.invalid = {}, this.submitted = {}, this.prepareForm(), this.hideErrors();
                    var e = this.elements().removeData("previousValue").removeAttr("aria-invalid");
                    this.resetElements(e)
                }, resetElements: function (t) {
                    var e;
                    if (this.settings.unhighlight) for (e = 0; t[e]; e++) this.settings.unhighlight.call(this, t[e], this.settings.errorClass, ""), this.findByName(t[e].name).removeClass(this.settings.validClass); else t.removeClass(this.settings.errorClass).removeClass(this.settings.validClass)
                }, numberOfInvalids: function () {
                    return this.objectLength(this.invalid)
                }, objectLength: function (t) {
                    var e, n = 0;
                    for (e in t) void 0 !== t[e] && null !== t[e] && !1 !== t[e] && n++;
                    return n
                }, hideErrors: function () {
                    this.hideThese(this.toHide)
                }, hideThese: function (t) {
                    t.not(this.containers).text(""), this.addWrapper(t).hide()
                }, valid: function () {
                    return 0 === this.size()
                }, size: function () {
                    return this.errorList.length
                }, focusInvalid: function () {
                    if (this.settings.focusInvalid) try {
                        t(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").trigger("focus").trigger("focusin")
                    } catch (t) {
                    }
                }, findLastActive: function () {
                    var e = this.lastActive;
                    return e && 1 === t.grep(this.errorList, (function (t) {
                        return t.element.name === e.name
                    })).length && e
                }, elements: function () {
                    var e = this, n = {};
                    return t(this.currentForm).find("input, select, textarea, [contenteditable]").not(":submit, :reset, :image, :disabled").not(this.settings.ignore).filter((function () {
                        var a = this.name || t(this).attr("name"),
                            i = void 0 !== t(this).attr("contenteditable") && "false" !== t(this).attr("contenteditable");
                        return !a && e.settings.debug && window.console && console.error("%o has no name assigned", this), i && (this.form = t(this).closest("form")[0], this.name = a), !(this.form !== e.currentForm || a in n || !e.objectLength(t(this).rules()) || (n[a] = !0, 0))
                    }))
                }, clean: function (e) {
                    return t(e)[0]
                }, errors: function () {
                    var e = this.settings.errorClass.split(" ").join(".");
                    return t(this.settings.errorElement + "." + e, this.errorContext)
                }, resetInternals: function () {
                    this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = t([]), this.toHide = t([])
                }, reset: function () {
                    this.resetInternals(), this.currentElements = t([])
                }, prepareForm: function () {
                    this.reset(), this.toHide = this.errors().add(this.containers)
                }, prepareElement: function (t) {
                    this.reset(), this.toHide = this.errorsFor(t)
                }, elementValue: function (e) {
                    var n, a, i = t(e), r = e.type,
                        o = void 0 !== i.attr("contenteditable") && "false" !== i.attr("contenteditable");
                    return "radio" === r || "checkbox" === r ? this.findByName(e.name).filter(":checked").val() : "number" === r && void 0 !== e.validity ? e.validity.badInput ? "NaN" : i.val() : (n = o ? i.text() : i.val(), "file" === r ? "C:\\fakepath\\" === n.substr(0, 12) ? n.substr(12) : (a = n.lastIndexOf("/")) >= 0 || (a = n.lastIndexOf("\\")) >= 0 ? n.substr(a + 1) : n : "string" == typeof n ? n.replace(/\r/g, "") : n)
                }, check: function (e) {
                    e = this.validationTargetFor(this.clean(e));
                    var n, a, i, r, o = t(e).rules(), s = t.map(o, (function (t, e) {
                        return e
                    })).length, l = !1, c = this.elementValue(e);
                    for (a in "function" == typeof o.normalizer ? r = o.normalizer : "function" == typeof this.settings.normalizer && (r = this.settings.normalizer), r && (c = r.call(e, c), delete o.normalizer), o) {
                        i = {method: a, parameters: o[a]};
                        try {
                            if ("dependency-mismatch" === (n = t.validator.methods[a].call(this, c, e, i.parameters)) && 1 === s) {
                                l = !0;
                                continue
                            }
                            if (l = !1, "pending" === n) return void (this.toHide = this.toHide.not(this.errorsFor(e)));
                            if (!n) return this.formatAndAdd(e, i), !1
                        } catch (t) {
                            throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + e.id + ", check the '" + i.method + "' method.", t), t instanceof TypeError && (t.message += ".  Exception occurred when checking element " + e.id + ", check the '" + i.method + "' method."), t
                        }
                    }
                    if (!l) return this.objectLength(o) && this.successList.push(e), !0
                }, customDataMessage: function (e, n) {
                    return t(e).data("msg" + n.charAt(0).toUpperCase() + n.substring(1).toLowerCase()) || t(e).data("msg")
                }, customMessage: function (t, e) {
                    var n = this.settings.messages[t];
                    return n && (n.constructor === String ? n : n[e])
                }, findDefined: function () {
                    for (var t = 0; t < arguments.length; t++) if (void 0 !== arguments[t]) return arguments[t]
                }, defaultMessage: function (e, n) {
                    "string" == typeof n && (n = {method: n});
                    var a = this.findDefined(this.customMessage(e.name, n.method), this.customDataMessage(e, n.method), !this.settings.ignoreTitle && e.title || void 0, t.validator.messages[n.method], "<strong>Warning: No message defined for " + e.name + "</strong>"),
                        i = /\$?\{(\d+)\}/g;
                    return "function" == typeof a ? a = a.call(this, n.parameters, e) : i.test(a) && (a = t.validator.format(a.replace(i, "{$1}"), n.parameters)), a
                }, formatAndAdd: function (t, e) {
                    var n = this.defaultMessage(t, e);
                    this.errorList.push({
                        message: n,
                        element: t,
                        method: e.method
                    }), this.errorMap[t.name] = n, this.submitted[t.name] = n
                }, addWrapper: function (t) {
                    return this.settings.wrapper && (t = t.add(t.parent(this.settings.wrapper))), t
                }, defaultShowErrors: function () {
                    var t, e, n;
                    for (t = 0; this.errorList[t]; t++) n = this.errorList[t], this.settings.highlight && this.settings.highlight.call(this, n.element, this.settings.errorClass, this.settings.validClass), this.showLabel(n.element, n.message);
                    if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) for (t = 0; this.successList[t]; t++) this.showLabel(this.successList[t]);
                    if (this.settings.unhighlight) for (t = 0, e = this.validElements(); e[t]; t++) this.settings.unhighlight.call(this, e[t], this.settings.errorClass, this.settings.validClass);
                    this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show()
                }, validElements: function () {
                    return this.currentElements.not(this.invalidElements())
                }, invalidElements: function () {
                    return t(this.errorList).map((function () {
                        return this.element
                    }))
                }, showLabel: function (e, n) {
                    var a, i, r, o, s = this.errorsFor(e), l = this.idOrName(e), c = t(e).attr("aria-describedby");
                    s.length ? (s.removeClass(this.settings.validClass).addClass(this.settings.errorClass), s.html(n)) : (a = s = t("<" + this.settings.errorElement + ">").attr("id", l + "-error").addClass(this.settings.errorClass).html(n || ""), this.settings.wrapper && (a = s.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), this.labelContainer.length ? this.labelContainer.append(a) : this.settings.errorPlacement ? this.settings.errorPlacement.call(this, a, t(e)) : a.insertAfter(e), s.is("label") ? s.attr("for", l) : 0 === s.parents("label[for='" + this.escapeCssMeta(l) + "']").length && (r = s.attr("id"), c ? c.match(new RegExp("\\b" + this.escapeCssMeta(r) + "\\b")) || (c += " " + r) : c = r, t(e).attr("aria-describedby", c), (i = this.groups[e.name]) && (o = this, t.each(o.groups, (function (e, n) {
                        n === i && t("[name='" + o.escapeCssMeta(e) + "']", o.currentForm).attr("aria-describedby", s.attr("id"))
                    }))))), !n && this.settings.success && (s.text(""), "string" == typeof this.settings.success ? s.addClass(this.settings.success) : this.settings.success(s, e)), this.toShow = this.toShow.add(s)
                }, errorsFor: function (e) {
                    var n = this.escapeCssMeta(this.idOrName(e)), a = t(e).attr("aria-describedby"),
                        i = "label[for='" + n + "'], label[for='" + n + "'] *";
                    return a && (i = i + ", #" + this.escapeCssMeta(a).replace(/\s+/g, ", #")), this.errors().filter(i)
                }, escapeCssMeta: function (t) {
                    return t.replace(/([\\!"#$%&'()*+,./:;<=>?@\[\]^`{|}~])/g, "\\$1")
                }, idOrName: function (t) {
                    return this.groups[t.name] || (this.checkable(t) ? t.name : t.id || t.name)
                }, validationTargetFor: function (e) {
                    return this.checkable(e) && (e = this.findByName(e.name)), t(e).not(this.settings.ignore)[0]
                }, checkable: function (t) {
                    return /radio|checkbox/i.test(t.type)
                }, findByName: function (e) {
                    return t(this.currentForm).find("[name='" + this.escapeCssMeta(e) + "']")
                }, getLength: function (e, n) {
                    switch (n.nodeName.toLowerCase()) {
                        case"select":
                            return t("option:selected", n).length;
                        case"input":
                            if (this.checkable(n)) return this.findByName(n.name).filter(":checked").length
                    }
                    return e.length
                }, depend: function (t, e) {
                    return !this.dependTypes[typeof t] || this.dependTypes[typeof t](t, e)
                }, dependTypes: {
                    boolean: function (t) {
                        return t
                    }, string: function (e, n) {
                        return !!t(e, n.form).length
                    }, function: function (t, e) {
                        return t(e)
                    }
                }, optional: function (e) {
                    var n = this.elementValue(e);
                    return !t.validator.methods.required.call(this, n, e) && "dependency-mismatch"
                }, startRequest: function (e) {
                    this.pending[e.name] || (this.pendingRequest++, t(e).addClass(this.settings.pendingClass), this.pending[e.name] = !0)
                }, stopRequest: function (e, n) {
                    this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[e.name], t(e).removeClass(this.settings.pendingClass), n && 0 === this.pendingRequest && this.formSubmitted && this.form() ? (t(this.currentForm).submit(), this.submitButton && t("input:hidden[name='" + this.submitButton.name + "']", this.currentForm).remove(), this.formSubmitted = !1) : !n && 0 === this.pendingRequest && this.formSubmitted && (t(this.currentForm).triggerHandler("invalid-form", [this]), this.formSubmitted = !1)
                }, previousValue: function (e, n) {
                    return n = "string" == typeof n && n || "remote", t.data(e, "previousValue") || t.data(e, "previousValue", {
                        old: null,
                        valid: !0,
                        message: this.defaultMessage(e, {method: n})
                    })
                }, destroy: function () {
                    this.resetForm(), t(this.currentForm).off(".validate").removeData("validator").find(".validate-equalTo-blur").off(".validate-equalTo").removeClass("validate-equalTo-blur").find(".validate-lessThan-blur").off(".validate-lessThan").removeClass("validate-lessThan-blur").find(".validate-lessThanEqual-blur").off(".validate-lessThanEqual").removeClass("validate-lessThanEqual-blur").find(".validate-greaterThanEqual-blur").off(".validate-greaterThanEqual").removeClass("validate-greaterThanEqual-blur").find(".validate-greaterThan-blur").off(".validate-greaterThan").removeClass("validate-greaterThan-blur")
                }
            },
            classRuleSettings: {
                required: {required: !0},
                email: {email: !0},
                url: {url: !0},
                date: {date: !0},
                dateISO: {dateISO: !0},
                number: {number: !0},
                digits: {digits: !0},
                creditcard: {creditcard: !0}
            },
            addClassRules: function (e, n) {
                e.constructor === String ? this.classRuleSettings[e] = n : t.extend(this.classRuleSettings, e)
            },
            classRules: function (e) {
                var n = {}, a = t(e).attr("class");
                return a && t.each(a.split(" "), (function () {
                    this in t.validator.classRuleSettings && t.extend(n, t.validator.classRuleSettings[this])
                })), n
            },
            normalizeAttributeRule: function (t, e, n, a) {
                /min|max|step/.test(n) && (null === e || /number|range|text/.test(e)) && (a = Number(a), isNaN(a) && (a = void 0)), a || 0 === a ? t[n] = a : e === n && "range" !== e && (t[n] = !0)
            },
            attributeRules: function (e) {
                var n, a, i = {}, r = t(e), o = e.getAttribute("type");
                for (n in t.validator.methods) "required" === n ? ("" === (a = e.getAttribute(n)) && (a = !0), a = !!a) : a = r.attr(n), this.normalizeAttributeRule(i, o, n, a);
                return i.maxlength && /-1|2147483647|524288/.test(i.maxlength) && delete i.maxlength, i
            },
            dataRules: function (e) {
                var n, a, i = {}, r = t(e), o = e.getAttribute("type");
                for (n in t.validator.methods) "" === (a = r.data("rule" + n.charAt(0).toUpperCase() + n.substring(1).toLowerCase())) && (a = !0), this.normalizeAttributeRule(i, o, n, a);
                return i
            },
            staticRules: function (e) {
                var n = {}, a = t.data(e.form, "validator");
                return a.settings.rules && (n = t.validator.normalizeRule(a.settings.rules[e.name]) || {}), n
            },
            normalizeRules: function (e, n) {
                return t.each(e, (function (a, i) {
                    if (!1 !== i) {
                        if (i.param || i.depends) {
                            var r = !0;
                            switch (typeof i.depends) {
                                case"string":
                                    r = !!t(i.depends, n.form).length;
                                    break;
                                case"function":
                                    r = i.depends.call(n, n)
                            }
                            r ? e[a] = void 0 === i.param || i.param : (t.data(n.form, "validator").resetElements(t(n)), delete e[a])
                        }
                    } else delete e[a]
                })), t.each(e, (function (a, i) {
                    e[a] = t.isFunction(i) && "normalizer" !== a ? i(n) : i
                })), t.each(["minlength", "maxlength"], (function () {
                    e[this] && (e[this] = Number(e[this]))
                })), t.each(["rangelength", "range"], (function () {
                    var n;
                    e[this] && (t.isArray(e[this]) ? e[this] = [Number(e[this][0]), Number(e[this][1])] : "string" == typeof e[this] && (n = e[this].replace(/[\[\]]/g, "").split(/[\s,]+/), e[this] = [Number(n[0]), Number(n[1])]))
                })), t.validator.autoCreateRanges && (null != e.min && null != e.max && (e.range = [e.min, e.max], delete e.min, delete e.max), null != e.minlength && null != e.maxlength && (e.rangelength = [e.minlength, e.maxlength], delete e.minlength, delete e.maxlength)), e
            },
            normalizeRule: function (e) {
                if ("string" == typeof e) {
                    var n = {};
                    t.each(e.split(/\s/), (function () {
                        n[this] = !0
                    })), e = n
                }
                return e
            },
            addMethod: function (e, n, a) {
                t.validator.methods[e] = n, t.validator.messages[e] = void 0 !== a ? a : t.validator.messages[e], n.length < 3 && t.validator.addClassRules(e, t.validator.normalizeRule(e))
            },
            methods: {
                required: function (e, n, a) {
                    if (!this.depend(a, n)) return "dependency-mismatch";
                    if ("select" === n.nodeName.toLowerCase()) {
                        var i = t(n).val();
                        return i && i.length > 0
                    }
                    return this.checkable(n) ? this.getLength(e, n) > 0 : null != e && e.length > 0
                }, email: function (t, e) {
                    return this.optional(e) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(t)
                }, url: function (t, e) {
                    return this.optional(e) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[/?#]\S*)?$/i.test(t)
                }, date: (e = !1, function (t, n) {
                    return e || (e = !0, this.settings.debug && window.console && console.warn("The `date` method is deprecated and will be removed in version '2.0.0'.\nPlease don't use it, since it relies on the Date constructor, which\nbehaves very differently across browsers and locales. Use `dateISO`\ninstead or one of the locale specific methods in `localizations/`\nand `additional-methods.js`.")), this.optional(n) || !/Invalid|NaN/.test(new Date(t).toString())
                }), dateISO: function (t, e) {
                    return this.optional(e) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(t)
                }, number: function (t, e) {
                    return this.optional(e) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(t)
                }, digits: function (t, e) {
                    return this.optional(e) || /^\d+$/.test(t)
                }, minlength: function (e, n, a) {
                    var i = t.isArray(e) ? e.length : this.getLength(e, n);
                    return this.optional(n) || i >= a
                }, maxlength: function (e, n, a) {
                    var i = t.isArray(e) ? e.length : this.getLength(e, n);
                    return this.optional(n) || i <= a
                }, rangelength: function (e, n, a) {
                    var i = t.isArray(e) ? e.length : this.getLength(e, n);
                    return this.optional(n) || i >= a[0] && i <= a[1]
                }, min: function (t, e, n) {
                    return this.optional(e) || t >= n
                }, max: function (t, e, n) {
                    return this.optional(e) || t <= n
                }, range: function (t, e, n) {
                    return this.optional(e) || t >= n[0] && t <= n[1]
                }, step: function (e, n, a) {
                    var i, r = t(n).attr("type"), o = "Step attribute on input type " + r + " is not supported.",
                        s = ["text", "number", "range"], l = new RegExp("\\b" + r + "\\b"), c = function (t) {
                            var e = ("" + t).match(/(?:\.(\d+))?$/);
                            return e && e[1] ? e[1].length : 0
                        }, d = function (t) {
                            return Math.round(t * Math.pow(10, i))
                        }, u = !0;
                    if (r && !l.test(s.join())) throw new Error(o);
                    return i = c(a), (c(e) > i || d(e) % d(a) != 0) && (u = !1), this.optional(n) || u
                }, equalTo: function (e, n, a) {
                    var i = t(a);
                    return this.settings.onfocusout && i.not(".validate-equalTo-blur").length && i.addClass("validate-equalTo-blur").on("blur.validate-equalTo", (function () {
                        t(n).valid()
                    })), e === i.val()
                }, remote: function (e, n, a, i) {
                    if (this.optional(n)) return "dependency-mismatch";
                    i = "string" == typeof i && i || "remote";
                    var r, o, s, l = this.previousValue(n, i);
                    return this.settings.messages[n.name] || (this.settings.messages[n.name] = {}), l.originalMessage = l.originalMessage || this.settings.messages[n.name][i], this.settings.messages[n.name][i] = l.message, a = "string" == typeof a && {url: a} || a, s = t.param(t.extend({data: e}, a.data)), l.old === s ? l.valid : (l.old = s, r = this, this.startRequest(n), (o = {})[n.name] = e, t.ajax(t.extend(!0, {
                        mode: "abort",
                        port: "validate" + n.name,
                        dataType: "json",
                        data: o,
                        context: r.currentForm,
                        success: function (t) {
                            var a, o, s, c = !0 === t || "true" === t;
                            r.settings.messages[n.name][i] = l.originalMessage, c ? (s = r.formSubmitted, r.resetInternals(), r.toHide = r.errorsFor(n), r.formSubmitted = s, r.successList.push(n), r.invalid[n.name] = !1, r.showErrors()) : (a = {}, o = t || r.defaultMessage(n, {
                                method: i,
                                parameters: e
                            }), a[n.name] = l.message = o, r.invalid[n.name] = !0, r.showErrors(a)), l.valid = c, r.stopRequest(n, c)
                        }
                    }, a)), "pending")
                }
            }
        });
        var a, i = {};
        return t.ajaxPrefilter ? t.ajaxPrefilter((function (t, e, n) {
            var a = t.port;
            "abort" === t.mode && (i[a] && i[a].abort(), i[a] = n)
        })) : (a = t.ajax, t.ajax = function (e) {
            var n = ("mode" in e ? e : t.ajaxSettings).mode, r = ("port" in e ? e : t.ajaxSettings).port;
            return "abort" === n ? (i[r] && i[r].abort(), i[r] = a.apply(this, arguments), i[r]) : a.apply(this, arguments)
        }), t
    }) ? a.apply(e, i) : a) || (t.exports = r)
}, function (t, e, n) {
    "use strict";
    (function (e) {
        var a = n(167), i = n(173), r = n(176), o = document, s = o.documentElement;

        function l(t, n, a, r) {
            e.navigator.pointerEnabled ? i[n](t, {
                mouseup: "pointerup",
                mousedown: "pointerdown",
                mousemove: "pointermove"
            }[a], r) : e.navigator.msPointerEnabled ? i[n](t, {
                mouseup: "MSPointerUp",
                mousedown: "MSPointerDown",
                mousemove: "MSPointerMove"
            }[a], r) : (i[n](t, {
                mouseup: "touchend",
                mousedown: "touchstart",
                mousemove: "touchmove"
            }[a], r), i[n](t, a, r))
        }

        function c(t) {
            if (void 0 !== t.touches) return t.touches.length;
            if (void 0 !== t.which && 0 !== t.which) return t.which;
            if (void 0 !== t.buttons) return t.buttons;
            var e = t.button;
            return void 0 !== e ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : void 0
        }

        function d(t) {
            var e = t.getBoundingClientRect();
            return {left: e.left + u("scrollLeft", "pageXOffset"), top: e.top + u("scrollTop", "pageYOffset")}
        }

        function u(t, n) {
            return void 0 !== e[n] ? e[n] : s.clientHeight ? s[t] : o.body[t]
        }

        function h(t, e, n) {
            var a, i = (t = t || {}).className || "";
            return t.className += " gu-hide", a = o.elementFromPoint(e, n), t.className = i, a
        }

        function p() {
            return !1
        }

        function f() {
            return !0
        }

        function g(t) {
            return t.width || t.right - t.left
        }

        function m(t) {
            return t.height || t.bottom - t.top
        }

        function v(t) {
            return t.parentNode === o ? null : t.parentNode
        }

        function b(t) {
            return "INPUT" === t.tagName || "TEXTAREA" === t.tagName || "SELECT" === t.tagName || y(t)
        }

        function y(t) {
            return !!t && ("false" !== t.contentEditable && ("true" === t.contentEditable || y(v(t))))
        }

        function x(t) {
            return t.nextElementSibling || function () {
                var e = t;
                do {
                    e = e.nextSibling
                } while (e && 1 !== e.nodeType);
                return e
            }()
        }

        function _(t, e) {
            var n = function (t) {
                return t.targetTouches && t.targetTouches.length ? t.targetTouches[0] : t.changedTouches && t.changedTouches.length ? t.changedTouches[0] : t
            }(e), a = {pageX: "clientX", pageY: "clientY"};
            return t in a && !(t in n) && a[t] in n && (t = a[t]), n[t]
        }

        t.exports = function (t, e) {
            var n, u, y, w, S, C, k, D, T, E, A, I = arguments.length;
            1 === I && !1 === Array.isArray(t) && (e = t, t = []);
            var M, R = null, P = e || {};
            void 0 === P.moves && (P.moves = f), void 0 === P.accepts && (P.accepts = f), void 0 === P.invalid && (P.invalid = U), void 0 === P.containers && (P.containers = t || []), void 0 === P.isContainer && (P.isContainer = p), void 0 === P.copy && (P.copy = !1), void 0 === P.copySortSource && (P.copySortSource = !1), void 0 === P.revertOnSpill && (P.revertOnSpill = !1), void 0 === P.removeOnSpill && (P.removeOnSpill = !1), void 0 === P.direction && (P.direction = "vertical"), void 0 === P.ignoreInputTextSelection && (P.ignoreInputTextSelection = !0), void 0 === P.mirrorContainer && (P.mirrorContainer = o.body);
            var O = a({
                containers: P.containers,
                start: $,
                end: G,
                cancel: J,
                remove: Q,
                destroy: H,
                canMove: V,
                dragging: !1
            });
            return !0 === P.removeOnSpill && O.on("over", it).on("out", rt), N(), O;

            function j(t) {
                return -1 !== O.containers.indexOf(t) || P.isContainer(t)
            }

            function N(t) {
                var e = t ? "remove" : "add";
                l(s, e, "mousedown", q), l(s, e, "mouseup", Z)
            }

            function L(t) {
                l(s, t ? "remove" : "add", "mousemove", z)
            }

            function F(t) {
                var e = t ? "remove" : "add";
                i[e](s, "selectstart", B), i[e](s, "click", B)
            }

            function H() {
                N(!0), Z({})
            }

            function B(t) {
                M && t.preventDefault()
            }

            function q(t) {
                if (C = t.clientX, k = t.clientY, !(1 !== c(t) || t.metaKey || t.ctrlKey)) {
                    var e = t.target, n = W(e);
                    n && (M = n, L(), "mousedown" === t.type && (b(e) ? e.focus() : t.preventDefault()))
                }
            }

            function z(t) {
                if (M) if (0 !== c(t)) {
                    if (!(void 0 !== t.clientX && Math.abs(t.clientX - C) <= (P.slideFactorX || 0) && void 0 !== t.clientY && Math.abs(t.clientY - k) <= (P.slideFactorY || 0))) {
                        if (P.ignoreInputTextSelection) {
                            var e = _("clientX", t) || 0, n = _("clientY", t) || 0;
                            if (b(o.elementFromPoint(e, n))) return
                        }
                        var a = M;
                        L(!0), F(), G(), Y(a);
                        var i = d(y);
                        w = _("pageX", t) - i.left, S = _("pageY", t) - i.top, r.add(E || y, "gu-transit"), ot(), at(t)
                    }
                } else Z({})
            }

            function W(t) {
                if (!(O.dragging && n || j(t))) {
                    for (var e = t; v(t) && !1 === j(v(t));) {
                        if (P.invalid(t, e)) return;
                        if (!(t = v(t))) return
                    }
                    var a = v(t);
                    if (a) if (!P.invalid(t, e)) if (P.moves(t, a, e, x(t))) return {item: t, source: a}
                }
            }

            function V(t) {
                return !!W(t)
            }

            function $(t) {
                var e = W(t);
                e && Y(e)
            }

            function Y(t) {
                dt(t.item, t.source) && (E = t.item.cloneNode(!0), O.emit("cloned", E, t.item, "copy")), u = t.source, y = t.item, D = T = x(t.item), O.dragging = !0, O.emit("drag", y, u)
            }

            function U() {
                return !1
            }

            function G() {
                if (O.dragging) {
                    var t = E || y;
                    K(t, v(t))
                }
            }

            function X() {
                M = !1, L(!0), F(!0)
            }

            function Z(t) {
                if (X(), O.dragging) {
                    var e = E || y, a = _("clientX", t) || 0, i = _("clientY", t) || 0, r = nt(h(n, a, i), a, i);
                    r && (E && P.copySortSource || !E || r !== u) ? K(e, r) : P.removeOnSpill ? Q() : J()
                }
            }

            function K(t, e) {
                var n = v(t);
                E && P.copySortSource && e === u && n.removeChild(y), et(e) ? O.emit("cancel", t, u, u) : O.emit("drop", t, e, u, T), tt()
            }

            function Q() {
                if (O.dragging) {
                    var t = E || y, e = v(t);
                    e && e.removeChild(t), O.emit(E ? "cancel" : "remove", t, e, u), tt()
                }
            }

            function J(t) {
                if (O.dragging) {
                    var e = arguments.length > 0 ? t : P.revertOnSpill, n = E || y, a = v(n), i = et(a);
                    !1 === i && e && (E ? a && a.removeChild(E) : u.insertBefore(n, D)), i || e ? O.emit("cancel", n, u, u) : O.emit("drop", n, a, u, T), tt()
                }
            }

            function tt() {
                var t = E || y;
                X(), st(), t && r.rm(t, "gu-transit"), A && clearTimeout(A), O.dragging = !1, R && O.emit("out", t, R, u), O.emit("dragend", t), u = y = E = D = T = A = R = null
            }

            function et(t, e) {
                var a;
                return a = void 0 !== e ? e : n ? T : x(E || y), t === u && a === D
            }

            function nt(t, e, n) {
                for (var a = t; a && !i();) a = v(a);
                return a;

                function i() {
                    if (!1 === j(a)) return !1;
                    var i = lt(a, t), r = ct(a, i, e, n);
                    return !!et(a, r) || P.accepts(y, a, u, r)
                }
            }

            function at(t) {
                if (n) {
                    t.preventDefault();
                    var e = _("clientX", t) || 0, a = _("clientY", t) || 0, i = e - w, r = a - S;
                    n.style.left = i + "px", n.style.top = r + "px";
                    var o = E || y, s = h(n, e, a), l = nt(s, e, a), c = null !== l && l !== R;
                    (c || null === l) && (R && g("out"), R = l, c && g("over"));
                    var d = v(o);
                    if (l !== u || !E || P.copySortSource) {
                        var p, f = lt(l, s);
                        if (null !== f) p = ct(l, f, e, a); else {
                            if (!0 !== P.revertOnSpill || E) return void (E && d && d.removeChild(o));
                            p = D, l = u
                        }
                        (null === p && c || p !== o && p !== x(o)) && (T = p, l.insertBefore(o, p), O.emit("shadow", o, l, u))
                    } else d && d.removeChild(o)
                }

                function g(t) {
                    O.emit(t, o, R, u)
                }
            }

            function it(t) {
                r.rm(t, "gu-hide")
            }

            function rt(t) {
                O.dragging && r.add(t, "gu-hide")
            }

            function ot() {
                if (!n) {
                    var t = y.getBoundingClientRect();
                    (n = y.cloneNode(!0)).style.width = g(t) + "px", n.style.height = m(t) + "px", r.rm(n, "gu-transit"), r.add(n, "gu-mirror"), P.mirrorContainer.appendChild(n), l(s, "add", "mousemove", at), r.add(P.mirrorContainer, "gu-unselectable"), O.emit("cloned", n, y, "mirror")
                }
            }

            function st() {
                n && (r.rm(P.mirrorContainer, "gu-unselectable"), l(s, "remove", "mousemove", at), v(n).removeChild(n), n = null)
            }

            function lt(t, e) {
                for (var n = e; n !== t && v(n) !== t;) n = v(n);
                return n === s ? null : n
            }

            function ct(t, e, n, a) {
                var i = "horizontal" === P.direction;
                return e !== t ? function () {
                    var t = e.getBoundingClientRect();
                    if (i) return r(n > t.left + g(t) / 2);
                    return r(a > t.top + m(t) / 2)
                }() : function () {
                    var e, r, o, s = t.children.length;
                    for (e = 0; e < s; e++) {
                        if (r = t.children[e], o = r.getBoundingClientRect(), i && o.left + o.width / 2 > n) return r;
                        if (!i && o.top + o.height / 2 > a) return r
                    }
                    return null
                }();

                function r(t) {
                    return t ? x(e) : e
                }
            }

            function dt(t, e) {
                return "boolean" == typeof P.copy ? P.copy : P.copy(t, e)
            }
        }
    }).call(this, n(3))
}, function (t, e, n) {
    (function (e) {
        var n = "__lodash_hash_undefined__", a = "[object Function]", i = "[object GeneratorFunction]",
            r = /^\[object .+?Constructor\]$/, o = "object" == typeof e && e && e.Object === Object && e,
            s = "object" == typeof self && self && self.Object === Object && self,
            l = o || s || Function("return this")();
        var c, d = Array.prototype, u = Function.prototype, h = Object.prototype, p = l["__core-js_shared__"],
            f = (c = /[^.]+$/.exec(p && p.keys && p.keys.IE_PROTO || "")) ? "Symbol(src)_1." + c : "", g = u.toString,
            m = h.hasOwnProperty, v = h.toString,
            b = RegExp("^" + g.call(m).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
            y = d.splice, x = E(l, "Map"), _ = E(Object, "create");

        function w(t) {
            var e = -1, n = t ? t.length : 0;
            for (this.clear(); ++e < n;) {
                var a = t[e];
                this.set(a[0], a[1])
            }
        }

        function S(t) {
            var e = -1, n = t ? t.length : 0;
            for (this.clear(); ++e < n;) {
                var a = t[e];
                this.set(a[0], a[1])
            }
        }

        function C(t) {
            var e = -1, n = t ? t.length : 0;
            for (this.clear(); ++e < n;) {
                var a = t[e];
                this.set(a[0], a[1])
            }
        }

        function k(t, e) {
            for (var n, a, i = t.length; i--;) if ((n = t[i][0]) === (a = e) || n != n && a != a) return i;
            return -1
        }

        function D(t) {
            return !(!I(t) || (e = t, f && f in e)) && (function (t) {
                var e = I(t) ? v.call(t) : "";
                return e == a || e == i
            }(t) || function (t) {
                var e = !1;
                if (null != t && "function" != typeof t.toString) try {
                    e = !!(t + "")
                } catch (t) {
                }
                return e
            }(t) ? b : r).test(function (t) {
                if (null != t) {
                    try {
                        return g.call(t)
                    } catch (t) {
                    }
                    try {
                        return t + ""
                    } catch (t) {
                    }
                }
                return ""
            }(t));
            var e
        }

        function T(t, e) {
            var n, a, i = t.__data__;
            return ("string" == (a = typeof (n = e)) || "number" == a || "symbol" == a || "boolean" == a ? "__proto__" !== n : null === n) ? i["string" == typeof e ? "string" : "hash"] : i.map
        }

        function E(t, e) {
            var n = function (t, e) {
                return null == t ? void 0 : t[e]
            }(t, e);
            return D(n) ? n : void 0
        }

        function A(t, e) {
            if ("function" != typeof t || e && "function" != typeof e) throw new TypeError("Expected a function");
            var n = function () {
                var a = arguments, i = e ? e.apply(this, a) : a[0], r = n.cache;
                if (r.has(i)) return r.get(i);
                var o = t.apply(this, a);
                return n.cache = r.set(i, o), o
            };
            return n.cache = new (A.Cache || C), n
        }

        function I(t) {
            var e = typeof t;
            return !!t && ("object" == e || "function" == e)
        }

        w.prototype.clear = function () {
            this.__data__ = _ ? _(null) : {}
        }, w.prototype.delete = function (t) {
            return this.has(t) && delete this.__data__[t]
        }, w.prototype.get = function (t) {
            var e = this.__data__;
            if (_) {
                var a = e[t];
                return a === n ? void 0 : a
            }
            return m.call(e, t) ? e[t] : void 0
        }, w.prototype.has = function (t) {
            var e = this.__data__;
            return _ ? void 0 !== e[t] : m.call(e, t)
        }, w.prototype.set = function (t, e) {
            return this.__data__[t] = _ && void 0 === e ? n : e, this
        }, S.prototype.clear = function () {
            this.__data__ = []
        }, S.prototype.delete = function (t) {
            var e = this.__data__, n = k(e, t);
            return !(n < 0) && (n == e.length - 1 ? e.pop() : y.call(e, n, 1), !0)
        }, S.prototype.get = function (t) {
            var e = this.__data__, n = k(e, t);
            return n < 0 ? void 0 : e[n][1]
        }, S.prototype.has = function (t) {
            return k(this.__data__, t) > -1
        }, S.prototype.set = function (t, e) {
            var n = this.__data__, a = k(n, t);
            return a < 0 ? n.push([t, e]) : n[a][1] = e, this
        }, C.prototype.clear = function () {
            this.__data__ = {hash: new w, map: new (x || S), string: new w}
        }, C.prototype.delete = function (t) {
            return T(this, t).delete(t)
        }, C.prototype.get = function (t) {
            return T(this, t).get(t)
        }, C.prototype.has = function (t) {
            return T(this, t).has(t)
        }, C.prototype.set = function (t, e) {
            return T(this, t).set(t, e), this
        }, A.Cache = C, t.exports = A
    }).call(this, n(3))
}, function (t, e, n) {
    "use strict";
    (function (t) {
        var n = function () {
                if ("undefined" != typeof Map) return Map;

                function t(t, e) {
                    var n = -1;
                    return t.some((function (t, a) {
                        return t[0] === e && (n = a, !0)
                    })), n
                }

                return function () {
                    function e() {
                        this.__entries__ = []
                    }

                    return Object.defineProperty(e.prototype, "size", {
                        get: function () {
                            return this.__entries__.length
                        }, enumerable: !0, configurable: !0
                    }), e.prototype.get = function (e) {
                        var n = t(this.__entries__, e), a = this.__entries__[n];
                        return a && a[1]
                    }, e.prototype.set = function (e, n) {
                        var a = t(this.__entries__, e);
                        ~a ? this.__entries__[a][1] = n : this.__entries__.push([e, n])
                    }, e.prototype.delete = function (e) {
                        var n = this.__entries__, a = t(n, e);
                        ~a && n.splice(a, 1)
                    }, e.prototype.has = function (e) {
                        return !!~t(this.__entries__, e)
                    }, e.prototype.clear = function () {
                        this.__entries__.splice(0)
                    }, e.prototype.forEach = function (t, e) {
                        void 0 === e && (e = null);
                        for (var n = 0, a = this.__entries__; n < a.length; n++) {
                            var i = a[n];
                            t.call(e, i[1], i[0])
                        }
                    }, e
                }()
            }(), a = "undefined" != typeof window && "undefined" != typeof document && window.document === document,
            i = void 0 !== t && t.Math === Math ? t : "undefined" != typeof self && self.Math === Math ? self : "undefined" != typeof window && window.Math === Math ? window : Function("return this")(),
            r = "function" == typeof requestAnimationFrame ? requestAnimationFrame.bind(i) : function (t) {
                return setTimeout((function () {
                    return t(Date.now())
                }), 1e3 / 60)
            };
        var o = ["top", "right", "bottom", "left", "width", "height", "size", "weight"],
            s = "undefined" != typeof MutationObserver, l = function () {
                function t() {
                    this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = function (t, e) {
                        var n = !1, a = !1, i = 0;

                        function o() {
                            n && (n = !1, t()), a && l()
                        }

                        function s() {
                            r(o)
                        }

                        function l() {
                            var t = Date.now();
                            if (n) {
                                if (t - i < 2) return;
                                a = !0
                            } else n = !0, a = !1, setTimeout(s, e);
                            i = t
                        }

                        return l
                    }(this.refresh.bind(this), 20)
                }

                return t.prototype.addObserver = function (t) {
                    ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_()
                }, t.prototype.removeObserver = function (t) {
                    var e = this.observers_, n = e.indexOf(t);
                    ~n && e.splice(n, 1), !e.length && this.connected_ && this.disconnect_()
                }, t.prototype.refresh = function () {
                    this.updateObservers_() && this.refresh()
                }, t.prototype.updateObservers_ = function () {
                    var t = this.observers_.filter((function (t) {
                        return t.gatherActive(), t.hasActive()
                    }));
                    return t.forEach((function (t) {
                        return t.broadcastActive()
                    })), t.length > 0
                }, t.prototype.connect_ = function () {
                    a && !this.connected_ && (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), s ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
                        attributes: !0,
                        childList: !0,
                        characterData: !0,
                        subtree: !0
                    })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0)
                }, t.prototype.disconnect_ = function () {
                    a && this.connected_ && (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1)
                }, t.prototype.onTransitionEnd_ = function (t) {
                    var e = t.propertyName, n = void 0 === e ? "" : e;
                    o.some((function (t) {
                        return !!~n.indexOf(t)
                    })) && this.refresh()
                }, t.getInstance = function () {
                    return this.instance_ || (this.instance_ = new t), this.instance_
                }, t.instance_ = null, t
            }(), c = function (t, e) {
                for (var n = 0, a = Object.keys(e); n < a.length; n++) {
                    var i = a[n];
                    Object.defineProperty(t, i, {value: e[i], enumerable: !1, writable: !1, configurable: !0})
                }
                return t
            }, d = function (t) {
                return t && t.ownerDocument && t.ownerDocument.defaultView || i
            }, u = v(0, 0, 0, 0);

        function h(t) {
            return parseFloat(t) || 0
        }

        function p(t) {
            for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
            return e.reduce((function (e, n) {
                return e + h(t["border-" + n + "-width"])
            }), 0)
        }

        function f(t) {
            var e = t.clientWidth, n = t.clientHeight;
            if (!e && !n) return u;
            var a = d(t).getComputedStyle(t), i = function (t) {
                for (var e = {}, n = 0, a = ["top", "right", "bottom", "left"]; n < a.length; n++) {
                    var i = a[n], r = t["padding-" + i];
                    e[i] = h(r)
                }
                return e
            }(a), r = i.left + i.right, o = i.top + i.bottom, s = h(a.width), l = h(a.height);
            if ("border-box" === a.boxSizing && (Math.round(s + r) !== e && (s -= p(a, "left", "right") + r), Math.round(l + o) !== n && (l -= p(a, "top", "bottom") + o)), !function (t) {
                return t === d(t).document.documentElement
            }(t)) {
                var c = Math.round(s + r) - e, f = Math.round(l + o) - n;
                1 !== Math.abs(c) && (s -= c), 1 !== Math.abs(f) && (l -= f)
            }
            return v(i.left, i.top, s, l)
        }

        var g = "undefined" != typeof SVGGraphicsElement ? function (t) {
            return t instanceof d(t).SVGGraphicsElement
        } : function (t) {
            return t instanceof d(t).SVGElement && "function" == typeof t.getBBox
        };

        function m(t) {
            return a ? g(t) ? function (t) {
                var e = t.getBBox();
                return v(0, 0, e.width, e.height)
            }(t) : f(t) : u
        }

        function v(t, e, n, a) {
            return {x: t, y: e, width: n, height: a}
        }

        var b = function () {
            function t(t) {
                this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = v(0, 0, 0, 0), this.target = t
            }

            return t.prototype.isActive = function () {
                var t = m(this.target);
                return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight
            }, t.prototype.broadcastRect = function () {
                var t = this.contentRect_;
                return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t
            }, t
        }(), y = function (t, e) {
            var n, a, i, r, o, s, l,
                d = (a = (n = e).x, i = n.y, r = n.width, o = n.height, s = "undefined" != typeof DOMRectReadOnly ? DOMRectReadOnly : Object, l = Object.create(s.prototype), c(l, {
                    x: a,
                    y: i,
                    width: r,
                    height: o,
                    top: i,
                    right: a + r,
                    bottom: o + i,
                    left: a
                }), l);
            c(this, {target: t, contentRect: d})
        }, x = function () {
            function t(t, e, a) {
                if (this.activeObservations_ = [], this.observations_ = new n, "function" != typeof t) throw new TypeError("The callback provided as parameter 1 is not a function.");
                this.callback_ = t, this.controller_ = e, this.callbackCtx_ = a
            }

            return t.prototype.observe = function (t) {
                if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(t instanceof d(t).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                    var e = this.observations_;
                    e.has(t) || (e.set(t, new b(t)), this.controller_.addObserver(this), this.controller_.refresh())
                }
            }, t.prototype.unobserve = function (t) {
                if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
                if ("undefined" != typeof Element && Element instanceof Object) {
                    if (!(t instanceof d(t).Element)) throw new TypeError('parameter 1 is not of type "Element".');
                    var e = this.observations_;
                    e.has(t) && (e.delete(t), e.size || this.controller_.removeObserver(this))
                }
            }, t.prototype.disconnect = function () {
                this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this)
            }, t.prototype.gatherActive = function () {
                var t = this;
                this.clearActive(), this.observations_.forEach((function (e) {
                    e.isActive() && t.activeObservations_.push(e)
                }))
            }, t.prototype.broadcastActive = function () {
                if (this.hasActive()) {
                    var t = this.callbackCtx_, e = this.activeObservations_.map((function (t) {
                        return new y(t.target, t.broadcastRect())
                    }));
                    this.callback_.call(t, e, t), this.clearActive()
                }
            }, t.prototype.clearActive = function () {
                this.activeObservations_.splice(0)
            }, t.prototype.hasActive = function () {
                return this.activeObservations_.length > 0
            }, t
        }(), _ = "undefined" != typeof WeakMap ? new WeakMap : new n, w = function t(e) {
            if (!(this instanceof t)) throw new TypeError("Cannot call a class as a function.");
            if (!arguments.length) throw new TypeError("1 argument required, but only 0 present.");
            var n = l.getInstance(), a = new x(e, n, this);
            _.set(this, a)
        };
        ["observe", "unobserve", "disconnect"].forEach((function (t) {
            w.prototype[t] = function () {
                var e;
                return (e = _.get(this))[t].apply(e, arguments)
            }
        }));
        var S = void 0 !== i.ResizeObserver ? i.ResizeObserver : w;
        e.a = S
    }).call(this, n(3))
}, function (t, e, n) {
    "use strict";
    var a;

    function i(t) {
        return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
            return typeof t
        } : function (t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
        })(t)
    }

    function r(t, e) {
        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
    }

    function o(t, e) {
        for (var n = 0; n < e.length; n++) {
            var a = e[n];
            a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
        }
    }

    function s(t, e, n) {
        return e && o(t.prototype, e), n && o(t, n), t
    }

    function l(t, e, n) {
        return e in t ? Object.defineProperty(t, e, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : t[e] = n, t
    }

    function c(t, e) {
        var n = Object.keys(t);
        if (Object.getOwnPropertySymbols) {
            var a = Object.getOwnPropertySymbols(t);
            e && (a = a.filter((function (e) {
                return Object.getOwnPropertyDescriptor(t, e).enumerable
            }))), n.push.apply(n, a)
        }
        return n
    }

    function d(t) {
        for (var e = 1; e < arguments.length; e++) {
            var n = null != arguments[e] ? arguments[e] : {};
            e % 2 ? c(Object(n), !0).forEach((function (e) {
                l(t, e, n[e])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : c(Object(n)).forEach((function (e) {
                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(n, e))
            }))
        }
        return t
    }

    function u(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                writable: !0,
                configurable: !0
            }
        }), e && p(t, e)
    }

    function h(t) {
        return (h = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {
            return t.__proto__ || Object.getPrototypeOf(t)
        })(t)
    }

    function p(t, e) {
        return (p = Object.setPrototypeOf || function (t, e) {
            return t.__proto__ = e, t
        })(t, e)
    }

    function f(t, e) {
        return !e || "object" != typeof e && "function" != typeof e ? function (t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }(t) : e
    }

    function g(t) {
        var e = function () {
            if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
            if (Reflect.construct.sham) return !1;
            if ("function" == typeof Proxy) return !0;
            try {
                return Date.prototype.toString.call(Reflect.construct(Date, [], (function () {
                }))), !0
            } catch (t) {
                return !1
            }
        }();
        return function () {
            var n, a = h(t);
            if (e) {
                var i = h(this).constructor;
                n = Reflect.construct(a, arguments, i)
            } else n = a.apply(this, arguments);
            return f(this, n)
        }
    }

    function m(t) {
        return function (t) {
            if (Array.isArray(t)) return v(t)
        }(t) || function (t) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
        }(t) || function (t, e) {
            if (t) {
                if ("string" == typeof t) return v(t, e);
                var n = Object.prototype.toString.call(t).slice(8, -1);
                return "Object" === n && t.constructor && (n = t.constructor.name), "Map" === n || "Set" === n ? Array.from(t) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? v(t, e) : void 0
            }
        }(t) || function () {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }

    function v(t, e) {
        (null == e || e > t.length) && (e = t.length);
        for (var n = 0, a = new Array(e); n < e; n++) a[n] = t[n];
        return a
    }

    var b = function () {
        function t() {
            r(this, t)
        }

        return s(t, [{
            key: "shadeRGBColor", value: function (t, e) {
                var n = e.split(","), a = t < 0 ? 0 : 255, i = t < 0 ? -1 * t : t, r = parseInt(n[0].slice(4), 10),
                    o = parseInt(n[1], 10), s = parseInt(n[2], 10);
                return "rgb(" + (Math.round((a - r) * i) + r) + "," + (Math.round((a - o) * i) + o) + "," + (Math.round((a - s) * i) + s) + ")"
            }
        }, {
            key: "shadeHexColor", value: function (t, e) {
                var n = parseInt(e.slice(1), 16), a = t < 0 ? 0 : 255, i = t < 0 ? -1 * t : t, r = n >> 16,
                    o = n >> 8 & 255, s = 255 & n;
                return "#" + (16777216 + 65536 * (Math.round((a - r) * i) + r) + 256 * (Math.round((a - o) * i) + o) + (Math.round((a - s) * i) + s)).toString(16).slice(1)
            }
        }, {
            key: "shadeColor", value: function (e, n) {
                return t.isColorHex(n) ? this.shadeHexColor(e, n) : this.shadeRGBColor(e, n)
            }
        }], [{
            key: "bind", value: function (t, e) {
                return function () {
                    return t.apply(e, arguments)
                }
            }
        }, {
            key: "isObject", value: function (t) {
                return t && "object" === i(t) && !Array.isArray(t) && null != t
            }
        }, {
            key: "listToArray", value: function (t) {
                var e, n = [];
                for (e = 0; e < t.length; e++) n[e] = t[e];
                return n
            }
        }, {
            key: "extend", value: function (t, e) {
                var n = this;
                "function" != typeof Object.assign && (Object.assign = function (t) {
                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                    for (var e = Object(t), n = 1; n < arguments.length; n++) {
                        var a = arguments[n];
                        if (null != a) for (var i in a) a.hasOwnProperty(i) && (e[i] = a[i])
                    }
                    return e
                });
                var a = Object.assign({}, t);
                return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach((function (i) {
                    n.isObject(e[i]) && i in t ? a[i] = n.extend(t[i], e[i]) : Object.assign(a, l({}, i, e[i]))
                })), a
            }
        }, {
            key: "extendArray", value: function (e, n) {
                var a = [];
                return e.map((function (e) {
                    a.push(t.extend(n, e))
                })), a
            }
        }, {
            key: "monthMod", value: function (t) {
                return t % 12
            }
        }, {
            key: "clone", value: function (t) {
                if ("[object Array]" === Object.prototype.toString.call(t)) {
                    for (var e = [], n = 0; n < t.length; n++) e[n] = this.clone(t[n]);
                    return e
                }
                if ("[object Null]" === Object.prototype.toString.call(t)) return null;
                if ("[object Date]" === Object.prototype.toString.call(t)) return t;
                if ("object" === i(t)) {
                    var a = {};
                    for (var r in t) t.hasOwnProperty(r) && (a[r] = this.clone(t[r]));
                    return a
                }
                return t
            }
        }, {
            key: "log10", value: function (t) {
                return Math.log(t) / Math.LN10
            }
        }, {
            key: "roundToBase10", value: function (t) {
                return Math.pow(10, Math.floor(Math.log10(t)))
            }
        }, {
            key: "roundToBase", value: function (t, e) {
                return Math.pow(e, Math.floor(Math.log(t) / Math.log(e)))
            }
        }, {
            key: "parseNumber", value: function (t) {
                return null === t ? t : parseFloat(t)
            }
        }, {
            key: "randomId", value: function () {
                return (Math.random() + 1).toString(36).substring(4)
            }
        }, {
            key: "noExponents", value: function (t) {
                var e = String(t).split(/[eE]/);
                if (1 === e.length) return e[0];
                var n = "", a = t < 0 ? "-" : "", i = e[0].replace(".", ""), r = Number(e[1]) + 1;
                if (r < 0) {
                    for (n = a + "0."; r++;) n += "0";
                    return n + i.replace(/^-/, "")
                }
                for (r -= i.length; r--;) n += "0";
                return i + n
            }
        }, {
            key: "getDimensions", value: function (t) {
                var e = getComputedStyle(t), n = [], a = t.clientHeight, i = t.clientWidth;
                return a -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), i -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), n.push(i), n.push(a), n
            }
        }, {
            key: "getBoundingClientRect", value: function (t) {
                var e = t.getBoundingClientRect();
                return {
                    top: e.top,
                    right: e.right,
                    bottom: e.bottom,
                    left: e.left,
                    width: t.clientWidth,
                    height: t.clientHeight,
                    x: e.left,
                    y: e.top
                }
            }
        }, {
            key: "getLargestStringFromArr", value: function (t) {
                return t.reduce((function (t, e) {
                    return Array.isArray(e) && (e = e.reduce((function (t, e) {
                        return t.length > e.length ? t : e
                    }))), t.length > e.length ? t : e
                }), 0)
            }
        }, {
            key: "hexToRgba", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999",
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                "#" !== t.substring(0, 1) && (t = "#999999");
                var n = t.replace("#", "");
                n = n.match(new RegExp("(.{" + n.length / 3 + "})", "g"));
                for (var a = 0; a < n.length; a++) n[a] = parseInt(1 === n[a].length ? n[a] + n[a] : n[a], 16);
                return void 0 !== e && n.push(e), "rgba(" + n.join(",") + ")"
            }
        }, {
            key: "getOpacityFromRGBA", value: function (t) {
                return parseFloat(t.replace(/^.*,(.+)\)/, "$1"))
            }
        }, {
            key: "rgb2hex", value: function (t) {
                return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t.length ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : ""
            }
        }, {
            key: "isColorHex", value: function (t) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t)
            }
        }, {
            key: "polarToCartesian", value: function (t, e, n, a) {
                var i = (a - 90) * Math.PI / 180;
                return {x: t + n * Math.cos(i), y: e + n * Math.sin(i)}
            }
        }, {
            key: "escapeString", value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", n = t.toString().slice();
                return n.replace(/[` ~!@#$%^&*()_|+\-=?;:'",.<>{}[\]\\/]/gi, e)
            }
        }, {
            key: "negToZero", value: function (t) {
                return t < 0 ? 0 : t
            }
        }, {
            key: "moveIndexInArray", value: function (t, e, n) {
                if (n >= t.length) for (var a = n - t.length + 1; a--;) t.push(void 0);
                return t.splice(n, 0, t.splice(e, 1)[0]), t
            }
        }, {
            key: "extractNumber", value: function (t) {
                return parseFloat(t.replace(/[^\d.]*/g, ""))
            }
        }, {
            key: "findAncestor", value: function (t, e) {
                for (; (t = t.parentElement) && !t.classList.contains(e);) ;
                return t
            }
        }, {
            key: "setELstyles", value: function (t, e) {
                for (var n in e) e.hasOwnProperty(n) && (t.style.key = e[n])
            }
        }, {
            key: "isNumber", value: function (t) {
                return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10))
            }
        }, {
            key: "isFloat", value: function (t) {
                return Number(t) === t && t % 1 != 0
            }
        }, {
            key: "isSafari", value: function () {
                return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
            }
        }, {
            key: "isFirefox", value: function () {
                return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
            }
        }, {
            key: "isIE11", value: function () {
                if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return !0
            }
        }, {
            key: "isIE", value: function () {
                var t = window.navigator.userAgent, e = t.indexOf("MSIE ");
                if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
                if (t.indexOf("Trident/") > 0) {
                    var n = t.indexOf("rv:");
                    return parseInt(t.substring(n + 3, t.indexOf(".", n)), 10)
                }
                var a = t.indexOf("Edge/");
                return a > 0 && parseInt(t.substring(a + 5, t.indexOf(".", a)), 10)
            }
        }]), t
    }(), y = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "getDefaultFilter", value: function (t, e) {
                var n = this.w;
                t.unfilter(!0), (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"), "none" !== n.config.states.normal.filter ? this.applyFilter(t, e, n.config.states.normal.filter.type, n.config.states.normal.filter.value) : n.config.chart.dropShadow.enabled && this.dropShadow(t, n.config.chart.dropShadow, e)
            }
        }, {
            key: "addNormalFilter", value: function (t, e) {
                var n = this.w;
                n.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, n.config.chart.dropShadow, e)
            }
        }, {
            key: "addLightenFilter", value: function (t, e, n) {
                var a = this, i = this.w, r = n.intensity;
                t.unfilter(!0), new window.SVG.Filter, t.filter((function (t) {
                    var n = i.config.chart.dropShadow;
                    (n.enabled ? a.addShadow(t, e, n) : t).componentTransfer({
                        rgb: {
                            type: "linear",
                            slope: 1.5,
                            intercept: r
                        }
                    })
                })), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
            }
        }, {
            key: "addDarkenFilter", value: function (t, e, n) {
                var a = this, i = this.w, r = n.intensity;
                t.unfilter(!0), new window.SVG.Filter, t.filter((function (t) {
                    var n = i.config.chart.dropShadow;
                    (n.enabled ? a.addShadow(t, e, n) : t).componentTransfer({rgb: {type: "linear", slope: r}})
                })), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
            }
        }, {
            key: "applyFilter", value: function (t, e, n) {
                var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                switch (n) {
                    case"none":
                        this.addNormalFilter(t, e);
                        break;
                    case"lighten":
                        this.addLightenFilter(t, e, {intensity: a});
                        break;
                    case"darken":
                        this.addDarkenFilter(t, e, {intensity: a})
                }
            }
        }, {
            key: "addShadow", value: function (t, e, n) {
                var a = n.blur, i = n.top, r = n.left, o = n.color, s = n.opacity,
                    l = t.flood(Array.isArray(o) ? o[e] : o, s).composite(t.sourceAlpha, "in").offset(r, i).gaussianBlur(a).merge(t.source);
                return t.blend(t.source, l)
            }
        }, {
            key: "dropShadow", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a = e.top, i = e.left,
                    r = e.blur, o = e.color, s = e.opacity, l = e.noUserSpaceOnUse, c = this.w;
                return t.unfilter(!0), b.isIE() && "radialBar" === c.config.chart.type || (o = Array.isArray(o) ? o[n] : o, t.filter((function (t) {
                    var e;
                    e = b.isSafari() || b.isFirefox() || b.isIE() ? t.flood(o, s).composite(t.sourceAlpha, "in").offset(i, a).gaussianBlur(r) : t.flood(o, s).composite(t.sourceAlpha, "in").offset(i, a).gaussianBlur(r).merge(t.source), t.blend(t.source, e)
                })), l || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t
            }
        }, {
            key: "setSelectionFilter", value: function (t, e, n) {
                var a = this.w;
                if (void 0 !== a.globals.selectedDataPoints[e] && a.globals.selectedDataPoints[e].indexOf(n) > -1) {
                    t.node.setAttribute("selected", !0);
                    var i = a.config.states.active.filter;
                    "none" !== i && this.applyFilter(t, e, i.type, i.value)
                }
            }
        }, {
            key: "_scaleFilterSize", value: function (t) {
                !function (e) {
                    for (var n in e) e.hasOwnProperty(n) && t.setAttribute(n, e[n])
                }({width: "200%", height: "200%", x: "-50%", y: "-50%"})
            }
        }]), t
    }(), x = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.setEasingFunctions()
        }

        return s(t, [{
            key: "setEasingFunctions", value: function () {
                var t;
                if (!this.w.globals.easing) {
                    switch (this.w.config.chart.animations.easing) {
                        case"linear":
                            t = "-";
                            break;
                        case"easein":
                            t = "<";
                            break;
                        case"easeout":
                            t = ">";
                            break;
                        case"easeinout":
                            t = "<>";
                            break;
                        case"swing":
                            t = function (t) {
                                var e = 1.70158;
                                return (t -= 1) * t * ((e + 1) * t + e) + 1
                            };
                            break;
                        case"bounce":
                            t = function (t) {
                                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                            };
                            break;
                        case"elastic":
                            t = function (t) {
                                return t === !!t ? t : Math.pow(2, -10 * t) * Math.sin((t - .075) * (2 * Math.PI) / .3) + 1
                            };
                            break;
                        default:
                            t = "<>"
                    }
                    this.w.globals.easing = t
                }
            }
        }, {
            key: "animateLine", value: function (t, e, n, a) {
                t.attr(e).animate(a).attr(n)
            }
        }, {
            key: "animateCircleRadius", value: function (t, e, n, a, i, r) {
                e || (e = 0), t.attr({r: e}).animate(a, i).attr({r: n}).afterAll((function () {
                    r()
                }))
            }
        }, {
            key: "animateCircle", value: function (t, e, n, a, i) {
                t.attr({r: e.r, cx: e.cx, cy: e.cy}).animate(a, i).attr({r: n.r, cx: n.cx, cy: n.cy})
            }
        }, {
            key: "animateRect", value: function (t, e, n, a, i) {
                t.attr(e).animate(a).attr(n).afterAll((function () {
                    return i()
                }))
            }
        }, {
            key: "animatePathsGradually", value: function (t) {
                var e = t.el, n = t.realIndex, a = t.j, i = t.fill, r = t.pathFrom, o = t.pathTo, s = t.speed,
                    l = t.delay, c = this.w, d = 0;
                c.config.chart.animations.animateGradually.enabled && (d = c.config.chart.animations.animateGradually.delay), c.config.chart.animations.dynamicAnimation.enabled && c.globals.dataChanged && "bar" !== c.config.chart.type && (d = 0), this.morphSVG(e, n, a, "line" !== c.config.chart.type || c.globals.comboCharts ? i : "stroke", r, o, s, l * d)
            }
        }, {
            key: "showDelayedElements", value: function () {
                this.w.globals.delayedElements.forEach((function (t) {
                    t.el.classList.remove("apexcharts-element-hidden")
                }))
            }
        }, {
            key: "animationCompleted", value: function (t) {
                var e = this.w;
                e.globals.animationEnded || (e.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e.config.chart.events.animationEnd && e.config.chart.events.animationEnd(this.ctx, {
                    el: t,
                    w: e
                }))
            }
        }, {
            key: "morphSVG", value: function (t, e, n, a, i, r, o, s) {
                var l = this, c = this.w;
                i || (i = t.attr("pathFrom")), r || (r = t.attr("pathTo"));
                var d = function (t) {
                    return "radar" === c.config.chart.type && (o = 1), "M 0 ".concat(c.globals.gridHeight)
                };
                (!i || i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = d()), (!r || r.indexOf("undefined") > -1 || r.indexOf("NaN") > -1) && (r = d()), c.globals.shouldAnimate || (o = 1), t.plot(i).animate(1, c.globals.easing, s).plot(i).animate(o, c.globals.easing, s).plot(r).afterAll((function () {
                    b.isNumber(n) ? n === c.globals.series[c.globals.maxValsInArrayIndex].length - 2 && c.globals.shouldAnimate && l.animationCompleted(t) : "none" !== a && c.globals.shouldAnimate && (!c.globals.comboCharts && e === c.globals.series.length - 1 || c.globals.comboCharts) && l.animationCompleted(t), l.showDelayedElements()
                }))
            }
        }]), t
    }(), _ = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "drawLine", value: function (t, e, n, a) {
                var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
                    r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                    o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, s = this.w,
                    l = s.globals.dom.Paper.line().attr({
                        x1: t,
                        y1: e,
                        x2: n,
                        y2: a,
                        stroke: i,
                        "stroke-dasharray": r,
                        "stroke-width": o
                    });
                return l
            }
        }, {
            key: "drawRect", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                    r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
                    o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
                    s = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                    l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
                    c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, d = this.w,
                    u = d.globals.dom.Paper.rect();
                return u.attr({
                    x: t,
                    y: e,
                    width: n > 0 ? n : 0,
                    height: a > 0 ? a : 0,
                    rx: i,
                    ry: i,
                    opacity: o,
                    "stroke-width": null !== s ? s : 0,
                    stroke: null !== l ? l : "none",
                    "stroke-dasharray": c
                }), u.node.setAttribute("fill", r), u
            }
        }, {
            key: "drawPolygon", value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none", i = this.w,
                    r = i.globals.dom.Paper.polygon(t).attr({fill: a, stroke: e, "stroke-width": n});
                return r
            }
        }, {
            key: "drawCircle", value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = this.w,
                    a = n.globals.dom.Paper.circle(2 * t);
                return null !== e && a.attr(e), a
            }
        }, {
            key: "drawPath", value: function (t) {
                var e = t.d, n = void 0 === e ? "" : e, a = t.stroke, i = void 0 === a ? "#a8a8a8" : a,
                    r = t.strokeWidth, o = void 0 === r ? 1 : r, s = t.fill, l = t.fillOpacity,
                    c = void 0 === l ? 1 : l, d = t.strokeOpacity, u = void 0 === d ? 1 : d, h = t.classes,
                    p = t.strokeLinecap, f = void 0 === p ? null : p, g = t.strokeDashArray, m = void 0 === g ? 0 : g,
                    v = this.w;
                return null === f && (f = v.config.stroke.lineCap), (n.indexOf("undefined") > -1 || n.indexOf("NaN") > -1) && (n = "M 0 ".concat(v.globals.gridHeight)), v.globals.dom.Paper.path(n).attr({
                    fill: s,
                    "fill-opacity": c,
                    stroke: i,
                    "stroke-opacity": u,
                    "stroke-linecap": f,
                    "stroke-width": o,
                    "stroke-dasharray": m,
                    class: h
                })
            }
        }, {
            key: "group", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e = this.w,
                    n = e.globals.dom.Paper.group();
                return null !== t && n.attr(t), n
            }
        }, {
            key: "move", value: function (t, e) {
                return ["M", t, e].join(" ")
            }
        }, {
            key: "line", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a = null;
                return null === n ? a = ["L", t, e].join(" ") : "H" === n ? a = ["H", t].join(" ") : "V" === n && (a = ["V", e].join(" ")), a
            }
        }, {
            key: "curve", value: function (t, e, n, a, i, r) {
                return ["C", t, e, n, a, i, r].join(" ")
            }
        }, {
            key: "quadraticCurve", value: function (t, e, n, a) {
                return ["Q", t, e, n, a].join(" ")
            }
        }, {
            key: "arc", value: function (t, e, n, a, i, r, o) {
                var s = arguments.length > 7 && void 0 !== arguments[7] && arguments[7], l = "A";
                s && (l = "a");
                var c = [l, t, e, n, a, i, r, o].join(" ");
                return c
            }
        }, {
            key: "renderPaths", value: function (t) {
                var e, n = t.j, a = t.realIndex, i = t.pathFrom, r = t.pathTo, o = t.stroke, s = t.strokeWidth,
                    l = t.strokeLinecap, c = t.fill, u = t.animationDelay, h = t.initialSpeed, p = t.dataChangeSpeed,
                    f = t.className, g = t.shouldClipToGrid, m = void 0 === g || g, v = t.bindEventsOnPaths,
                    b = void 0 === v || v, _ = t.drawShadow, w = void 0 === _ || _, S = this.w, C = new y(this.ctx),
                    k = new x(this.ctx), D = this.w.config.chart.animations.enabled,
                    T = D && this.w.config.chart.animations.dynamicAnimation.enabled,
                    E = !!(D && !S.globals.resized || T && S.globals.dataChanged && S.globals.shouldAnimate);
                E ? e = i : (e = r, S.globals.animationEnded = !0);
                var A, I = S.config.stroke.dashArray;
                A = Array.isArray(I) ? I[a] : S.config.stroke.dashArray;
                var M = this.drawPath({
                    d: e,
                    stroke: o,
                    strokeWidth: s,
                    fill: c,
                    fillOpacity: 1,
                    classes: f,
                    strokeLinecap: l,
                    strokeDashArray: A
                });
                if (M.attr("index", a), m && M.attr({"clip-path": "url(#gridRectMask".concat(S.globals.cuid, ")")}), "none" !== S.config.states.normal.filter.type) C.getDefaultFilter(M, a); else if (S.config.chart.dropShadow.enabled && w && (!S.config.chart.dropShadow.enabledOnSeries || S.config.chart.dropShadow.enabledOnSeries && -1 !== S.config.chart.dropShadow.enabledOnSeries.indexOf(a))) {
                    var R = S.config.chart.dropShadow;
                    C.dropShadow(M, R, a)
                }
                b && (M.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, M)), M.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, M)), M.node.addEventListener("mousedown", this.pathMouseDown.bind(this, M))), M.attr({
                    pathTo: r,
                    pathFrom: i
                });
                var P = {el: M, j: n, realIndex: a, pathFrom: i, pathTo: r, fill: c, strokeWidth: s, delay: u};
                return !D || S.globals.resized || S.globals.dataChanged ? !S.globals.resized && S.globals.dataChanged || k.showDelayedElements() : k.animatePathsGradually(d(d({}, P), {}, {speed: h})), S.globals.dataChanged && T && E && k.animatePathsGradually(d(d({}, P), {}, {speed: p})), M
            }
        }, {
            key: "drawPattern", value: function (t, e, n) {
                var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
                    i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r = this.w,
                    o = r.globals.dom.Paper.pattern(e, n, (function (r) {
                        "horizontalLines" === t ? r.line(0, 0, n, 0).stroke({
                            color: a,
                            width: i + 1
                        }) : "verticalLines" === t ? r.line(0, 0, 0, e).stroke({
                            color: a,
                            width: i + 1
                        }) : "slantedLines" === t ? r.line(0, 0, e, n).stroke({
                            color: a,
                            width: i
                        }) : "squares" === t ? r.rect(e, n).fill("none").stroke({
                            color: a,
                            width: i
                        }) : "circles" === t && r.circle(e).fill("none").stroke({color: a, width: i})
                    }));
                return o
            }
        }, {
            key: "drawGradient", value: function (t, e, n, a, i) {
                var r, o = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                    s = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                    l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                    c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, d = this.w;
                e.length < 9 && 0 === e.indexOf("#") && (e = b.hexToRgba(e, a)), n.length < 9 && 0 === n.indexOf("#") && (n = b.hexToRgba(n, i));
                var u = 0, h = 1, p = 1, f = null;
                null !== s && (u = void 0 !== s[0] ? s[0] / 100 : 0, h = void 0 !== s[1] ? s[1] / 100 : 1, p = void 0 !== s[2] ? s[2] / 100 : 1, f = void 0 !== s[3] ? s[3] / 100 : null);
                var g = !("donut" !== d.config.chart.type && "pie" !== d.config.chart.type && "polarArea" !== d.config.chart.type && "bubble" !== d.config.chart.type);
                if (r = null === l || 0 === l.length ? d.globals.dom.Paper.gradient(g ? "radial" : "linear", (function (t) {
                    t.at(u, e, a), t.at(h, n, i), t.at(p, n, i), null !== f && t.at(f, e, a)
                })) : d.globals.dom.Paper.gradient(g ? "radial" : "linear", (function (t) {
                    (Array.isArray(l[c]) ? l[c] : l).forEach((function (e) {
                        t.at(e.offset / 100, e.color, e.opacity)
                    }))
                })), g) {
                    var m = d.globals.gridWidth / 2, v = d.globals.gridHeight / 2;
                    "bubble" !== d.config.chart.type ? r.attr({
                        gradientUnits: "userSpaceOnUse",
                        cx: m,
                        cy: v,
                        r: o
                    }) : r.attr({cx: .5, cy: .5, r: .8, fx: .2, fy: .2})
                } else "vertical" === t ? r.from(0, 0).to(0, 1) : "diagonal" === t ? r.from(0, 0).to(1, 1) : "horizontal" === t ? r.from(0, 1).to(1, 1) : "diagonal2" === t && r.from(1, 0).to(0, 1);
                return r
            }
        }, {
            key: "drawText", value: function (t) {
                var e, n = t.x, a = t.y, i = t.text, r = t.textAnchor, o = t.fontSize, s = t.fontFamily,
                    l = t.fontWeight, c = t.foreColor, d = t.opacity, u = t.cssClass, h = void 0 === u ? "" : u,
                    p = t.isPlainText, f = void 0 === p || p, g = this.w;
                return void 0 === i && (i = ""), r || (r = "start"), c && c.length || (c = g.config.chart.foreColor), s = s || g.config.chart.fontFamily, l = l || "regular", (e = Array.isArray(i) ? g.globals.dom.Paper.text((function (t) {
                    for (var e = 0; e < i.length; e++) 0 === e ? t.tspan(i[e]) : t.tspan(i[e]).newLine()
                })) : f ? g.globals.dom.Paper.plain(i) : g.globals.dom.Paper.text((function (t) {
                    return t.tspan(i)
                }))).attr({
                    x: n,
                    y: a,
                    "text-anchor": r,
                    "dominant-baseline": "auto",
                    "font-size": o,
                    "font-family": s,
                    "font-weight": l,
                    fill: c,
                    class: "apexcharts-text " + h
                }), e.node.style.fontFamily = s, e.node.style.opacity = d, e
            }
        }, {
            key: "drawMarker", value: function (t, e, n) {
                t = t || 0;
                var a = n.pSize || 0, i = null;
                if ("square" === n.shape) {
                    var r = void 0 === n.pRadius ? a / 2 : n.pRadius;
                    null !== e && a || (a = 0, r = 0);
                    var o = 1.2 * a + r, s = this.drawRect(o, o, o, o, r);
                    s.attr({
                        x: t - o / 2,
                        y: e - o / 2,
                        cx: t,
                        cy: e,
                        class: n.class ? n.class : "",
                        fill: n.pointFillColor,
                        "fill-opacity": n.pointFillOpacity ? n.pointFillOpacity : 1,
                        stroke: n.pointStrokeColor,
                        "stroke-width": n.pWidth ? n.pWidth : 0,
                        "stroke-opacity": n.pointStrokeOpacity ? n.pointStrokeOpacity : 1
                    }), i = s
                } else "circle" !== n.shape && n.shape || (b.isNumber(e) || (a = 0, e = 0), i = this.drawCircle(a, {
                    cx: t,
                    cy: e,
                    class: n.class ? n.class : "",
                    stroke: n.pointStrokeColor,
                    fill: n.pointFillColor,
                    "fill-opacity": n.pointFillOpacity ? n.pointFillOpacity : 1,
                    "stroke-width": n.pWidth ? n.pWidth : 0,
                    "stroke-opacity": n.pointStrokeOpacity ? n.pointStrokeOpacity : 1
                }));
                return i
            }
        }, {
            key: "pathMouseEnter", value: function (t, e) {
                var n = this.w, a = new y(this.ctx), i = parseInt(t.node.getAttribute("index"), 10),
                    r = parseInt(t.node.getAttribute("j"), 10);
                if ("function" == typeof n.config.chart.events.dataPointMouseEnter && n.config.chart.events.dataPointMouseEnter(e, this.ctx, {
                    seriesIndex: i,
                    dataPointIndex: r,
                    w: n
                }), this.ctx.events.fireEvent("dataPointMouseEnter", [e, this.ctx, {
                    seriesIndex: i,
                    dataPointIndex: r,
                    w: n
                }]), ("none" === n.config.states.active.filter.type || "true" !== t.node.getAttribute("selected")) && "none" !== n.config.states.hover.filter.type && "none" !== n.config.states.active.filter.type && !n.globals.isTouchDevice) {
                    var o = n.config.states.hover.filter;
                    a.applyFilter(t, i, o.type, o.value)
                }
            }
        }, {
            key: "pathMouseLeave", value: function (t, e) {
                var n = this.w, a = new y(this.ctx), i = parseInt(t.node.getAttribute("index"), 10),
                    r = parseInt(t.node.getAttribute("j"), 10);
                "function" == typeof n.config.chart.events.dataPointMouseLeave && n.config.chart.events.dataPointMouseLeave(e, this.ctx, {
                    seriesIndex: i,
                    dataPointIndex: r,
                    w: n
                }), this.ctx.events.fireEvent("dataPointMouseLeave", [e, this.ctx, {
                    seriesIndex: i,
                    dataPointIndex: r,
                    w: n
                }]), "none" !== n.config.states.active.filter.type && "true" === t.node.getAttribute("selected") || "none" !== n.config.states.hover.filter.type && a.getDefaultFilter(t, i)
            }
        }, {
            key: "pathMouseDown", value: function (t, e) {
                var n = this.w, a = new y(this.ctx), i = parseInt(t.node.getAttribute("index"), 10),
                    r = parseInt(t.node.getAttribute("j"), 10), o = "false";
                if ("true" === t.node.getAttribute("selected")) {
                    if (t.node.setAttribute("selected", "false"), n.globals.selectedDataPoints[i].indexOf(r) > -1) {
                        var s = n.globals.selectedDataPoints[i].indexOf(r);
                        n.globals.selectedDataPoints[i].splice(s, 1)
                    }
                } else {
                    if (!n.config.states.active.allowMultipleDataPointsSelection && n.globals.selectedDataPoints.length > 0) {
                        n.globals.selectedDataPoints = [];
                        var l = n.globals.dom.Paper.select(".apexcharts-series path").members,
                            c = n.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
                            d = function (t) {
                                Array.prototype.forEach.call(t, (function (t) {
                                    t.node.setAttribute("selected", "false"), a.getDefaultFilter(t, i)
                                }))
                            };
                        d(l), d(c)
                    }
                    t.node.setAttribute("selected", "true"), o = "true", void 0 === n.globals.selectedDataPoints[i] && (n.globals.selectedDataPoints[i] = []), n.globals.selectedDataPoints[i].push(r)
                }
                if ("true" === o) {
                    var u = n.config.states.active.filter;
                    "none" !== u && a.applyFilter(t, i, u.type, u.value)
                } else "none" !== n.config.states.active.filter.type && a.getDefaultFilter(t, i);
                "function" == typeof n.config.chart.events.dataPointSelection && n.config.chart.events.dataPointSelection(e, this.ctx, {
                    selectedDataPoints: n.globals.selectedDataPoints,
                    seriesIndex: i,
                    dataPointIndex: r,
                    w: n
                }), e && this.ctx.events.fireEvent("dataPointSelection", [e, this.ctx, {
                    selectedDataPoints: n.globals.selectedDataPoints,
                    seriesIndex: i,
                    dataPointIndex: r,
                    w: n
                }])
            }
        }, {
            key: "rotateAroundCenter", value: function (t) {
                var e = t.getBBox();
                return {x: e.x + e.width / 2, y: e.y + e.height / 2}
            }
        }, {
            key: "getTextRects", value: function (t, e, n, a) {
                var i = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r = this.w,
                    o = this.drawText({
                        x: -200,
                        y: -200,
                        text: t,
                        textAnchor: "start",
                        fontSize: e,
                        fontFamily: n,
                        foreColor: "#fff",
                        opacity: 0
                    });
                a && o.attr("transform", a), r.globals.dom.Paper.add(o);
                var s = o.bbox();
                return i || (s = o.node.getBoundingClientRect()), o.remove(), {width: s.width, height: s.height}
            }
        }, {
            key: "placeTextWithEllipsis", value: function (t, e, n) {
                if ("function" == typeof t.getComputedTextLength && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= n / .8)) {
                    for (var a = e.length - 3; a > 0; a -= 3) if (t.getSubStringLength(0, a) <= n / .8) return void (t.textContent = e.substring(0, a) + "...");
                    t.textContent = "."
                }
            }
        }], [{
            key: "setAttrs", value: function (t, e) {
                for (var n in e) e.hasOwnProperty(n) && t.setAttribute(n, e[n])
            }
        }]), t
    }(), w = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.annoCtx = e
        }

        return s(t, [{
            key: "setOrientations", value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = this.w;
                if ("vertical" === t.label.orientation) {
                    var a = null !== e ? e : 0,
                        i = n.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a, "']"));
                    if (null !== i) {
                        var r = i.getBoundingClientRect();
                        i.setAttribute("x", parseFloat(i.getAttribute("x")) - r.height + 4), "top" === t.label.position ? i.setAttribute("y", parseFloat(i.getAttribute("y")) + r.width) : i.setAttribute("y", parseFloat(i.getAttribute("y")) - r.width);
                        var o = this.annoCtx.graphics.rotateAroundCenter(i), s = o.x, l = o.y;
                        i.setAttribute("transform", "rotate(-90 ".concat(s, " ").concat(l, ")"))
                    }
                }
            }
        }, {
            key: "addBackgroundToAnno", value: function (t, e) {
                var n = this.w;
                if (!t || !e.label.text || e.label.text && !e.label.text.trim()) return null;
                var a = n.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
                    i = t.getBoundingClientRect(), r = e.label.style.padding.left, o = e.label.style.padding.right,
                    s = e.label.style.padding.top, l = e.label.style.padding.bottom;
                "vertical" === e.label.orientation && (s = e.label.style.padding.left, l = e.label.style.padding.right, r = e.label.style.padding.top, o = e.label.style.padding.bottom);
                var c = i.left - a.left - r, d = i.top - a.top - s,
                    u = this.annoCtx.graphics.drawRect(c - n.globals.barPadForNumericAxis, d, i.width + r + o, i.height + s + l, e.label.borderRadius, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0);
                return e.id && u.node.classList.add(e.id), u
            }
        }, {
            key: "annotationsBackground", value: function () {
                var t = this, e = this.w, n = function (n, a, i) {
                    var r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(i, "-annotations .apexcharts-").concat(i, "-annotation-label[rel='").concat(a, "']"));
                    if (r) {
                        var o = r.parentNode, s = t.addBackgroundToAnno(r, n);
                        s && o.insertBefore(s.node, r)
                    }
                };
                e.config.annotations.xaxis.map((function (t, e) {
                    n(t, e, "xaxis")
                })), e.config.annotations.yaxis.map((function (t, e) {
                    n(t, e, "yaxis")
                })), e.config.annotations.points.map((function (t, e) {
                    n(t, e, "point")
                }))
            }
        }, {
            key: "getStringX", value: function (t) {
                var e = this.w, n = t;
                e.config.xaxis.convertedCatToNumeric && e.globals.categoryLabels.length && (t = e.globals.categoryLabels.indexOf(t) + 1);
                var a = e.globals.labels.indexOf(t),
                    i = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a + 1) + ")");
                return i && (n = parseFloat(i.getAttribute("x"))), n
            }
        }]), t
    }(), S = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis
        }

        return s(t, [{
            key: "addXaxisAnnotation", value: function (t, e, n) {
                var a = this.w, i = this.invertAxis ? a.globals.minY : a.globals.minX,
                    r = this.invertAxis ? a.globals.maxY : a.globals.maxX,
                    o = this.invertAxis ? a.globals.yRange[0] : a.globals.xRange,
                    s = (t.x - i) / (o / a.globals.gridWidth);
                this.annoCtx.inversedReversedAxis && (s = (r - t.x) / (o / a.globals.gridWidth));
                var l = t.label.text;
                "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (s = this.annoCtx.helpers.getStringX(t.x));
                var c = t.strokeDashArray;
                if (b.isNumber(s)) {
                    if (null === t.x2 || void 0 === t.x2) {
                        var d = this.annoCtx.graphics.drawLine(s + t.offsetX, 0 + t.offsetY, s + t.offsetX, a.globals.gridHeight + t.offsetY, t.borderColor, c, t.borderWidth);
                        e.appendChild(d.node), t.id && d.node.classList.add(t.id)
                    } else {
                        var u = (t.x2 - i) / (o / a.globals.gridWidth);
                        if (this.annoCtx.inversedReversedAxis && (u = (r - t.x2) / (o / a.globals.gridWidth)), "category" !== a.config.xaxis.type && !a.config.xaxis.convertedCatToNumeric || this.invertAxis || a.globals.dataFormatXNumeric || (u = this.annoCtx.helpers.getStringX(t.x2)), u < s) {
                            var h = s;
                            s = u, u = h
                        }
                        var p = this.annoCtx.graphics.drawRect(s + t.offsetX, 0 + t.offsetY, u - s, a.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, c);
                        p.node.classList.add("apexcharts-annotation-rect"), p.attr("clip-path", "url(#gridRectMask".concat(a.globals.cuid, ")")), e.appendChild(p.node), t.id && p.node.classList.add(t.id)
                    }
                    var f = "top" === t.label.position ? 4 : a.globals.gridHeight,
                        g = this.annoCtx.graphics.getTextRects(l, parseFloat(t.label.style.fontSize)),
                        m = this.annoCtx.graphics.drawText({
                            x: s + t.label.offsetX,
                            y: f + t.label.offsetY - ("vertical" === t.label.orientation ? "top" === t.label.position ? g.width / 2 - 12 : -g.width / 2 : 0),
                            text: l,
                            textAnchor: t.label.textAnchor,
                            fontSize: t.label.style.fontSize,
                            fontFamily: t.label.style.fontFamily,
                            fontWeight: t.label.style.fontWeight,
                            foreColor: t.label.style.color,
                            cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                        });
                    m.attr({rel: n}), e.appendChild(m.node), this.annoCtx.helpers.setOrientations(t, n)
                }
            }
        }, {
            key: "drawXAxisAnnotations", value: function () {
                var t = this, e = this.w, n = this.annoCtx.graphics.group({class: "apexcharts-xaxis-annotations"});
                return e.config.annotations.xaxis.map((function (e, a) {
                    t.addXaxisAnnotation(e, n.node, a)
                })), n
            }
        }]), t
    }(), C = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "getStackedSeriesTotals", value: function () {
                var t = this.w, e = [];
                if (0 === t.globals.series.length) return e;
                for (var n = 0; n < t.globals.series[t.globals.maxValsInArrayIndex].length; n++) {
                    for (var a = 0, i = 0; i < t.globals.series.length; i++) void 0 !== t.globals.series[i][n] && (a += t.globals.series[i][n]);
                    e.push(a)
                }
                return t.globals.stackedSeriesTotals = e, e
            }
        }, {
            key: "getSeriesTotalByIndex", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return null === t ? this.w.config.series.reduce((function (t, e) {
                    return t + e
                }), 0) : this.w.globals.series[t].reduce((function (t, e) {
                    return t + e
                }), 0)
            }
        }, {
            key: "isSeriesNull", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                return 0 === (null === t ? this.w.config.series.filter((function (t) {
                    return null !== t
                })) : this.w.config.series[t].data.filter((function (t) {
                    return null !== t
                }))).length
            }
        }, {
            key: "seriesHaveSameValues", value: function (t) {
                return this.w.globals.series[t].every((function (t, e, n) {
                    return t === n[0]
                }))
            }
        }, {
            key: "getCategoryLabels", value: function (t) {
                var e = this.w, n = t.slice();
                return e.config.xaxis.convertedCatToNumeric && (n = t.map((function (t, n) {
                    return e.config.xaxis.labels.formatter(t - e.globals.minX + 1)
                }))), n
            }
        }, {
            key: "getLargestSeries", value: function () {
                var t = this.w;
                t.globals.maxValsInArrayIndex = t.globals.series.map((function (t) {
                    return t.length
                })).indexOf(Math.max.apply(Math, t.globals.series.map((function (t) {
                    return t.length
                }))))
            }
        }, {
            key: "getLargestMarkerSize", value: function () {
                var t = this.w, e = 0;
                return t.globals.markers.size.forEach((function (t) {
                    e = Math.max(e, t)
                })), t.globals.markers.largestSize = e, e
            }
        }, {
            key: "getSeriesTotals", value: function () {
                var t = this.w;
                t.globals.seriesTotals = t.globals.series.map((function (t, e) {
                    var n = 0;
                    if (Array.isArray(t)) for (var a = 0; a < t.length; a++) n += t[a]; else n += t;
                    return n
                }))
            }
        }, {
            key: "getSeriesTotalsXRange", value: function (t, e) {
                var n = this.w;
                return n.globals.series.map((function (a, i) {
                    for (var r = 0, o = 0; o < a.length; o++) n.globals.seriesX[i][o] > t && n.globals.seriesX[i][o] < e && (r += a[o]);
                    return r
                }))
            }
        }, {
            key: "getPercentSeries", value: function () {
                var t = this.w;
                t.globals.seriesPercent = t.globals.series.map((function (e, n) {
                    var a = [];
                    if (Array.isArray(e)) for (var i = 0; i < e.length; i++) {
                        var r = t.globals.stackedSeriesTotals[i], o = 0;
                        r && (o = 100 * e[i] / r), a.push(o)
                    } else {
                        var s = 100 * e / t.globals.seriesTotals.reduce((function (t, e) {
                            return t + e
                        }), 0);
                        a.push(s)
                    }
                    return a
                }))
            }
        }, {
            key: "getCalculatedRatios", value: function () {
                var t, e, n, a, i = this.w.globals, r = [], o = 0, s = [], l = .1, c = 0;
                if (i.yRange = [], i.isMultipleYAxis) for (var d = 0; d < i.minYArr.length; d++) i.yRange.push(Math.abs(i.minYArr[d] - i.maxYArr[d])), s.push(0); else i.yRange.push(Math.abs(i.minY - i.maxY));
                i.xRange = Math.abs(i.maxX - i.minX), i.zRange = Math.abs(i.maxZ - i.minZ);
                for (var u = 0; u < i.yRange.length; u++) r.push(i.yRange[u] / i.gridHeight);
                if (e = i.xRange / i.gridWidth, n = Math.abs(i.initialMaxX - i.initialMinX) / i.gridWidth, t = i.yRange / i.gridWidth, a = i.xRange / i.gridHeight, (o = i.zRange / i.gridHeight * 16) || (o = 1), i.minY !== Number.MIN_VALUE && 0 !== Math.abs(i.minY) && (i.hasNegs = !0), i.isMultipleYAxis) {
                    s = [];
                    for (var h = 0; h < r.length; h++) s.push(-i.minYArr[h] / r[h])
                } else s.push(-i.minY / r[0]), i.minY !== Number.MIN_VALUE && 0 !== Math.abs(i.minY) && (l = -i.minY / t, c = i.minX / e);
                return {
                    yRatio: r,
                    invertedYRatio: t,
                    zRatio: o,
                    xRatio: e,
                    initialXRatio: n,
                    invertedXRatio: a,
                    baseLineInvertedY: l,
                    baseLineY: s,
                    baseLineX: c
                }
            }
        }, {
            key: "getLogSeries", value: function (t) {
                var e = this, n = this.w;
                return n.globals.seriesLog = t.map((function (t, a) {
                    return n.config.yaxis[a] && n.config.yaxis[a].logarithmic ? t.map((function (t) {
                        return null === t ? null : e.getLogVal(t, a)
                    })) : t
                })), n.globals.invalidLogScale ? t : n.globals.seriesLog
            }
        }, {
            key: "getLogVal", value: function (t, e) {
                var n = this.w;
                return (Math.log(t) - Math.log(n.globals.minYArr[e])) / (Math.log(n.globals.maxYArr[e]) - Math.log(n.globals.minYArr[e]))
            }
        }, {
            key: "getLogYRatios", value: function (t) {
                var e = this, n = this.w, a = this.w.globals;
                return a.yLogRatio = t.slice(), a.logYRange = a.yRange.map((function (t, i) {
                    if (n.config.yaxis[i] && e.w.config.yaxis[i].logarithmic) {
                        var r, o = -Number.MAX_VALUE, s = Number.MIN_VALUE;
                        return a.seriesLog.forEach((function (t, e) {
                            t.forEach((function (t) {
                                n.config.yaxis[e] && n.config.yaxis[e].logarithmic && (o = Math.max(t, o), s = Math.min(t, s))
                            }))
                        })), r = Math.pow(a.yRange[i], Math.abs(s - o) / a.yRange[i]), a.yLogRatio[i] = r / a.gridHeight, r
                    }
                })), a.invalidLogScale ? t.slice() : a.yLogRatio
            }
        }], [{
            key: "checkComboSeries", value: function (t) {
                var e = !1, n = 0;
                return t.length && void 0 !== t[0].type && (e = !0, t.forEach((function (t) {
                    "bar" !== t.type && "column" !== t.type && "candlestick" !== t.type || n++
                }))), {comboBarCount: n, comboCharts: e}
            }
        }, {
            key: "extendArrayProps", value: function (t, e, n) {
                return e.yaxis && (e = t.extendYAxis(e, n)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e
            }
        }]), t
    }(), k = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.annoCtx = e
        }

        return s(t, [{
            key: "addYaxisAnnotation", value: function (t, e, n) {
                var a, i = this.w, r = t.strokeDashArray, o = this._getY1Y2("y1", t), s = t.label.text;
                if (null === t.y2 || void 0 === t.y2) {
                    var l = this.annoCtx.graphics.drawLine(0 + t.offsetX, o + t.offsetY, this._getYAxisAnnotationWidth(t), o + t.offsetY, t.borderColor, r, t.borderWidth);
                    e.appendChild(l.node), t.id && l.node.classList.add(t.id)
                } else {
                    if ((a = this._getY1Y2("y2", t)) > o) {
                        var c = o;
                        o = a, a = c
                    }
                    var d = this.annoCtx.graphics.drawRect(0 + t.offsetX, a + t.offsetY, this._getYAxisAnnotationWidth(t), o - a, 0, t.fillColor, t.opacity, 1, t.borderColor, r);
                    d.node.classList.add("apexcharts-annotation-rect"), d.attr("clip-path", "url(#gridRectMask".concat(i.globals.cuid, ")")), e.appendChild(d.node), t.id && d.node.classList.add(t.id)
                }
                var u = "right" === t.label.position ? i.globals.gridWidth : 0, h = this.annoCtx.graphics.drawText({
                    x: u + t.label.offsetX,
                    y: (a || o) + t.label.offsetY - 3,
                    text: s,
                    textAnchor: t.label.textAnchor,
                    fontSize: t.label.style.fontSize,
                    fontFamily: t.label.style.fontFamily,
                    fontWeight: t.label.style.fontWeight,
                    foreColor: t.label.style.color,
                    cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                });
                h.attr({rel: n}), e.appendChild(h.node)
            }
        }, {
            key: "_getY1Y2", value: function (t, e) {
                var n, a = "y1" === t ? e.y : e.y2, i = this.w;
                if (this.annoCtx.invertAxis) {
                    var r = i.globals.labels.indexOf(a);
                    i.config.xaxis.convertedCatToNumeric && (r = i.globals.categoryLabels.indexOf(a));
                    var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (r + 1) + ")");
                    o && (n = parseFloat(o.getAttribute("y")))
                } else {
                    var s;
                    s = i.config.yaxis[e.yAxisIndex].logarithmic ? (a = new C(this.annoCtx.ctx).getLogVal(a, e.yAxisIndex)) / i.globals.yLogRatio[e.yAxisIndex] : (a - i.globals.minYArr[e.yAxisIndex]) / (i.globals.yRange[e.yAxisIndex] / i.globals.gridHeight), n = i.globals.gridHeight - s, i.config.yaxis[e.yAxisIndex] && i.config.yaxis[e.yAxisIndex].reversed && (n = s)
                }
                return n
            }
        }, {
            key: "_getYAxisAnnotationWidth", value: function (t) {
                var e = this.w;
                return e.globals.gridWidth, (t.width.indexOf("%") > -1 ? e.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX
            }
        }, {
            key: "drawYAxisAnnotations", value: function () {
                var t = this, e = this.w, n = this.annoCtx.graphics.group({class: "apexcharts-yaxis-annotations"});
                return e.config.annotations.yaxis.map((function (e, a) {
                    t.addYaxisAnnotation(e, n.node, a)
                })), n
            }
        }]), t
    }(), D = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.annoCtx = e
        }

        return s(t, [{
            key: "addPointAnnotation", value: function (t, e, n) {
                var a = this.w, i = 0, r = 0, o = 0;
                this.annoCtx.invertAxis && console.warn("Point annotation is not supported in horizontal bar charts.");
                var s, l = parseFloat(t.y);
                if ("string" == typeof t.x) {
                    var c = a.globals.labels.indexOf(t.x);
                    a.config.xaxis.convertedCatToNumeric && (c = a.globals.categoryLabels.indexOf(t.x)), i = this.annoCtx.helpers.getStringX(t.x), null === t.y && (l = a.globals.series[t.seriesIndex][c])
                } else i = (t.x - a.globals.minX) / (a.globals.xRange / a.globals.gridWidth);
                if (s = a.config.yaxis[t.yAxisIndex].logarithmic ? (l = new C(this.annoCtx.ctx).getLogVal(l, t.yAxisIndex)) / a.globals.yLogRatio[t.yAxisIndex] : (l - a.globals.minYArr[t.yAxisIndex]) / (a.globals.yRange[t.yAxisIndex] / a.globals.gridHeight), r = a.globals.gridHeight - s - parseFloat(t.label.style.fontSize) - t.marker.size, o = a.globals.gridHeight - s, a.config.yaxis[t.yAxisIndex] && a.config.yaxis[t.yAxisIndex].reversed && (r = s + parseFloat(t.label.style.fontSize) + t.marker.size, o = s), b.isNumber(i)) {
                    var d = {
                        pSize: t.marker.size,
                        pWidth: t.marker.strokeWidth,
                        pointFillColor: t.marker.fillColor,
                        pointStrokeColor: t.marker.strokeColor,
                        shape: t.marker.shape,
                        pRadius: t.marker.radius,
                        class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "")
                    }, u = this.annoCtx.graphics.drawMarker(i + t.marker.offsetX, o + t.marker.offsetY, d);
                    e.appendChild(u.node);
                    var h = t.label.text ? t.label.text : "", p = this.annoCtx.graphics.drawText({
                        x: i + t.label.offsetX,
                        y: r + t.label.offsetY,
                        text: h,
                        textAnchor: t.label.textAnchor,
                        fontSize: t.label.style.fontSize,
                        fontFamily: t.label.style.fontFamily,
                        fontWeight: t.label.style.fontWeight,
                        foreColor: t.label.style.color,
                        cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                    });
                    if (p.attr({rel: n}), e.appendChild(p.node), t.customSVG.SVG) {
                        var f = this.annoCtx.graphics.group({class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass});
                        f.attr({transform: "translate(".concat(i + t.customSVG.offsetX, ", ").concat(r + t.customSVG.offsetY, ")")}), f.node.innerHTML = t.customSVG.SVG, e.appendChild(f.node)
                    }
                    if (t.image.path) {
                        var g = t.image.width ? t.image.width : 20, m = t.image.height ? t.image.height : 20;
                        this.annoCtx.addImage({
                            x: i + t.image.offsetX - g / 2,
                            y: r + t.image.offsetY - m / 2,
                            width: g,
                            height: m,
                            path: t.image.path,
                            appendTo: ".apexcharts-point-annotations"
                        })
                    }
                }
            }
        }, {
            key: "drawPointAnnotations", value: function () {
                var t = this, e = this.w, n = this.annoCtx.graphics.group({class: "apexcharts-point-annotations"});
                return e.config.annotations.points.map((function (e, a) {
                    t.addPointAnnotation(e, n.node, a)
                })), n
            }
        }]), t
    }(), T = {
        name: "en",
        options: {
            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            toolbar: {
                exportToSVG: "Download SVG",
                exportToPNG: "Download PNG",
                exportToCSV: "Download CSV",
                menu: "Menu",
                selection: "Selection",
                selectionZoom: "Selection Zoom",
                zoomIn: "Zoom In",
                zoomOut: "Zoom Out",
                pan: "Panning",
                reset: "Reset Zoom"
            }
        }
    }, E = function () {
        function t() {
            r(this, t), this.yAxis = {
                show: !0,
                showAlways: !1,
                showForNullSeries: !0,
                seriesName: void 0,
                opposite: !1,
                reversed: !1,
                logarithmic: !1,
                tickAmount: void 0,
                forceNiceScale: !1,
                max: void 0,
                min: void 0,
                floating: !1,
                decimalsInFloat: void 0,
                labels: {
                    show: !0,
                    minWidth: 0,
                    maxWidth: 160,
                    offsetX: 0,
                    offsetY: 0,
                    align: void 0,
                    rotate: 0,
                    padding: 20,
                    style: {colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: ""},
                    formatter: void 0
                },
                axisBorder: {show: !1, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0},
                axisTicks: {show: !1, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0},
                title: {
                    text: void 0,
                    rotate: -90,
                    offsetY: 0,
                    offsetX: 0,
                    style: {color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: ""}
                },
                tooltip: {enabled: !1, offsetX: 0},
                crosshairs: {show: !0, position: "front", stroke: {color: "#b6b6b6", width: 1, dashArray: 0}}
            }, this.pointAnnotation = {
                x: 0,
                y: null,
                yAxisIndex: 0,
                seriesIndex: 0,
                marker: {
                    size: 4,
                    fillColor: "#fff",
                    strokeWidth: 2,
                    strokeColor: "#333",
                    shape: "circle",
                    offsetX: 0,
                    offsetY: 0,
                    radius: 2,
                    cssClass: ""
                },
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    offsetX: 0,
                    offsetY: 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {left: 5, right: 5, top: 2, bottom: 2}
                    }
                },
                customSVG: {SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0},
                image: {path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0}
            }, this.yAxisAnnotation = {
                y: 0,
                y2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                width: "100%",
                yAxisIndex: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "end",
                    position: "right",
                    offsetX: 0,
                    offsetY: -3,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {left: 5, right: 5, top: 2, bottom: 2}
                    }
                }
            }, this.xAxisAnnotation = {
                x: 0,
                x2: null,
                strokeDashArray: 1,
                fillColor: "#c2c2c2",
                borderColor: "#c2c2c2",
                borderWidth: 1,
                opacity: .3,
                offsetX: 0,
                offsetY: 0,
                label: {
                    borderColor: "#c2c2c2",
                    borderWidth: 1,
                    borderRadius: 2,
                    text: void 0,
                    textAnchor: "middle",
                    orientation: "vertical",
                    position: "top",
                    offsetX: 0,
                    offsetY: 0,
                    style: {
                        background: "#fff",
                        color: void 0,
                        fontSize: "11px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        cssClass: "",
                        padding: {left: 5, right: 5, top: 2, bottom: 2}
                    }
                }
            }, this.text = {
                x: 0,
                y: 0,
                text: "",
                textAnchor: "start",
                foreColor: void 0,
                fontSize: "13px",
                fontFamily: void 0,
                fontWeight: 400,
                appendTo: ".apexcharts-annotations",
                backgroundColor: "transparent",
                borderColor: "#c2c2c2",
                borderRadius: 0,
                borderWidth: 0,
                paddingLeft: 4,
                paddingRight: 4,
                paddingTop: 2,
                paddingBottom: 2
            }
        }

        return s(t, [{
            key: "init", value: function () {
                return {
                    annotations: {
                        position: "front",
                        yaxis: [this.yAxisAnnotation],
                        xaxis: [this.xAxisAnnotation],
                        points: [this.pointAnnotation],
                        texts: [],
                        images: [],
                        shapes: []
                    },
                    chart: {
                        animations: {
                            enabled: !0,
                            easing: "easeinout",
                            speed: 800,
                            animateGradually: {delay: 150, enabled: !0},
                            dynamicAnimation: {enabled: !0, speed: 350}
                        },
                        background: "transparent",
                        locales: [T],
                        defaultLocale: "en",
                        dropShadow: {
                            enabled: !1,
                            enabledOnSeries: void 0,
                            top: 2,
                            left: 2,
                            blur: 4,
                            color: "#000",
                            opacity: .35
                        },
                        events: {
                            animationEnd: void 0,
                            beforeMount: void 0,
                            mounted: void 0,
                            updated: void 0,
                            click: void 0,
                            mouseMove: void 0,
                            legendClick: void 0,
                            markerClick: void 0,
                            selection: void 0,
                            dataPointSelection: void 0,
                            dataPointMouseEnter: void 0,
                            dataPointMouseLeave: void 0,
                            beforeZoom: void 0,
                            beforeResetZoom: void 0,
                            zoomed: void 0,
                            scrolled: void 0,
                            brushScrolled: void 0
                        },
                        foreColor: "#373d3f",
                        fontFamily: "Helvetica, Arial, sans-serif",
                        height: "auto",
                        parentHeightOffset: 15,
                        redrawOnParentResize: !0,
                        redrawOnWindowResize: !0,
                        id: void 0,
                        group: void 0,
                        offsetX: 0,
                        offsetY: 0,
                        selection: {
                            enabled: !1,
                            type: "x",
                            fill: {color: "#24292e", opacity: .1},
                            stroke: {width: 1, color: "#24292e", opacity: .4, dashArray: 3},
                            xaxis: {min: void 0, max: void 0},
                            yaxis: {min: void 0, max: void 0}
                        },
                        sparkline: {enabled: !1},
                        brush: {enabled: !1, autoScaleYaxis: !0, target: void 0},
                        stacked: !1,
                        stackType: "normal",
                        toolbar: {
                            show: !0,
                            offsetX: 0,
                            offsetY: 0,
                            tools: {
                                download: !0,
                                selection: !0,
                                zoom: !0,
                                zoomin: !0,
                                zoomout: !0,
                                pan: !0,
                                reset: !0,
                                customIcons: []
                            },
                            export: {
                                csv: {
                                    filename: void 0,
                                    columnDelimiter: ",",
                                    headerCategory: "category",
                                    headerValue: "value",
                                    dateFormatter: function (t) {
                                        return new Date(t).toDateString()
                                    }
                                }
                            },
                            autoSelected: "zoom"
                        },
                        type: "line",
                        width: "100%",
                        zoom: {
                            enabled: !0,
                            type: "x",
                            autoScaleYaxis: !1,
                            zoomedArea: {
                                fill: {color: "#90CAF9", opacity: .4},
                                stroke: {color: "#0D47A1", opacity: .4, width: 1}
                            }
                        }
                    },
                    plotOptions: {
                        area: {fillTo: "origin"},
                        bar: {
                            horizontal: !1,
                            columnWidth: "70%",
                            barHeight: "70%",
                            distributed: !1,
                            startingShape: "flat",
                            endingShape: "flat",
                            rangeBarOverlap: !0,
                            rangeBarGroupRows: !1,
                            colors: {
                                ranges: [],
                                backgroundBarColors: [],
                                backgroundBarOpacity: 1,
                                backgroundBarRadius: 0
                            },
                            dataLabels: {
                                position: "top",
                                maxItems: 100,
                                hideOverflowingLabels: !0,
                                orientation: "horizontal"
                            }
                        },
                        bubble: {minBubbleRadius: void 0, maxBubbleRadius: void 0},
                        candlestick: {colors: {upward: "#00B746", downward: "#EF403C"}, wick: {useFillColor: !0}},
                        heatmap: {
                            radius: 2,
                            enableShades: !0,
                            shadeIntensity: .5,
                            reverseNegativeShade: !1,
                            distributed: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {inverse: !1, ranges: [], min: void 0, max: void 0}
                        },
                        treemap: {
                            enableShades: !0,
                            shadeIntensity: .5,
                            distributed: !1,
                            reverseNegativeShade: !1,
                            useFillColorAsStroke: !1,
                            colorScale: {inverse: !1, ranges: [], min: void 0, max: void 0}
                        },
                        radialBar: {
                            inverseOrder: !1,
                            startAngle: 0,
                            endAngle: 360,
                            offsetX: 0,
                            offsetY: 0,
                            hollow: {
                                margin: 5,
                                size: "50%",
                                background: "transparent",
                                image: void 0,
                                imageWidth: 150,
                                imageHeight: 150,
                                imageOffsetX: 0,
                                imageOffsetY: 0,
                                imageClipped: !0,
                                position: "front",
                                dropShadow: {enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: .5}
                            },
                            track: {
                                show: !0,
                                startAngle: void 0,
                                endAngle: void 0,
                                background: "#f2f2f2",
                                strokeWidth: "97%",
                                opacity: 1,
                                margin: 5,
                                dropShadow: {enabled: !1, top: 0, left: 0, blur: 3, color: "#000", opacity: .5}
                            },
                            dataLabels: {
                                show: !0,
                                name: {
                                    show: !0,
                                    fontSize: "16px",
                                    fontFamily: void 0,
                                    fontWeight: 600,
                                    color: void 0,
                                    offsetY: 0,
                                    formatter: function (t) {
                                        return t
                                    }
                                },
                                value: {
                                    show: !0,
                                    fontSize: "14px",
                                    fontFamily: void 0,
                                    fontWeight: 400,
                                    color: void 0,
                                    offsetY: 16,
                                    formatter: function (t) {
                                        return t + "%"
                                    }
                                },
                                total: {
                                    show: !1,
                                    label: "Total",
                                    fontSize: "16px",
                                    fontWeight: 600,
                                    fontFamily: void 0,
                                    color: void 0,
                                    formatter: function (t) {
                                        return t.globals.seriesTotals.reduce((function (t, e) {
                                            return t + e
                                        }), 0) / t.globals.series.length + "%"
                                    }
                                }
                            }
                        },
                        pie: {
                            customScale: 1,
                            offsetX: 0,
                            offsetY: 0,
                            startAngle: 0,
                            endAngle: 360,
                            expandOnClick: !0,
                            dataLabels: {offset: 0, minAngleToShowLabel: 10},
                            donut: {
                                size: "65%",
                                background: "transparent",
                                labels: {
                                    show: !1,
                                    name: {
                                        show: !0,
                                        fontSize: "16px",
                                        fontFamily: void 0,
                                        fontWeight: 600,
                                        color: void 0,
                                        offsetY: -10,
                                        formatter: function (t) {
                                            return t
                                        }
                                    },
                                    value: {
                                        show: !0,
                                        fontSize: "20px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        color: void 0,
                                        offsetY: 10,
                                        formatter: function (t) {
                                            return t
                                        }
                                    },
                                    total: {
                                        show: !1,
                                        showAlways: !1,
                                        label: "Total",
                                        fontSize: "16px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        color: void 0,
                                        formatter: function (t) {
                                            return t.globals.seriesTotals.reduce((function (t, e) {
                                                return t + e
                                            }), 0)
                                        }
                                    }
                                }
                            }
                        },
                        polarArea: {rings: {strokeWidth: 1, strokeColor: "#e8e8e8"}},
                        radar: {
                            size: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            polygons: {
                                strokeWidth: 1,
                                strokeColors: "#e8e8e8",
                                connectorColors: "#e8e8e8",
                                fill: {colors: void 0}
                            }
                        }
                    },
                    colors: void 0,
                    dataLabels: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        formatter: function (t) {
                            return null !== t ? t : ""
                        },
                        textAnchor: "middle",
                        distributed: !1,
                        offsetX: 0,
                        offsetY: 0,
                        style: {fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0},
                        background: {
                            enabled: !0,
                            foreColor: "#fff",
                            borderRadius: 2,
                            padding: 4,
                            opacity: .9,
                            borderWidth: 1,
                            borderColor: "#fff",
                            dropShadow: {enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: .45}
                        },
                        dropShadow: {enabled: !1, top: 1, left: 1, blur: 1, color: "#000", opacity: .45}
                    },
                    fill: {
                        type: "solid",
                        colors: void 0,
                        opacity: .85,
                        gradient: {
                            shade: "dark",
                            type: "horizontal",
                            shadeIntensity: .5,
                            gradientToColors: void 0,
                            inverseColors: !0,
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [0, 50, 100],
                            colorStops: []
                        },
                        image: {src: [], width: void 0, height: void 0},
                        pattern: {style: "squares", width: 6, height: 6, strokeWidth: 2}
                    },
                    grid: {
                        show: !0,
                        borderColor: "#e0e0e0",
                        strokeDashArray: 0,
                        position: "back",
                        xaxis: {lines: {show: !1}},
                        yaxis: {lines: {show: !0}},
                        row: {colors: void 0, opacity: .5},
                        column: {colors: void 0, opacity: .5},
                        padding: {top: 0, right: 10, bottom: 0, left: 12}
                    },
                    labels: [],
                    legend: {
                        show: !0,
                        showForSingleSeries: !1,
                        showForNullSeries: !0,
                        showForZeroSeries: !0,
                        floating: !1,
                        position: "bottom",
                        horizontalAlign: "center",
                        inverseOrder: !1,
                        fontSize: "12px",
                        fontFamily: void 0,
                        fontWeight: 400,
                        width: void 0,
                        height: void 0,
                        formatter: void 0,
                        tooltipHoverFormatter: void 0,
                        offsetX: -20,
                        offsetY: 4,
                        labels: {colors: void 0, useSeriesColors: !1},
                        markers: {
                            width: 12,
                            height: 12,
                            strokeWidth: 0,
                            fillColors: void 0,
                            strokeColor: "#fff",
                            radius: 12,
                            customHTML: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            onClick: void 0
                        },
                        itemMargin: {horizontal: 5, vertical: 2},
                        onItemClick: {toggleDataSeries: !0},
                        onItemHover: {highlightDataSeries: !0}
                    },
                    markers: {
                        discrete: [],
                        size: 0,
                        colors: void 0,
                        strokeColors: "#fff",
                        strokeWidth: 2,
                        strokeOpacity: .9,
                        strokeDashArray: 0,
                        fillOpacity: 1,
                        shape: "circle",
                        radius: 2,
                        offsetX: 0,
                        offsetY: 0,
                        onClick: void 0,
                        onDblClick: void 0,
                        showNullDataPoints: !0,
                        hover: {size: void 0, sizeOffset: 3}
                    },
                    noData: {
                        text: void 0,
                        align: "center",
                        verticalAlign: "middle",
                        offsetX: 0,
                        offsetY: 0,
                        style: {color: void 0, fontSize: "14px", fontFamily: void 0}
                    },
                    responsive: [],
                    series: void 0,
                    states: {
                        normal: {filter: {type: "none", value: 0}},
                        hover: {filter: {type: "lighten", value: .1}},
                        active: {allowMultipleDataPointsSelection: !1, filter: {type: "darken", value: .5}}
                    },
                    title: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 0,
                        floating: !1,
                        style: {fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0}
                    },
                    subtitle: {
                        text: void 0,
                        align: "left",
                        margin: 5,
                        offsetX: 0,
                        offsetY: 30,
                        floating: !1,
                        style: {fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0}
                    },
                    stroke: {show: !0, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0},
                    tooltip: {
                        enabled: !0,
                        enabledOnSeries: void 0,
                        shared: !0,
                        followCursor: !1,
                        intersect: !1,
                        inverseOrder: !1,
                        custom: void 0,
                        fillSeriesColor: !1,
                        theme: "light",
                        style: {fontSize: "12px", fontFamily: void 0},
                        onDatasetHover: {highlightDataSeries: !1},
                        x: {show: !0, format: "dd MMM", formatter: void 0},
                        y: {
                            formatter: void 0, title: {
                                formatter: function (t) {
                                    return t + ": "
                                }
                            }
                        },
                        z: {formatter: void 0, title: "Size: "},
                        marker: {show: !0, fillColors: void 0},
                        items: {display: "flex"},
                        fixed: {enabled: !1, position: "topRight", offsetX: 0, offsetY: 0}
                    },
                    xaxis: {
                        type: "category",
                        categories: [],
                        convertedCatToNumeric: !1,
                        sorted: !1,
                        offsetX: 0,
                        offsetY: 0,
                        labels: {
                            show: !0,
                            rotate: -45,
                            rotateAlways: !1,
                            hideOverlappingLabels: !0,
                            trim: !1,
                            minHeight: void 0,
                            maxHeight: 120,
                            showDuplicates: !0,
                            style: {colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: ""},
                            offsetX: 0,
                            offsetY: 0,
                            format: void 0,
                            formatter: void 0,
                            datetimeUTC: !0,
                            datetimeFormatter: {
                                year: "yyyy",
                                month: "MMM 'yy",
                                day: "dd MMM",
                                hour: "HH:mm",
                                minute: "HH:mm:ss"
                            }
                        },
                        axisBorder: {show: !0, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0},
                        axisTicks: {show: !0, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0},
                        tickAmount: void 0,
                        tickPlacement: "on",
                        min: void 0,
                        max: void 0,
                        range: void 0,
                        floating: !1,
                        position: "bottom",
                        title: {
                            text: void 0,
                            offsetX: 0,
                            offsetY: 0,
                            style: {color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: ""}
                        },
                        crosshairs: {
                            show: !0,
                            width: 1,
                            position: "back",
                            opacity: .9,
                            stroke: {color: "#b6b6b6", width: 1, dashArray: 3},
                            fill: {
                                type: "solid",
                                color: "#B1B9C4",
                                gradient: {
                                    colorFrom: "#D8E3F0",
                                    colorTo: "#BED1E6",
                                    stops: [0, 100],
                                    opacityFrom: .4,
                                    opacityTo: .5
                                }
                            },
                            dropShadow: {enabled: !1, left: 0, top: 0, blur: 1, opacity: .4}
                        },
                        tooltip: {
                            enabled: !0,
                            offsetY: 0,
                            formatter: void 0,
                            style: {fontSize: "12px", fontFamily: void 0}
                        }
                    },
                    yaxis: this.yAxis,
                    theme: {
                        mode: "light",
                        palette: "palette1",
                        monochrome: {enabled: !1, color: "#008FFB", shadeTo: "light", shadeIntensity: .65}
                    }
                }
            }
        }]), t
    }(), A = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.graphics = new _(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new w(this), this.xAxisAnnotations = new S(this), this.yAxisAnnotations = new k(this), this.pointsAnnotations = new D(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
        }

        return s(t, [{
            key: "drawAxesAnnotations", value: function () {
                var t = this.w;
                if (t.globals.axisCharts) {
                    for (var e = this.yAxisAnnotations.drawYAxisAnnotations(), n = this.xAxisAnnotations.drawXAxisAnnotations(), a = this.pointsAnnotations.drawPointAnnotations(), i = t.config.chart.animations.enabled, r = [e, n, a], o = [n.node, e.node, a.node], s = 0; s < 3; s++) t.globals.dom.elGraphical.add(r[s]), !i || t.globals.resized || t.globals.dataChanged || "scatter" !== t.config.chart.type && "bubble" !== t.config.chart.type && t.globals.dataPoints > 1 && o[s].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({
                        el: o[s],
                        index: 0
                    });
                    this.helpers.annotationsBackground()
                }
            }
        }, {
            key: "drawImageAnnos", value: function () {
                var t = this;
                this.w.config.annotations.images.map((function (e, n) {
                    t.addImage(e, n)
                }))
            }
        }, {
            key: "drawTextAnnos", value: function () {
                var t = this;
                this.w.config.annotations.texts.map((function (e, n) {
                    t.addText(e, n)
                }))
            }
        }, {
            key: "addXaxisAnnotation", value: function (t, e, n) {
                this.xAxisAnnotations.addXaxisAnnotation(t, e, n)
            }
        }, {
            key: "addYaxisAnnotation", value: function (t, e, n) {
                this.yAxisAnnotations.addYaxisAnnotation(t, e, n)
            }
        }, {
            key: "addPointAnnotation", value: function (t, e, n) {
                this.pointsAnnotations.addPointAnnotation(t, e, n)
            }
        }, {
            key: "addText", value: function (t, e) {
                var n = t.x, a = t.y, i = t.text, r = t.textAnchor, o = t.foreColor, s = t.fontSize, l = t.fontFamily,
                    c = t.fontWeight, d = t.cssClass, u = t.backgroundColor, h = t.borderWidth, p = t.strokeDashArray,
                    f = t.borderRadius, g = t.borderColor, m = t.appendTo,
                    v = void 0 === m ? ".apexcharts-annotations" : m, b = t.paddingLeft, y = void 0 === b ? 4 : b,
                    x = t.paddingRight, _ = void 0 === x ? 4 : x, w = t.paddingBottom, S = void 0 === w ? 2 : w,
                    C = t.paddingTop, k = void 0 === C ? 2 : C, D = this.w, T = this.graphics.drawText({
                        x: n,
                        y: a,
                        text: i,
                        textAnchor: r || "start",
                        fontSize: s || "12px",
                        fontWeight: c || "regular",
                        fontFamily: l || D.config.chart.fontFamily,
                        foreColor: o || D.config.chart.foreColor,
                        cssClass: d
                    }), E = D.globals.dom.baseEl.querySelector(v);
                E && E.appendChild(T.node);
                var A = T.bbox();
                if (i) {
                    var I = this.graphics.drawRect(A.x - y, A.y - k, A.width + y + _, A.height + S + k, f, u || "transparent", 1, h, g, p);
                    E.insertBefore(I.node, T.node)
                }
            }
        }, {
            key: "addImage", value: function (t, e) {
                var n = this.w, a = t.path, i = t.x, r = void 0 === i ? 0 : i, o = t.y, s = void 0 === o ? 0 : o,
                    l = t.width, c = void 0 === l ? 20 : l, d = t.height, u = void 0 === d ? 20 : d, h = t.appendTo,
                    p = void 0 === h ? ".apexcharts-annotations" : h, f = n.globals.dom.Paper.image(a);
                f.size(c, u).move(r, s);
                var g = n.globals.dom.baseEl.querySelector(p);
                g && g.appendChild(f.node)
            }
        }, {
            key: "addXaxisAnnotationExternal", value: function (t, e, n) {
                return this.addAnnotationExternal({
                    params: t,
                    pushToMemory: e,
                    context: n,
                    type: "xaxis",
                    contextMethod: n.addXaxisAnnotation
                }), n
            }
        }, {
            key: "addYaxisAnnotationExternal", value: function (t, e, n) {
                return this.addAnnotationExternal({
                    params: t,
                    pushToMemory: e,
                    context: n,
                    type: "yaxis",
                    contextMethod: n.addYaxisAnnotation
                }), n
            }
        }, {
            key: "addPointAnnotationExternal", value: function (t, e, n) {
                return void 0 === this.invertAxis && (this.invertAxis = n.w.globals.isBarHorizontal), this.addAnnotationExternal({
                    params: t,
                    pushToMemory: e,
                    context: n,
                    type: "point",
                    contextMethod: n.addPointAnnotation
                }), n
            }
        }, {
            key: "addAnnotationExternal", value: function (t) {
                var e = t.params, n = t.pushToMemory, a = t.context, i = t.type, r = t.contextMethod, o = a, s = o.w,
                    l = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(i, "-annotations")),
                    c = l.childNodes.length + 1, d = new E,
                    u = Object.assign({}, "xaxis" === i ? d.xAxisAnnotation : "yaxis" === i ? d.yAxisAnnotation : d.pointAnnotation),
                    h = b.extend(u, e);
                switch (i) {
                    case"xaxis":
                        this.addXaxisAnnotation(h, l, c);
                        break;
                    case"yaxis":
                        this.addYaxisAnnotation(h, l, c);
                        break;
                    case"point":
                        this.addPointAnnotation(h, l, c)
                }
                var p = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(i, "-annotations .apexcharts-").concat(i, "-annotation-label[rel='").concat(c, "']")),
                    f = this.helpers.addBackgroundToAnno(p, h);
                return f && l.insertBefore(f.node, p), n && s.globals.memory.methodsToExec.push({
                    context: o,
                    id: h.id ? h.id : b.randomId(),
                    method: r,
                    label: "addAnnotation",
                    params: e
                }), a
            }
        }, {
            key: "clearAnnotations", value: function (t) {
                var e = t.w,
                    n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                e.globals.memory.methodsToExec.map((function (t, n) {
                    "addText" !== t.label && "addAnnotation" !== t.label || e.globals.memory.methodsToExec.splice(n, 1)
                })), n = b.listToArray(n), Array.prototype.forEach.call(n, (function (t) {
                    for (; t.firstChild;) t.removeChild(t.firstChild)
                }))
            }
        }, {
            key: "removeAnnotation", value: function (t, e) {
                var n = t.w, a = n.globals.dom.baseEl.querySelectorAll(".".concat(e));
                a && (n.globals.memory.methodsToExec.map((function (t, a) {
                    t.id === e && n.globals.memory.methodsToExec.splice(a, 1)
                })), Array.prototype.forEach.call(a, (function (t) {
                    t.parentElement.removeChild(t)
                })))
            }
        }]), t
    }(), I = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0
        }

        return s(t, [{
            key: "clippedImgArea", value: function (t) {
                var e = this.w, n = e.config, a = parseInt(e.globals.gridWidth, 10),
                    i = parseInt(e.globals.gridHeight, 10), r = a > i ? a : i, o = t.image, s = 0, l = 0;
                void 0 === t.width && void 0 === t.height ? void 0 !== n.fill.image.width && void 0 !== n.fill.image.height ? (s = n.fill.image.width + 1, l = n.fill.image.height) : (s = r + 1, l = r) : (s = t.width, l = t.height);
                var c = document.createElementNS(e.globals.SVGNS, "pattern");
                _.setAttrs(c, {
                    id: t.patternID,
                    patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse",
                    width: s + "px",
                    height: l + "px"
                });
                var d = document.createElementNS(e.globals.SVGNS, "image");
                c.appendChild(d), d.setAttributeNS(window.SVG.xlink, "href", o), _.setAttrs(d, {
                    x: 0,
                    y: 0,
                    preserveAspectRatio: "none",
                    width: s + "px",
                    height: l + "px"
                }), d.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(c)
            }
        }, {
            key: "getSeriesIndex", value: function (t) {
                var e = this.w;
                return ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || "heatmap" === e.config.chart.type || "treemap" === e.config.chart.type ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % e.globals.series.length, this.seriesIndex
            }
        }, {
            key: "fillPath", value: function (t) {
                var e = this.w;
                this.opts = t;
                var n, a, i, r = this.w.config;
                this.seriesIndex = this.getSeriesIndex(t);
                var o = this.getFillColors()[this.seriesIndex];
                void 0 !== e.globals.seriesColors[this.seriesIndex] && (o = e.globals.seriesColors[this.seriesIndex]), "function" == typeof o && (o = o({
                    seriesIndex: this.seriesIndex,
                    dataPointIndex: t.dataPointIndex,
                    value: t.value,
                    w: e
                }));
                var s = this.getFillType(this.seriesIndex),
                    l = Array.isArray(r.fill.opacity) ? r.fill.opacity[this.seriesIndex] : r.fill.opacity;
                t.color && (o = t.color);
                var c = o;
                if (-1 === o.indexOf("rgb") ? o.length < 9 && (c = b.hexToRgba(o, l)) : o.indexOf("rgba") > -1 && (l = b.getOpacityFromRGBA(o)), t.opacity && (l = t.opacity), "pattern" === s && (a = this.handlePatternFill(a, o, l, c)), "gradient" === s && (i = this.handleGradientFill(o, l, this.seriesIndex)), "image" === s) {
                    var d = r.fill.image.src, u = t.patternID ? t.patternID : "";
                    this.clippedImgArea({
                        opacity: l,
                        image: Array.isArray(d) ? t.seriesNumber < d.length ? d[t.seriesNumber] : d[0] : d,
                        width: t.width ? t.width : void 0,
                        height: t.height ? t.height : void 0,
                        patternUnits: t.patternUnits,
                        patternID: "pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(u)
                    }), n = "url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(u, ")")
                } else n = "gradient" === s ? i : "pattern" === s ? a : c;
                return t.solid && (n = c), n
            }
        }, {
            key: "getFillType", value: function (t) {
                var e = this.w;
                return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type
            }
        }, {
            key: "getFillColors", value: function () {
                var t = this.w, e = t.config, n = this.opts, a = [];
                return t.globals.comboCharts ? "line" === t.config.series[this.seriesIndex].type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors) : "line" === e.chart.type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors), void 0 !== n.fillColors && (a = [], Array.isArray(n.fillColors) ? a = n.fillColors.slice() : a.push(n.fillColors)), a
            }
        }, {
            key: "handlePatternFill", value: function (t, e, n, a) {
                var i = this.w.config, r = this.opts, o = new _(this.ctx),
                    s = void 0 === i.fill.pattern.strokeWidth ? Array.isArray(i.stroke.width) ? i.stroke.width[this.seriesIndex] : i.stroke.width : Array.isArray(i.fill.pattern.strokeWidth) ? i.fill.pattern.strokeWidth[this.seriesIndex] : i.fill.pattern.strokeWidth,
                    l = e;
                return Array.isArray(i.fill.pattern.style) ? void 0 !== i.fill.pattern.style[r.seriesNumber] ? o.drawPattern(i.fill.pattern.style[r.seriesNumber], i.fill.pattern.width, i.fill.pattern.height, l, s, n) : a : o.drawPattern(i.fill.pattern.style, i.fill.pattern.width, i.fill.pattern.height, l, s, n)
            }
        }, {
            key: "handleGradientFill", value: function (t, e, n) {
                var a, i = this.w.config, r = this.opts, o = new _(this.ctx), s = new b, l = i.fill.gradient.type,
                    c = t,
                    d = void 0 === i.fill.gradient.opacityFrom ? e : Array.isArray(i.fill.gradient.opacityFrom) ? i.fill.gradient.opacityFrom[n] : i.fill.gradient.opacityFrom;
                c.indexOf("rgba") > -1 && (d = b.getOpacityFromRGBA(c));
                var u = void 0 === i.fill.gradient.opacityTo ? e : Array.isArray(i.fill.gradient.opacityTo) ? i.fill.gradient.opacityTo[n] : i.fill.gradient.opacityTo;
                if (void 0 === i.fill.gradient.gradientToColors || 0 === i.fill.gradient.gradientToColors.length) a = "dark" === i.fill.gradient.shade ? s.shadeColor(-1 * parseFloat(i.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? b.rgb2hex(t) : t) : s.shadeColor(parseFloat(i.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? b.rgb2hex(t) : t); else if (i.fill.gradient.gradientToColors[r.seriesNumber]) {
                    var h = i.fill.gradient.gradientToColors[r.seriesNumber];
                    a = h, h.indexOf("rgba") > -1 && (u = b.getOpacityFromRGBA(h))
                } else a = t;
                if (i.fill.gradient.inverseColors) {
                    var p = c;
                    c = a, a = p
                }
                return c.indexOf("rgb") > -1 && (c = b.rgb2hex(c)), a.indexOf("rgb") > -1 && (a = b.rgb2hex(a)), o.drawGradient(l, c, a, d, u, r.size, i.fill.gradient.stops, i.fill.gradient.colorStops, n)
            }
        }]), t
    }(), M = function () {
        function t(e, n) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "setGlobalMarkerSize", value: function () {
                var t = this.w;
                if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
                    if (t.globals.markers.size.length < t.globals.series.length + 1) for (var e = 0; e <= t.globals.series.length; e++) void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0])
                } else t.globals.markers.size = t.config.series.map((function (e) {
                    return t.config.markers.size
                }))
            }
        }, {
            key: "plotChartMarkers", value: function (t, e, n, a) {
                var i, r = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], o = this.w, s = e, l = t,
                    c = null, d = new _(this.ctx);
                if ((o.globals.markers.size[e] > 0 || r) && (c = d.group({class: r ? "" : "apexcharts-series-markers"})).attr("clip-path", "url(#gridRectMarkerMask".concat(o.globals.cuid, ")")), Array.isArray(l.x)) for (var u = 0; u < l.x.length; u++) {
                    var h = n;
                    1 === n && 0 === u && (h = 0), 1 === n && 1 === u && (h = 1);
                    var p = "apexcharts-marker";
                    "line" !== o.config.chart.type && "area" !== o.config.chart.type || o.globals.comboCharts || o.config.tooltip.intersect || (p += " no-pointer-events");
                    var f = Array.isArray(o.config.markers.size) ? o.globals.markers.size[e] > 0 : o.config.markers.size > 0;
                    if (f || r) {
                        b.isNumber(l.y[u]) ? p += " w".concat(b.randomId()) : p = "apexcharts-nullpoint";
                        var g = this.getMarkerConfig(p, e, h);
                        o.config.series[s].data[h] && (o.config.series[s].data[h].fillColor && (g.pointFillColor = o.config.series[s].data[h].fillColor), o.config.series[s].data[h].strokeColor && (g.pointStrokeColor = o.config.series[s].data[h].strokeColor)), a && (g.pSize = a), (i = d.drawMarker(l.x[u], l.y[u], g)).attr("rel", h), i.attr("j", h), i.attr("index", e), i.node.setAttribute("default-marker-size", g.pSize);
                        var m = new y(this.ctx);
                        m.setSelectionFilter(i, e, h), this.addEvents(i), c && c.add(i)
                    } else void 0 === o.globals.pointsArray[e] && (o.globals.pointsArray[e] = []), o.globals.pointsArray[e].push([l.x[u], l.y[u]])
                }
                return c
            }
        }, {
            key: "getMarkerConfig", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a = this.w,
                    i = this.getMarkerStyle(e), r = a.globals.markers.size[e], o = a.config.markers;
                return null !== n && o.discrete.length && o.discrete.map((function (t) {
                    t.seriesIndex === e && t.dataPointIndex === n && (i.pointStrokeColor = t.strokeColor, i.pointFillColor = t.fillColor, r = t.size)
                })), {
                    pSize: r,
                    pRadius: o.radius,
                    pWidth: Array.isArray(o.strokeWidth) ? o.strokeWidth[e] : o.strokeWidth,
                    pointStrokeColor: i.pointStrokeColor,
                    pointFillColor: i.pointFillColor,
                    shape: Array.isArray(o.shape) ? o.shape[e] : o.shape,
                    class: t,
                    pointStrokeOpacity: Array.isArray(o.strokeOpacity) ? o.strokeOpacity[e] : o.strokeOpacity,
                    pointStrokeDashArray: Array.isArray(o.strokeDashArray) ? o.strokeDashArray[e] : o.strokeDashArray,
                    pointFillOpacity: Array.isArray(o.fillOpacity) ? o.fillOpacity[e] : o.fillOpacity,
                    seriesIndex: e
                }
            }
        }, {
            key: "addEvents", value: function (t) {
                var e = this.w, n = new _(this.ctx);
                t.node.addEventListener("mouseenter", n.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", n.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", n.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", e.config.markers.onClick), t.node.addEventListener("dblclick", e.config.markers.onDblClick), t.node.addEventListener("touchstart", n.pathMouseDown.bind(this.ctx, t), {passive: !0})
            }
        }, {
            key: "getMarkerStyle", value: function (t) {
                var e = this.w, n = e.globals.markers.colors,
                    a = e.config.markers.strokeColor || e.config.markers.strokeColors;
                return {pointStrokeColor: Array.isArray(a) ? a[t] : a, pointFillColor: Array.isArray(n) ? n[t] : n}
            }
        }]), t
    }(), R = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
        }

        return s(t, [{
            key: "draw", value: function (t, e, n) {
                var a = this.w, i = new _(this.ctx), r = n.realIndex, o = n.pointsPos, s = n.zRatio, l = n.elParent,
                    c = i.group({class: "apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)});
                if (c.attr("clip-path", "url(#gridRectMarkerMask".concat(a.globals.cuid, ")")), Array.isArray(o.x)) for (var d = 0; d < o.x.length; d++) {
                    var u = e + 1, h = !0;
                    0 === e && 0 === d && (u = 0), 0 === e && 1 === d && (u = 1);
                    var p = 0, f = a.globals.markers.size[r];
                    if (s !== 1 / 0) {
                        f = a.globals.seriesZ[r][u] / s;
                        var g = a.config.plotOptions.bubble;
                        g.minBubbleRadius && f < g.minBubbleRadius && (f = g.minBubbleRadius), g.maxBubbleRadius && f > g.maxBubbleRadius && (f = g.maxBubbleRadius)
                    }
                    a.config.chart.animations.enabled || (p = f);
                    var m = o.x[d], v = o.y[d];
                    if (p = p || 0, null !== v && void 0 !== a.globals.series[r][u] || (h = !1), h) {
                        var b = this.drawPoint(m, v, p, f, r, u, e);
                        c.add(b)
                    }
                    l.add(c)
                }
            }
        }, {
            key: "drawPoint", value: function (t, e, n, a, i, r, o) {
                var s = this.w, l = i, c = new x(this.ctx), d = new y(this.ctx), u = new I(this.ctx),
                    h = new M(this.ctx), p = new _(this.ctx), f = h.getMarkerConfig("apexcharts-marker", l),
                    g = u.fillPath({
                        seriesNumber: i,
                        dataPointIndex: r,
                        patternUnits: "objectBoundingBox",
                        value: s.globals.series[i][o]
                    }), m = p.drawCircle(n);
                if (s.config.series[l].data[r] && s.config.series[l].data[r].fillColor && (g = s.config.series[l].data[r].fillColor), m.attr({
                    cx: t,
                    cy: e,
                    fill: g,
                    stroke: f.pointStrokeColor,
                    r: a,
                    "stroke-width": f.pWidth,
                    "stroke-dasharray": f.pointStrokeDashArray,
                    "stroke-opacity": f.pointStrokeOpacity
                }), s.config.chart.dropShadow.enabled) {
                    var v = s.config.chart.dropShadow;
                    d.dropShadow(m, v, i)
                }
                if (this.initialAnim && !s.globals.dataChanged && !s.globals.resized) {
                    var b = s.config.chart.animations.speed;
                    c.animateCircleRadius(m, 0, a, b, s.globals.easing, (function () {
                        window.setTimeout((function () {
                            c.animationCompleted(m)
                        }), 100)
                    }))
                }
                if (s.globals.dataChanged) if (this.dynamicAnim) {
                    var w, S, C, k, D = s.config.chart.animations.dynamicAnimation.speed;
                    null != (k = s.globals.previousPaths[i] && s.globals.previousPaths[i][o]) && (w = k.x, S = k.y, C = void 0 !== k.r ? k.r : a);
                    for (var T = 0; T < s.globals.collapsedSeries.length; T++) s.globals.collapsedSeries[T].index === i && (D = 1, a = 0);
                    0 === t && 0 === e && (a = 0), c.animateCircle(m, {cx: w, cy: S, r: C}, {
                        cx: t,
                        cy: e,
                        r: a
                    }, D, s.globals.easing)
                } else m.attr({r: a});
                return m.attr({
                    rel: r,
                    j: r,
                    index: i,
                    "default-marker-size": a
                }), d.setSelectionFilter(m, i, r), h.addEvents(m), m.node.classList.add("apexcharts-marker"), m
            }
        }, {
            key: "centerTextInBubble", value: function (t) {
                var e = this.w;
                return {y: t += parseInt(e.config.dataLabels.style.fontSize, 10) / 4}
            }
        }]), t
    }(), P = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "dataLabelsCorrection", value: function (t, e, n, a, i, r, o) {
                var s = this.w, l = !1, c = new _(this.ctx).getTextRects(n, o), d = c.width, u = c.height;
                void 0 === s.globals.dataLabelsRects[a] && (s.globals.dataLabelsRects[a] = []), s.globals.dataLabelsRects[a].push({
                    x: t,
                    y: e,
                    width: d,
                    height: u
                });
                var h = s.globals.dataLabelsRects[a].length - 2,
                    p = void 0 !== s.globals.lastDrawnDataLabelsIndexes[a] ? s.globals.lastDrawnDataLabelsIndexes[a][s.globals.lastDrawnDataLabelsIndexes[a].length - 1] : 0;
                if (void 0 !== s.globals.dataLabelsRects[a][h]) {
                    var f = s.globals.dataLabelsRects[a][p];
                    (t > f.x + f.width + 2 || e > f.y + f.height + 2 || t + d < f.x) && (l = !0)
                }
                return (0 === i || r) && (l = !0), {x: t, y: e, textRects: c, drawnextLabel: l}
            }
        }, {
            key: "drawDataLabel", value: function (t, e, n) {
                var a = this, i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2, r = this.w,
                    o = new _(this.ctx), s = r.config.dataLabels, l = 0, c = 0, d = n, u = null;
                if (!s.enabled || !Array.isArray(t.x)) return u;
                u = o.group({class: "apexcharts-data-labels"});
                for (var h = 0; h < t.x.length; h++) if (l = t.x[h] + s.offsetX, c = t.y[h] + s.offsetY + i, !isNaN(l)) {
                    1 === n && 0 === h && (d = 0), 1 === n && 1 === h && (d = 1);
                    var p = r.globals.series[e][d], f = "", g = function (t) {
                        return r.config.dataLabels.formatter(t, {ctx: a.ctx, seriesIndex: e, dataPointIndex: d, w: r})
                    };
                    if ("bubble" === r.config.chart.type) {
                        f = g(p = r.globals.seriesZ[e][d]), c = t.y[h];
                        var m = new R(this.ctx), v = m.centerTextInBubble(c, e, d);
                        c = v.y
                    } else void 0 !== p && (f = g(p));
                    this.plotDataLabelsText({
                        x: l,
                        y: c,
                        text: f,
                        i: e,
                        j: d,
                        parent: u,
                        offsetCorrection: !0,
                        dataLabelsConfig: r.config.dataLabels
                    })
                }
                return u
            }
        }, {
            key: "plotDataLabelsText", value: function (t) {
                var e = this.w, n = new _(this.ctx), a = t.x, i = t.y, r = t.i, o = t.j, s = t.text, l = t.textAnchor,
                    c = t.fontSize, d = t.parent, u = t.dataLabelsConfig, h = t.color, p = t.alwaysDrawDataLabel,
                    f = t.offsetCorrection;
                if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(r) < 0)) {
                    var g = {x: a, y: i, drawnextLabel: !0};
                    f && (g = this.dataLabelsCorrection(a, i, s, r, o, p, parseInt(u.style.fontSize, 10))), e.globals.zoomed || (a = g.x, i = g.y), g.textRects && (a + g.textRects.width < -20 || a > e.globals.gridWidth + 20) && (s = "");
                    var m = e.globals.dataLabels.style.colors[r];
                    (("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || e.config.dataLabels.distributed) && (m = e.globals.dataLabels.style.colors[o]), h && (m = h);
                    var v = u.offsetX, b = u.offsetY;
                    if ("bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || (v = 0, b = 0), g.drawnextLabel) {
                        var x = n.drawText({
                            width: 100,
                            height: parseInt(u.style.fontSize, 10),
                            x: a + v,
                            y: i + b,
                            foreColor: m,
                            textAnchor: l || u.textAnchor,
                            text: s,
                            fontSize: c || u.style.fontSize,
                            fontFamily: u.style.fontFamily,
                            fontWeight: u.style.fontWeight || "normal"
                        });
                        if (x.attr({class: "apexcharts-datalabel", cx: a, cy: i}), u.dropShadow.enabled) {
                            var w = u.dropShadow;
                            new y(this.ctx).dropShadow(x, w)
                        }
                        d.add(x), void 0 === e.globals.lastDrawnDataLabelsIndexes[r] && (e.globals.lastDrawnDataLabelsIndexes[r] = []), e.globals.lastDrawnDataLabelsIndexes[r].push(o)
                    }
                }
            }
        }, {
            key: "addBackgroundToDataLabel", value: function (t, e) {
                var n = this.w, a = n.config.dataLabels.background, i = a.padding, r = a.padding / 2, o = e.width,
                    s = e.height,
                    l = new _(this.ctx).drawRect(e.x - i, e.y - r / 2, o + 2 * i, s + r, a.borderRadius, "transparent" === n.config.chart.background ? "#fff" : n.config.chart.background, a.opacity, a.borderWidth, a.borderColor);
                return a.dropShadow.enabled && new y(this.ctx).dropShadow(l, a.dropShadow), l
            }
        }, {
            key: "dataLabelsBackground", value: function () {
                var t = this.w;
                if ("bubble" !== t.config.chart.type) for (var e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), n = 0; n < e.length; n++) {
                    var a = e[n], i = a.getBBox(), r = null;
                    if (i.width && i.height && (r = this.addBackgroundToDataLabel(a, i)), r) {
                        a.parentNode.insertBefore(r.node, a);
                        var o = a.getAttribute("fill");
                        !t.config.chart.animations.enabled || t.globals.resized || t.globals.dataChanged ? r.attr({fill: o}) : r.animate().attr({fill: o}), a.setAttribute("fill", t.config.dataLabels.background.foreColor)
                    }
                }
            }
        }, {
            key: "bringForward", value: function () {
                for (var t = this.w, e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), n = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a = 0; a < e.length; a++) n && n.insertBefore(e[a], n.nextSibling)
            }
        }]), t
    }(), O = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.barCtx = e
        }

        return s(t, [{
            key: "handleBarDataLabels", value: function (t) {
                var e = t.x, n = t.y, a = t.y1, i = t.y2, r = t.i, o = t.j, s = t.realIndex, l = t.series,
                    c = t.barHeight, d = t.barWidth, u = t.barYPosition, h = t.visibleSeries, p = t.renderedPath,
                    f = this.w, g = new _(this.barCtx.ctx),
                    m = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[s] : this.barCtx.strokeWidth,
                    v = e + parseFloat(d * h), b = n + parseFloat(c * h);
                f.globals.isXNumeric && !f.globals.isBarHorizontal && (v = e + parseFloat(d * (h + 1)), b = n + parseFloat(c * (h + 1)) - m);
                var y, x = e, w = n, S = f.config.dataLabels, C = this.barCtx.barOptions.dataLabels;
                void 0 !== u && this.barCtx.isTimelineBar && (b = u, w = u);
                var k = S.offsetX, D = S.offsetY, T = {width: 0, height: 0};
                if (f.config.dataLabels.enabled) {
                    var E = this.barCtx.series[r][o];
                    T = g.getTextRects(f.globals.yLabelFormatters[0](E), parseFloat(S.style.fontSize))
                }
                var A = {
                    x: e,
                    y: n,
                    i: r,
                    j: o,
                    renderedPath: p,
                    bcx: v,
                    bcy: b,
                    barHeight: c,
                    barWidth: d,
                    textRects: T,
                    strokeWidth: m,
                    dataLabelsX: x,
                    dataLabelsY: w,
                    barDataLabelsConfig: C,
                    offX: k,
                    offY: D
                };
                return y = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(A) : this.calculateColumnsDataLabelsPosition(A), p.attr({
                    cy: y.bcy,
                    cx: y.bcx,
                    j: o,
                    val: l[r][o],
                    barHeight: c,
                    barWidth: d
                }), this.drawCalculatedDataLabels({
                    x: y.dataLabelsX,
                    y: y.dataLabelsY,
                    val: this.barCtx.isTimelineBar ? [a, i] : l[r][o],
                    i: s,
                    j: o,
                    barWidth: d,
                    barHeight: c,
                    textRects: T,
                    dataLabelsConfig: S
                })
            }
        }, {
            key: "calculateColumnsDataLabelsPosition", value: function (t) {
                var e, n = this.w, a = t.i, i = t.j, r = t.y, o = t.bcx, s = t.barWidth, l = t.barHeight,
                    c = t.textRects, d = t.dataLabelsY, u = t.barDataLabelsConfig, h = t.strokeWidth, p = t.offX,
                    f = t.offY;
                l = Math.abs(l);
                var g = "vertical" === n.config.plotOptions.bar.dataLabels.orientation;
                o -= h / 2;
                var m = n.globals.gridWidth / n.globals.dataPoints;
                e = n.globals.isXNumeric ? o - s / 2 + p : o - m + s / 2 + p, g && (e = e + c.height / 2 - h / 2 - 2);
                var v = this.barCtx.series[a][i] < 0, b = r;
                switch (this.barCtx.isReversed && (b = r - l + (v ? 2 * l : 0), r -= l), u.position) {
                    case"center":
                        d = g ? v ? b + l / 2 + f : b + l / 2 - f : v ? b - l / 2 + c.height / 2 + f : b + l / 2 + c.height / 2 - f;
                        break;
                    case"bottom":
                        d = g ? v ? b + l + f : b + l - f : v ? b - l + c.height + h + f : b + l - c.height / 2 + h - f;
                        break;
                    case"top":
                        d = g ? v ? b + f : b - f : v ? b - c.height / 2 - f : b + c.height + f
                }
                return n.config.chart.stacked || (d < 0 ? d = 0 + h : d + c.height / 3 > n.globals.gridHeight && (d = n.globals.gridHeight - h)), {
                    bcx: o,
                    bcy: r,
                    dataLabelsX: e,
                    dataLabelsY: d
                }
            }
        }, {
            key: "calculateBarsDataLabelsPosition", value: function (t) {
                var e = this.w, n = t.x, a = t.i, i = t.j, r = t.bcy, o = t.barHeight, s = t.barWidth, l = t.textRects,
                    c = t.dataLabelsX, d = t.strokeWidth, u = t.barDataLabelsConfig, h = t.offX, p = t.offY,
                    f = e.globals.gridHeight / e.globals.dataPoints;
                s = Math.abs(s);
                var g = r - (this.barCtx.isTimelineBar ? 0 : f) + o / 2 + l.height / 2 + p - 3,
                    m = this.barCtx.series[a][i] < 0, v = n;
                switch (this.barCtx.isReversed && (v = n + s - (m ? 2 * s : 0), n = e.globals.gridWidth - s), u.position) {
                    case"center":
                        c = m ? v + s / 2 - h : Math.max(l.width / 2, v - s / 2) + h;
                        break;
                    case"bottom":
                        c = m ? v + s - d - Math.round(l.width / 2) - h : v - s + d + Math.round(l.width / 2) + h;
                        break;
                    case"top":
                        c = m ? v - d + Math.round(l.width / 2) - h : v - d - Math.round(l.width / 2) + h
                }
                return e.config.chart.stacked || (c < 0 ? c = c + l.width + d : c + l.width / 2 > e.globals.gridWidth && (c = e.globals.gridWidth - l.width - d)), {
                    bcx: n,
                    bcy: r,
                    dataLabelsX: c,
                    dataLabelsY: g
                }
            }
        }, {
            key: "drawCalculatedDataLabels", value: function (t) {
                var e = t.x, n = t.y, a = t.val, i = t.i, r = t.j, o = t.textRects, s = t.barHeight, l = t.barWidth,
                    c = t.dataLabelsConfig, u = this.w, h = "rotate(0)";
                "vertical" === u.config.plotOptions.bar.dataLabels.orientation && (h = "rotate(-90, ".concat(e, ", ").concat(n, ")"));
                var p = new P(this.barCtx.ctx), f = new _(this.barCtx.ctx), g = c.formatter, m = null,
                    v = u.globals.collapsedSeriesIndices.indexOf(i) > -1;
                if (c.enabled && !v) {
                    m = f.group({class: "apexcharts-data-labels", transform: h});
                    var b = "";
                    void 0 !== a && (b = g(a, {
                        seriesIndex: i,
                        dataPointIndex: r,
                        w: u
                    })), 0 === a && u.config.chart.stacked && (b = "");
                    var y = u.globals.series[i][r] <= 0, x = u.config.plotOptions.bar.dataLabels.position;
                    "vertical" === u.config.plotOptions.bar.dataLabels.orientation && ("top" === x && (c.textAnchor = y ? "end" : "start"), "center" === x && (c.textAnchor = "middle"), "bottom" === x && (c.textAnchor = y ? "end" : "start")), this.barCtx.isTimelineBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && l < f.getTextRects(b, parseFloat(c.style.fontSize)).width && (b = ""), u.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? (l > 0 && o.width / 1.6 > l || l < 0 && o.width / 1.6 < l) && (b = "") : o.height / 1.6 > s && (b = ""));
                    var w = d({}, c);
                    this.barCtx.isHorizontal && a < 0 && ("start" === c.textAnchor ? w.textAnchor = "end" : "end" === c.textAnchor && (w.textAnchor = "start")), p.plotDataLabelsText({
                        x: e,
                        y: n,
                        text: b,
                        i: i,
                        j: r,
                        parent: m,
                        dataLabelsConfig: w,
                        alwaysDrawDataLabel: !0,
                        offsetCorrection: !0
                    })
                }
                return m
            }
        }]), t
    }(), j = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive"
        }

        return s(t, [{
            key: "getAllSeriesEls", value: function () {
                return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
            }
        }, {
            key: "getSeriesByName", value: function (t) {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(b.escapeString(t), "']"))
            }
        }, {
            key: "isSeriesHidden", value: function (t) {
                var e = this.getSeriesByName(t), n = parseInt(e.getAttribute("data:realIndex"), 10);
                return {isHidden: e.classList.contains("apexcharts-series-collapsed"), realIndex: n}
            }
        }, {
            key: "addCollapsedClassToSeries", value: function (t, e) {
                var n = this.w;

                function a(n) {
                    for (var a = 0; a < n.length; a++) n[a].index === e && t.node.classList.add("apexcharts-series-collapsed")
                }

                a(n.globals.collapsedSeries), a(n.globals.ancillaryCollapsedSeries)
            }
        }, {
            key: "toggleSeries", value: function (t) {
                var e = this.isSeriesHidden(t);
                return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden
            }
        }, {
            key: "showSeries", value: function (t) {
                var e = this.isSeriesHidden(t);
                e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0)
            }
        }, {
            key: "hideSeries", value: function (t) {
                var e = this.isSeriesHidden(t);
                e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1)
            }
        }, {
            key: "resetSeries", value: function () {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                    e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a = this.w,
                    i = b.clone(a.globals.initialSeries);
                a.globals.previousPaths = [], n ? (a.globals.collapsedSeries = [], a.globals.ancillaryCollapsedSeries = [], a.globals.collapsedSeriesIndices = [], a.globals.ancillaryCollapsedSeriesIndices = []) : i = this.emptyCollapsedSeries(i), a.config.series = i, t && (e && (a.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(i, a.config.chart.animations.dynamicAnimation.enabled))
            }
        }, {
            key: "emptyCollapsedSeries", value: function (t) {
                for (var e = this.w, n = 0; n < t.length; n++) e.globals.collapsedSeriesIndices.indexOf(n) > -1 && (t[n].data = []);
                return t
            }
        }, {
            key: "toggleSeriesOnHover", value: function (t, e) {
                var n = this.w, a = n.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                if ("mousemove" === t.type) {
                    var i = parseInt(e.getAttribute("rel"), 10) - 1, r = null, o = null;
                    n.globals.axisCharts || "radialBar" === n.config.chart.type ? n.globals.axisCharts ? (r = n.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(i, "']")), o = n.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(i, "']"))) : r = n.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(i + 1, "']")) : r = n.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(i + 1, "'] path"));
                    for (var s = 0; s < a.length; s++) a[s].classList.add(this.legendInactiveClass);
                    null !== r && (n.globals.axisCharts || r.parentNode.classList.remove(this.legendInactiveClass), r.classList.remove(this.legendInactiveClass), null !== o && o.classList.remove(this.legendInactiveClass))
                } else if ("mouseout" === t.type) for (var l = 0; l < a.length; l++) a[l].classList.remove(this.legendInactiveClass)
            }
        }, {
            key: "highlightRangeInSeries", value: function (t, e) {
                var n = this, a = this.w, i = a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
                    r = function (t) {
                        for (var e = 0; e < i.length; e++) i[e].classList[t](n.legendInactiveClass)
                    };
                if ("mousemove" === t.type) {
                    var o = parseInt(e.getAttribute("rel"), 10) - 1;
                    r("add"), function (t) {
                        for (var e = 0; e < i.length; e++) {
                            var a = parseInt(i[e].getAttribute("val"), 10);
                            a >= t.from && a <= t.to && i[e].classList.remove(n.legendInactiveClass)
                        }
                    }(a.config.plotOptions.heatmap.colorScale.ranges[o])
                } else "mouseout" === t.type && r("remove")
            }
        }, {
            key: "getActiveConfigSeriesIndex", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], e = this.w, n = 0;
                if (e.config.series.length > 1) for (var a = e.config.series.map((function (n, a) {
                    var i = !1;
                    return t && (i = "bar" === e.config.series[a].type || "column" === e.config.series[a].type), n.data && n.data.length > 0 && !i ? a : -1
                })), i = 0; i < a.length; i++) if (-1 !== a[i]) {
                    n = a[i];
                    break
                }
                return n
            }
        }, {
            key: "getPreviousPaths", value: function () {
                var t = this.w;

                function e(e, n, a) {
                    for (var i = e[n].childNodes, r = {
                        type: a,
                        paths: [],
                        realIndex: e[n].getAttribute("data:realIndex")
                    }, o = 0; o < i.length; o++) if (i[o].hasAttribute("pathTo")) {
                        var s = i[o].getAttribute("pathTo");
                        r.paths.push({d: s})
                    }
                    t.globals.previousPaths.push(r)
                }

                t.globals.previousPaths = [], ["line", "area", "bar", "candlestick", "radar"].forEach((function (n) {
                    for (var a, i = (a = n, t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a, "-series .apexcharts-series"))), r = 0; r < i.length; r++) e(i, r, n)
                })), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
                var n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
                if (n.length > 0) for (var a = function (e) {
                    for (var n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e, "'] rect")), a = [], i = function (t) {
                        var e = function (e) {
                            return n[t].getAttribute(e)
                        }, i = {
                            x: parseFloat(e("x")),
                            y: parseFloat(e("y")),
                            width: parseFloat(e("width")),
                            height: parseFloat(e("height"))
                        };
                        a.push({rect: i, color: n[t].getAttribute("color")})
                    }, r = 0; r < n.length; r++) i(r);
                    t.globals.previousPaths.push(a)
                }, i = 0; i < n.length; i++) a(i);
                t.globals.axisCharts || (t.globals.previousPaths = t.globals.series)
            }
        }, {
            key: "handlePrevBubbleScatterPaths", value: function (t) {
                var e = this.w,
                    n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
                if (n.length > 0) for (var a = 0; a < n.length; a++) {
                    for (var i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(a, "'] circle")), r = [], o = 0; o < i.length; o++) r.push({
                        x: i[o].getAttribute("cx"),
                        y: i[o].getAttribute("cy"),
                        r: i[o].getAttribute("r")
                    });
                    e.globals.previousPaths.push(r)
                }
            }
        }, {
            key: "clearPreviousPaths", value: function () {
                var t = this.w;
                t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1
            }
        }, {
            key: "handleNoData", value: function () {
                var t = this.w, e = t.config.noData, n = new _(this.ctx), a = t.globals.svgWidth / 2,
                    i = t.globals.svgHeight / 2, r = "middle";
                if (t.globals.noData = !0, t.globals.animationEnded = !0, "left" === e.align ? (a = 10, r = "start") : "right" === e.align && (a = t.globals.svgWidth - 10, r = "end"), "top" === e.verticalAlign ? i = 50 : "bottom" === e.verticalAlign && (i = t.globals.svgHeight - 50), a += e.offsetX, i = i + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && "" !== e.text) {
                    var o = n.drawText({
                        x: a,
                        y: i,
                        text: e.text,
                        textAnchor: r,
                        fontSize: e.style.fontSize,
                        fontFamily: e.style.fontFamily,
                        foreColor: e.style.color,
                        opacity: 1,
                        class: "apexcharts-text-nodata"
                    });
                    t.globals.dom.Paper.add(o)
                }
            }
        }, {
            key: "setNullSeriesToZeroValues", value: function (t) {
                for (var e = this.w, n = 0; n < t.length; n++) if (0 === t[n].length) for (var a = 0; a < t[e.globals.maxValsInArrayIndex].length; a++) t[n].push(0);
                return t
            }
        }, {
            key: "hasAllSeriesEqualX", value: function () {
                for (var t = !0, e = this.w, n = this.filteredSeriesX(), a = 0; a < n.length - 1; a++) if (n[a][0] !== n[a + 1][0]) {
                    t = !1;
                    break
                }
                return e.globals.allSeriesHasEqualX = t, t
            }
        }, {
            key: "filteredSeriesX", value: function () {
                return this.w.globals.seriesX.map((function (t) {
                    return t.length > 0 ? t : []
                }))
            }
        }]), t
    }(), N = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.barCtx = e
        }

        return s(t, [{
            key: "initVariables", value: function (t) {
                var e = this.w;
                this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
                for (var n = 0; n < t.length; n++) if (t[n].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[n].length), e.globals.isXNumeric) for (var a = 0; a < t[n].length; a++) e.globals.seriesX[n][a] > e.globals.minX && e.globals.seriesX[n][a] < e.globals.maxX && this.barCtx.visibleItems++; else this.barCtx.visibleItems = e.globals.dataPoints;
                0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1)
            }
        }, {
            key: "initialPositions", value: function () {
                var t, e, n, a, i, r, o, s, l = this.w, c = l.globals.dataPoints;
                this.barCtx.isTimelineBar && (c = l.globals.labels.length);
                var d = this.barCtx.seriesLen;
                if (l.config.plotOptions.bar.rangeBarGroupRows && (d = 1), this.barCtx.isHorizontal) i = (n = l.globals.gridHeight / c) / d, l.globals.isXNumeric && (i = (n = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), i = i * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, s = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e = (n - i * this.barCtx.seriesLen) / 2; else {
                    if (a = l.globals.gridWidth / this.barCtx.visibleItems, l.config.xaxis.convertedCatToNumeric && (a = l.globals.gridWidth / l.globals.dataPoints), r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric) {
                        var u = this.barCtx.xRatio;
                        l.config.xaxis.convertedCatToNumeric && (u = this.barCtx.initialXRatio), l.globals.minXDiff && .5 !== l.globals.minXDiff && l.globals.minXDiff / u > 0 && (a = l.globals.minXDiff / u), (r = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (r = 1)
                    }
                    o = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = l.globals.padHorizontal + (a - r * this.barCtx.seriesLen) / 2
                }
                return {x: t, y: e, yDivision: n, xDivision: a, barHeight: i, barWidth: r, zeroH: o, zeroW: s}
            }
        }, {
            key: "getPathFillColor", value: function (t, e, n, a) {
                var i = this.w, r = new I(this.barCtx.ctx), o = null, s = this.barCtx.barOptions.distributed ? n : e;
                return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map((function (a) {
                    t[e][n] >= a.from && t[e][n] <= a.to && (o = a.color)
                })), i.config.series[e].data[n] && i.config.series[e].data[n].fillColor && (o = i.config.series[e].data[n].fillColor), r.fillPath({
                    seriesNumber: this.barCtx.barOptions.distributed ? s : a,
                    dataPointIndex: n,
                    color: o,
                    value: t[e][n]
                })
            }
        }, {
            key: "getStrokeWidth", value: function (t, e, n) {
                var a = 0, i = this.w;
                return void 0 === this.barCtx.series[t][e] || null === this.barCtx.series[t][e] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, i.config.stroke.show && (this.barCtx.isNullValue || (a = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[n] : this.barCtx.strokeWidth)), a
            }
        }, {
            key: "barBackground", value: function (t) {
                var e = t.j, n = t.i, a = t.x1, i = t.x2, r = t.y1, o = t.y2, s = t.elSeries, l = this.w,
                    c = new _(this.barCtx.ctx), d = new j(this.barCtx.ctx).getActiveConfigSeriesIndex();
                if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && d === n) {
                    e >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e -= this.barCtx.barOptions.colors.backgroundBarColors.length);
                    var u = this.barCtx.barOptions.colors.backgroundBarColors[e],
                        h = c.drawRect(void 0 !== a ? a : 0, void 0 !== r ? r : 0, void 0 !== i ? i : l.globals.gridWidth, void 0 !== o ? o : l.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, u, this.barCtx.barOptions.colors.backgroundBarOpacity);
                    s.add(h), h.node.classList.add("apexcharts-backgroundBar")
                }
            }
        }, {
            key: "getColumnPaths", value: function (t) {
                var e = t.barWidth, n = t.barXPosition, a = t.yRatio, i = t.y1, r = t.y2, o = t.strokeWidth,
                    s = t.series, l = t.realIndex, c = t.i, d = t.j, u = t.w, h = new _(this.barCtx.ctx);
                (o = Array.isArray(o) ? o[l] : o) || (o = 0);
                var p = {barWidth: e, strokeWidth: o, yRatio: a, barXPosition: n, y1: i, y2: r},
                    f = this.getRoundedBars(u, p, s, c, d), g = n, m = n + e, v = h.move(g, f.y1), b = h.move(g, f.y1);
                return u.globals.previousPaths.length > 0 && (b = this.barCtx.getPreviousPath(l, d, !1)), {
                    pathTo: v = v + h.line(g, f.y2) + f.endingPath + h.line(m - o, f.y2) + h.line(m - o, f.y1) + f.startingPath + "z",
                    pathFrom: b = b + h.line(g, i) + h.line(m - o, i) + h.line(m - o, i) + h.line(m - o, i) + h.line(g, i)
                }
            }
        }, {
            key: "getBarpaths", value: function (t) {
                var e = t.barYPosition, n = t.barHeight, a = t.x1, i = t.x2, r = t.strokeWidth, o = t.series,
                    s = t.realIndex, l = t.i, c = t.j, d = t.w, u = new _(this.barCtx.ctx);
                (r = Array.isArray(r) ? r[s] : r) || (r = 0);
                var h = {barHeight: n, strokeWidth: r, barYPosition: e, x2: i, x1: a},
                    p = this.getRoundedBars(d, h, o, l, c), f = u.move(p.x1, e), g = u.move(p.x1, e);
                d.globals.previousPaths.length > 0 && (g = this.barCtx.getPreviousPath(s, c, !1));
                var m = e, v = e + n;
                return {
                    pathTo: f = f + u.line(p.x2, m) + p.endingPath + u.line(p.x2, v - r) + u.line(p.x1, v - r) + p.startingPath + "z",
                    pathFrom: g = g + u.line(a, m) + u.line(a, v - r) + u.line(a, v - r) + u.line(a, v - r) + u.line(a, m)
                }
            }
        }, {
            key: "getRoundedBars", value: function (t, e, n, a, i) {
                var r = new _(this.barCtx.ctx), o = Array.isArray(e.strokeWidth) ? e.strokeWidth[a] : e.strokeWidth;
                if (o || (o = 0), this.barCtx.isHorizontal) {
                    var s = null, l = "", c = e.x2, d = e.x1;
                    if (void 0 !== n[a][i] || null !== n[a][i]) {
                        var u = n[a][i] < 0, h = e.barHeight / 2 - o;
                        switch (u && (h = -e.barHeight / 2 - o), h > Math.abs(c - d) && (h = Math.abs(c - d)), "rounded" === this.barCtx.barOptions.endingShape && (c = e.x2 - h / 2), "rounded" === this.barCtx.barOptions.startingShape && (d = e.x1 + h / 2), this.barCtx.barOptions.endingShape) {
                            case"flat":
                                s = r.line(c, e.barYPosition + e.barHeight - o);
                                break;
                            case"rounded":
                                s = r.quadraticCurve(c + h, e.barYPosition + (e.barHeight - o) / 2, c, e.barYPosition + e.barHeight - o)
                        }
                        switch (this.barCtx.barOptions.startingShape) {
                            case"flat":
                                l = r.line(d, e.barYPosition + e.barHeight - o);
                                break;
                            case"rounded":
                                l = r.quadraticCurve(d - h, e.barYPosition + e.barHeight / 2, d, e.barYPosition)
                        }
                    }
                    return {endingPath: s, startingPath: l, x2: c, x1: d}
                }
                var p = null, f = "", g = e.y2, m = e.y1;
                if (void 0 !== n[a][i] || null !== n[a][i]) {
                    var v = n[a][i] < 0, b = e.barWidth / 2 - o;
                    switch (v && (b = -e.barWidth / 2 - o), b > Math.abs(g - m) && (b = Math.abs(g - m)), "rounded" === this.barCtx.barOptions.endingShape && (g += b / 2), "rounded" === this.barCtx.barOptions.startingShape && (m -= b / 2), this.barCtx.barOptions.endingShape) {
                        case"flat":
                            p = r.line(e.barXPosition + e.barWidth - o, g);
                            break;
                        case"rounded":
                            p = r.quadraticCurve(e.barXPosition + (e.barWidth - o) / 2, g - b, e.barXPosition + e.barWidth - o, g)
                    }
                    switch (this.barCtx.barOptions.startingShape) {
                        case"flat":
                            f = r.line(e.barXPosition + e.barWidth - o, m);
                            break;
                        case"rounded":
                            f = r.quadraticCurve(e.barXPosition + (e.barWidth - o) / 2, m + b, e.barXPosition, m)
                    }
                }
                return {endingPath: p, startingPath: f, y2: g, y1: m}
            }
        }]), t
    }(), L = function () {
        function t(e, n) {
            r(this, t), this.ctx = e, this.w = e.w;
            var a = this.w;
            this.barOptions = a.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = a.config.stroke.width, this.isNullValue = !1, this.isTimelineBar = "datetime" === a.config.xaxis.type && a.globals.seriesRangeBarTimeline.length, this.xyRatios = n, null !== this.xyRatios && (this.xRatio = n.xRatio, this.initialXRatio = n.initialXRatio, this.yRatio = n.yRatio, this.invertedXRatio = n.invertedXRatio, this.invertedYRatio = n.invertedYRatio, this.baseLineY = n.baseLineY, this.baseLineInvertedY = n.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new N(this)
        }

        return s(t, [{
            key: "draw", value: function (t, e) {
                var n = this.w, a = new _(this.ctx), i = new C(this.ctx, n);
                t = i.getLogSeries(t), this.series = t, this.yRatio = i.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
                var r = a.group({class: "apexcharts-bar-series apexcharts-plot-series"});
                n.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
                for (var o = 0, s = 0; o < t.length; o++, s++) {
                    var l, c, u, h, p = void 0, f = void 0, g = [], m = [], v = n.globals.comboCharts ? e[o] : o,
                        y = a.group({
                            class: "apexcharts-series",
                            rel: o + 1,
                            seriesName: b.escapeString(n.globals.seriesNames[v]),
                            "data:realIndex": v
                        });
                    this.ctx.series.addCollapsedClassToSeries(y, v), t[o].length > 0 && (this.visibleI = this.visibleI + 1);
                    var x = 0, w = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = v), this.isReversed = n.config.yaxis[this.yaxisIndex] && n.config.yaxis[this.yaxisIndex].reversed;
                    var S = this.barHelpers.initialPositions();
                    f = S.y, x = S.barHeight, c = S.yDivision, h = S.zeroW, p = S.x, w = S.barWidth, l = S.xDivision, u = S.zeroH, this.horizontal || m.push(p + w / 2);
                    for (var k = a.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": v
                    }), D = 0; D < n.globals.dataPoints; D++) {
                        var T = this.barHelpers.getStrokeWidth(o, D, v), E = null,
                            A = {indexes: {i: o, j: D, realIndex: v, bc: s}, x: p, y: f, strokeWidth: T, elSeries: y};
                        this.isHorizontal ? (E = this.drawBarPaths(d(d({}, A), {}, {
                            barHeight: x,
                            zeroW: h,
                            yDivision: c
                        })), w = this.series[o][D] / this.invertedYRatio) : (E = this.drawColumnPaths(d(d({}, A), {}, {
                            xDivision: l,
                            barWidth: w,
                            zeroH: u
                        })), x = this.series[o][D] / this.yRatio[this.yaxisIndex]), f = E.y, p = E.x, D > 0 && m.push(p + w / 2), g.push(f);
                        var I = this.barHelpers.getPathFillColor(t, o, D, v);
                        this.renderSeries({
                            realIndex: v,
                            pathFill: I,
                            j: D,
                            i: o,
                            pathFrom: E.pathFrom,
                            pathTo: E.pathTo,
                            strokeWidth: T,
                            elSeries: y,
                            x: p,
                            y: f,
                            series: t,
                            barHeight: x,
                            barWidth: w,
                            elDataLabelsWrap: k,
                            visibleSeries: this.visibleI,
                            type: "bar"
                        })
                    }
                    n.globals.seriesXvalues[v] = m, n.globals.seriesYvalues[v] = g, r.add(y)
                }
                return r
            }
        }, {
            key: "renderSeries", value: function (t) {
                var e = t.realIndex, n = t.pathFill, a = t.lineFill, i = t.j, r = t.i, o = t.pathFrom, s = t.pathTo,
                    l = t.strokeWidth, c = t.elSeries, d = t.x, u = t.y, h = t.y1, p = t.y2, f = t.series,
                    g = t.barHeight, m = t.barWidth, v = t.barYPosition, b = t.elDataLabelsWrap, x = t.visibleSeries,
                    w = t.type, S = this.w, C = new _(this.ctx);
                a || (a = this.barOptions.distributed ? S.globals.stroke.colors[i] : S.globals.stroke.colors[e]), S.config.series[r].data[i] && S.config.series[r].data[i].strokeColor && (a = S.config.series[r].data[i].strokeColor), this.isNullValue && (n = "none");
                var k = i / S.config.chart.animations.animateGradually.delay * (S.config.chart.animations.speed / S.globals.dataPoints) / 2.4,
                    D = C.renderPaths({
                        i: r,
                        j: i,
                        realIndex: e,
                        pathFrom: o,
                        pathTo: s,
                        stroke: a,
                        strokeWidth: l,
                        strokeLineCap: S.config.stroke.lineCap,
                        fill: n,
                        animationDelay: k,
                        initialSpeed: S.config.chart.animations.speed,
                        dataChangeSpeed: S.config.chart.animations.dynamicAnimation.speed,
                        className: "apexcharts-".concat(w, "-area")
                    });
                D.attr("clip-path", "url(#gridRectMask".concat(S.globals.cuid, ")")), void 0 !== h && void 0 !== p && (D.attr("data-range-y1", h), D.attr("data-range-y2", p)), new y(this.ctx).setSelectionFilter(D, e, i), c.add(D);
                var T = new O(this).handleBarDataLabels({
                    x: d,
                    y: u,
                    y1: h,
                    y2: p,
                    i: r,
                    j: i,
                    series: f,
                    realIndex: e,
                    barHeight: g,
                    barWidth: m,
                    barYPosition: v,
                    renderedPath: D,
                    visibleSeries: x
                });
                return null !== T && b.add(T), c.add(b), c
            }
        }, {
            key: "drawBarPaths", value: function (t) {
                var e = t.indexes, n = t.barHeight, a = t.strokeWidth, i = t.zeroW, r = t.x, o = t.y, s = t.yDivision,
                    l = t.elSeries, c = this.w, d = e.i, u = e.j;
                c.globals.isXNumeric && (o = (c.globals.seriesX[d][u] - c.globals.minX) / this.invertedXRatio - n);
                var h = o + n * this.visibleI;
                r = void 0 === this.series[d][u] || null === this.series[d][u] ? i : i + this.series[d][u] / this.invertedYRatio - 2 * (this.isReversed ? this.series[d][u] / this.invertedYRatio : 0);
                var p = this.barHelpers.getBarpaths({
                    barYPosition: h,
                    barHeight: n,
                    x1: i,
                    x2: r,
                    strokeWidth: a,
                    series: this.series,
                    realIndex: e.realIndex,
                    i: d,
                    j: u,
                    w: c
                });
                return c.globals.isXNumeric || (o += s), this.barHelpers.barBackground({
                    j: u,
                    i: d,
                    y1: h - n * this.visibleI,
                    y2: n * this.seriesLen,
                    elSeries: l
                }), {pathTo: p.pathTo, pathFrom: p.pathFrom, x: r, y: o, barYPosition: h}
            }
        }, {
            key: "drawColumnPaths", value: function (t) {
                var e = t.indexes, n = t.x, a = t.y, i = t.xDivision, r = t.barWidth, o = t.zeroH, s = t.strokeWidth,
                    l = t.elSeries, c = this.w, d = e.i, u = e.j, h = e.bc;
                if (c.globals.isXNumeric) {
                    var p = d;
                    c.globals.seriesX[d].length || (p = c.globals.maxValsInArrayIndex), n = (c.globals.seriesX[p][u] - c.globals.minX) / this.xRatio - r * this.seriesLen / 2
                }
                var f = n + r * this.visibleI;
                a = void 0 === this.series[d][u] || null === this.series[d][u] ? o : o - this.series[d][u] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[d][u] / this.yRatio[this.yaxisIndex] : 0);
                var g = this.barHelpers.getColumnPaths({
                    barXPosition: f,
                    barWidth: r,
                    y1: o,
                    y2: a,
                    strokeWidth: s,
                    series: this.series,
                    realIndex: e.realIndex,
                    i: d,
                    j: u,
                    w: c
                });
                return c.globals.isXNumeric || (n += i), this.barHelpers.barBackground({
                    bc: h,
                    j: u,
                    i: d,
                    x1: f - s / 2 - r * this.visibleI,
                    x2: r * this.seriesLen + s / 2,
                    elSeries: l
                }), {pathTo: g.pathTo, pathFrom: g.pathFrom, x: n, y: a, barXPosition: f}
            }
        }, {
            key: "getPreviousPath", value: function (t, e) {
                for (var n, a = this.w, i = 0; i < a.globals.previousPaths.length; i++) {
                    var r = a.globals.previousPaths[i];
                    r.paths && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(t, 10) && void 0 !== a.globals.previousPaths[i].paths[e] && (n = a.globals.previousPaths[i].paths[e].d)
                }
                return n
            }
        }]), t
    }(), F = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
        }

        return s(t, [{
            key: "isValidDate", value: function (t) {
                return !isNaN(this.parseDate(t))
            }
        }, {
            key: "getTimeStamp", value: function (t) {
                return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t
            }
        }, {
            key: "getDate", value: function (t) {
                return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t)
            }
        }, {
            key: "parseDate", value: function (t) {
                var e = Date.parse(t);
                if (!isNaN(e)) return this.getTimeStamp(t);
                var n = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                return this.getTimeStamp(n)
            }
        }, {
            key: "parseDateWithTimezone", value: function (t) {
                return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
            }
        }, {
            key: "formatDate", value: function (t, e) {
                var n = this.w.globals.locale, a = this.w.config.xaxis.labels.datetimeUTC,
                    i = ["\0"].concat(m(n.months)), r = [""].concat(m(n.shortMonths)), o = [""].concat(m(n.days)),
                    s = [""].concat(m(n.shortDays));

                function l(t, e) {
                    var n = t + "";
                    for (e = e || 2; n.length < e;) n = "0" + n;
                    return n
                }

                var c = a ? t.getUTCFullYear() : t.getFullYear();
                e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(/(^|[^\\])yy/g, "$1" + c.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c);
                var d = (a ? t.getUTCMonth() : t.getMonth()) + 1;
                e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + i[0])).replace(/(^|[^\\])MMM/g, "$1" + r[0])).replace(/(^|[^\\])MM/g, "$1" + l(d))).replace(/(^|[^\\])M/g, "$1" + d);
                var u = a ? t.getUTCDate() : t.getDate();
                e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + o[0])).replace(/(^|[^\\])ddd/g, "$1" + s[0])).replace(/(^|[^\\])dd/g, "$1" + l(u))).replace(/(^|[^\\])d/g, "$1" + u);
                var h = a ? t.getUTCHours() : t.getHours(), p = h > 12 ? h - 12 : 0 === h ? 12 : h;
                e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + l(h))).replace(/(^|[^\\])H/g, "$1" + h)).replace(/(^|[^\\])hh+/g, "$1" + l(p))).replace(/(^|[^\\])h/g, "$1" + p);
                var f = a ? t.getUTCMinutes() : t.getMinutes();
                e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + l(f))).replace(/(^|[^\\])m/g, "$1" + f);
                var g = a ? t.getUTCSeconds() : t.getSeconds();
                e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + l(g))).replace(/(^|[^\\])s/g, "$1" + g);
                var v = a ? t.getUTCMilliseconds() : t.getMilliseconds();
                e = e.replace(/(^|[^\\])fff+/g, "$1" + l(v, 3)), v = Math.round(v / 10), e = e.replace(/(^|[^\\])ff/g, "$1" + l(v)), v = Math.round(v / 10);
                var b = h < 12 ? "AM" : "PM";
                e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + v)).replace(/(^|[^\\])TT+/g, "$1" + b)).replace(/(^|[^\\])T/g, "$1" + b.charAt(0));
                var y = b.toLowerCase();
                e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + y)).replace(/(^|[^\\])t/g, "$1" + y.charAt(0));
                var x = -t.getTimezoneOffset(), _ = a || !x ? "Z" : x > 0 ? "+" : "-";
                if (!a) {
                    var w = (x = Math.abs(x)) % 60;
                    _ += l(Math.floor(x / 60)) + ":" + l(w)
                }
                e = e.replace(/(^|[^\\])K/g, "$1" + _);
                var S = (a ? t.getUTCDay() : t.getDay()) + 1;
                return (e = (e = (e = (e = e.replace(new RegExp(o[0], "g"), o[S])).replace(new RegExp(s[0], "g"), s[S])).replace(new RegExp(i[0], "g"), i[d])).replace(new RegExp(r[0], "g"), r[d])).replace(/\\(.)/g, "$1")
            }
        }, {
            key: "getTimeUnitsfromTimestamp", value: function (t, e, n) {
                var a = this.w;
                void 0 !== a.config.xaxis.min && (t = a.config.xaxis.min), void 0 !== a.config.xaxis.max && (e = a.config.xaxis.max);
                var i = this.getDate(t), r = this.getDate(e), o = this.formatDate(i, "yyyy MM dd HH mm ss").split(" "),
                    s = this.formatDate(r, "yyyy MM dd HH mm ss").split(" ");
                return {
                    minSecond: parseInt(o[5], 10),
                    maxSecond: parseInt(s[5], 10),
                    minMinute: parseInt(o[4], 10),
                    maxMinute: parseInt(s[4], 10),
                    minHour: parseInt(o[3], 10),
                    maxHour: parseInt(s[3], 10),
                    minDate: parseInt(o[2], 10),
                    maxDate: parseInt(s[2], 10),
                    minMonth: parseInt(o[1], 10) - 1,
                    maxMonth: parseInt(s[1], 10) - 1,
                    minYear: parseInt(o[0], 10),
                    maxYear: parseInt(s[0], 10)
                }
            }
        }, {
            key: "isLeapYear", value: function (t) {
                return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
            }
        }, {
            key: "calculcateLastDaysOfMonth", value: function (t, e, n) {
                return this.determineDaysOfMonths(t, e) - n
            }
        }, {
            key: "determineDaysOfYear", value: function (t) {
                var e = 365;
                return this.isLeapYear(t) && (e = 366), e
            }
        }, {
            key: "determineRemainingDaysOfYear", value: function (t, e, n) {
                var a = this.daysCntOfYear[e] + n;
                return e > 1 && this.isLeapYear() && a++, a
            }
        }, {
            key: "determineDaysOfMonths", value: function (t, e) {
                var n = 30;
                switch (t = b.monthMod(t), !0) {
                    case this.months30.indexOf(t) > -1:
                        2 === t && (n = this.isLeapYear(e) ? 29 : 28);
                        break;
                    case this.months31.indexOf(t) > -1:
                    default:
                        n = 31
                }
                return n
            }
        }]), t
    }(), H = function (t) {
        u(n, L);
        var e = g(n);

        function n() {
            return r(this, n), e.apply(this, arguments)
        }

        return s(n, [{
            key: "draw", value: function (t, e) {
                var n = this.w, a = new _(this.ctx);
                this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t, this.seriesRangeStart = n.globals.seriesRangeStart, this.seriesRangeEnd = n.globals.seriesRangeEnd, this.barHelpers.initVariables(t);
                for (var i = a.group({class: "apexcharts-rangebar-series apexcharts-plot-series"}), r = 0; r < t.length; r++) {
                    var o, s, l, c = void 0, u = void 0, h = void 0, p = n.globals.comboCharts ? e[r] : r, f = a.group({
                        class: "apexcharts-series",
                        seriesName: b.escapeString(n.globals.seriesNames[p]),
                        rel: r + 1,
                        "data:realIndex": p
                    });
                    t[r].length > 0 && (this.visibleI = this.visibleI + 1);
                    var g = 0, m = 0;
                    this.yRatio.length > 1 && (this.yaxisIndex = p);
                    var v = this.barHelpers.initialPositions();
                    u = v.y, l = v.zeroW, c = v.x, m = v.barWidth, o = v.xDivision, s = v.zeroH;
                    for (var y = a.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": p
                    }), x = 0; x < n.globals.dataPoints; x++) {
                        var w = this.barHelpers.getStrokeWidth(r, x, p), S = this.seriesRangeStart[r][x],
                            C = this.seriesRangeEnd[r][x], k = null, D = null,
                            T = {x: c, y: u, strokeWidth: w, elSeries: f};
                        if (h = v.yDivision, g = v.barHeight, this.isHorizontal) {
                            D = u + g * this.visibleI;
                            var E = this.seriesLen;
                            n.config.plotOptions.bar.rangeBarGroupRows && (E = 1);
                            var A = (h - g * E) / 2;
                            if (void 0 === n.config.series[r].data[x]) break;
                            if (this.isTimelineBar && n.config.series[r].data[x].x) {
                                var I = this.detectOverlappingBars({
                                    i: r,
                                    j: x,
                                    barYPosition: D,
                                    srty: A,
                                    barHeight: g,
                                    yDivision: h,
                                    initPositions: v
                                });
                                g = I.barHeight, D = I.barYPosition
                            }
                            m = (k = this.drawRangeBarPaths(d({
                                indexes: {i: r, j: x, realIndex: p},
                                barHeight: g,
                                barYPosition: D,
                                zeroW: l,
                                yDivision: h,
                                y1: S,
                                y2: C
                            }, T))).barWidth
                        } else g = (k = this.drawRangeColumnPaths(d({
                            indexes: {i: r, j: x, realIndex: p},
                            zeroH: s,
                            barWidth: m,
                            xDivision: o
                        }, T))).barHeight;
                        u = k.y, c = k.x;
                        var M = this.barHelpers.getPathFillColor(t, r, x, p), R = n.globals.stroke.colors[p];
                        this.renderSeries({
                            realIndex: p,
                            pathFill: M,
                            lineFill: R,
                            j: x,
                            i: r,
                            x: c,
                            y: u,
                            y1: S,
                            y2: C,
                            pathFrom: k.pathFrom,
                            pathTo: k.pathTo,
                            strokeWidth: w,
                            elSeries: f,
                            series: t,
                            barHeight: g,
                            barYPosition: D,
                            barWidth: m,
                            elDataLabelsWrap: y,
                            visibleSeries: this.visibleI,
                            type: "rangebar"
                        })
                    }
                    i.add(f)
                }
                return i
            }
        }, {
            key: "detectOverlappingBars", value: function (t) {
                var e = t.i, n = t.j, a = t.barYPosition, i = t.srty, r = t.barHeight, o = t.yDivision,
                    s = t.initPositions, l = this.w, c = [], d = l.config.series[e].data[n].rangeName,
                    u = l.config.series[e].data[n].x, h = l.globals.labels.indexOf(u),
                    p = l.globals.seriesRangeBarTimeline[e].findIndex((function (t) {
                        return t.x === u && t.overlaps.length > 0
                    }));
                return a = l.config.plotOptions.bar.rangeBarGroupRows ? i + o * h : i + r * this.visibleI + o * h, p > -1 && !l.config.plotOptions.bar.rangeBarOverlap && (c = l.globals.seriesRangeBarTimeline[e][p].overlaps).indexOf(d) > -1 && (a = (r = s.barHeight / c.length) * this.visibleI + o * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + r * (this.visibleI + c.indexOf(d)) + o * h), {
                    barYPosition: a,
                    barHeight: r
                }
            }
        }, {
            key: "drawRangeColumnPaths", value: function (t) {
                var e = t.indexes, n = t.x, a = (t.strokeWidth, t.xDivision), i = t.barWidth, r = t.zeroH, o = this.w,
                    s = e.i, l = e.j, c = this.yRatio[this.yaxisIndex], d = e.realIndex, u = this.getRangeValue(d, l),
                    h = Math.min(u.start, u.end), p = Math.max(u.start, u.end);
                o.globals.isXNumeric && (n = (o.globals.seriesX[s][l] - o.globals.minX) / this.xRatio - i / 2);
                var f = n + i * this.visibleI;
                void 0 === this.series[s][l] || null === this.series[s][l] ? h = r : (h = r - h / c, p = r - p / c);
                var g = Math.abs(p - h), m = this.barHelpers.getColumnPaths({
                    barXPosition: f,
                    barWidth: i,
                    y1: h,
                    y2: p,
                    strokeWidth: this.strokeWidth,
                    series: this.seriesRangeEnd,
                    i: d,
                    j: l,
                    w: o
                });
                return o.globals.isXNumeric || (n += a), {
                    pathTo: m.pathTo,
                    pathFrom: m.pathFrom,
                    barHeight: g,
                    x: n,
                    y: p,
                    barXPosition: f
                }
            }
        }, {
            key: "drawRangeBarPaths", value: function (t) {
                var e = t.indexes, n = t.y, a = t.y1, i = t.y2, r = t.yDivision, o = t.barHeight, s = t.barYPosition,
                    l = t.zeroW, c = this.w, d = l + a / this.invertedYRatio, u = l + i / this.invertedYRatio,
                    h = Math.abs(u - d), p = this.barHelpers.getBarpaths({
                        barYPosition: s,
                        barHeight: o,
                        x1: d,
                        x2: u,
                        strokeWidth: this.strokeWidth,
                        series: this.seriesRangeEnd,
                        i: e.realIndex,
                        j: e.j,
                        w: c
                    });
                return c.globals.isXNumeric || (n += r), {
                    pathTo: p.pathTo,
                    pathFrom: p.pathFrom,
                    barWidth: h,
                    x: u,
                    y: n
                }
            }
        }, {
            key: "getRangeValue", value: function (t, e) {
                var n = this.w;
                return {start: n.globals.seriesRangeStart[t][e], end: n.globals.seriesRangeEnd[t][e]}
            }
        }, {
            key: "getTooltipValues", value: function (t) {
                var e = t.ctx, n = t.seriesIndex, a = t.dataPointIndex, i = t.y1, r = t.y2, o = t.w,
                    s = o.globals.seriesRangeStart[n][a], l = o.globals.seriesRangeEnd[n][a], c = o.globals.labels[a],
                    d = o.config.series[n].name, u = o.config.tooltip.y.formatter,
                    h = o.config.tooltip.y.title.formatter, p = {w: o, seriesIndex: n, dataPointIndex: a};
                "function" == typeof h && (d = h(d, p)), i && r && (s = i, l = r, o.config.series[n].data[a].x && (c = o.config.series[n].data[a].x + ":"), "function" == typeof u && (c = u(c, p)));
                var f = "", g = "", m = o.globals.colors[n];
                if (void 0 === o.config.tooltip.x.formatter) if ("datetime" === o.config.xaxis.type) {
                    var v = new F(e);
                    f = v.formatDate(v.getDate(s), o.config.tooltip.x.format), g = v.formatDate(v.getDate(l), o.config.tooltip.x.format)
                } else f = s, g = l; else f = o.config.tooltip.x.formatter(s), g = o.config.tooltip.x.formatter(l);
                return {start: s, end: l, startVal: f, endVal: g, ylabel: c, color: m, seriesName: d}
            }
        }, {
            key: "buildCustomTooltipHTML", value: function (t) {
                return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t.color + '">' + (t.seriesName || "") + '</span></div><div> <span class="category">' + t.ylabel + ' </span> <span class="value start-value">' + t.start + '</span> <span class="separator">-</span> <span class="value end-value">' + t.end + "</span></div></div>"
            }
        }]), n
    }(), B = function () {
        function t(e) {
            r(this, t), this.opts = e
        }

        return s(t, [{
            key: "line", value: function () {
                return {
                    chart: {animations: {easing: "swing"}},
                    dataLabels: {enabled: !1},
                    stroke: {width: 5, curve: "straight"},
                    markers: {size: 0, hover: {sizeOffset: 6}},
                    xaxis: {crosshairs: {width: 1}}
                }
            }
        }, {
            key: "sparkline", value: function (t) {
                return this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0, b.extend(t, {
                    grid: {
                        show: !1,
                        padding: {left: 0, right: 0, top: 0, bottom: 0}
                    },
                    legend: {show: !1},
                    xaxis: {labels: {show: !1}, tooltip: {enabled: !1}, axisBorder: {show: !1}, axisTicks: {show: !1}},
                    chart: {toolbar: {show: !1}, zoom: {enabled: !1}},
                    dataLabels: {enabled: !1}
                })
            }
        }, {
            key: "bar", value: function () {
                return {
                    chart: {stacked: !1, animations: {easing: "swing"}},
                    plotOptions: {bar: {dataLabels: {position: "center"}}},
                    dataLabels: {style: {colors: ["#fff"]}, background: {enabled: !1}},
                    stroke: {width: 0, lineCap: "square"},
                    fill: {opacity: .85},
                    legend: {markers: {shape: "square", radius: 2, size: 8}},
                    tooltip: {shared: !1},
                    xaxis: {
                        tooltip: {enabled: !1},
                        tickPlacement: "between",
                        crosshairs: {
                            width: "barWidth",
                            position: "back",
                            fill: {type: "gradient"},
                            dropShadow: {enabled: !1},
                            stroke: {width: 0}
                        }
                    }
                }
            }
        }, {
            key: "candlestick", value: function () {
                return {
                    stroke: {width: 1, colors: ["#333"]},
                    fill: {opacity: 1},
                    dataLabels: {enabled: !1},
                    tooltip: {
                        shared: !0, custom: function (t) {
                            var e = t.seriesIndex, n = t.dataPointIndex, a = t.w;
                            return '<div class="apexcharts-tooltip-candlestick"><div>Open: <span class="value">' + a.globals.seriesCandleO[e][n] + '</span></div><div>High: <span class="value">' + a.globals.seriesCandleH[e][n] + '</span></div><div>Low: <span class="value">' + a.globals.seriesCandleL[e][n] + '</span></div><div>Close: <span class="value">' + a.globals.seriesCandleC[e][n] + "</span></div></div>"
                        }
                    },
                    states: {active: {filter: {type: "none"}}},
                    xaxis: {crosshairs: {width: 1}}
                }
            }
        }, {
            key: "rangeBar", value: function () {
                return {
                    stroke: {width: 0, lineCap: "square"},
                    plotOptions: {bar: {dataLabels: {position: "center"}}},
                    dataLabels: {
                        enabled: !1, formatter: function (t, e) {
                            e.ctx;
                            var n = e.seriesIndex, a = e.dataPointIndex, i = e.w, r = i.globals.seriesRangeStart[n][a];
                            return i.globals.seriesRangeEnd[n][a] - r
                        }, background: {enabled: !1}, style: {colors: ["#fff"]}
                    },
                    tooltip: {
                        shared: !1, followCursor: !0, custom: function (t) {
                            return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function (t) {
                                var e = new H(t.ctx, null), n = e.getTooltipValues(t), a = n.color, i = n.seriesName,
                                    r = n.ylabel, o = n.startVal, s = n.endVal;
                                return e.buildCustomTooltipHTML({color: a, seriesName: i, ylabel: r, start: o, end: s})
                            }(t) : function (t) {
                                var e = new H(t.ctx, null), n = e.getTooltipValues(t), a = n.color, i = n.seriesName,
                                    r = n.ylabel, o = n.start, s = n.end;
                                return e.buildCustomTooltipHTML({color: a, seriesName: i, ylabel: r, start: o, end: s})
                            }(t)
                        }
                    },
                    xaxis: {tickPlacement: "between", tooltip: {enabled: !1}, crosshairs: {stroke: {width: 0}}}
                }
            }
        }, {
            key: "area", value: function () {
                return {
                    stroke: {width: 4},
                    fill: {
                        type: "gradient",
                        gradient: {
                            inverseColors: !1,
                            shade: "light",
                            type: "vertical",
                            opacityFrom: .65,
                            opacityTo: .5,
                            stops: [0, 100, 100]
                        }
                    },
                    markers: {size: 0, hover: {sizeOffset: 6}},
                    tooltip: {followCursor: !1}
                }
            }
        }, {
            key: "brush", value: function (t) {
                return b.extend(t, {
                    chart: {toolbar: {autoSelected: "selection", show: !1}, zoom: {enabled: !1}},
                    dataLabels: {enabled: !1},
                    stroke: {width: 1},
                    tooltip: {enabled: !1},
                    xaxis: {tooltip: {enabled: !1}}
                })
            }
        }, {
            key: "stacked100", value: function (t) {
                t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
                var e = t.dataLabels.formatter;
                return t.yaxis.forEach((function (e, n) {
                    t.yaxis[n].min = 0, t.yaxis[n].max = 100
                })), "bar" === t.chart.type && (t.dataLabels.formatter = e || function (t) {
                    return "number" == typeof t && t ? t.toFixed(0) + "%" : t
                }), t
            }
        }, {
            key: "convertCatToNumeric", value: function (t) {
                return t.xaxis.convertedCatToNumeric = !0, t
            }
        }, {
            key: "convertCatToNumericXaxis", value: function (t, e, n) {
                t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function (t) {
                    return b.isNumber(t) ? Math.floor(t) : t
                };
                var a = t.xaxis.labels.formatter,
                    i = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
                return n && n.length && (i = n.map((function (t) {
                    return t.toString()
                }))), i && i.length && (t.xaxis.labels.formatter = function (t) {
                    return b.isNumber(t) ? a(i[Math.floor(t) - 1]) : a(t)
                }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t
            }
        }, {
            key: "bubble", value: function () {
                return {
                    dataLabels: {style: {colors: ["#fff"]}},
                    tooltip: {shared: !1, intersect: !0},
                    xaxis: {crosshairs: {width: 0}},
                    fill: {
                        type: "solid",
                        gradient: {shade: "light", inverse: !0, shadeIntensity: .55, opacityFrom: .4, opacityTo: .8}
                    }
                }
            }
        }, {
            key: "scatter", value: function () {
                return {
                    dataLabels: {enabled: !1},
                    tooltip: {shared: !1, intersect: !0},
                    markers: {size: 6, strokeWidth: 1, hover: {sizeOffset: 2}}
                }
            }
        }, {
            key: "heatmap", value: function () {
                return {
                    chart: {stacked: !1},
                    fill: {opacity: 1},
                    dataLabels: {style: {colors: ["#fff"]}},
                    stroke: {colors: ["#fff"]},
                    tooltip: {followCursor: !0, marker: {show: !1}, x: {show: !1}},
                    legend: {position: "top", markers: {shape: "square", size: 10, offsetY: 2}},
                    grid: {padding: {right: 20}}
                }
            }
        }, {
            key: "treemap", value: function () {
                return {
                    chart: {zoom: {enabled: !1}},
                    dataLabels: {style: {fontSize: 14, fontWeight: 600, colors: ["#fff"]}},
                    stroke: {show: !0, width: 2, colors: ["#fff"]},
                    legend: {show: !1},
                    fill: {gradient: {stops: [0, 100]}},
                    tooltip: {followCursor: !0, x: {show: !1}},
                    grid: {padding: {left: 0, right: 0}},
                    xaxis: {crosshairs: {show: !1}, tooltip: {enabled: !1}}
                }
            }
        }, {
            key: "pie", value: function () {
                return {
                    chart: {toolbar: {show: !1}},
                    plotOptions: {pie: {donut: {labels: {show: !1}}}},
                    dataLabels: {
                        formatter: function (t) {
                            return t.toFixed(1) + "%"
                        }, style: {colors: ["#fff"]}, background: {enabled: !1}, dropShadow: {enabled: !0}
                    },
                    stroke: {colors: ["#fff"]},
                    fill: {opacity: 1, gradient: {shade: "light", stops: [0, 100]}},
                    tooltip: {theme: "dark", fillSeriesColor: !0},
                    legend: {position: "right"}
                }
            }
        }, {
            key: "donut", value: function () {
                return {
                    chart: {toolbar: {show: !1}},
                    dataLabels: {
                        formatter: function (t) {
                            return t.toFixed(1) + "%"
                        }, style: {colors: ["#fff"]}, background: {enabled: !1}, dropShadow: {enabled: !0}
                    },
                    stroke: {colors: ["#fff"]},
                    fill: {
                        opacity: 1,
                        gradient: {shade: "light", shadeIntensity: .35, stops: [80, 100], opacityFrom: 1, opacityTo: 1}
                    },
                    tooltip: {theme: "dark", fillSeriesColor: !0},
                    legend: {position: "right"}
                }
            }
        }, {
            key: "polarArea", value: function () {
                return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
                    chart: {toolbar: {show: !1}},
                    dataLabels: {
                        formatter: function (t) {
                            return t.toFixed(1) + "%"
                        }, enabled: !1
                    },
                    stroke: {show: !0, width: 2},
                    fill: {opacity: .7},
                    tooltip: {theme: "dark", fillSeriesColor: !0},
                    legend: {position: "right"}
                }
            }
        }, {
            key: "radar", value: function () {
                return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
                    dataLabels: {
                        enabled: !1,
                        style: {fontSize: "11px"}
                    },
                    stroke: {width: 2},
                    markers: {size: 3, strokeWidth: 1, strokeOpacity: 1},
                    fill: {opacity: .2},
                    tooltip: {shared: !1, intersect: !0, followCursor: !0},
                    grid: {show: !1},
                    xaxis: {
                        labels: {
                            formatter: function (t) {
                                return t
                            }, style: {colors: ["#a8a8a8"], fontSize: "11px"}
                        }, tooltip: {enabled: !1}, crosshairs: {show: !1}
                    }
                }
            }
        }, {
            key: "radialBar", value: function () {
                return {
                    chart: {animations: {dynamicAnimation: {enabled: !0, speed: 800}}, toolbar: {show: !1}},
                    fill: {
                        gradient: {
                            shade: "dark",
                            shadeIntensity: .4,
                            inverseColors: !1,
                            type: "diagonal2",
                            opacityFrom: 1,
                            opacityTo: 1,
                            stops: [70, 98, 100]
                        }
                    },
                    legend: {show: !1, position: "right"},
                    tooltip: {enabled: !1, fillSeriesColor: !0}
                }
            }
        }]), t
    }(), q = function () {
        function t(e) {
            r(this, t), this.opts = e
        }

        return s(t, [{
            key: "init", value: function (t) {
                var e = t.responsiveOverride, n = this.opts, a = new E, r = new B(n);
                this.chartType = n.chart.type, "histogram" === this.chartType && (n.chart.type = "bar", n = b.extend({plotOptions: {bar: {columnWidth: "99.99%"}}}, n)), n = this.extendYAxis(n), n = this.extendAnnotations(n);
                var o = a.init(), s = {};
                if (n && "object" === i(n)) {
                    var l = {};
                    l = -1 !== ["line", "area", "bar", "candlestick", "rangeBar", "histogram", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(n.chart.type) ? r[n.chart.type]() : r.line(), n.chart.brush && n.chart.brush.enabled && (l = r.brush(l)), n.chart.stacked && "100%" === n.chart.stackType && (n = r.stacked100(n)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(n), n.xaxis = n.xaxis || window.Apex.xaxis || {}, e || (n.xaxis.convertedCatToNumeric = !1), ((n = this.checkForCatToNumericXAxis(this.chartType, l, n)).chart.sparkline && n.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l = r.sparkline(l)), s = b.extend(o, l)
                }
                var c = b.extend(s, window.Apex);
                return o = b.extend(c, n), this.handleUserInputErrors(o)
            }
        }, {
            key: "checkForCatToNumericXAxis", value: function (t, e, n) {
                var a = new B(n), i = "bar" === t && n.plotOptions && n.plotOptions.bar && n.plotOptions.bar.horizontal,
                    r = "pie" === t || "polarArea" === t || "donut" === t || "radar" === t || "radialBar" === t || "heatmap" === t,
                    o = "datetime" !== n.xaxis.type && "numeric" !== n.xaxis.type,
                    s = n.xaxis.tickPlacement ? n.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement;
                return i || r || !o || "between" === s || (n = a.convertCatToNumeric(n)), n
            }
        }, {
            key: "extendYAxis", value: function (t, e) {
                var n = new E;
                (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && 0 === t.yaxis.length) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = b.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [b.extend(n.yAxis, t.yaxis)] : t.yaxis = b.extendArray(t.yaxis, n.yAxis);
                var a = !1;
                t.yaxis.forEach((function (t) {
                    t.logarithmic && (a = !0)
                }));
                var i = t.series;
                return e && !i && (i = e.config.series), a && i.length !== t.yaxis.length && i.length && (t.yaxis = i.map((function (e, a) {
                    if (e.name || (i[a].name = "series-".concat(a + 1)), t.yaxis[a]) return t.yaxis[a].seriesName = i[a].name, t.yaxis[a];
                    var r = b.extend(n.yAxis, t.yaxis[0]);
                    return r.show = !1, r
                }))), a && i.length > 1 && i.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t
            }
        }, {
            key: "extendAnnotations", value: function (t) {
                return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), this.extendPointAnnotations(t)
            }
        }, {
            key: "extendYAxisAnnotations", value: function (t) {
                var e = new E;
                return t.annotations.yaxis = b.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t
            }
        }, {
            key: "extendXAxisAnnotations", value: function (t) {
                var e = new E;
                return t.annotations.xaxis = b.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t
            }
        }, {
            key: "extendPointAnnotations", value: function (t) {
                var e = new E;
                return t.annotations.points = b.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t
            }
        }, {
            key: "checkForDarkTheme", value: function (t) {
                t.theme && "dark" === t.theme.mode && (t.tooltip || (t.tooltip = {}), "light" !== t.tooltip.theme && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"))
            }
        }, {
            key: "handleUserInputErrors", value: function (t) {
                var e = t;
                if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                if (("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal) {
                    if (e.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                    e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1
                }
                return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && ("barWidth" === e.xaxis.crosshairs.width && e.series.length > 1 && (console.warn('crosshairs.width = "barWidth" is only supported in single series, not in a multi-series barChart.'), e.xaxis.crosshairs.width = "tickWidth"), e.plotOptions.bar.horizontal && (e.states.hover.type = "none", e.tooltip.shared = !1), e.tooltip.followCursor || (console.warn("followCursor option in shared columns cannot be turned off. Please set %ctooltip.followCursor: true", "color: blue;"), e.tooltip.followCursor = !0)), "candlestick" === e.chart.type && e.yaxis[0].reversed && (console.warn("Reversed y-axis in candlestick chart is not supported."), e.yaxis[0].reversed = !1), e.chart.group && 0 === e.yaxis[0].labels.minWidth && console.warn("It looks like you have multiple charts in synchronization. You must provide yaxis.labels.minWidth which must be EQUAL for all grouped charts to prevent incorrect behaviour."), Array.isArray(e.stroke.width) && "line" !== e.chart.type && "area" !== e.chart.type && (console.warn("stroke.width option accepts array only for line and area charts. Reverted back to Number"), e.stroke.width = e.stroke.width[0]), e
            }
        }]), t
    }(), z = function () {
        function t() {
            r(this, t)
        }

        return s(t, [{
            key: "initGlobalVars", value: function (t) {
                t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRangeBarTimeline = [], t.seriesPercent = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.xaxisLabelsCount = 0, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0
            }
        }, {
            key: "globalVars", value: function (t) {
                return {
                    chartID: null,
                    cuid: null,
                    events: {
                        beforeMount: [],
                        mounted: [],
                        updated: [],
                        clicked: [],
                        selection: [],
                        dataPointSelection: [],
                        zoomed: [],
                        scrolled: []
                    },
                    colors: [],
                    clientX: null,
                    clientY: null,
                    fill: {colors: []},
                    stroke: {colors: []},
                    dataLabels: {style: {colors: []}},
                    radarPolygons: {fill: {colors: []}},
                    markers: {colors: [], size: t.markers.size, largestSize: 0},
                    animationEnded: !1,
                    isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
                    isDirty: !1,
                    isExecCalled: !1,
                    initialConfig: null,
                    initialSeries: [],
                    lastXAxis: [],
                    lastYAxis: [],
                    columnSeries: null,
                    labels: [],
                    timescaleLabels: [],
                    noLabelsProvided: !1,
                    allSeriesCollapsed: !1,
                    collapsedSeries: [],
                    collapsedSeriesIndices: [],
                    ancillaryCollapsedSeries: [],
                    ancillaryCollapsedSeriesIndices: [],
                    risingSeries: [],
                    dataFormatXNumeric: !1,
                    capturedSeriesIndex: -1,
                    capturedDataPointIndex: -1,
                    selectedDataPoints: [],
                    goldenPadding: 35,
                    invalidLogScale: !1,
                    ignoreYAxisIndexes: [],
                    yAxisSameScaleIndices: [],
                    maxValsInArrayIndex: 0,
                    radialSize: 0,
                    selection: void 0,
                    zoomEnabled: "zoom" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
                    panEnabled: "pan" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.pan,
                    selectionEnabled: "selection" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.selection,
                    yaxis: null,
                    mousedown: !1,
                    lastClientPosition: {},
                    visibleXRange: void 0,
                    yValueDecimal: 0,
                    total: 0,
                    SVGNS: "http://www.w3.org/2000/svg",
                    svgWidth: 0,
                    svgHeight: 0,
                    noData: !1,
                    locale: {},
                    dom: {},
                    memory: {methodsToExec: []},
                    shouldAnimate: !0,
                    skipLastTimelinelabel: !1,
                    skipFirstTimelinelabel: !1,
                    delayedElements: [],
                    axisCharts: !0,
                    isDataXYZ: !1,
                    resized: !1,
                    resizeTimer: null,
                    comboCharts: !1,
                    dataChanged: !1,
                    previousPaths: [],
                    allSeriesHasEqualX: !0,
                    pointsArray: [],
                    dataLabelsRects: [],
                    lastDrawnDataLabelsIndexes: [],
                    hasNullValues: !1,
                    easing: null,
                    zoomed: !1,
                    gridWidth: 0,
                    gridHeight: 0,
                    rotateXLabels: !1,
                    defaultLabels: !1,
                    xLabelFormatter: void 0,
                    yLabelFormatters: [],
                    xaxisTooltipFormatter: void 0,
                    ttKeyFormatter: void 0,
                    ttVal: void 0,
                    ttZFormatter: void 0,
                    LINE_HEIGHT_RATIO: 1.618,
                    xAxisLabelsHeight: 0,
                    xAxisLabelsWidth: 0,
                    yAxisLabelsWidth: 0,
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0,
                    translateYAxisX: [],
                    yAxisWidths: [],
                    translateXAxisY: 0,
                    translateXAxisX: 0,
                    tooltip: null
                }
            }
        }, {
            key: "init", value: function (t) {
                var e = this.globalVars(t);
                return this.initGlobalVars(e), e.initialConfig = b.extend({}, t), e.initialSeries = b.clone(t.series), e.lastXAxis = b.clone(e.initialConfig.xaxis), e.lastYAxis = b.clone(e.initialConfig.yaxis), e
            }
        }]), t
    }(), W = function () {
        function t(e) {
            r(this, t), this.opts = e
        }

        return s(t, [{
            key: "init", value: function () {
                var t = new q(this.opts).init({responsiveOverride: !1});
                return {config: t, globals: (new z).init(t)}
            }
        }]), t
    }(), V = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.coreUtils = new C(this.ctx)
        }

        return s(t, [{
            key: "isMultiFormat", value: function () {
                return this.isFormatXY() || this.isFormat2DArray()
            }
        }, {
            key: "isFormatXY", value: function () {
                var t = this.w.config.series.slice(), e = new j(this.ctx);
                if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null !== t[this.activeSeriesIndex].data[0] && void 0 !== t[this.activeSeriesIndex].data[0].x && null !== t[this.activeSeriesIndex].data[0]) return !0
            }
        }, {
            key: "isFormat2DArray", value: function () {
                var t = this.w.config.series.slice(), e = new j(this.ctx);
                if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && void 0 !== t[this.activeSeriesIndex].data[0] && null !== t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0].constructor === Array) return !0
            }
        }, {
            key: "handleFormat2DArray", value: function (t, e) {
                var n = this.w.config, a = this.w.globals;
                n.xaxis.sorted && ("datetime" === n.xaxis.type ? t[e].data.sort((function (t, e) {
                    return new Date(t[0]).getTime() - new Date(e[0]).getTime()
                })) : "numeric" === n.xaxis.type && t[e].data.sort((function (t, e) {
                    return t[0] - e[0]
                })));
                for (var i = 0; i < t[e].data.length; i++) if (void 0 !== t[e].data[i][1] && (Array.isArray(t[e].data[i][1]) && 4 === t[e].data[i][1].length ? this.twoDSeries.push(b.parseNumber(t[e].data[i][1][3])) : 5 === t[e].data[i].length ? this.twoDSeries.push(b.parseNumber(t[e].data[i][4])) : this.twoDSeries.push(b.parseNumber(t[e].data[i][1])), a.dataFormatXNumeric = !0), "datetime" === n.xaxis.type) {
                    var r = new Date(t[e].data[i][0]);
                    r = new Date(r).getTime(), this.twoDSeriesX.push(r)
                } else this.twoDSeriesX.push(t[e].data[i][0]);
                for (var o = 0; o < t[e].data.length; o++) void 0 !== t[e].data[o][2] && (this.threeDSeries.push(t[e].data[o][2]), a.isDataXYZ = !0)
            }
        }, {
            key: "handleFormatXY", value: function (t, e) {
                var n = this.w.config, a = this.w.globals, i = new F(this.ctx), r = e;
                a.collapsedSeriesIndices.indexOf(e) > -1 && (r = this.activeSeriesIndex), n.xaxis.sorted && ("datetime" === n.xaxis.type ? t[e].data.sort((function (t, e) {
                    return new Date(t.x).getTime() - new Date(e.x).getTime()
                })) : "numeric" === n.xaxis.type && t[e].data.sort((function (t, e) {
                    return t.x - e.x
                })));
                for (var o = 0; o < t[e].data.length; o++) void 0 !== t[e].data[o].y && (Array.isArray(t[e].data[o].y) ? this.twoDSeries.push(b.parseNumber(t[e].data[o].y[t[e].data[o].y.length - 1])) : this.twoDSeries.push(b.parseNumber(t[e].data[o].y)));
                for (var s = 0; s < t[r].data.length; s++) {
                    var l = "string" == typeof t[r].data[s].x, c = Array.isArray(t[r].data[s].x),
                        d = !c && !!i.isValidDate(t[r].data[s].x.toString());
                    if (l || d) if (l || n.xaxis.convertedCatToNumeric) {
                        var u = a.isBarHorizontal && a.isRangeData;
                        "datetime" !== n.xaxis.type || u ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[s].x)) : this.twoDSeriesX.push(i.parseDate(t[r].data[s].x))
                    } else "datetime" === n.xaxis.type ? this.twoDSeriesX.push(i.parseDate(t[r].data[s].x.toString())) : (a.dataFormatXNumeric = !0, a.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[r].data[s].x))); else c ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[r].data[s].x)) : (a.isXNumeric = !0, a.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[r].data[s].x))
                }
                if (t[e].data[0] && void 0 !== t[e].data[0].z) {
                    for (var h = 0; h < t[e].data.length; h++) this.threeDSeries.push(t[e].data[h].z);
                    a.isDataXYZ = !0
                }
            }
        }, {
            key: "handleRangeData", value: function (t, e) {
                var n = this.w.config, a = this.w.globals, i = {};
                return this.isFormat2DArray() ? i = this.handleRangeDataFormat("array", t, e) : this.isFormatXY() && (i = this.handleRangeDataFormat("xy", t, e)), a.seriesRangeStart.push(i.start), a.seriesRangeEnd.push(i.end), "datetime" === n.xaxis.type && a.seriesRangeBarTimeline.push(i.rangeUniques), a.seriesRangeBarTimeline.forEach((function (t, e) {
                    t && t.forEach((function (t, e) {
                        t.y.forEach((function (e, n) {
                            for (var a = 0; a < t.y.length; a++) if (n !== a) {
                                var i = e.y1, r = e.y2, o = t.y[a].y1;
                                i <= t.y[a].y2 && o <= r && (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName), t.overlaps.indexOf(t.y[a].rangeName) < 0 && t.overlaps.push(t.y[a].rangeName))
                            }
                        }))
                    }))
                })), i
            }
        }, {
            key: "handleCandleStickData", value: function (t, e) {
                var n = this.w.globals, a = {};
                return this.isFormat2DArray() ? a = this.handleCandleStickDataFormat("array", t, e) : this.isFormatXY() && (a = this.handleCandleStickDataFormat("xy", t, e)), n.seriesCandleO[e] = a.o, n.seriesCandleH[e] = a.h, n.seriesCandleL[e] = a.l, n.seriesCandleC[e] = a.c, a
            }
        }, {
            key: "handleRangeDataFormat", value: function (t, e, n) {
                var a = [], i = [], r = e[n].data.filter((function (t, e, n) {
                        return e === n.findIndex((function (e) {
                            return e.x === t.x
                        }))
                    })).map((function (t, e) {
                        return {x: t.x, overlaps: [], y: []}
                    })),
                    o = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts",
                    s = new j(this.ctx).getActiveConfigSeriesIndex();
                if ("array" === t) {
                    if (2 !== e[s].data[0][1].length) throw new Error(o);
                    for (var l = 0; l < e[n].data.length; l++) a.push(e[n].data[l][1][0]), i.push(e[n].data[l][1][1])
                } else if ("xy" === t) {
                    if (2 !== e[s].data[0].y.length) throw new Error(o);
                    for (var c = function (t) {
                        var o = b.randomId(), s = e[n].data[t].x,
                            l = {y1: e[n].data[t].y[0], y2: e[n].data[t].y[1], rangeName: o};
                        e[n].data[t].rangeName = o;
                        var c = r.findIndex((function (t) {
                            return t.x === s
                        }));
                        r[c].y.push(l), a.push(l.y1), i.push(l.y2)
                    }, d = 0; d < e[n].data.length; d++) c(d)
                }
                return {start: a, end: i, rangeUniques: r}
            }
        }, {
            key: "handleCandleStickDataFormat", value: function (t, e, n) {
                var a = this.w, i = [], r = [], o = [], s = [],
                    l = "Please provide [Open, High, Low and Close] values in valid format. Read more https://apexcharts.com/docs/series/#candlestick";
                if ("array" === t) {
                    if (!Array.isArray(e[n].data[0][1]) && 5 !== e[n].data[0].length || Array.isArray(e[n].data[0][1]) && 4 !== e[n].data[0][1].length) throw new Error(l);
                    if (5 === e[n].data[0].length) for (var c = 0; c < e[n].data.length; c++) i.push(e[n].data[c][1]), r.push(e[n].data[c][2]), o.push(e[n].data[c][3]), s.push(e[n].data[c][4]); else for (var d = 0; d < e[n].data.length; d++) i.push(e[n].data[d][1][0]), r.push(e[n].data[d][1][1]), o.push(e[n].data[d][1][2]), s.push(e[n].data[d][1][3])
                } else if ("xy" === t) {
                    if (!a.globals.comboCharts && 4 !== e[n].data[0].y.length || a.globals.comboCharts && "candlestick" === e[n].type && e[n].data.length && 4 !== e[n].data[0].y.length) throw new Error(l);
                    for (var u = 0; u < e[n].data.length; u++) i.push(e[n].data[u].y[0]), r.push(e[n].data[u].y[1]), o.push(e[n].data[u].y[2]), s.push(e[n].data[u].y[3])
                }
                return {o: i, h: r, l: o, c: s}
            }
        }, {
            key: "parseDataAxisCharts", value: function (t) {
                for (var e = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a = this.w.config, i = this.w.globals, r = new F(n), o = a.labels.length > 0 ? a.labels.slice() : a.xaxis.categories.slice(), s = function () {
                    for (var t = 0; t < o.length; t++) if ("string" == typeof o[t]) {
                        if (!r.isValidDate(o[t])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                        e.twoDSeriesX.push(r.parseDate(o[t]))
                    } else e.twoDSeriesX.push(o[t])
                }, l = 0; l < t.length; l++) {
                    if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[l].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
                    if ("rangeBar" !== a.chart.type && "rangeArea" !== a.chart.type && "rangeBar" !== t[l].type && "rangeArea" !== t[l].type || (i.isRangeData = !0, this.handleRangeData(t, l)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, l) : this.isFormatXY() && this.handleFormatXY(t, l), "candlestick" !== a.chart.type && "candlestick" !== t[l].type || this.handleCandleStickData(t, l), i.series.push(this.twoDSeries), i.labels.push(this.twoDSeriesX), i.seriesX.push(this.twoDSeriesX), l !== this.activeSeriesIndex || this.fallbackToCategory || (i.isXNumeric = !0); else {
                        "datetime" === a.xaxis.type ? (i.isXNumeric = !0, s(), i.seriesX.push(this.twoDSeriesX)) : "numeric" === a.xaxis.type && (i.isXNumeric = !0, o.length > 0 && (this.twoDSeriesX = o, i.seriesX.push(this.twoDSeriesX))), i.labels.push(this.twoDSeriesX);
                        var c = t[l].data.map((function (t) {
                            return b.parseNumber(t)
                        }));
                        i.series.push(c)
                    }
                    i.seriesZ.push(this.threeDSeries), void 0 !== t[l].name ? i.seriesNames.push(t[l].name) : i.seriesNames.push("series-" + parseInt(l + 1, 10)), void 0 !== t[l].color ? i.seriesColors.push(t[l].color) : i.seriesColors.push(void 0)
                }
                return this.w
            }
        }, {
            key: "parseDataNonAxisCharts", value: function (t) {
                var e = this.w.globals, n = this.w.config;
                e.series = t.slice(), e.seriesNames = n.labels.slice();
                for (var a = 0; a < e.series.length; a++) void 0 === e.seriesNames[a] && e.seriesNames.push("series-" + (a + 1));
                return this.w
            }
        }, {
            key: "handleExternalLabelsData", value: function (t) {
                var e = this.w.config, n = this.w.globals;
                e.xaxis.categories.length > 0 ? n.labels = e.xaxis.categories : e.labels.length > 0 ? n.labels = e.labels.slice() : this.fallbackToCategory ? (n.labels = n.labels[0], n.seriesRangeBarTimeline.length && (n.seriesRangeBarTimeline.map((function (t) {
                    t.forEach((function (t) {
                        n.labels.indexOf(t.x) < 0 && t.x && n.labels.push(t.x)
                    }))
                })), n.labels = n.labels.filter((function (t, e, n) {
                    return n.indexOf(t) === e
                }))), e.xaxis.convertedCatToNumeric && (new B(e).convertCatToNumericXaxis(e, this.ctx, n.seriesX[0]), this._generateExternalLabels(t))) : this._generateExternalLabels(t)
            }
        }, {
            key: "_generateExternalLabels", value: function (t) {
                var e = this.w.globals, n = this.w.config, a = [];
                if (e.axisCharts) {
                    if (e.series.length > 0) for (var i = 0; i < e.series[e.maxValsInArrayIndex].length; i++) a.push(i + 1);
                    e.seriesX = [];
                    for (var r = 0; r < t.length; r++) e.seriesX.push(a);
                    e.isXNumeric = !0
                }
                if (0 === a.length) {
                    a = e.axisCharts ? [] : e.series.map((function (t, e) {
                        return e + 1
                    }));
                    for (var o = 0; o < t.length; o++) e.seriesX.push(a)
                }
                e.labels = a, n.xaxis.convertedCatToNumeric && (e.categoryLabels = a.map((function (t) {
                    return n.xaxis.labels.formatter(t)
                }))), e.noLabelsProvided = !0
            }
        }, {
            key: "parseData", value: function (t) {
                var e = this.w, n = e.config, a = e.globals;
                if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a.axisCharts ? this.parseDataAxisCharts(t) : this.parseDataNonAxisCharts(t), this.coreUtils.getLargestSeries(), "bar" === n.chart.type && n.chart.stacked) {
                    var i = new j(this.ctx);
                    a.series = i.setNullSeriesToZeroValues(a.series)
                }
                this.coreUtils.getSeriesTotals(), a.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a.dataFormatXNumeric || a.isXNumeric && ("numeric" !== n.xaxis.type || 0 !== n.labels.length || 0 !== n.xaxis.categories.length) || this.handleExternalLabelsData(t);
                for (var r = this.coreUtils.getCategoryLabels(a.labels), o = 0; o < r.length; o++) if (Array.isArray(r[o])) {
                    a.isMultiLineX = !0;
                    break
                }
            }
        }, {
            key: "excludeCollapsedSeriesInYAxis", value: function () {
                var t = this, e = this.w;
                e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map((function (n, a) {
                    if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return n.index
                }))
            }
        }]), t
    }(), $ = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM"
        }

        return s(t, [{
            key: "xLabelFormat", value: function (t, e, n, a) {
                var i = this.w;
                if ("datetime" === i.config.xaxis.type && void 0 === i.config.xaxis.labels.formatter && void 0 === i.config.tooltip.x.formatter) {
                    var r = new F(this.ctx);
                    return r.formatDate(r.getDate(e), i.config.tooltip.x.format)
                }
                return t(e, n, a)
            }
        }, {
            key: "defaultGeneralFormatter", value: function (t) {
                return Array.isArray(t) ? t.map((function (t) {
                    return t
                })) : t
            }
        }, {
            key: "defaultYFormatter", value: function (t, e, n) {
                var a = this.w;
                return b.isNumber(t) && (t = 0 !== a.globals.yValueDecimal ? t.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : a.globals.yValueDecimal) : a.globals.maxYArr[n] - a.globals.minYArr[n] < 5 ? t.toFixed(1) : t.toFixed(0)), t
            }
        }, {
            key: "setLabelFormatters", value: function () {
                var t = this, e = this.w;
                return e.globals.xLabelFormatter = function (e) {
                    return t.defaultGeneralFormatter(e)
                }, e.globals.xaxisTooltipFormatter = function (e) {
                    return t.defaultGeneralFormatter(e)
                }, e.globals.ttKeyFormatter = function (e) {
                    return t.defaultGeneralFormatter(e)
                }, e.globals.ttZFormatter = function (t) {
                    return t
                }, e.globals.legendFormatter = function (e) {
                    return t.defaultGeneralFormatter(e)
                }, void 0 !== e.config.xaxis.labels.formatter ? e.globals.xLabelFormatter = e.config.xaxis.labels.formatter : e.globals.xLabelFormatter = function (t) {
                    return b.isNumber(t) ? !e.config.xaxis.convertedCatToNumeric && "numeric" === e.config.xaxis.type && e.globals.dataPoints < 50 || e.globals.isBarHorizontal && e.globals.maxY - e.globals.minYArr < 4 ? t.toFixed(1) : t.toFixed(0) : t
                }, "function" == typeof e.config.tooltip.x.formatter ? e.globals.ttKeyFormatter = e.config.tooltip.x.formatter : e.globals.ttKeyFormatter = e.globals.xLabelFormatter, "function" == typeof e.config.xaxis.tooltip.formatter && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), (Array.isArray(e.config.tooltip.y) || void 0 !== e.config.tooltip.y.formatter) && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach((function (n, a) {
                    void 0 !== n.labels.formatter ? e.globals.yLabelFormatters[a] = n.labels.formatter : e.globals.yLabelFormatters[a] = function (i) {
                        return e.globals.xyCharts ? Array.isArray(i) ? i.map((function (e) {
                            return t.defaultYFormatter(e, n, a)
                        })) : t.defaultYFormatter(i, n, a) : i
                    }
                })), e.globals
            }
        }, {
            key: "heatmapLabelFormatters", value: function () {
                var t = this.w;
                if ("heatmap" === t.config.chart.type) {
                    t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
                    var e = t.globals.seriesNames.reduce((function (t, e) {
                        return t.length > e.length ? t : e
                    }), 0);
                    t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e
                }
            }
        }]), t
    }(), Y = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "getLabel", value: function (t, e, n, a) {
                var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [],
                    r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", o = this.w,
                    s = void 0 === t[a] ? "" : t[a], l = s, c = o.globals.xLabelFormatter,
                    d = o.config.xaxis.labels.formatter, u = !1, h = new $(this.ctx), p = s;
                l = h.xLabelFormat(c, s, p, {
                    i: a,
                    dateFormatter: new F(this.ctx).formatDate,
                    w: o
                }), void 0 !== d && (l = d(s, t[a], {i: a, dateFormatter: new F(this.ctx).formatDate, w: o}));
                var f = function (t) {
                    var n = null;
                    return e.forEach((function (t) {
                        "month" === t.unit ? n = "year" : "day" === t.unit ? n = "month" : "hour" === t.unit ? n = "day" : "minute" === t.unit && (n = "hour")
                    })), n === t
                };
                e.length > 0 ? (u = f(e[a].unit), n = e[a].position, l = e[a].value) : "datetime" === o.config.xaxis.type && void 0 === d && (l = ""), void 0 === l && (l = ""), l = Array.isArray(l) ? l : l.toString();
                var g = new _(this.ctx), m = {};
                m = o.globals.rotateXLabels ? g.getTextRects(l, parseInt(r, 10), null, "rotate(".concat(o.config.xaxis.labels.rotate, " 0 0)"), !1) : g.getTextRects(l, parseInt(r, 10));
                var v = !o.config.xaxis.labels.showDuplicates && this.ctx.timeScale && "hours" !== this.ctx.timeScale.tickInterval && "minutes" !== this.ctx.timeScale.tickInterval;
                return !Array.isArray(l) && (0 === l.indexOf("NaN") || 0 === l.toLowerCase().indexOf("invalid") || l.toLowerCase().indexOf("infinity") >= 0 || i.indexOf(l) >= 0 && v) && (l = ""), {
                    x: n,
                    text: l,
                    textRect: m,
                    isBold: u
                }
            }
        }, {
            key: "checkLabelBasedOnTickamount", value: function (t, e, n) {
                var a = this.w, i = a.config.xaxis.tickAmount;
                return "dataPoints" === i && (i = Math.round(a.globals.gridWidth / 120)), i > n || t % Math.round(n / (i + 1)) == 0 || (e.text = ""), e
            }
        }, {
            key: "checkForOverflowingLabels", value: function (t, e, n, a, i) {
                var r = this.w;
                if (0 === t && r.globals.skipFirstTimelinelabel && (e.text = ""), t === n - 1 && r.globals.skipLastTimelinelabel && (e.text = ""), r.config.xaxis.labels.hideOverlappingLabels && a.length > 0) {
                    var o = i[i.length - 1];
                    e.x < o.textRect.width / (r.globals.rotateXLabels ? Math.abs(r.config.xaxis.labels.rotate) / 12 : 1.01) + o.x && (e.text = "")
                }
                return e
            }
        }, {
            key: "checkForReversedLabels", value: function (t, e) {
                var n = this.w;
                return n.config.yaxis[t] && n.config.yaxis[t].reversed && e.reverse(), e
            }
        }, {
            key: "isYAxisHidden", value: function (t) {
                var e = this.w, n = new C(this.ctx);
                return !e.config.yaxis[t].show || !e.config.yaxis[t].showForNullSeries && n.isSeriesNull(t) && -1 === e.globals.collapsedSeriesIndices.indexOf(t)
            }
        }, {
            key: "getYAxisForeColor", value: function (t, e) {
                var n = this.w;
                return Array.isArray(t) && n.globals.yAxisScale[e] && this.ctx.theme.pushExtraColors(t, n.globals.yAxisScale[e].result.length, !1), t
            }
        }, {
            key: "drawYAxisTicks", value: function (t, e, n, a, i, r, o) {
                var s = this.w, l = new _(this.ctx), c = s.globals.translateY;
                if (a.show && e > 0) {
                    !0 === s.config.yaxis[i].opposite && (t += a.width);
                    for (var d = e; d >= 0; d--) {
                        var u = c + e / 10 + s.config.yaxis[i].labels.offsetY - 1;
                        s.globals.isBarHorizontal && (u = r * d), "heatmap" === s.config.chart.type && (u += r / 2);
                        var h = l.drawLine(t + n.offsetX - a.width + a.offsetX, u + a.offsetY, t + n.offsetX + a.offsetX, u + a.offsetY, a.color);
                        o.add(h), c += r
                    }
                }
            }
        }]), t
    }(), U = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "fixSvgStringForIe11", value: function (t) {
                if (!b.isIE11()) return t;
                var e = 0, n = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, (function (t) {
                    return 2 == ++e ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.com/svgjs"' : t
                }));
                return (n = n.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
            }
        }, {
            key: "getSvgString", value: function () {
                var t = this.w.globals.dom.Paper.svg();
                return this.fixSvgStringForIe11(t)
            }
        }, {
            key: "cleanup", value: function () {
                var t = this.w, e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
                    n = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
                    a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                Array.prototype.forEach.call(a, (function (t) {
                    t.setAttribute("width", 0)
                })), e && e[0] && (e[0].setAttribute("x", -500), e[0].setAttribute("x1", -500), e[0].setAttribute("x2", -500)), n && n[0] && (n[0].setAttribute("y", -100), n[0].setAttribute("y1", -100), n[0].setAttribute("y2", -100))
            }
        }, {
            key: "svgUrl", value: function () {
                this.cleanup();
                var t = this.getSvgString(), e = new Blob([t], {type: "image/svg+xml;charset=utf-8"});
                return URL.createObjectURL(e)
            }
        }, {
            key: "dataURI", value: function () {
                var t = this;
                return new Promise((function (e) {
                    var n = t.w;
                    t.cleanup();
                    var a = document.createElement("canvas");
                    a.width = n.globals.svgWidth, a.height = parseInt(n.globals.dom.elWrap.style.height, 10);
                    var i = "transparent" === n.config.chart.background ? "#fff" : n.config.chart.background,
                        r = a.getContext("2d");
                    r.fillStyle = i, r.fillRect(0, 0, a.width, a.height);
                    var o = t.getSvgString();
                    if (window.canvg && b.isIE11()) {
                        var s = window.canvg.Canvg.fromString(r, o, {ignoreClear: !0, ignoreDimensions: !0});
                        s.start();
                        var l = a.msToBlob();
                        s.stop(), e({blob: l})
                    } else {
                        var c = "data:image/svg+xml," + encodeURIComponent(o), d = new Image;
                        d.crossOrigin = "anonymous", d.onload = function () {
                            if (r.drawImage(d, 0, 0), a.msToBlob) {
                                var t = a.msToBlob();
                                e({blob: t})
                            } else {
                                var n = a.toDataURL("image/png");
                                e({imgURI: n})
                            }
                        }, d.src = c
                    }
                }))
            }
        }, {
            key: "exportToSVG", value: function () {
                this.triggerDownload(this.svgUrl(), null, ".svg")
            }
        }, {
            key: "exportToPng", value: function () {
                var t = this;
                this.dataURI().then((function (e) {
                    var n = e.imgURI, a = e.blob;
                    a ? navigator.msSaveOrOpenBlob(a, t.w.globals.chartID + ".png") : t.triggerDownload(n, null, ".png")
                }))
            }
        }, {
            key: "exportToCSV", value: function (t) {
                var e = this, n = t.series, a = t.columnDelimiter, i = t.lineDelimiter, r = void 0 === i ? "\n" : i,
                    o = this.w, s = [], l = [], c = "data:text/csv;charset=utf-8,", d = new V(this.ctx),
                    u = new Y(this.ctx), h = function (t) {
                        var n = "";
                        if (o.globals.axisCharts) {
                            if ("category" === o.config.xaxis.type || o.config.xaxis.convertedCatToNumeric) if (o.globals.isBarHorizontal) {
                                var a = o.globals.yLabelFormatters[0], i = new j(e.ctx).getActiveConfigSeriesIndex();
                                n = a(o.globals.labels[t], {seriesIndex: i, dataPointIndex: t, w: o})
                            } else n = u.getLabel(o.globals.labels, o.globals.timescaleLabels, 0, t).text;
                            "datetime" === o.config.xaxis.type && (o.config.xaxis.categories.length ? n = o.config.xaxis.categories[t] : o.config.labels.length && (n = o.config.labels[t]))
                        } else n = o.config.labels[t];
                        return n
                    };
                s.push(o.config.chart.toolbar.export.csv.headerCategory), n.map((function (t, e) {
                    o.globals.axisCharts && s.push(t.name ? t.name : "series-".concat(e))
                })), o.globals.axisCharts || (s.push(o.config.chart.toolbar.export.csv.headerValue), l.push(s.join(a))), n.map((function (t, e) {
                    o.globals.axisCharts ? function (t, e) {
                        if (s.length && 0 === e && l.push(s.join(a)), t.data && t.data.length) for (var i = 0; i < t.data.length; i++) {
                            s = [];
                            var r = h(i);
                            if (r || (d.isFormatXY() ? r = n[e].data[i].x : d.isFormat2DArray() && (r = n[e].data[i] ? n[e].data[i][0] : "")), 0 === e) {
                                s.push((u = r, "datetime" === o.config.xaxis.type && String(u).length >= 10 ? o.config.chart.toolbar.export.csv.dateFormatter(r) : r));
                                for (var c = 0; c < o.globals.series.length; c++) s.push(o.globals.series[c][i])
                            }
                            ("candlestick" === o.config.chart.type || t.type && "candlestick" === t.type) && (s.pop(), s.push(o.globals.seriesCandleO[e][i]), s.push(o.globals.seriesCandleH[e][i]), s.push(o.globals.seriesCandleL[e][i]), s.push(o.globals.seriesCandleC[e][i])), "rangeBar" === o.config.chart.type && (s.pop(), s.push(o.globals.seriesRangeStart[e][i]), s.push(o.globals.seriesRangeEnd[e][i])), s.length && l.push(s.join(a))
                        }
                        var u
                    }(t, e) : ((s = []).push(o.globals.labels[e]), s.push(o.globals.series[e]), l.push(s.join(a)))
                })), c += l.join(r), this.triggerDownload(encodeURI(c), o.config.chart.toolbar.export.csv.filename, ".csv")
            }
        }, {
            key: "triggerDownload", value: function (t, e, n) {
                var a = document.createElement("a");
                a.href = t, a.download = (e || this.w.globals.chartID) + n, document.body.appendChild(a), a.click(), document.body.removeChild(a)
            }
        }]), t
    }(), G = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w;
            var n = this.w;
            this.axesUtils = new Y(e), this.xaxisLabels = n.globals.labels.slice(), n.globals.timescaleLabels.length > 0 && !n.globals.isBarHorizontal && (this.xaxisLabels = n.globals.timescaleLabels.slice()), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === n.config.xaxis.position ? this.offY = 0 : this.offY = n.globals.gridHeight + 1, this.offY = this.offY + n.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === n.config.chart.type && n.config.plotOptions.bar.horizontal, this.xaxisFontSize = n.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = n.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = n.config.xaxis.labels.style.colors, this.xaxisBorderWidth = n.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = n.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = n.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = n.config.xaxis.axisBorder.height, this.yaxis = n.config.yaxis[0]
        }

        return s(t, [{
            key: "drawXaxis", value: function () {
                var t, e = this, n = this.w, a = new _(this.ctx), i = a.group({
                    class: "apexcharts-xaxis",
                    transform: "translate(".concat(n.config.xaxis.offsetX, ", ").concat(n.config.xaxis.offsetY, ")")
                }), r = a.group({
                    class: "apexcharts-xaxis-texts-g",
                    transform: "translate(".concat(n.globals.translateXAxisX, ", ").concat(n.globals.translateXAxisY, ")")
                });
                i.add(r);
                for (var o = n.globals.padHorizontal, s = [], l = 0; l < this.xaxisLabels.length; l++) s.push(this.xaxisLabels[l]);
                var c = s.length;
                if (n.globals.isXNumeric) {
                    var d = c > 1 ? c - 1 : c;
                    t = n.globals.gridWidth / d, o = o + t / 2 + n.config.xaxis.labels.offsetX
                } else t = n.globals.gridWidth / s.length, o = o + t + n.config.xaxis.labels.offsetX;
                if (n.config.xaxis.labels.show) for (var u = function (i) {
                    var l = o - t / 2 + n.config.xaxis.labels.offsetX;
                    0 === i && 1 === c && t / 2 === o && 1 === n.globals.dataPoints && (l = n.globals.gridWidth / 2);
                    var d = e.axesUtils.getLabel(s, n.globals.timescaleLabels, l, i, e.drawnLabels, e.xaxisFontSize),
                        u = 28;
                    n.globals.rotateXLabels && (u = 22), (d = void 0 !== n.config.xaxis.tickAmount && "dataPoints" !== n.config.xaxis.tickAmount && "datetime" !== n.config.xaxis.type ? e.axesUtils.checkLabelBasedOnTickamount(i, d, c) : e.axesUtils.checkForOverflowingLabels(i, d, c, e.drawnLabels, e.drawnLabelsRects)).text && n.globals.xaxisLabelsCount++;
                    var h = a.drawText({
                        x: d.x,
                        y: e.offY + n.config.xaxis.labels.offsetY + u - ("top" === n.config.xaxis.position ? n.globals.xAxisHeight + n.config.xaxis.axisTicks.height - 2 : 0),
                        text: d.text,
                        textAnchor: "middle",
                        fontWeight: d.isBold ? 600 : n.config.xaxis.labels.style.fontWeight,
                        fontSize: e.xaxisFontSize,
                        fontFamily: e.xaxisFontFamily,
                        foreColor: Array.isArray(e.xaxisForeColors) ? n.config.xaxis.convertedCatToNumeric ? e.xaxisForeColors[n.globals.minX + i - 1] : e.xaxisForeColors[i] : e.xaxisForeColors,
                        isPlainText: !1,
                        cssClass: "apexcharts-xaxis-label " + n.config.xaxis.labels.style.cssClass
                    });
                    r.add(h);
                    var p = document.createElementNS(n.globals.SVGNS, "title");
                    p.textContent = Array.isArray(d.text) ? d.text.join(" ") : d.text, h.node.appendChild(p), "" !== d.text && (e.drawnLabels.push(d.text), e.drawnLabelsRects.push(d)), o += t
                }, h = 0; h <= c - 1; h++) u(h);
                if (void 0 !== n.config.xaxis.title.text) {
                    var p = a.group({class: "apexcharts-xaxis-title"}), f = a.drawText({
                        x: n.globals.gridWidth / 2 + n.config.xaxis.title.offsetX,
                        y: this.offY - parseFloat(this.xaxisFontSize) + n.globals.xAxisLabelsHeight + n.config.xaxis.title.offsetY,
                        text: n.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: n.config.xaxis.title.style.fontSize,
                        fontFamily: n.config.xaxis.title.style.fontFamily,
                        fontWeight: n.config.xaxis.title.style.fontWeight,
                        foreColor: n.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + n.config.xaxis.title.style.cssClass
                    });
                    p.add(f), i.add(p)
                }
                if (n.config.xaxis.axisBorder.show) {
                    var g = n.globals.barPadForNumericAxis,
                        m = a.drawLine(n.globals.padHorizontal + n.config.xaxis.axisBorder.offsetX - g, this.offY, this.xaxisBorderWidth + g, this.offY, n.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                    i.add(m)
                }
                return i
            }
        }, {
            key: "drawXaxisInversed", value: function (t) {
                var e, n, a = this, i = this.w, r = new _(this.ctx),
                    o = i.config.yaxis[0].opposite ? i.globals.translateYAxisX[t] : 0,
                    s = r.group({class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t}), l = r.group({
                        class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                        transform: "translate(" + o + ", 0)"
                    });
                s.add(l);
                var c = [];
                if (i.config.yaxis[t].show) for (var d = 0; d < this.xaxisLabels.length; d++) c.push(this.xaxisLabels[d]);
                e = i.globals.gridHeight / c.length, n = -e / 2.2;
                var u = i.globals.yLabelFormatters[0], h = i.config.yaxis[0].labels;
                if (h.show) for (var p = function (o) {
                    var s = void 0 === c[o] ? "" : c[o];
                    s = u(s, {seriesIndex: t, dataPointIndex: o, w: i});
                    var d = a.axesUtils.getYAxisForeColor(h.style.colors, t), p = 0;
                    Array.isArray(s) && (p = s.length / 2 * parseInt(h.style.fontSize, 10));
                    var f = r.drawText({
                        x: h.offsetX - 15,
                        y: n + e + h.offsetY - p,
                        text: s,
                        textAnchor: a.yaxis.opposite ? "start" : "end",
                        foreColor: Array.isArray(d) ? d[o] : d,
                        fontSize: h.style.fontSize,
                        fontFamily: h.style.fontFamily,
                        fontWeight: h.style.fontWeight,
                        isPlainText: !1,
                        cssClass: "apexcharts-yaxis-label " + h.style.cssClass
                    });
                    l.add(f);
                    var g = document.createElementNS(i.globals.SVGNS, "title");
                    if (g.textContent = s.text, f.node.appendChild(g), 0 !== i.config.yaxis[t].labels.rotate) {
                        var m = r.rotateAroundCenter(f.node);
                        f.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[t].labels.rotate, " 0 ").concat(m.y, ")"))
                    }
                    n += e
                }, f = 0; f <= c.length - 1; f++) p(f);
                if (void 0 !== i.config.yaxis[0].title.text) {
                    var g = r.group({
                        class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                        transform: "translate(" + o + ", 0)"
                    }), m = r.drawText({
                        x: 0,
                        y: i.globals.gridHeight / 2,
                        text: i.config.yaxis[0].title.text,
                        textAnchor: "middle",
                        foreColor: i.config.yaxis[0].title.style.color,
                        fontSize: i.config.yaxis[0].title.style.fontSize,
                        fontWeight: i.config.yaxis[0].title.style.fontWeight,
                        fontFamily: i.config.yaxis[0].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[0].title.style.cssClass
                    });
                    g.add(m), s.add(g)
                }
                var v = 0;
                this.isCategoryBarHorizontal && i.config.yaxis[0].opposite && (v = i.globals.gridWidth);
                var b = i.config.xaxis.axisBorder;
                if (b.show) {
                    var y = r.drawLine(i.globals.padHorizontal + b.offsetX + v, 1 + b.offsetY, i.globals.padHorizontal + b.offsetX + v, i.globals.gridHeight + b.offsetY, b.color, 0);
                    s.add(y)
                }
                return i.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(v, c.length, i.config.yaxis[0].axisBorder, i.config.yaxis[0].axisTicks, 0, e, s), s
            }
        }, {
            key: "drawXaxisTicks", value: function (t, e) {
                var n = this.w, a = t;
                if (!(t < 0 || t - 2 > n.globals.gridWidth)) {
                    var i = this.offY + n.config.xaxis.axisTicks.offsetY, r = i + n.config.xaxis.axisTicks.height;
                    if ("top" === n.config.xaxis.position && (r = i - n.config.xaxis.axisTicks.height), n.config.xaxis.axisTicks.show) {
                        var o = new _(this.ctx).drawLine(t + n.config.xaxis.axisTicks.offsetX, i + n.config.xaxis.offsetY, a + n.config.xaxis.axisTicks.offsetX, r + n.config.xaxis.offsetY, n.config.xaxis.axisTicks.color);
                        e.add(o), o.node.classList.add("apexcharts-xaxis-tick")
                    }
                }
            }
        }, {
            key: "getXAxisTicksPositions", value: function () {
                var t = this.w, e = [], n = this.xaxisLabels.length, a = t.globals.padHorizontal;
                if (t.globals.timescaleLabels.length > 0) for (var i = 0; i < n; i++) a = this.xaxisLabels[i].position, e.push(a); else for (var r = n, o = 0; o < r; o++) {
                    var s = r;
                    t.globals.isXNumeric && "bar" !== t.config.chart.type && (s -= 1), a += t.globals.gridWidth / s, e.push(a)
                }
                return e
            }
        }, {
            key: "xAxisLabelCorrections", value: function () {
                var t = this.w, e = new _(this.ctx),
                    n = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
                    a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text"),
                    i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
                    r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways) for (var o = 0; o < a.length; o++) {
                    var s = e.rotateAroundCenter(a[o]);
                    s.y = s.y - 1, s.x = s.x + 1, a[o].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(s.x, " ").concat(s.y, ")")), a[o].setAttribute("text-anchor", "end"), n.setAttribute("transform", "translate(0, ".concat(-10, ")"));
                    var l = a[o].childNodes;
                    t.config.xaxis.labels.trim && Array.prototype.forEach.call(l, (function (n) {
                        e.placeTextWithEllipsis(n, n.textContent, t.config.xaxis.labels.maxHeight - ("bottom" === t.config.legend.position ? 20 : 10))
                    }))
                } else !function () {
                    for (var n = t.globals.gridWidth / (t.globals.labels.length + 1), i = 0; i < a.length; i++) {
                        var r = a[i].childNodes;
                        t.config.xaxis.labels.trim && "datetime" !== t.config.xaxis.type && Array.prototype.forEach.call(r, (function (t) {
                            e.placeTextWithEllipsis(t, t.textContent, n)
                        }))
                    }
                }();
                if (i.length > 0) {
                    var c = i[i.length - 1].getBBox(), d = i[0].getBBox();
                    c.x < -20 && i[i.length - 1].parentNode.removeChild(i[i.length - 1]), d.x + d.width > t.globals.gridWidth && !t.globals.isBarHorizontal && i[0].parentNode.removeChild(i[0]);
                    for (var u = 0; u < r.length; u++) e.placeTextWithEllipsis(r[u], r[u].textContent, t.config.yaxis[0].labels.maxWidth - 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) - 20)
                }
            }
        }]), t
    }(), X = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w;
            var n = this.w;
            this.xaxisLabels = n.globals.labels.slice(), this.axesUtils = new Y(e), this.isTimelineBar = "datetime" === n.config.xaxis.type && n.globals.seriesRangeBarTimeline.length, n.globals.timescaleLabels.length > 0 && (this.xaxisLabels = n.globals.timescaleLabels.slice())
        }

        return s(t, [{
            key: "drawGridArea", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e = this.w,
                    n = new _(this.ctx);
                null === t && (t = n.group({class: "apexcharts-grid"}));
                var a = n.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, "transparent"),
                    i = n.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, "transparent");
                return t.add(i), t.add(a), t
            }
        }, {
            key: "drawGrid", value: function () {
                var t = null;
                return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t
            }
        }, {
            key: "createGridMask", value: function () {
                var t = this.w, e = t.globals, n = new _(this.ctx),
                    a = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
                if (Array.isArray(t.config.stroke.width)) {
                    var i = 0;
                    t.config.stroke.width.forEach((function (t) {
                        i = Math.max(i, t)
                    })), a = i
                }
                e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid));
                var r = t.config.chart.type, o = 0, s = 0;
                ("bar" === r || "rangeBar" === r || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (o = t.config.grid.padding.left, s = t.config.grid.padding.right, e.barPadForNumericAxis > o && (o = e.barPadForNumericAxis, s = e.barPadForNumericAxis)), e.dom.elGridRect = n.drawRect(-a / 2 - o - 2, -a / 2, e.gridWidth + a + s + o + 4, e.gridHeight + a, 0, "#fff"), new C(this).getLargestMarkerSize();
                var l = t.globals.markers.largestSize + 1;
                e.dom.elGridRectMarker = n.drawRect(2 * -l, 2 * -l, e.gridWidth + 4 * l, e.gridHeight + 4 * l, 0, "#fff"), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
                var c = e.dom.baseEl.querySelector("defs");
                c.appendChild(e.dom.elGridRectMask), c.appendChild(e.dom.elGridRectMarkerMask)
            }
        }, {
            key: "_drawGridLines", value: function (t) {
                var e = t.i, n = t.x1, a = t.y1, i = t.x2, r = t.y2, o = t.xCount, s = t.parent, l = this.w;
                0 === e && l.globals.skipFirstTimelinelabel || e === o - 1 && l.globals.skipLastTimelinelabel && !l.config.xaxis.labels.formatter || "radar" === l.config.chart.type || (l.config.grid.xaxis.lines.show && this._drawGridLine({
                    x1: n,
                    y1: a,
                    x2: i,
                    y2: r,
                    parent: s
                }), new G(this.ctx).drawXaxisTicks(n, this.elg))
            }
        }, {
            key: "_drawGridLine", value: function (t) {
                var e = t.x1, n = t.y1, a = t.x2, i = t.y2, r = t.parent, o = this.w,
                    s = r.node.classList.contains("apexcharts-gridlines-horizontal"), l = o.config.grid.strokeDashArray,
                    c = o.globals.barPadForNumericAxis,
                    d = new _(this).drawLine(e - (s ? c : 0), n, a + (s ? c : 0), i, o.config.grid.borderColor, l);
                d.node.classList.add("apexcharts-gridline"), r.add(d)
            }
        }, {
            key: "_drawGridBandRect", value: function (t) {
                var e = t.c, n = t.x1, a = t.y1, i = t.x2, r = t.y2, o = t.type, s = this.w, l = new _(this.ctx),
                    c = s.globals.barPadForNumericAxis;
                if ("column" !== o || "datetime" !== s.config.xaxis.type) {
                    var d = s.config.grid[o].colors[e],
                        u = l.drawRect(n - ("row" === o ? c : 0), a, i + ("row" === o ? 2 * c : 0), r, 0, d, s.config.grid[o].opacity);
                    this.elg.add(u), u.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")), u.node.classList.add("apexcharts-grid-".concat(o))
                }
            }
        }, {
            key: "_drawXYLines", value: function (t) {
                var e = this, n = t.xCount, a = t.tickAmount, i = this.w;
                if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show) {
                    var r, o = i.globals.padHorizontal, s = i.globals.gridHeight;
                    i.globals.timescaleLabels.length ? function (t) {
                        for (var a = t.xC, i = t.x1, r = t.y1, o = t.x2, s = t.y2, l = 0; l < a; l++) i = e.xaxisLabels[l].position, o = e.xaxisLabels[l].position, e._drawGridLines({
                            i: l,
                            x1: i,
                            y1: r,
                            x2: o,
                            y2: s,
                            xCount: n,
                            parent: e.elgridLinesV
                        })
                    }({
                        xC: n,
                        x1: o,
                        y1: 0,
                        x2: r,
                        y2: s
                    }) : (i.globals.isXNumeric && (n = i.globals.xAxisScale.result.length), i.config.xaxis.convertedCatToNumeric && (n = i.globals.xaxisLabelsCount), function (t) {
                        var a = t.xC, r = t.x1, o = t.y1, s = t.x2, l = t.y2;
                        if (void 0 !== i.config.xaxis.tickAmount && "dataPoints" !== i.config.xaxis.tickAmount) i.globals.dom.baseEl.querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)").forEach((function (t, a) {
                            var i = t.getBBox();
                            e._drawGridLines({
                                i: a,
                                x1: i.x + i.width / 2,
                                y1: o,
                                x2: i.x + i.width / 2,
                                y2: l,
                                xCount: n,
                                parent: e.elgridLinesV
                            })
                        })); else for (var c = 0; c < a + (i.globals.isXNumeric ? 0 : 1); c++) 0 === c && 1 === a && 1 === i.globals.dataPoints && (s = r = i.globals.gridWidth / 2), e._drawGridLines({
                            i: c,
                            x1: r,
                            y1: o,
                            x2: s,
                            y2: l,
                            xCount: n,
                            parent: e.elgridLinesV
                        }), s = r += i.globals.gridWidth / (i.globals.isXNumeric ? a - 1 : a)
                    }({xC: n, x1: o, y1: 0, x2: r, y2: s}))
                }
                if (i.config.grid.yaxis.lines.show) {
                    var l = 0, c = 0, d = i.globals.gridWidth, u = a + 1;
                    this.isTimelineBar && (u = i.globals.labels.length);
                    for (var h = 0; h < u + (this.isTimelineBar ? 1 : 0); h++) this._drawGridLine({
                        x1: 0,
                        y1: l,
                        x2: d,
                        y2: c,
                        parent: this.elgridLinesH
                    }), c = l += i.globals.gridHeight / (this.isTimelineBar ? u : a)
                }
            }
        }, {
            key: "_drawInvertedXYLines", value: function (t) {
                var e = t.xCount, n = this.w;
                if (n.config.grid.xaxis.lines.show || n.config.xaxis.axisTicks.show) for (var a, i = n.globals.padHorizontal, r = n.globals.gridHeight, o = 0; o < e + 1; o++) n.config.grid.xaxis.lines.show && this._drawGridLine({
                    x1: i,
                    y1: 0,
                    x2: a,
                    y2: r,
                    parent: this.elgridLinesV
                }), new G(this.ctx).drawXaxisTicks(i, this.elg), a = i = i + n.globals.gridWidth / e + .3;
                if (n.config.grid.yaxis.lines.show) for (var s = 0, l = 0, c = n.globals.gridWidth, d = 0; d < n.globals.dataPoints + 1; d++) this._drawGridLine({
                    x1: 0,
                    y1: s,
                    x2: c,
                    y2: l,
                    parent: this.elgridLinesH
                }), l = s += n.globals.gridHeight / n.globals.dataPoints
            }
        }, {
            key: "renderGrid", value: function () {
                var t = this.w, e = new _(this.ctx);
                this.elg = e.group({class: "apexcharts-grid"}), this.elgridLinesH = e.group({class: "apexcharts-gridlines-horizontal"}), this.elgridLinesV = e.group({class: "apexcharts-gridlines-vertical"}), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide());
                for (var n, a = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, i = 0; i < t.globals.series.length && (void 0 !== t.globals.yAxisScale[i] && (a = t.globals.yAxisScale[i].result.length - 1), !(a > 2)); i++) ;
                return !t.globals.isBarHorizontal || this.isTimelineBar ? (n = this.xaxisLabels.length, this.isTimelineBar && (a = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (n = t.config.xaxis.tickAmount)), this._drawXYLines({
                    xCount: n,
                    tickAmount: a
                })) : (n = a, a = t.globals.xTickAmount, this._drawInvertedXYLines({
                    xCount: n,
                    tickAmount: a
                })), this.drawGridBands(n, a), {el: this.elg, xAxisTickWidth: t.globals.gridWidth / n}
            }
        }, {
            key: "drawGridBands", value: function (t, e) {
                var n = this.w;
                if (void 0 !== n.config.grid.row.colors && n.config.grid.row.colors.length > 0) for (var a = 0, i = n.globals.gridHeight / e, r = n.globals.gridWidth, o = 0, s = 0; o < e; o++, s++) s >= n.config.grid.row.colors.length && (s = 0), this._drawGridBandRect({
                    c: s,
                    x1: 0,
                    y1: a,
                    x2: r,
                    y2: i,
                    type: "row"
                }), a += n.globals.gridHeight / e;
                if (void 0 !== n.config.grid.column.colors && n.config.grid.column.colors.length > 0) for (var l = n.globals.isBarHorizontal || "category" !== n.config.xaxis.type && !n.config.xaxis.convertedCatToNumeric ? t : t - 1, c = n.globals.padHorizontal, d = n.globals.padHorizontal + n.globals.gridWidth / l, u = n.globals.gridHeight, h = 0, p = 0; h < t; h++, p++) p >= n.config.grid.column.colors.length && (p = 0), this._drawGridBandRect({
                    c: p,
                    x1: c,
                    y1: 0,
                    x2: d,
                    y2: u,
                    type: "column"
                }), c += n.globals.gridWidth / l
            }
        }]), t
    }(), Z = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "niceScale", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                    i = arguments.length > 4 ? arguments[4] : void 0, r = this.w, o = Math.abs(e - t);
                if ("dataPoints" === (n = this._adjustTicksForSmallRange(n, a, o)) && (n = r.globals.dataPoints - 1), t === Number.MIN_VALUE && 0 === e || !b.isNumber(t) && !b.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) {
                    t = 0, e = n;
                    var s = this.linearScale(t, e, n);
                    return s
                }
                t > e ? (console.warn("axis.min cannot be greater than axis.max"), e = t + .1) : t === e && (t = 0 === t ? 0 : t - .5, e = 0 === e ? 2 : e + .5);
                var l = [];
                o < 1 && i && ("candlestick" === r.config.chart.type || "candlestick" === r.config.series[a].type || r.globals.isRangeData) && (e *= 1.01);
                var c = n + 1;
                c < 2 ? c = 2 : c > 2 && (c -= 2);
                var d = o / c, u = Math.floor(b.log10(d)), h = Math.pow(10, u), p = Math.round(d / h);
                p < 1 && (p = 1);
                var f = p * h, g = f * Math.floor(t / f), m = f * Math.ceil(e / f), v = g;
                if (i && o > 2) {
                    for (; l.push(v), !((v += f) > m);) ;
                    return {result: l, niceMin: l[0], niceMax: l[l.length - 1]}
                }
                var y = t;
                (l = []).push(y);
                for (var x = Math.abs(e - t) / n, _ = 0; _ <= n; _++) y += x, l.push(y);
                return l[l.length - 2] >= e && l.pop(), {result: l, niceMin: l[0], niceMax: l[l.length - 1]}
            }
        }, {
            key: "linearScale", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                    a = arguments.length > 3 ? arguments[3] : void 0, i = Math.abs(e - t),
                    r = i / (n = this._adjustTicksForSmallRange(n, a, i));
                n === Number.MAX_VALUE && (n = 10, r = 1);
                for (var o = [], s = t; n >= 0;) o.push(s), s += r, n -= 1;
                return {result: o, niceMin: o[0], niceMax: o[o.length - 1]}
            }
        }, {
            key: "logarithmicScale", value: function (t, e, n, a) {
                (e <= 0 || e === Number.MIN_VALUE) && (e = .01);
                for (var i = Math.log(e) / Math.log(10), r = Math.log(n) / Math.log(10), o = Math.abs(n - e) / a, s = [], l = e; a >= 0;) s.push(l), l += o, a -= 1;
                var c = s.map((function (t, a) {
                    t <= 0 && (t = .01);
                    var o = (r - i) / (n - e), s = Math.pow(10, i + o * (t - i));
                    return Math.round(s / b.roundToBase(s, 10)) * b.roundToBase(s, 10)
                }));
                return 0 === c[0] && (c[0] = 1), {result: c, niceMin: c[0], niceMax: c[c.length - 1]}
            }
        }, {
            key: "_adjustTicksForSmallRange", value: function (t, e, n) {
                var a = t;
                if (void 0 !== e && this.w.config.yaxis[e].labels.formatter) {
                    var i = this.w.config.yaxis[e].labels.formatter(1);
                    b.isNumber(Number(i)) && !b.isFloat(i) && (a = Math.ceil(n))
                }
                return a < t ? a : t
            }
        }, {
            key: "setYScaleForIndex", value: function (t, e, n) {
                var a = this.w.globals, i = this.w.config, r = a.isBarHorizontal ? i.xaxis : i.yaxis[t];
                void 0 === a.yAxisScale[t] && (a.yAxisScale[t] = []);
                var o = Math.abs(n - e);
                if (r.logarithmic && o <= 5 && (a.invalidLogScale = !0), r.logarithmic && o > 5) a.allSeriesCollapsed = !1, a.yAxisScale[t] = this.logarithmicScale(t, e, n, r.tickAmount ? r.tickAmount : Math.floor(Math.log10(n))); else if (n !== -Number.MAX_VALUE && b.isNumber(n)) if (a.allSeriesCollapsed = !1, void 0 === r.min && void 0 === r.max || r.forceNiceScale) {
                    var s = void 0 === i.yaxis[t].max && void 0 === i.yaxis[t].min || i.yaxis[t].forceNiceScale;
                    a.yAxisScale[t] = this.niceScale(e, n, r.tickAmount ? r.tickAmount : o < 5 && o > 1 ? o + 1 : 5, t, s)
                } else a.yAxisScale[t] = this.linearScale(e, n, r.tickAmount, t); else a.yAxisScale[t] = this.linearScale(0, 5, 5)
            }
        }, {
            key: "setXScale", value: function (t, e) {
                var n = this.w, a = n.globals, i = n.config.xaxis, r = Math.abs(e - t);
                return e !== -Number.MAX_VALUE && b.isNumber(e) ? a.xAxisScale = this.niceScale(t, e, i.tickAmount ? i.tickAmount : r < 5 && r > 1 ? r + 1 : 5, 0) : a.xAxisScale = this.linearScale(0, 5, 5), a.xAxisScale
            }
        }, {
            key: "setMultipleYScales", value: function () {
                var t = this, e = this.w.globals, n = this.w.config, a = e.minYArr.concat([]), i = e.maxYArr.concat([]),
                    r = [];
                n.yaxis.forEach((function (e, o) {
                    var s = o;
                    n.series.forEach((function (t, n) {
                        t.name === e.seriesName && (s = n, o !== n ? r.push({
                            index: n,
                            similarIndex: o,
                            alreadyExists: !0
                        }) : r.push({index: n}))
                    }));
                    var l = a[s], c = i[s];
                    t.setYScaleForIndex(o, l, c)
                })), this.sameScaleInMultipleAxes(a, i, r)
            }
        }, {
            key: "sameScaleInMultipleAxes", value: function (t, e, n) {
                var a = this, i = this.w.config, r = this.w.globals, o = [];
                n.forEach((function (t) {
                    t.alreadyExists && (void 0 === o[t.index] && (o[t.index] = []), o[t.index].push(t.index), o[t.index].push(t.similarIndex))
                })), r.yAxisSameScaleIndices = o, o.forEach((function (t, e) {
                    o.forEach((function (n, a) {
                        var i, r;
                        e !== a && (i = t, r = n, i.filter((function (t) {
                            return -1 !== r.indexOf(t)
                        }))).length > 0 && (o[e] = o[e].concat(o[a]))
                    }))
                }));
                var s = o.map((function (t) {
                    return t.filter((function (e, n) {
                        return t.indexOf(e) === n
                    }))
                })).map((function (t) {
                    return t.sort()
                }));
                o = o.filter((function (t) {
                    return !!t
                }));
                var l = s.slice(), c = l.map((function (t) {
                    return JSON.stringify(t)
                }));
                l = l.filter((function (t, e) {
                    return c.indexOf(JSON.stringify(t)) === e
                }));
                var d = [], u = [];
                t.forEach((function (t, n) {
                    l.forEach((function (a, i) {
                        a.indexOf(n) > -1 && (void 0 === d[i] && (d[i] = [], u[i] = []), d[i].push({
                            key: n,
                            value: t
                        }), u[i].push({key: n, value: e[n]}))
                    }))
                }));
                var h = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
                    p = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                d.forEach((function (t, e) {
                    t.forEach((function (t, n) {
                        h[e] = Math.min(t.value, h[e])
                    }))
                })), u.forEach((function (t, e) {
                    t.forEach((function (t, n) {
                        p[e] = Math.max(t.value, p[e])
                    }))
                })), t.forEach((function (t, e) {
                    u.forEach((function (t, n) {
                        var o = h[n], s = p[n];
                        i.chart.stacked && (s = 0, t.forEach((function (t, e) {
                            t.value !== -Number.MAX_VALUE && (s += t.value), o !== Number.MIN_VALUE && (o += d[n][e].value)
                        }))), t.forEach((function (n, l) {
                            t[l].key === e && (void 0 !== i.yaxis[e].min && (o = "function" == typeof i.yaxis[e].min ? i.yaxis[e].min(r.minY) : i.yaxis[e].min), void 0 !== i.yaxis[e].max && (s = "function" == typeof i.yaxis[e].max ? i.yaxis[e].max(r.maxY) : i.yaxis[e].max), a.setYScaleForIndex(e, o, s))
                        }))
                    }))
                }))
            }
        }, {
            key: "autoScaleY", value: function (t, e, n) {
                t || (t = this);
                var a = t.w;
                if (a.globals.isMultipleYAxis || a.globals.collapsedSeries.length) return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e;
                var i = a.globals.seriesX[0], r = a.config.chart.stacked;
                return e.forEach((function (t, o) {
                    for (var s = 0, l = 0; l < i.length; l++) if (i[l] >= n.xaxis.min) {
                        s = l;
                        break
                    }
                    var c, d, u = a.globals.minYArr[o], h = a.globals.maxYArr[o], p = a.globals.stackedSeriesTotals;
                    a.globals.series.forEach((function (o, l) {
                        var f = o[s];
                        r ? (f = p[s], c = d = f, p.forEach((function (t, e) {
                            i[e] <= n.xaxis.max && i[e] >= n.xaxis.min && (t > d && null !== t && (d = t), o[e] < c && null !== o[e] && (c = o[e]))
                        }))) : (c = d = f, o.forEach((function (t, e) {
                            if (i[e] <= n.xaxis.max && i[e] >= n.xaxis.min) {
                                var r = t, o = t;
                                a.globals.series.forEach((function (n, a) {
                                    null !== t && (r = Math.min(n[e], r), o = Math.max(n[e], o))
                                })), o > d && null !== o && (d = o), r < c && null !== r && (c = r)
                            }
                        }))), void 0 === c && void 0 === d && (c = u, d = h), (d *= d < 0 ? .9 : 1.1) < 0 && d < h && (d = h), (c *= c < 0 ? 1.1 : .9) < 0 && c > u && (c = u), e.length > 1 ? (e[l].min = void 0 === t.min ? c : t.min, e[l].max = void 0 === t.max ? d : t.max) : (e[0].min = void 0 === t.min ? c : t.min, e[0].max = void 0 === t.max ? d : t.max)
                    }))
                })), e
            }
        }]), t
    }(), K = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.scales = new Z(e)
        }

        return s(t, [{
            key: "init", value: function () {
                this.setYRange(), this.setXRange(), this.setZRange()
            }
        }, {
            key: "getMinYMaxY", value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = this.w.config,
                    r = this.w.globals, o = -Number.MAX_VALUE, s = Number.MIN_VALUE;
                null === a && (a = t + 1);
                var l = r.series, c = l, d = l;
                "candlestick" === i.chart.type ? (c = r.seriesCandleL, d = r.seriesCandleH) : r.isRangeData && (c = r.seriesRangeStart, d = r.seriesRangeEnd);
                for (var u = t; u < a; u++) {
                    r.dataPoints = Math.max(r.dataPoints, l[u].length);
                    for (var h = 0; h < r.series[u].length; h++) {
                        var p = l[u][h];
                        null !== p && b.isNumber(p) ? (o = Math.max(o, d[u][h]), e = Math.min(e, c[u][h]), n = Math.max(n, c[u][h]), "candlestick" === this.w.config.chart.type && (o = Math.max(o, r.seriesCandleO[u][h]), o = Math.max(o, r.seriesCandleH[u][h]), o = Math.max(o, r.seriesCandleL[u][h]), n = o = Math.max(o, r.seriesCandleC[u][h])), b.isFloat(p) && (p = b.noExponents(p), r.yValueDecimal = Math.max(r.yValueDecimal, p.toString().split(".")[1].length)), s > c[u][h] && c[u][h] < 0 && (s = c[u][h])) : r.hasNullValues = !0
                    }
                }
                return "rangeBar" === i.chart.type && r.seriesRangeStart.length && r.isBarHorizontal && "datetime" === i.xaxis.type && (s = e), "bar" === i.chart.type && (s < 0 && o < 0 && (o = 0), s === Number.MIN_VALUE && (s = 0)), {
                    minY: s,
                    maxY: o,
                    lowestY: e,
                    highestY: n
                }
            }
        }, {
            key: "setYRange", value: function () {
                var t = this.w.globals, e = this.w.config;
                t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
                var n = Number.MAX_VALUE;
                if (t.isMultipleYAxis) for (var a = 0; a < t.series.length; a++) {
                    var i = this.getMinYMaxY(a, n, null, a + 1);
                    t.minYArr.push(i.minY), t.maxYArr.push(i.maxY), n = i.lowestY
                }
                var r = this.getMinYMaxY(0, n, null, t.series.length);
                if (t.minY = r.minY, t.maxY = r.maxY, n = r.lowestY, e.chart.stacked && this._setStackedMinMax(), ("line" === e.chart.type || "area" === e.chart.type || "candlestick" === e.chart.type || "rangeBar" === e.chart.type && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && n !== -Number.MAX_VALUE && n !== t.maxY) {
                    var o = t.maxY - n;
                    n >= 0 && n <= 10 && (o = 0), t.minY = n - 5 * o / 100, n > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * o / 100
                }
                return e.yaxis.forEach((function (e, n) {
                    void 0 !== e.max && ("number" == typeof e.max ? t.maxYArr[n] = e.max : "function" == typeof e.max && (t.maxYArr[n] = e.max(t.maxY)), t.maxY = t.maxYArr[n]), void 0 !== e.min && ("number" == typeof e.min ? t.minYArr[n] = e.min : "function" == typeof e.min && (t.minYArr[n] = e.min(t.minY)), t.minY = t.minYArr[n])
                })), t.isBarHorizontal && ["min", "max"].forEach((function (n) {
                    void 0 !== e.xaxis[n] && "number" == typeof e.xaxis[n] && ("min" === n ? t.minY = e.xaxis[n] : t.maxY = e.xaxis[n])
                })), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = n, t.yAxisScale.forEach((function (e, n) {
                    t.minYArr[n] = e.niceMin, t.maxYArr[n] = e.niceMax
                }))) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
                    minY: t.minY,
                    maxY: t.maxY,
                    minYArr: t.minYArr,
                    maxYArr: t.maxYArr
                }
            }
        }, {
            key: "setXRange", value: function () {
                var t = this.w.globals, e = this.w.config,
                    n = "numeric" === e.xaxis.type || "datetime" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;
                if (t.isXNumeric && function () {
                    for (var e = 0; e < t.series.length; e++) if (t.labels[e]) for (var n = 0; n < t.labels[e].length; n++) null !== t.labels[e][n] && b.isNumber(t.labels[e][n]) && (t.maxX = Math.max(t.maxX, t.labels[e][n]), t.initialMaxX = Math.max(t.maxX, t.labels[e][n]), t.minX = Math.min(t.minX, t.labels[e][n]), t.initialMinX = Math.min(t.minX, t.labels[e][n]))
                }(), t.noLabelsProvided && 0 === e.xaxis.categories.length && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
                    var a;
                    if (void 0 === e.xaxis.tickAmount ? (a = Math.round(t.svgWidth / 150), "numeric" === e.xaxis.type && t.dataPoints < 30 && (a = t.dataPoints - 1), a > t.dataPoints && 0 !== t.dataPoints && (a = t.dataPoints - 1)) : "dataPoints" === e.xaxis.tickAmount ? (t.series.length > 1 && (a = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (a = t.maxX - t.minX - 1)) : a = e.xaxis.tickAmount, t.xTickAmount = a, void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE) if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
                        for (var i = [], r = t.minX - 1; r < t.maxX; r++) i.push(r + 1);
                        t.xAxisScale = {result: i, niceMin: i[0], niceMax: i[i.length - 1]}
                    } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX); else t.xAxisScale = this.scales.linearScale(1, a, a), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, a - 1), t.seriesX = t.labels.slice());
                    n && (t.labels = t.xAxisScale.result.slice())
                }
                return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
                    minX: t.minX,
                    maxX: t.maxX
                }
            }
        }, {
            key: "setZRange", value: function () {
                var t = this.w.globals;
                if (t.isDataXYZ) for (var e = 0; e < t.series.length; e++) if (void 0 !== t.seriesZ[e]) for (var n = 0; n < t.seriesZ[e].length; n++) null !== t.seriesZ[e][n] && b.isNumber(t.seriesZ[e][n]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][n]), t.minZ = Math.min(t.minZ, t.seriesZ[e][n]))
            }
        }, {
            key: "_handleSingleDataPoint", value: function () {
                var t = this.w.globals, e = this.w.config;
                if (t.minX === t.maxX) {
                    var n = new F(this.ctx);
                    if ("datetime" === e.xaxis.type) {
                        var a = n.getDate(t.minX);
                        a.setUTCDate(a.getDate() - 2), t.minX = new Date(a).getTime();
                        var i = n.getDate(t.maxX);
                        i.setUTCDate(i.getDate() + 2), t.maxX = new Date(i).getTime()
                    } else ("numeric" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX)
                }
            }
        }, {
            key: "_getMinXDiff", value: function () {
                var t = this.w.globals;
                t.isXNumeric && t.seriesX.forEach((function (e, n) {
                    1 === e.length && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
                    var a = e.slice();
                    a.sort((function (t, e) {
                        return t - e
                    })), a.forEach((function (e, a) {
                        if (a > 0) {
                            var i = e - t.seriesX[n][a - 1];
                            i > 0 && (t.minXDiff = Math.min(i, t.minXDiff))
                        }
                    })), 1 === t.dataPoints && t.minXDiff === Number.MAX_VALUE && (t.minXDiff = .5)
                }))
            }
        }, {
            key: "_setStackedMinMax", value: function () {
                var t = this.w.globals, e = [], n = [];
                if (t.series.length) for (var a = 0; a < t.series[t.maxValsInArrayIndex].length; a++) for (var i = 0, r = 0, o = 0; o < t.series.length; o++) null !== t.series[o][a] && b.isNumber(t.series[o][a]) && (t.series[o][a] > 0 ? i = i + parseFloat(t.series[o][a]) + 1e-4 : r += parseFloat(t.series[o][a])), o === t.series.length - 1 && (e.push(i), n.push(r));
                for (var s = 0; s < e.length; s++) t.maxY = Math.max(t.maxY, e[s]), t.minY = Math.min(t.minY, n[s])
            }
        }]), t
    }(), Q = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w;
            var n = this.w;
            this.xaxisFontSize = n.config.xaxis.labels.style.fontSize, this.axisFontFamily = n.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = n.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === n.config.chart.type && n.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === n.config.xaxis.position && (this.xAxisoffX = n.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new Y(e)
        }

        return s(t, [{
            key: "drawYaxis", value: function (t) {
                var e = this, n = this.w, a = new _(this.ctx), i = n.config.yaxis[t].labels.style, r = i.fontSize,
                    o = i.fontFamily, s = i.fontWeight, l = a.group({
                        class: "apexcharts-yaxis",
                        rel: t,
                        transform: "translate(" + n.globals.translateYAxisX[t] + ", 0)"
                    });
                if (this.axesUtils.isYAxisHidden(t)) return l;
                var c = a.group({class: "apexcharts-yaxis-texts-g"});
                l.add(c);
                var d = n.globals.yAxisScale[t].result.length - 1, u = n.globals.gridHeight / d,
                    h = n.globals.translateY, p = n.globals.yLabelFormatters[t],
                    f = n.globals.yAxisScale[t].result.slice();
                f = this.axesUtils.checkForReversedLabels(t, f);
                var g = "";
                if (n.config.yaxis[t].labels.show) for (var m = function (l) {
                    var m = f[l];
                    m = p(m, l);
                    var v = n.config.yaxis[t].labels.padding;
                    n.config.yaxis[t].opposite && 0 !== n.config.yaxis.length && (v *= -1);
                    var b = e.axesUtils.getYAxisForeColor(i.colors, t), y = a.drawText({
                        x: v,
                        y: h + d / 10 + n.config.yaxis[t].labels.offsetY + 1,
                        text: m,
                        textAnchor: n.config.yaxis[t].opposite ? "start" : "end",
                        fontSize: r,
                        fontFamily: o,
                        fontWeight: s,
                        foreColor: Array.isArray(b) ? b[l] : b,
                        isPlainText: !1,
                        cssClass: "apexcharts-yaxis-label " + i.cssClass
                    });
                    if (l === d && (g = y), c.add(y), 0 !== n.config.yaxis[t].labels.rotate) {
                        var x = a.rotateAroundCenter(g.node), _ = a.rotateAroundCenter(y.node);
                        y.node.setAttribute("transform", "rotate(".concat(n.config.yaxis[t].labels.rotate, " ").concat(x.x, " ").concat(_.y, ")"))
                    }
                    h += u
                }, v = d; v >= 0; v--) m(v);
                if (void 0 !== n.config.yaxis[t].title.text) {
                    var b = a.group({class: "apexcharts-yaxis-title"}), y = 0;
                    n.config.yaxis[t].opposite && (y = n.globals.translateYAxisX[t]);
                    var x = a.drawText({
                        x: y,
                        y: n.globals.gridHeight / 2 + n.globals.translateY + n.config.yaxis[t].title.offsetY,
                        text: n.config.yaxis[t].title.text,
                        textAnchor: "end",
                        foreColor: n.config.yaxis[t].title.style.color,
                        fontSize: n.config.yaxis[t].title.style.fontSize,
                        fontWeight: n.config.yaxis[t].title.style.fontWeight,
                        fontFamily: n.config.yaxis[t].title.style.fontFamily,
                        cssClass: "apexcharts-yaxis-title-text " + n.config.yaxis[t].title.style.cssClass
                    });
                    b.add(x), l.add(b)
                }
                var w = n.config.yaxis[t].axisBorder, S = 31 + w.offsetX;
                if (n.config.yaxis[t].opposite && (S = -31 - w.offsetX), w.show) {
                    var C = a.drawLine(S, n.globals.translateY + w.offsetY - 2, S, n.globals.gridHeight + n.globals.translateY + w.offsetY + 2, w.color, 0, w.width);
                    l.add(C)
                }
                return n.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(S, d, w, n.config.yaxis[t].axisTicks, t, u, l), l
            }
        }, {
            key: "drawYaxisInversed", value: function (t) {
                var e = this.w, n = new _(this.ctx), a = n.group({class: "apexcharts-xaxis apexcharts-yaxis-inversed"}),
                    i = n.group({
                        class: "apexcharts-xaxis-texts-g",
                        transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
                    });
                a.add(i);
                var r = e.globals.yAxisScale[t].result.length - 1, o = e.globals.gridWidth / r + .1,
                    s = o + e.config.xaxis.labels.offsetX, l = e.globals.xLabelFormatter,
                    c = e.globals.yAxisScale[t].result.slice(), d = e.globals.timescaleLabels;
                d.length > 0 && (this.xaxisLabels = d.slice(), r = (c = d.slice()).length), c = this.axesUtils.checkForReversedLabels(t, c);
                var u = d.length;
                if (e.config.xaxis.labels.show) for (var h = u ? 0 : r; u ? h < u : h >= 0; u ? h++ : h--) {
                    var p = c[h];
                    p = l(p, h);
                    var f = e.globals.gridWidth + e.globals.padHorizontal - (s - o + e.config.xaxis.labels.offsetX);
                    if (d.length) {
                        var g = this.axesUtils.getLabel(c, d, f, h, this.drawnLabels, this.xaxisFontSize);
                        f = g.x, p = g.text, this.drawnLabels.push(g.text), 0 === h && e.globals.skipFirstTimelinelabel && (p = ""), h === c.length - 1 && e.globals.skipLastTimelinelabel && (p = "")
                    }
                    var m = n.drawText({
                        x: f,
                        y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30 - ("top" === e.config.xaxis.position ? e.globals.xAxisHeight + e.config.xaxis.axisTicks.height - 2 : 0),
                        text: p,
                        textAnchor: "middle",
                        foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors,
                        fontSize: this.xaxisFontSize,
                        fontFamily: this.xaxisFontFamily,
                        fontWeight: e.config.xaxis.labels.style.fontWeight,
                        isPlainText: !1,
                        cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass
                    });
                    i.add(m), m.tspan(p);
                    var v = document.createElementNS(e.globals.SVGNS, "title");
                    v.textContent = p, m.node.appendChild(v), s += o
                }
                return this.inversedYAxisTitleText(a), this.inversedYAxisBorder(a), a
            }
        }, {
            key: "inversedYAxisBorder", value: function (t) {
                var e = this.w, n = new _(this.ctx), a = e.config.xaxis.axisBorder;
                if (a.show) {
                    var i = 0;
                    "bar" === e.config.chart.type && e.globals.isXNumeric && (i -= 15);
                    var r = n.drawLine(e.globals.padHorizontal + i + a.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height);
                    t.add(r)
                }
            }
        }, {
            key: "inversedYAxisTitleText", value: function (t) {
                var e = this.w, n = new _(this.ctx);
                if (void 0 !== e.config.xaxis.title.text) {
                    var a = n.group({class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"}), i = n.drawText({
                        x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                        y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + e.config.xaxis.title.offsetY + 20,
                        text: e.config.xaxis.title.text,
                        textAnchor: "middle",
                        fontSize: e.config.xaxis.title.style.fontSize,
                        fontFamily: e.config.xaxis.title.style.fontFamily,
                        fontWeight: e.config.xaxis.title.style.fontWeight,
                        foreColor: e.config.xaxis.title.style.color,
                        cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
                    });
                    a.add(i), t.add(a)
                }
            }
        }, {
            key: "yAxisTitleRotate", value: function (t, e) {
                var n = this.w, a = new _(this.ctx), i = {width: 0, height: 0}, r = {width: 0, height: 0},
                    o = n.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
                null !== o && (i = o.getBoundingClientRect());
                var s = n.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));
                if (null !== s && (r = s.getBoundingClientRect()), null !== s) {
                    var l = this.xPaddingForYAxisTitle(t, i, r, e);
                    s.setAttribute("x", l.xPos - (e ? 10 : 0))
                }
                if (null !== s) {
                    var c = a.rotateAroundCenter(s);
                    s.setAttribute("transform", "rotate(".concat(e ? -1 * n.config.yaxis[t].title.rotate : n.config.yaxis[t].title.rotate, " ").concat(c.x, " ").concat(c.y, ")"))
                }
            }
        }, {
            key: "xPaddingForYAxisTitle", value: function (t, e, n, a) {
                var i = this.w, r = 0, o = 0, s = 10;
                return void 0 === i.config.yaxis[t].title.text || t < 0 ? {
                    xPos: o,
                    padd: 0
                } : (a ? (o = e.width + i.config.yaxis[t].title.offsetX + n.width / 2 + s / 2, 0 === (r += 1) && (o -= s / 2)) : (o = -1 * e.width + i.config.yaxis[t].title.offsetX + s / 2 + n.width / 2, i.globals.isBarHorizontal && (s = 25, o = -1 * e.width - i.config.yaxis[t].title.offsetX - s)), {
                    xPos: o,
                    padd: s
                })
            }
        }, {
            key: "setYAxisXPosition", value: function (t, e) {
                var n = this.w, a = 0, i = 0, r = 18, o = 1;
                n.config.yaxis.length > 1 && (this.multipleYs = !0), n.config.yaxis.map((function (s, l) {
                    var c = n.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !s.show || s.floating || 0 === t[l].width,
                        d = t[l].width + e[l].width;
                    s.opposite ? n.globals.isBarHorizontal ? (i = n.globals.gridWidth + n.globals.translateX - 1, n.globals.translateYAxisX[l] = i - s.labels.offsetX) : (i = n.globals.gridWidth + n.globals.translateX + o, c || (o = o + d + 20), n.globals.translateYAxisX[l] = i - s.labels.offsetX + 20) : (a = n.globals.translateX - r, c || (r = r + d + 20), n.globals.translateYAxisX[l] = a + s.labels.offsetX)
                }))
            }
        }, {
            key: "setYAxisTextAlignments", value: function () {
                var t = this.w, e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                (e = b.listToArray(e)).forEach((function (e, n) {
                    var a = t.config.yaxis[n];
                    if (a && void 0 !== a.labels.align) {
                        var i = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(n, "'] .apexcharts-yaxis-texts-g")),
                            r = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(n, "'] .apexcharts-yaxis-label"));
                        r = b.listToArray(r);
                        var o = i.getBoundingClientRect();
                        "left" === a.labels.align ? (r.forEach((function (t, e) {
                            t.setAttribute("text-anchor", "start")
                        })), a.opposite || i.setAttribute("transform", "translate(-".concat(o.width, ", 0)"))) : "center" === a.labels.align ? (r.forEach((function (t, e) {
                            t.setAttribute("text-anchor", "middle")
                        })), i.setAttribute("transform", "translate(".concat(o.width / 2 * (a.opposite ? 1 : -1), ", 0)"))) : "right" === a.labels.align && (r.forEach((function (t, e) {
                            t.setAttribute("text-anchor", "end")
                        })), a.opposite && i.setAttribute("transform", "translate(".concat(o.width, ", 0)")))
                    }
                }))
            }
        }]), t
    }(), J = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.documentEvent = b.bind(this.documentEvent, this)
        }

        return s(t, [{
            key: "addEventListener", value: function (t, e) {
                var n = this.w;
                n.globals.events.hasOwnProperty(t) ? n.globals.events[t].push(e) : n.globals.events[t] = [e]
            }
        }, {
            key: "removeEventListener", value: function (t, e) {
                var n = this.w;
                if (n.globals.events.hasOwnProperty(t)) {
                    var a = n.globals.events[t].indexOf(e);
                    -1 !== a && n.globals.events[t].splice(a, 1)
                }
            }
        }, {
            key: "fireEvent", value: function (t, e) {
                var n = this.w;
                if (n.globals.events.hasOwnProperty(t)) {
                    e && e.length || (e = []);
                    for (var a = n.globals.events[t], i = a.length, r = 0; r < i; r++) a[r].apply(null, e)
                }
            }
        }, {
            key: "setupEventHandlers", value: function () {
                var t = this, e = this.w, n = this.ctx, a = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
                this.ctx.eventList.forEach((function (t) {
                    a.addEventListener(t, (function (t) {
                        var a = Object.assign({}, e, {
                            seriesIndex: e.globals.capturedSeriesIndex,
                            dataPointIndex: e.globals.capturedDataPointIndex
                        });
                        "mousemove" === t.type || "touchmove" === t.type ? "function" == typeof e.config.chart.events.mouseMove && e.config.chart.events.mouseMove(t, n, a) : ("mouseup" === t.type && 1 === t.which || "touchend" === t.type) && ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(t, n, a), n.ctx.events.fireEvent("click", [t, n, a]))
                    }), {capture: !1, passive: !0})
                })), this.ctx.eventList.forEach((function (n) {
                    e.globals.dom.baseEl.addEventListener(n, t.documentEvent)
                })), this.ctx.core.setupBrushHandler()
            }
        }, {
            key: "documentEvent", value: function (t) {
                var e = this.w, n = t.target.className;
                if ("click" === t.type) {
                    var a = e.globals.dom.baseEl.querySelector(".apexcharts-menu");
                    a && a.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== n && a.classList.remove("apexcharts-menu-open")
                }
                e.globals.clientX = "touchmove" === t.type ? t.touches[0].clientX : t.clientX, e.globals.clientY = "touchmove" === t.type ? t.touches[0].clientY : t.clientY
            }
        }]), t
    }(), tt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "setCurrentLocaleValues", value: function (t) {
                var e = this.w.config.chart.locales;
                window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                var n = e.filter((function (e) {
                    return e.name === t
                }))[0];
                if (!n) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                var a = b.extend(T, n);
                this.w.globals.locale = a.options
            }
        }]), t
    }(), et = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "drawAxis", value: function (t, e) {
                var n, a, i = this.w.globals, r = this.w.config, o = new G(this.ctx), s = new Q(this.ctx);
                i.axisCharts && "radar" !== t && (i.isBarHorizontal ? (a = s.drawYaxisInversed(0), n = o.drawXaxisInversed(0), i.dom.elGraphical.add(n), i.dom.elGraphical.add(a)) : (n = o.drawXaxis(), i.dom.elGraphical.add(n), r.yaxis.map((function (t, e) {
                    -1 === i.ignoreYAxisIndexes.indexOf(e) && (a = s.drawYaxis(e), i.dom.Paper.add(a))
                })))), r.yaxis.map((function (t, e) {
                    -1 === i.ignoreYAxisIndexes.indexOf(e) && s.yAxisTitleRotate(e, t.opposite)
                }))
            }
        }]), t
    }(), nt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "drawXCrosshairs", value: function () {
                var t = this.w, e = new _(this.ctx), n = new y(this.ctx), a = t.config.xaxis.crosshairs.fill.gradient,
                    i = t.config.xaxis.crosshairs.dropShadow, r = t.config.xaxis.crosshairs.fill.type, o = a.colorFrom,
                    s = a.colorTo, l = a.opacityFrom, c = a.opacityTo, d = a.stops, u = i.enabled, h = i.left,
                    p = i.top, f = i.blur, g = i.color, m = i.opacity, v = t.config.xaxis.crosshairs.fill.color;
                if (t.config.xaxis.crosshairs.show) {
                    "gradient" === r && (v = e.drawGradient("vertical", o, s, l, c, null, d, null));
                    var x = e.drawRect();
                    1 === t.config.xaxis.crosshairs.width && (x = e.drawLine()), x.attr({
                        class: "apexcharts-xcrosshairs",
                        x: 0,
                        y: 0,
                        y2: t.globals.gridHeight,
                        width: b.isNumber(t.config.xaxis.crosshairs.width) ? t.config.xaxis.crosshairs.width : 0,
                        height: t.globals.gridHeight,
                        fill: v,
                        filter: "none",
                        "fill-opacity": t.config.xaxis.crosshairs.opacity,
                        stroke: t.config.xaxis.crosshairs.stroke.color,
                        "stroke-width": t.config.xaxis.crosshairs.stroke.width,
                        "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray
                    }), u && (x = n.dropShadow(x, {
                        left: h,
                        top: p,
                        blur: f,
                        color: g,
                        opacity: m
                    })), t.globals.dom.elGraphical.add(x)
                }
            }
        }, {
            key: "drawYCrosshairs", value: function () {
                var t = this.w, e = new _(this.ctx), n = t.config.yaxis[0].crosshairs,
                    a = t.globals.barPadForNumericAxis;
                if (t.config.yaxis[0].crosshairs.show) {
                    var i = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, n.stroke.color, n.stroke.dashArray, n.stroke.width);
                    i.attr({class: "apexcharts-ycrosshairs"}), t.globals.dom.elGraphical.add(i)
                }
                var r = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, n.stroke.color, 0, 0);
                r.attr({class: "apexcharts-ycrosshairs-hidden"}), t.globals.dom.elGraphical.add(r)
            }
        }]), t
    }(), at = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "checkResponsiveConfig", value: function (t) {
                var e = this, n = this.w, a = n.config;
                if (0 !== a.responsive.length) {
                    var i = a.responsive.slice();
                    i.sort((function (t, e) {
                        return t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0
                    })).reverse();
                    var r = new q({}), o = function () {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                            a = i[0].breakpoint, o = window.innerWidth > 0 ? window.innerWidth : screen.width;
                        if (o > a) {
                            var s = C.extendArrayProps(r, n.globals.initialConfig, n);
                            t = b.extend(s, t), t = b.extend(n.config, t), e.overrideResponsiveOptions(t)
                        } else for (var l = 0; l < i.length; l++) o < i[l].breakpoint && (t = C.extendArrayProps(r, i[l].options, n), t = b.extend(n.config, t), e.overrideResponsiveOptions(t))
                    };
                    if (t) {
                        var s = C.extendArrayProps(r, t, n);
                        s = b.extend(n.config, s), o(s = b.extend(s, t))
                    } else o({})
                }
            }
        }, {
            key: "overrideResponsiveOptions", value: function (t) {
                var e = new q(t).init({responsiveOverride: !0});
                this.w.config = e
            }
        }]), t
    }(), it = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.colors = [], this.w = e.w;
            var n = this.w;
            this.isColorFn = !1, this.isHeatmapDistributed = "treemap" === n.config.chart.type && n.config.plotOptions.treemap.distributed || "heatmap" === n.config.chart.type && n.config.plotOptions.heatmap.distributed, this.isBarDistributed = n.config.plotOptions.bar.distributed && ("bar" === n.config.chart.type || "rangeBar" === n.config.chart.type)
        }

        return s(t, [{
            key: "init", value: function () {
                this.setDefaultColors()
            }
        }, {
            key: "setDefaultColors", value: function () {
                var t = this, e = this.w, n = new b;
                if (e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode)), void 0 === e.config.colors ? e.globals.colors = this.predefined() : (e.globals.colors = e.config.colors, Array.isArray(e.config.colors) && e.config.colors.length > 0 && "function" == typeof e.config.colors[0] && (e.globals.colors = e.config.series.map((function (n, a) {
                    var i = e.config.colors[a];
                    return i || (i = e.config.colors[0]), "function" == typeof i ? (t.isColorFn = !0, i({
                        value: e.globals.axisCharts ? e.globals.series[a][0] ? e.globals.series[a][0] : 0 : e.globals.series[a],
                        seriesIndex: a,
                        dataPointIndex: a,
                        w: e
                    })) : i
                })))), e.globals.seriesColors.map((function (t, n) {
                    t && (e.globals.colors[n] = t)
                })), e.config.theme.monochrome.enabled) {
                    var a = [], i = e.globals.series.length;
                    (this.isBarDistributed || this.isHeatmapDistributed) && (i = e.globals.series[0].length * e.globals.series.length);
                    for (var r = e.config.theme.monochrome.color, o = 1 / (i / e.config.theme.monochrome.shadeIntensity), s = e.config.theme.monochrome.shadeTo, l = 0, c = 0; c < i; c++) {
                        var d = void 0;
                        "dark" === s ? (d = n.shadeColor(-1 * l, r), l += o) : (d = n.shadeColor(l, r), l += o), a.push(d)
                    }
                    e.globals.colors = a.slice()
                }
                var u = e.globals.colors.slice();
                this.pushExtraColors(e.globals.colors), ["fill", "stroke"].forEach((function (n) {
                    void 0 === e.config[n].colors ? e.globals[n].colors = t.isColorFn ? e.config.colors : u : e.globals[n].colors = e.config[n].colors.slice(), t.pushExtraColors(e.globals[n].colors)
                })), void 0 === e.config.dataLabels.style.colors ? e.globals.dataLabels.style.colors = u : e.globals.dataLabels.style.colors = e.config.dataLabels.style.colors.slice(), this.pushExtraColors(e.globals.dataLabels.style.colors, 50), void 0 === e.config.plotOptions.radar.polygons.fill.colors ? e.globals.radarPolygons.fill.colors = ["dark" === e.config.theme.mode ? "#424242" : "#fff"] : e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20), void 0 === e.config.markers.colors ? e.globals.markers.colors = u : e.globals.markers.colors = e.config.markers.colors.slice(), this.pushExtraColors(e.globals.markers.colors)
            }
        }, {
            key: "pushExtraColors", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a = this.w,
                    i = e || a.globals.series.length;
                if (null === n && (n = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a.config.chart.type && a.config.plotOptions.heatmap.colorScale.inverse), n && a.globals.series.length && (i = a.globals.series[a.globals.maxValsInArrayIndex].length * a.globals.series.length), t.length < i) for (var r = i - t.length, o = 0; o < r; o++) t.push(t[o])
            }
        }, {
            key: "updateThemeOptions", value: function (t) {
                t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
                var e = t.theme.mode || "light",
                    n = t.theme.palette ? t.theme.palette : "dark" === e ? "palette4" : "palette1",
                    a = t.chart.foreColor ? t.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
                return t.tooltip.theme = e, t.chart.foreColor = a, t.theme.palette = n, t
            }
        }, {
            key: "predefined", value: function () {
                switch (this.w.config.theme.palette) {
                    case"palette1":
                        this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                        break;
                    case"palette2":
                        this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                        break;
                    case"palette3":
                        this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                        break;
                    case"palette4":
                        this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                        break;
                    case"palette5":
                        this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                        break;
                    case"palette6":
                        this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                        break;
                    case"palette7":
                        this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                        break;
                    case"palette8":
                        this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                        break;
                    case"palette9":
                        this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                        break;
                    case"palette10":
                        this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"];
                        break;
                    default:
                        this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"]
                }
                return this.colors
            }
        }]), t
    }(), rt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "draw", value: function () {
                this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle")
            }
        }, {
            key: "drawTitleSubtitle", value: function (t) {
                var e = this.w, n = "title" === t ? e.config.title : e.config.subtitle, a = e.globals.svgWidth / 2,
                    i = n.offsetY, r = "middle";
                if ("left" === n.align ? (a = 10, r = "start") : "right" === n.align && (a = e.globals.svgWidth - 10, r = "end"), a += n.offsetX, i = i + parseInt(n.style.fontSize, 10) + n.margin / 2, void 0 !== n.text) {
                    var o = new _(this.ctx).drawText({
                        x: a,
                        y: i,
                        text: n.text,
                        textAnchor: r,
                        fontSize: n.style.fontSize,
                        fontFamily: n.style.fontFamily,
                        fontWeight: n.style.fontWeight,
                        foreColor: n.style.color,
                        opacity: 1
                    });
                    o.node.setAttribute("class", "apexcharts-".concat(t, "-text")), e.globals.dom.Paper.add(o)
                }
            }
        }]), t
    }(), ot = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.dCtx = e
        }

        return s(t, [{
            key: "getTitleSubtitleCoords", value: function (t) {
                var e = this.w, n = 0, a = 0, i = "title" === t ? e.config.title.floating : e.config.subtitle.floating,
                    r = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
                if (null !== r && !i) {
                    var o = r.getBoundingClientRect();
                    n = o.width, a = e.globals.axisCharts ? o.height + 5 : o.height
                }
                return {width: n, height: a}
            }
        }, {
            key: "getLegendsRect", value: function () {
                var t = this.w, e = t.globals.dom.baseEl.querySelector(".apexcharts-legend");
                t.config.legend.height || "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || (e.style.maxHeight = t.globals.svgHeight / 2 + "px");
                var n = Object.assign({}, b.getBoundingClientRect(e));
                return null !== e && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = {
                    x: n.x,
                    y: n.y,
                    height: n.height,
                    width: 0 === n.height ? 0 : n.width
                } : this.dCtx.lgRect = {
                    x: 0,
                    y: 0,
                    height: 0,
                    width: 0
                }, "left" !== t.config.legend.position && "right" !== t.config.legend.position || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect
            }
        }, {
            key: "getLargestStringFromMultiArr", value: function (t, e) {
                var n = t;
                if (this.w.globals.isMultiLineX) {
                    var a = e.map((function (t, e) {
                        return Array.isArray(t) ? t.length : 1
                    })), i = Math.max.apply(Math, m(a));
                    n = e[a.indexOf(i)]
                }
                return n
            }
        }]), t
    }(), st = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.dCtx = e
        }

        return s(t, [{
            key: "getxAxisLabelsCoords", value: function () {
                var t, e = this.w, n = e.globals.labels.slice();
                if (e.config.xaxis.convertedCatToNumeric && 0 === n.length && (n = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) {
                    var a = this.getxAxisTimeScaleLabelsCoords();
                    t = {width: a.width, height: a.height}, e.globals.rotateXLabels = !1
                } else {
                    this.dCtx.lgWidthForSideLegends = "left" !== e.config.legend.position && "right" !== e.config.legend.position || e.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                    var i = e.globals.xLabelFormatter, r = b.getLargestStringFromArr(n),
                        o = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r, n);
                    e.globals.isBarHorizontal && (o = r = e.globals.yAxisScale[0].result.reduce((function (t, e) {
                        return t.length > e.length ? t : e
                    }), 0));
                    var s = new $(this.dCtx.ctx), l = r;
                    r = s.xLabelFormat(i, r, l, {
                        i: void 0,
                        dateFormatter: new F(this.dCtx.ctx).formatDate,
                        w: e
                    }), o = s.xLabelFormat(i, o, l, {
                        i: void 0,
                        dateFormatter: new F(this.dCtx.ctx).formatDate,
                        w: e
                    }), (e.config.xaxis.convertedCatToNumeric && void 0 === r || "" === String(r).trim()) && (o = r = "1");
                    var c = new _(this.dCtx.ctx), d = c.getTextRects(r, e.config.xaxis.labels.style.fontSize), u = d;
                    if (r !== o && (u = c.getTextRects(o, e.config.xaxis.labels.style.fontSize)), (t = {
                        width: d.width >= u.width ? d.width : u.width,
                        height: d.height >= u.height ? d.height : u.height
                    }).width * n.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e.config.xaxis.labels.rotate || e.config.xaxis.labels.rotateAlways) {
                        if (!e.globals.isBarHorizontal) {
                            e.globals.rotateXLabels = !0;
                            var h = function (t) {
                                return c.getTextRects(t, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"), !1)
                            };
                            d = h(r), r !== o && (u = h(o)), t.height = (d.height > u.height ? d.height : u.height) / 1.5, t.width = d.width > u.width ? d.width : u.width
                        }
                    } else e.globals.rotateXLabels = !1
                }
                return e.config.xaxis.labels.show || (t = {width: 0, height: 0}), {width: t.width, height: t.height}
            }
        }, {
            key: "getxAxisTitleCoords", value: function () {
                var t = this.w, e = 0, n = 0;
                if (void 0 !== t.config.xaxis.title.text) {
                    var a = new _(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
                    e = a.width, n = a.height
                }
                return {width: e, height: n}
            }
        }, {
            key: "getxAxisTimeScaleLabelsCoords", value: function () {
                var t, e = this.w;
                this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
                var n = this.dCtx.timescaleLabels.map((function (t) {
                    return t.value
                })), a = n.reduce((function (t, e) {
                    return void 0 === t ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t.length > e.length ? t : e
                }), 0);
                return 1.05 * (t = new _(this.dCtx.ctx).getTextRects(a, e.config.xaxis.labels.style.fontSize)).width * n.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = !0), t
            }
        }, {
            key: "additionalPaddingXLabels", value: function (t) {
                var e = this, n = this.w, a = n.globals, i = n.config, r = i.xaxis.type, o = t.width;
                a.skipLastTimelinelabel = !1, a.skipFirstTimelinelabel = !1;
                var s = n.config.yaxis[0].opposite && n.globals.isBarHorizontal, l = function (t, i) {
                    (function (t) {
                        return -1 !== a.collapsedSeriesIndices.indexOf(t)
                    })(i) || function (t) {
                        if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) {
                            var i = e.dCtx.timescaleLabels[0],
                                s = e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + o / 1.75 - e.dCtx.yAxisWidthRight,
                                l = i.position - o / 1.75 + e.dCtx.yAxisWidthLeft;
                            s > a.svgWidth - a.translateX && (a.skipLastTimelinelabel = !0), l < 0 && (a.skipFirstTimelinelabel = !0)
                        } else "datetime" === r ? e.dCtx.gridPad.right < o && !a.rotateXLabels && (a.skipLastTimelinelabel = !0) : "datetime" !== r && e.dCtx.gridPad.right < o / 2 - e.dCtx.yAxisWidthRight && !a.rotateXLabels && ("between" !== n.config.xaxis.tickPlacement || n.globals.isBarHorizontal) && (e.dCtx.xPadRight = o / 2 + 1)
                    }()
                };
                i.yaxis.forEach((function (t, n) {
                    s ? (e.dCtx.gridPad.left < o && (e.dCtx.xPadLeft = o / 2 + 1), e.dCtx.xPadRight = o / 2 + 1) : l(0, n)
                }))
            }
        }]), t
    }(), lt = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.dCtx = e
        }

        return s(t, [{
            key: "getyAxisLabelsCoords", value: function () {
                var t = this, e = this.w, n = [], a = 10, i = new Y(this.dCtx.ctx);
                return e.config.yaxis.map((function (r, o) {
                    var s = e.globals.yAxisScale[o];
                    if (!i.isYAxisHidden(o) && r.labels.show && s.result.length) {
                        var l = e.globals.yLabelFormatters[o],
                            c = String(s.niceMin).length > String(s.niceMax).length ? s.niceMin : s.niceMax,
                            d = l(c, {seriesIndex: o, dataPointIndex: -1, w: e}), u = d;
                        if (void 0 !== d && 0 !== d.length || (d = c), e.globals.isBarHorizontal) {
                            a = 0;
                            var h = e.globals.labels.slice();
                            d = l(d = b.getLargestStringFromArr(h), {
                                seriesIndex: o,
                                dataPointIndex: -1,
                                w: e
                            }), u = t.dCtx.dimHelpers.getLargestStringFromMultiArr(d, h)
                        }
                        var p = new _(t.dCtx.ctx), f = p.getTextRects(d, r.labels.style.fontSize), g = f;
                        d !== u && (g = p.getTextRects(u, r.labels.style.fontSize)), n.push({
                            width: (g.width > f.width ? g.width : f.width) + a,
                            height: g.height > f.height ? g.height : f.height
                        })
                    } else n.push({width: 0, height: 0})
                })), n
            }
        }, {
            key: "getyAxisTitleCoords", value: function () {
                var t = this, e = this.w, n = [];
                return e.config.yaxis.map((function (e, a) {
                    if (e.show && void 0 !== e.title.text) {
                        var i = new _(t.dCtx.ctx).getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, "rotate(-90 0 0)", !1);
                        n.push({width: i.width, height: i.height})
                    } else n.push({width: 0, height: 0})
                })), n
            }
        }, {
            key: "getTotalYAxisWidth", value: function () {
                var t = this.w, e = 0, n = 0, a = 0, i = t.globals.yAxisScale.length > 1 ? 10 : 0,
                    r = new Y(this.dCtx.ctx), o = function (o, s) {
                        var l = t.config.yaxis[s].floating, c = 0;
                        o.width > 0 && !l ? (c = o.width + i, function (e) {
                            return t.globals.ignoreYAxisIndexes.indexOf(e) > -1
                        }(s) && (c = c - o.width - i)) : c = l || r.isYAxisHidden(s) ? 0 : 5, t.config.yaxis[s].opposite ? a += c : n += c, e += c
                    };
                return t.globals.yLabelsCoords.map((function (t, e) {
                    o(t, e)
                })), t.globals.yTitleCoords.map((function (t, e) {
                    o(t, e)
                })), t.globals.isBarHorizontal && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = n, this.dCtx.yAxisWidthRight = a, e
            }
        }]), t
    }(), ct = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.dCtx = e
        }

        return s(t, [{
            key: "gridPadForColumnsInNumericAxis", value: function (t) {
                var e = this.w;
                if (e.globals.noData || e.globals.allSeriesCollapsed) return 0;
                var n = e.config.chart.type, a = 0, i = "bar" === n || "rangeBar" === n ? e.config.series.length : 1;
                if (e.globals.comboBarCount > 0 && (i = e.globals.comboBarCount), e.globals.collapsedSeries.forEach((function (t) {
                    "bar" !== t.type && "rangeBar" !== t.type || (i -= 1)
                })), e.config.chart.stacked && (i = 1), ("bar" === n || "rangeBar" === n || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && i > 0) {
                    var r, o, s = Math.abs(e.globals.initialMaxX - e.globals.initialMinX);
                    s <= 3 && (s = e.globals.dataPoints), r = s / t, e.globals.minXDiff && e.globals.minXDiff / r > 0 && (o = e.globals.minXDiff / r), o > t / 2 && (o /= 2), (a = o / i * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (a = 1), a = a / (i > 1 ? 1 : 1.5) + 5, e.globals.barPadForNumericAxis = a
                }
                return a
            }
        }, {
            key: "gridPadFortitleSubtitle", value: function () {
                var t = this, e = this.w, n = e.globals, a = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
                ["title", "subtitle"].forEach((function (n) {
                    void 0 !== e.config[n].text ? a += e.config[n].margin : a += t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5
                })), !e.config.legend.show || "bottom" !== e.config.legend.position || e.config.legend.floating || e.globals.axisCharts || (a += 10);
                var i = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
                    r = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                n.gridHeight = n.gridHeight - i.height - r.height - a, n.translateY = n.translateY + i.height + r.height + a
            }
        }, {
            key: "setGridXPosForDualYAxis", value: function (t, e) {
                var n = this.w, a = new Y(this.dCtx.ctx);
                n.config.yaxis.map((function (i, r) {
                    -1 !== n.globals.ignoreYAxisIndexes.indexOf(r) || i.floating || a.isYAxisHidden(r) || (i.opposite && (n.globals.translateX = n.globals.translateX - (e[r].width + t[r].width) - parseInt(n.config.yaxis[r].labels.style.fontSize, 10) / 1.2 - 12), n.globals.translateX < 2 && (n.globals.translateX = 2))
                }))
            }
        }]), t
    }(), dt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new ot(this), this.dimYAxis = new lt(this), this.dimXAxis = new st(this), this.dimGrid = new ct(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0
        }

        return s(t, [{
            key: "plotCoords", value: function () {
                var t = this.w.globals;
                this.lgRect = this.dimHelpers.getLegendsRect(), t.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), t.gridHeight = t.gridHeight - this.gridPad.top - this.gridPad.bottom, t.gridWidth = t.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                var e = this.dimGrid.gridPadForColumnsInNumericAxis(t.gridWidth);
                t.gridWidth = t.gridWidth - 2 * e, t.translateX = t.translateX + this.gridPad.left + this.xPadLeft + (e > 0 ? e + 4 : 0), t.translateY = t.translateY + this.gridPad.top
            }
        }, {
            key: "setDimensionsForAxisCharts", value: function () {
                var t = this, e = this.w, n = e.globals, a = this.dimYAxis.getyAxisLabelsCoords(),
                    i = this.dimYAxis.getyAxisTitleCoords();
                e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map((function (t, n) {
                    e.globals.yLabelsCoords.push({
                        width: a[n].width,
                        index: n
                    }), e.globals.yTitleCoords.push({width: i[n].width, index: n})
                })), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                var r = this.dimXAxis.getxAxisLabelsCoords(), o = this.dimXAxis.getxAxisTitleCoords();
                this.conditionalChecksForAxisCoords(r, o), n.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, n.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (n.rotateXLabels = !1, n.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), n.translateXAxisY = n.translateXAxisY + e.config.xaxis.labels.offsetY, n.translateXAxisX = n.translateXAxisX + e.config.xaxis.labels.offsetX;
                var s = this.yAxisWidth, l = this.xAxisHeight;
                n.xAxisLabelsHeight = this.xAxisHeight, n.xAxisLabelsWidth = this.xAxisWidth, n.xAxisHeight = this.xAxisHeight;
                var c = 10;
                ("radar" === e.config.chart.type || this.isSparkline) && (s = 0, l = n.goldenPadding), this.isSparkline && (this.lgRect = {
                    height: 0,
                    width: 0
                }), (this.isSparkline || "treemap" === e.config.chart.type) && (s = 0, l = 0, c = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(r);
                var d = function () {
                    n.translateX = s, n.gridHeight = n.svgHeight - t.lgRect.height - l - (t.isSparkline || "treemap" === e.config.chart.type ? 0 : e.globals.rotateXLabels ? 10 : 15), n.gridWidth = n.svgWidth - s
                };
                switch ("top" === e.config.xaxis.position && (c = n.xAxisHeight - e.config.xaxis.axisTicks.height - 5), e.config.legend.position) {
                    case"bottom":
                        n.translateY = c, d();
                        break;
                    case"top":
                        n.translateY = this.lgRect.height + c, d();
                        break;
                    case"left":
                        n.translateY = c, n.translateX = this.lgRect.width + s, n.gridHeight = n.svgHeight - l - 12, n.gridWidth = n.svgWidth - this.lgRect.width - s;
                        break;
                    case"right":
                        n.translateY = c, n.translateX = s, n.gridHeight = n.svgHeight - l - 12, n.gridWidth = n.svgWidth - this.lgRect.width - s - 5;
                        break;
                    default:
                        throw new Error("Legend position not supported")
                }
                this.dimGrid.setGridXPosForDualYAxis(i, a), new Q(this.ctx).setYAxisXPosition(a, i)
            }
        }, {
            key: "setDimensionsForNonAxisCharts", value: function () {
                var t = this.w, e = t.globals, n = t.config, a = 0;
                t.config.legend.show && !t.config.legend.floating && (a = 20);
                var i = "pie" === n.chart.type || "polarArea" === n.chart.type || "donut" === n.chart.type ? "pie" : "radialBar",
                    r = n.plotOptions[i].offsetY, o = n.plotOptions[i].offsetX;
                if (!n.legend.show || n.legend.floating) return e.gridHeight = e.svgHeight - n.grid.padding.left + n.grid.padding.right, e.gridWidth = e.gridHeight, e.translateY = r, void (e.translateX = o + (e.svgWidth - e.gridWidth) / 2);
                switch (n.legend.position) {
                    case"bottom":
                        e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = r - 10, e.translateX = o + (e.svgWidth - e.gridWidth) / 2;
                        break;
                    case"top":
                        e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = this.lgRect.height + r + 10, e.translateX = o + (e.svgWidth - e.gridWidth) / 2;
                        break;
                    case"left":
                        e.gridWidth = e.svgWidth - this.lgRect.width - a, e.gridHeight = "auto" !== n.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = o + this.lgRect.width + a;
                        break;
                    case"right":
                        e.gridWidth = e.svgWidth - this.lgRect.width - a - 5, e.gridHeight = "auto" !== n.chart.height ? e.svgHeight : e.gridWidth, e.translateY = r, e.translateX = o + 10;
                        break;
                    default:
                        throw new Error("Legend position not supported")
                }
            }
        }, {
            key: "conditionalChecksForAxisCoords", value: function (t, e) {
                var n = this.w;
                this.xAxisHeight = (t.height + e.height) * (n.globals.isMultiLineX ? 1.2 : n.globals.LINE_HEIGHT_RATIO) + (n.globals.rotateXLabels ? 22 : 10), this.xAxisWidth = t.width, this.xAxisHeight - e.height > n.config.xaxis.labels.maxHeight && (this.xAxisHeight = n.config.xaxis.labels.maxHeight), n.config.xaxis.labels.minHeight && this.xAxisHeight < n.config.xaxis.labels.minHeight && (this.xAxisHeight = n.config.xaxis.labels.minHeight), n.config.xaxis.floating && (this.xAxisHeight = 0);
                var a = 0, i = 0;
                n.config.yaxis.forEach((function (t) {
                    a += t.labels.minWidth, i += t.labels.maxWidth
                })), this.yAxisWidth < a && (this.yAxisWidth = a), this.yAxisWidth > i && (this.yAxisWidth = i)
            }
        }]), t
    }(), ut = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.lgCtx = e
        }

        return s(t, [{
            key: "getLegendStyles", value: function () {
                var t = document.createElement("style");
                t.setAttribute("type", "text/css");
                var e = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.position-bottom, .apexcharts-legend.position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-left, .apexcharts-legend.position-top.apexcharts-align-left, .apexcharts-legend.position-right, .apexcharts-legend.position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-center, .apexcharts-legend.position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.position-bottom.apexcharts-align-right, .apexcharts-legend.position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.position-bottom .apexcharts-legend-series, .apexcharts-legend.position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
                return t.appendChild(e), t
            }
        }, {
            key: "getLegendBBox", value: function () {
                var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),
                    e = t.width;
                return {clwh: t.height, clww: e}
            }
        }, {
            key: "appendToForeignObject", value: function () {
                var t = this.w.globals;
                t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject");
                var e = t.dom.elLegendForeign;
                e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("width", t.svgWidth), e.setAttribute("height", t.svgHeight), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.appendChild(t.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node)
            }
        }, {
            key: "toggleDataSeries", value: function (t, e) {
                var n = this, a = this.w;
                if (a.globals.axisCharts || "radialBar" === a.config.chart.type) {
                    a.globals.resized = !0;
                    var i = null, r = null;
                    a.globals.risingSeries = [], a.globals.axisCharts ? (i = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), r = parseInt(i.getAttribute("data:realIndex"), 10)) : (i = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), r = parseInt(i.getAttribute("rel"), 10) - 1), e ? [{
                        cs: a.globals.collapsedSeries,
                        csi: a.globals.collapsedSeriesIndices
                    }, {
                        cs: a.globals.ancillaryCollapsedSeries,
                        csi: a.globals.ancillaryCollapsedSeriesIndices
                    }].forEach((function (t) {
                        n.riseCollapsedSeries(t.cs, t.csi, r)
                    })) : this.hideSeries({seriesEl: i, realIndex: r})
                } else {
                    var o = a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")),
                        s = a.config.chart.type;
                    if ("pie" === s || "polarArea" === s || "donut" === s) {
                        var l = a.config.plotOptions.pie.donut.labels;
                        new _(this.lgCtx.ctx).pathMouseDown(o.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(o.members[0].node, l)
                    }
                    o.fire("click")
                }
            }
        }, {
            key: "hideSeries", value: function (t) {
                var e = t.seriesEl, n = t.realIndex, a = this.w, i = b.clone(a.config.series);
                if (a.globals.axisCharts) {
                    var r = !1;
                    if (a.config.yaxis[n] && a.config.yaxis[n].show && a.config.yaxis[n].showAlways && (r = !0, a.globals.ancillaryCollapsedSeriesIndices.indexOf(n) < 0 && (a.globals.ancillaryCollapsedSeries.push({
                        index: n,
                        data: i[n].data.slice(),
                        type: e.parentNode.className.baseVal.split("-")[1]
                    }), a.globals.ancillaryCollapsedSeriesIndices.push(n))), !r) {
                        a.globals.collapsedSeries.push({
                            index: n,
                            data: i[n].data.slice(),
                            type: e.parentNode.className.baseVal.split("-")[1]
                        }), a.globals.collapsedSeriesIndices.push(n);
                        var o = a.globals.risingSeries.indexOf(n);
                        a.globals.risingSeries.splice(o, 1)
                    }
                } else a.globals.collapsedSeries.push({index: n, data: i[n]}), a.globals.collapsedSeriesIndices.push(n);
                for (var s = e.childNodes, l = 0; l < s.length; l++) s[l].classList.contains("apexcharts-series-markers-wrap") && (s[l].classList.contains("apexcharts-hide") ? s[l].classList.remove("apexcharts-hide") : s[l].classList.add("apexcharts-hide"));
                a.globals.allSeriesCollapsed = a.globals.collapsedSeries.length === a.config.series.length, i = this._getSeriesBasedOnCollapsedState(i), this.lgCtx.ctx.updateHelpers._updateSeries(i, a.config.chart.animations.dynamicAnimation.enabled)
            }
        }, {
            key: "riseCollapsedSeries", value: function (t, e, n) {
                var a = this.w, i = b.clone(a.config.series);
                if (t.length > 0) {
                    for (var r = 0; r < t.length; r++) t[r].index === n && (a.globals.axisCharts ? (i[n].data = t[r].data.slice(), t.splice(r, 1), e.splice(r, 1), a.globals.risingSeries.push(n)) : (i[n] = t[r].data, t.splice(r, 1), e.splice(r, 1), a.globals.risingSeries.push(n)));
                    i = this._getSeriesBasedOnCollapsedState(i), this.lgCtx.ctx.updateHelpers._updateSeries(i, a.config.chart.animations.dynamicAnimation.enabled)
                }
            }
        }, {
            key: "_getSeriesBasedOnCollapsedState", value: function (t) {
                var e = this.w;
                return e.globals.axisCharts ? t.forEach((function (n, a) {
                    e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a].data = [])
                })) : t.forEach((function (n, a) {
                    e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a] = 0)
                })), t
            }
        }]), t
    }(), ht = function () {
        function t(e, n) {
            r(this, t), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new ut(this)
        }

        return s(t, [{
            key: "init", value: function () {
                var t = this.w, e = t.globals, n = t.config;
                if ((n.legend.showForSingleSeries && 1 === e.series.length || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && n.legend.show) {
                    for (; e.dom.elLegendWrap.firstChild;) e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
                    this.drawLegends(), b.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === n.legend.position || "top" === n.legend.position ? this.legendAlignHorizontal() : "right" !== n.legend.position && "left" !== n.legend.position || this.legendAlignVertical()
                }
            }
        }, {
            key: "drawLegends", value: function () {
                var t = this, e = this.w, n = e.config.legend.fontFamily, a = e.globals.seriesNames,
                    i = e.globals.colors.slice();
                if ("heatmap" === e.config.chart.type) {
                    var r = e.config.plotOptions.heatmap.colorScale.ranges;
                    a = r.map((function (t) {
                        return t.name ? t.name : t.from + " - " + t.to
                    })), i = r.map((function (t) {
                        return t.color
                    }))
                } else this.isBarsDistributed && (a = e.globals.labels.slice());
                for (var o = e.globals.legendFormatter, s = e.config.legend.inverseOrder, l = s ? a.length - 1 : 0; s ? l >= 0 : l <= a.length - 1; s ? l-- : l++) {
                    var c = o(a[l], {seriesIndex: l, w: e}), d = !1, u = !1;
                    if (e.globals.collapsedSeries.length > 0) for (var h = 0; h < e.globals.collapsedSeries.length; h++) e.globals.collapsedSeries[h].index === l && (d = !0);
                    if (e.globals.ancillaryCollapsedSeriesIndices.length > 0) for (var p = 0; p < e.globals.ancillaryCollapsedSeriesIndices.length; p++) e.globals.ancillaryCollapsedSeriesIndices[p] === l && (u = !0);
                    var f = document.createElement("span");
                    f.classList.add("apexcharts-legend-marker");
                    var g = e.config.legend.markers.offsetX, m = e.config.legend.markers.offsetY,
                        v = e.config.legend.markers.height, y = e.config.legend.markers.width,
                        x = e.config.legend.markers.strokeWidth, w = e.config.legend.markers.strokeColor,
                        S = e.config.legend.markers.radius, k = f.style;
                    k.background = i[l], k.color = i[l], k.setProperty("background", i[l], "important"), e.config.legend.markers.fillColors && e.config.legend.markers.fillColors[l] && (k.background = e.config.legend.markers.fillColors[l]), void 0 !== e.globals.seriesColors[l] && (k.background = e.globals.seriesColors[l], k.color = e.globals.seriesColors[l]), k.height = Array.isArray(v) ? parseFloat(v[l]) + "px" : parseFloat(v) + "px", k.width = Array.isArray(y) ? parseFloat(y[l]) + "px" : parseFloat(y) + "px", k.left = Array.isArray(g) ? g[l] : g, k.top = Array.isArray(m) ? m[l] : m, k.borderWidth = Array.isArray(x) ? x[l] : x, k.borderColor = Array.isArray(w) ? w[l] : w, k.borderRadius = Array.isArray(S) ? parseFloat(S[l]) + "px" : parseFloat(S) + "px", e.config.legend.markers.customHTML && (Array.isArray(e.config.legend.markers.customHTML) ? e.config.legend.markers.customHTML[l] && (f.innerHTML = e.config.legend.markers.customHTML[l]()) : f.innerHTML = e.config.legend.markers.customHTML()), _.setAttrs(f, {
                        rel: l + 1,
                        "data:collapsed": d || u
                    }), (d || u) && f.classList.add("apexcharts-inactive-legend");
                    var D = document.createElement("div"), T = document.createElement("span");
                    T.classList.add("apexcharts-legend-text"), T.innerHTML = Array.isArray(c) ? c.join(" ") : c;
                    var E = e.config.legend.labels.useSeriesColors ? e.globals.colors[l] : e.config.legend.labels.colors;
                    E || (E = e.config.chart.foreColor), T.style.color = E, T.style.fontSize = parseFloat(e.config.legend.fontSize) + "px", T.style.fontWeight = e.config.legend.fontWeight, T.style.fontFamily = n || e.config.chart.fontFamily, _.setAttrs(T, {
                        rel: l + 1,
                        i: l,
                        "data:default-text": encodeURIComponent(c),
                        "data:collapsed": d || u
                    }), D.appendChild(f), D.appendChild(T);
                    var A = new C(this.ctx);
                    e.config.legend.showForZeroSeries || 0 === A.getSeriesTotalByIndex(l) && A.seriesHaveSameValues(l) && !A.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && D.classList.add("apexcharts-hidden-zero-series"), e.config.legend.showForNullSeries || A.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && D.classList.add("apexcharts-hidden-null-series"), e.globals.dom.elLegendWrap.appendChild(D), e.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e.config.legend.horizontalAlign)), e.globals.dom.elLegendWrap.classList.add("position-" + e.config.legend.position), D.classList.add("apexcharts-legend-series"), D.style.margin = "".concat(e.config.legend.itemMargin.vertical, "px ").concat(e.config.legend.itemMargin.horizontal, "px"), e.globals.dom.elLegendWrap.style.width = e.config.legend.width ? e.config.legend.width + "px" : "", e.globals.dom.elLegendWrap.style.height = e.config.legend.height ? e.config.legend.height + "px" : "", _.setAttrs(D, {
                        rel: l + 1,
                        seriesName: b.escapeString(a[l]),
                        "data:collapsed": d || u
                    }), (d || u) && D.classList.add("apexcharts-inactive-legend"), e.config.legend.onItemClick.toggleDataSeries || D.classList.add("apexcharts-no-click")
                }
                e.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), e.config.legend.onItemHover.highlightDataSeries && (e.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), e.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0))
            }
        }, {
            key: "setLegendWrapXY", value: function (t, e) {
                var n = this.w, a = n.globals.dom.baseEl.querySelector(".apexcharts-legend"),
                    i = a.getBoundingClientRect(), r = 0, o = 0;
                if ("bottom" === n.config.legend.position) o += n.globals.svgHeight - i.height / 2; else if ("top" === n.config.legend.position) {
                    var s = new dt(this.ctx), l = s.dimHelpers.getTitleSubtitleCoords("title").height,
                        c = s.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                    o = o + (l > 0 ? l - 10 : 0) + (c > 0 ? c - 10 : 0)
                }
                a.style.position = "absolute", r = r + t + n.config.legend.offsetX, o = o + e + n.config.legend.offsetY, a.style.left = r + "px", a.style.top = o + "px", "bottom" === n.config.legend.position ? (a.style.top = "auto", a.style.bottom = 5 - n.config.legend.offsetY + "px") : "right" === n.config.legend.position && (a.style.left = "auto", a.style.right = 25 + n.config.legend.offsetX + "px"), ["width", "height"].forEach((function (t) {
                    a.style[t] && (a.style[t] = parseInt(n.config.legend[t], 10) + "px")
                }))
            }
        }, {
            key: "legendAlignHorizontal", value: function () {
                var t = this.w;
                t.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
                var e = this.legendHelpers.getLegendBBox(), n = new dt(this.ctx),
                    a = n.dimHelpers.getTitleSubtitleCoords("title"),
                    i = n.dimHelpers.getTitleSubtitleCoords("subtitle"), r = 0;
                "bottom" === t.config.legend.position ? r = -e.clwh / 1.8 : "top" === t.config.legend.position && (r = a.height + i.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, r)
            }
        }, {
            key: "legendAlignVertical", value: function () {
                var t = this.w, e = this.legendHelpers.getLegendBBox(), n = 0;
                "left" === t.config.legend.position && (n = 20), "right" === t.config.legend.position && (n = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(n, 20)
            }
        }, {
            key: "onLegendHovered", value: function (t) {
                var e = this.w,
                    n = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");
                if ("heatmap" === e.config.chart.type || this.isBarsDistributed) {
                    if (n) {
                        var a = parseInt(t.target.getAttribute("rel"), 10) - 1;
                        this.ctx.events.fireEvent("legendHover", [this.ctx, a, this.w]), new j(this.ctx).highlightRangeInSeries(t, t.target)
                    }
                } else !t.target.classList.contains("apexcharts-inactive-legend") && n && new j(this.ctx).toggleSeriesOnHover(t, t.target)
            }
        }, {
            key: "onLegendClick", value: function (t) {
                var e = this.w;
                if (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker")) {
                    var n = parseInt(t.target.getAttribute("rel"), 10) - 1,
                        a = "true" === t.target.getAttribute("data:collapsed"),
                        i = this.w.config.chart.events.legendClick;
                    "function" == typeof i && i(this.ctx, n, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, n, this.w]);
                    var r = this.w.config.legend.markers.onClick;
                    "function" == typeof r && t.target.classList.contains("apexcharts-legend-marker") && (r(this.ctx, n, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, n, this.w])), "treemap" !== e.config.chart.type && "heatmap" !== e.config.chart.type && !this.isBarsDistributed && e.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(n, a)
                }
            }
        }]), t
    }(), pt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar
        }

        return s(t, [{
            key: "createToolbar", value: function () {
                var t = this, e = this.w, n = function () {
                    return document.createElement("div")
                }, a = n();
                if (a.setAttribute("class", "apexcharts-toolbar"), a.style.top = e.config.chart.toolbar.offsetY + "px", a.style.right = 3 - e.config.chart.toolbar.offsetX + "px", e.globals.dom.elWrap.appendChild(a), this.elZoom = n(), this.elZoomIn = n(), this.elZoomOut = n(), this.elPan = n(), this.elSelection = n(), this.elZoomReset = n(), this.elMenuIcon = n(), this.elMenu = n(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons)) for (var i = 0; i < this.t.customIcons.length; i++) this.elCustomIcons.push(n());
                var r = [], o = function (n, a, i) {
                    var o = n.toLowerCase();
                    t.t[o] && e.config.chart.zoom.enabled && r.push({
                        el: a,
                        icon: "string" == typeof t.t[o] ? t.t[o] : i,
                        title: t.localeValues[n],
                        class: "apexcharts-".concat(o, "-icon")
                    })
                };
                o("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), o("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                var s = function (n) {
                    t.t[n] && e.config.chart[n].enabled && r.push({
                        el: "zoom" === n ? t.elZoom : t.elSelection,
                        icon: "string" == typeof t.t[n] ? t.t[n] : "zoom" === n ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                        title: t.localeValues["zoom" === n ? "selectionZoom" : "selection"],
                        class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(n, "-icon")
                    })
                };
                s("zoom"), s("selection"), this.t.pan && e.config.chart.zoom.enabled && r.push({
                    el: this.elPan,
                    icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                    title: this.localeValues.pan,
                    class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                }), o("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r.push({
                    el: this.elMenuIcon,
                    icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                    title: this.localeValues.menu,
                    class: "apexcharts-menu-icon"
                });
                for (var l = 0; l < this.elCustomIcons.length; l++) r.push({
                    el: this.elCustomIcons[l],
                    icon: this.t.customIcons[l].icon,
                    title: this.t.customIcons[l].title,
                    index: this.t.customIcons[l].index,
                    class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
                });
                r.forEach((function (t, e) {
                    t.index && b.moveIndexInArray(r, e, t.index)
                }));
                for (var c = 0; c < r.length; c++) _.setAttrs(r[c].el, {
                    class: r[c].class,
                    title: r[c].title
                }), r[c].el.innerHTML = r[c].icon, a.appendChild(r[c].el);
                this._createHamburgerMenu(a), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners()
            }
        }, {
            key: "_createHamburgerMenu", value: function (t) {
                this.elMenuItems = [], t.appendChild(this.elMenu), _.setAttrs(this.elMenu, {class: "apexcharts-menu"});
                var e = [{name: "exportSVG", title: this.localeValues.exportToSVG}, {
                    name: "exportPNG",
                    title: this.localeValues.exportToPNG
                }, {name: "exportCSV", title: this.localeValues.exportToCSV}];
                this.w.globals.allSeriesHasEqualX || e.splice(2, 1);
                for (var n = 0; n < e.length; n++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[n].innerHTML = e[n].title, _.setAttrs(this.elMenuItems[n], {
                    class: "apexcharts-menu-item ".concat(e[n].name),
                    title: e[n].title
                }), this.elMenu.appendChild(this.elMenuItems[n])
            }
        }, {
            key: "addToolbarEventListeners", value: function () {
                var t = this;
                this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach((function (e) {
                    e.classList.contains("exportSVG") ? e.addEventListener("click", t.handleDownload.bind(t, "svg")) : e.classList.contains("exportPNG") ? e.addEventListener("click", t.handleDownload.bind(t, "png")) : e.classList.contains("exportCSV") && e.addEventListener("click", t.handleDownload.bind(t, "csv"))
                }));
                for (var e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w))
            }
        }, {
            key: "toggleZoomSelection", value: function (t) {
                this.ctx.getSyncedCharts().forEach((function (e) {
                    e.ctx.toolbar.toggleOtherControls();
                    var n = "selection" === t ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
                        a = "selection" === t ? "selectionEnabled" : "zoomEnabled";
                    e.w.globals[a] = !e.w.globals[a], n.classList.contains(e.ctx.toolbar.selectedClass) ? n.classList.remove(e.ctx.toolbar.selectedClass) : n.classList.add(e.ctx.toolbar.selectedClass)
                }))
            }
        }, {
            key: "getToolbarIconsReference", value: function () {
                var t = this.w;
                this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
            }
        }, {
            key: "enableZoomPanFromToolbar", value: function (t) {
                this.toggleOtherControls(), "pan" === t ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                var e = "pan" === t ? this.elPan : this.elZoom, n = "pan" === t ? this.elZoom : this.elPan;
                e && e.classList.add(this.selectedClass), n && n.classList.remove(this.selectedClass)
            }
        }, {
            key: "togglePanning", value: function () {
                this.ctx.getSyncedCharts().forEach((function (t) {
                    t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass)
                }))
            }
        }, {
            key: "toggleOtherControls", value: function () {
                var t = this, e = this.w;
                e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach((function (e) {
                    e && e.classList.remove(t.selectedClass)
                }))
            }
        }, {
            key: "handleZoomIn", value: function () {
                var t = this.w, e = (t.globals.minX + t.globals.maxX) / 2, n = (t.globals.minX + e) / 2,
                    a = (t.globals.maxX + e) / 2, i = this._getNewMinXMaxX(n, a);
                t.globals.disableZoomIn || this.zoomUpdateOptions(i.minX, i.maxX)
            }
        }, {
            key: "handleZoomOut", value: function () {
                var t = this.w;
                if (!("datetime" === t.config.xaxis.type && new Date(t.globals.minX).getUTCFullYear() < 1e3)) {
                    var e = (t.globals.minX + t.globals.maxX) / 2, n = t.globals.minX - (e - t.globals.minX),
                        a = t.globals.maxX - (e - t.globals.maxX), i = this._getNewMinXMaxX(n, a);
                    t.globals.disableZoomOut || this.zoomUpdateOptions(i.minX, i.maxX)
                }
            }
        }, {
            key: "_getNewMinXMaxX", value: function (t, e) {
                var n = this.w.config.xaxis.convertedCatToNumeric;
                return {minX: n ? Math.floor(t) : t, maxX: n ? Math.floor(e) : e}
            }
        }, {
            key: "zoomUpdateOptions", value: function (t, e) {
                var n = this.w;
                if (void 0 !== t || void 0 !== e) {
                    if (!(n.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = n.globals.dataPoints), e - t < 2))) {
                        var a = {min: t, max: e}, i = this.getBeforeZoomRange(a);
                        i && (a = i.xaxis);
                        var r = {xaxis: a}, o = b.clone(n.globals.initialConfig.yaxis);
                        n.config.chart.zoom.autoScaleYaxis && (o = new Z(this.ctx).autoScaleY(this.ctx, o, {xaxis: a})), n.config.chart.group || (r.yaxis = o), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(r, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a, o)
                    }
                } else this.handleZoomReset()
            }
        }, {
            key: "zoomCallback", value: function (t, e) {
                "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {xaxis: t, yaxis: e})
            }
        }, {
            key: "getBeforeZoomRange", value: function (t, e) {
                var n = null;
                return "function" == typeof this.ev.beforeZoom && (n = this.ev.beforeZoom(this, {
                    xaxis: t,
                    yaxis: e
                })), n
            }
        }, {
            key: "toggleMenu", value: function () {
                var t = this;
                window.setTimeout((function () {
                    t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open")
                }), 0)
            }
        }, {
            key: "handleDownload", value: function (t) {
                var e = this.w, n = new U(this.ctx);
                switch (t) {
                    case"svg":
                        n.exportToSVG(this.ctx);
                        break;
                    case"png":
                        n.exportToPng(this.ctx);
                        break;
                    case"csv":
                        n.exportToCSV({
                            series: e.config.series,
                            columnDelimiter: e.config.chart.toolbar.export.csv.columnDelimiter
                        })
                }
            }
        }, {
            key: "handleZoomReset", value: function (t) {
                this.ctx.getSyncedCharts().forEach((function (t) {
                    var e = t.w;
                    if (e.globals.lastXAxis.min = void 0, e.globals.lastXAxis.max = void 0, t.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e.config.chart.events.beforeResetZoom) {
                        var n = e.config.chart.events.beforeResetZoom(t, e);
                        n && t.updateHelpers.revertDefaultAxisMinMax(n)
                    }
                    "function" == typeof e.config.chart.events.zoomed && t.ctx.toolbar.zoomCallback({
                        min: e.config.xaxis.min,
                        max: e.config.xaxis.max
                    }), e.globals.zoomed = !1;
                    var a = t.ctx.series.emptyCollapsedSeries(b.clone(e.globals.initialSeries));
                    t.updateHelpers._updateSeries(a, e.config.chart.animations.dynamicAnimation.enabled)
                }))
            }
        }, {
            key: "destroy", value: function () {
                this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null
            }
        }]), t
    }(), ft = function (t) {
        u(n, pt);
        var e = g(n);

        function n(t) {
            var a;
            return r(this, n), (a = e.call(this, t)).ctx = t, a.w = t.w, a.dragged = !1, a.graphics = new _(a.ctx), a.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], a.clientX = 0, a.clientY = 0, a.startX = 0, a.endX = 0, a.dragX = 0, a.startY = 0, a.endY = 0, a.dragY = 0, a.moveDirection = "none", a
        }

        return s(n, [{
            key: "init", value: function (t) {
                var e = this, n = t.xyRatios, a = this.w, i = this;
                this.xyRatios = n, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a.globals.dom.elGraphical.add(this.zoomRect), a.globals.dom.elGraphical.add(this.selectionRect), "x" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                    minX: 0,
                    minY: 0,
                    maxX: a.globals.gridWidth,
                    maxY: a.globals.gridHeight
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                    minX: 0,
                    maxX: a.globals.gridWidth
                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a.globals.dom.baseEl.querySelector("".concat(a.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach((function (t) {
                    e.hoverArea.addEventListener(t, i.svgMouseEvents.bind(i, n), {capture: !1, passive: !0})
                }))
            }
        }, {
            key: "destroy", value: function () {
                this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null
            }
        }, {
            key: "svgMouseEvents", value: function (t, e) {
                var n = this.w, a = this, i = this.ctx.toolbar,
                    r = n.globals.zoomEnabled ? n.config.chart.zoom.type : n.config.chart.selection.type,
                    o = n.config.chart.toolbar.autoSelected;
                e.shiftKey ? (this.shiftWasPressed = !0, i.enableZoomPanFromToolbar("pan" === o ? "zoom" : "pan")) : this.shiftWasPressed && (i.enableZoomPanFromToolbar(o), this.shiftWasPressed = !1);
                var s = e.target.classList;
                if (!(s.contains("apexcharts-selection-rect") || s.contains("apexcharts-legend-marker") || s.contains("apexcharts-legend-text") || e.target.parentNode.classList.contains("apexcharts-toolbar"))) {
                    if (a.clientX = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientX : "touchend" === e.type ? e.changedTouches[0].clientX : e.clientX, a.clientY = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientY : "touchend" === e.type ? e.changedTouches[0].clientY : e.clientY, "mousedown" === e.type && 1 === e.which) {
                        var l = a.gridRect.getBoundingClientRect();
                        a.startX = a.clientX - l.left, a.startY = a.clientY - l.top, a.dragged = !1, a.w.globals.mousedown = !0
                    }
                    if (("mousemove" === e.type && 1 === e.which || "touchmove" === e.type) && (a.dragged = !0, n.globals.panEnabled ? (n.globals.selection = null, a.w.globals.mousedown && a.panDragging({
                        context: a,
                        zoomtype: r,
                        xyRatios: t
                    })) : (a.w.globals.mousedown && n.globals.zoomEnabled || a.w.globals.mousedown && n.globals.selectionEnabled) && (a.selection = a.selectionDrawing({
                        context: a,
                        zoomtype: r
                    }))), "mouseup" === e.type || "touchend" === e.type || "mouseleave" === e.type) {
                        var c = a.gridRect.getBoundingClientRect();
                        a.w.globals.mousedown && (a.endX = a.clientX - c.left, a.endY = a.clientY - c.top, a.dragX = Math.abs(a.endX - a.startX), a.dragY = Math.abs(a.endY - a.startY), (n.globals.zoomEnabled || n.globals.selectionEnabled) && a.selectionDrawn({
                            context: a,
                            zoomtype: r
                        }), n.globals.panEnabled && n.config.xaxis.convertedCatToNumeric && a.delayedPanScrolled()), n.globals.zoomEnabled && a.hideSelectionRect(this.selectionRect), a.dragged = !1, a.w.globals.mousedown = !1
                    }
                    this.makeSelectionRectDraggable()
                }
            }
        }, {
            key: "makeSelectionRectDraggable", value: function () {
                var t = this.w;
                if (this.selectionRect) {
                    var e = this.selectionRect.node.getBoundingClientRect();
                    e.width > 0 && e.height > 0 && this.slDraggableRect.selectize({
                        points: "l, r",
                        pointSize: 8,
                        pointType: "rect"
                    }).resize({
                        constraint: {
                            minX: 0,
                            minY: 0,
                            maxX: t.globals.gridWidth,
                            maxY: t.globals.gridHeight
                        }
                    }).on("resizing", this.selectionDragging.bind(this, "resizing"))
                }
            }
        }, {
            key: "preselectedSelection", value: function () {
                var t = this.w, e = this.xyRatios;
                if (!t.globals.zoomEnabled) if (void 0 !== t.globals.selection && null !== t.globals.selection) this.drawSelectionRect(t.globals.selection); else if (void 0 !== t.config.chart.selection.xaxis.min && void 0 !== t.config.chart.selection.xaxis.max) {
                    var n = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio, a = {
                        x: n,
                        y: 0,
                        width: t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - n,
                        height: t.globals.gridHeight,
                        translateX: 0,
                        translateY: 0,
                        selectionEnabled: !0
                    };
                    this.drawSelectionRect(a), this.makeSelectionRectDraggable(), "function" == typeof t.config.chart.events.selection && t.config.chart.events.selection(this.ctx, {
                        xaxis: {
                            min: t.config.chart.selection.xaxis.min,
                            max: t.config.chart.selection.xaxis.max
                        }, yaxis: {}
                    })
                }
            }
        }, {
            key: "drawSelectionRect", value: function (t) {
                var e = t.x, n = t.y, a = t.width, i = t.height, r = t.translateX, o = void 0 === r ? 0 : r,
                    s = t.translateY, l = void 0 === s ? 0 : s, c = this.w, d = this.zoomRect, u = this.selectionRect;
                if (this.dragged || null !== c.globals.selection) {
                    var h = {transform: "translate(" + o + ", " + l + ")"};
                    c.globals.zoomEnabled && this.dragged && (a < 0 && (a = 1), d.attr({
                        x: e,
                        y: n,
                        width: a,
                        height: i,
                        fill: c.config.chart.zoom.zoomedArea.fill.color,
                        "fill-opacity": c.config.chart.zoom.zoomedArea.fill.opacity,
                        stroke: c.config.chart.zoom.zoomedArea.stroke.color,
                        "stroke-width": c.config.chart.zoom.zoomedArea.stroke.width,
                        "stroke-opacity": c.config.chart.zoom.zoomedArea.stroke.opacity
                    }), _.setAttrs(d.node, h)), c.globals.selectionEnabled && (u.attr({
                        x: e,
                        y: n,
                        width: a > 0 ? a : 0,
                        height: i > 0 ? i : 0,
                        fill: c.config.chart.selection.fill.color,
                        "fill-opacity": c.config.chart.selection.fill.opacity,
                        stroke: c.config.chart.selection.stroke.color,
                        "stroke-width": c.config.chart.selection.stroke.width,
                        "stroke-dasharray": c.config.chart.selection.stroke.dashArray,
                        "stroke-opacity": c.config.chart.selection.stroke.opacity
                    }), _.setAttrs(u.node, h))
                }
            }
        }, {
            key: "hideSelectionRect", value: function (t) {
                t && t.attr({x: 0, y: 0, width: 0, height: 0})
            }
        }, {
            key: "selectionDrawing", value: function (t) {
                var e, n = t.context, a = t.zoomtype, i = this.w, r = n, o = this.gridRect.getBoundingClientRect(),
                    s = r.startX - 1, l = r.startY, c = !1, d = !1, u = r.clientX - o.left - s,
                    h = r.clientY - o.top - l;
                return Math.abs(u + s) > i.globals.gridWidth ? u = i.globals.gridWidth - s : r.clientX - o.left < 0 && (u = s), s > r.clientX - o.left && (c = !0, u = Math.abs(u)), l > r.clientY - o.top && (d = !0, h = Math.abs(h)), e = "x" === a ? {
                    x: c ? s - u : s,
                    y: 0,
                    width: u,
                    height: i.globals.gridHeight
                } : "y" === a ? {x: 0, y: d ? l - h : l, width: i.globals.gridWidth, height: h} : {
                    x: c ? s - u : s,
                    y: d ? l - h : l,
                    width: u,
                    height: h
                }, r.drawSelectionRect(e), r.selectionDragging("resizing"), e
            }
        }, {
            key: "selectionDragging", value: function (t, e) {
                var n = this, a = this.w, i = this.xyRatios, r = this.selectionRect, o = 0;
                "resizing" === t && (o = 30);
                var s = function (t) {
                    return parseFloat(r.node.getAttribute(t))
                }, l = {x: s("x"), y: s("y"), width: s("width"), height: s("height")};
                a.globals.selection = l, "function" == typeof a.config.chart.events.selection && a.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout((function () {
                    var t = n.gridRect.getBoundingClientRect(), e = r.node.getBoundingClientRect(), o = {
                        xaxis: {
                            min: a.globals.xAxisScale.niceMin + (e.left - t.left) * i.xRatio,
                            max: a.globals.xAxisScale.niceMin + (e.right - t.left) * i.xRatio
                        },
                        yaxis: {
                            min: a.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * i.yRatio[0],
                            max: a.globals.yAxisScale[0].niceMax - (e.top - t.top) * i.yRatio[0]
                        }
                    };
                    a.config.chart.events.selection(n.ctx, o), a.config.chart.brush.enabled && void 0 !== a.config.chart.events.brushScrolled && a.config.chart.events.brushScrolled(n.ctx, o)
                }), o))
            }
        }, {
            key: "selectionDrawn", value: function (t) {
                var e = t.context, n = t.zoomtype, a = this.w, i = e, r = this.xyRatios, o = this.ctx.toolbar;
                if (i.startX > i.endX) {
                    var s = i.startX;
                    i.startX = i.endX, i.endX = s
                }
                if (i.startY > i.endY) {
                    var l = i.startY;
                    i.startY = i.endY, i.endY = l
                }
                var c = a.globals.xAxisScale.niceMin + i.startX * r.xRatio,
                    d = a.globals.xAxisScale.niceMin + i.endX * r.xRatio, u = [], h = [];
                if (a.config.yaxis.forEach((function (t, e) {
                    u.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * i.startY), h.push(a.globals.yAxisScale[e].niceMax - r.yRatio[e] * i.endY)
                })), i.dragged && (i.dragX > 10 || i.dragY > 10) && c !== d) if (a.globals.zoomEnabled) {
                    var p = b.clone(a.globals.initialConfig.yaxis), f = b.clone(a.globals.initialConfig.xaxis);
                    if (a.globals.zoomed = !0, a.config.xaxis.convertedCatToNumeric && (c = Math.floor(c), d = Math.floor(d), c < 1 && (c = 1, d = a.globals.dataPoints), d - c < 2 && (d = c + 1)), "xy" !== n && "x" !== n || (f = {
                        min: c,
                        max: d
                    }), "xy" !== n && "y" !== n || p.forEach((function (t, e) {
                        p[e].min = h[e], p[e].max = u[e]
                    })), a.config.chart.zoom.autoScaleYaxis) {
                        var g = new Z(i.ctx);
                        p = g.autoScaleY(i.ctx, p, {xaxis: f})
                    }
                    if (o) {
                        var m = o.getBeforeZoomRange(f, p);
                        m && (f = m.xaxis ? m.xaxis : f, p = m.yaxis ? m.yaxis : p)
                    }
                    var v = {xaxis: f};
                    a.config.chart.group || (v.yaxis = p), i.ctx.updateHelpers._updateOptions(v, !1, i.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a.config.chart.events.zoomed && o.zoomCallback(f, p)
                } else if (a.globals.selectionEnabled) {
                    var y, x = null;
                    y = {
                        min: c,
                        max: d
                    }, "xy" !== n && "y" !== n || (x = b.clone(a.config.yaxis)).forEach((function (t, e) {
                        x[e].min = h[e], x[e].max = u[e]
                    })), a.globals.selection = i.selection, "function" == typeof a.config.chart.events.selection && a.config.chart.events.selection(i.ctx, {
                        xaxis: y,
                        yaxis: x
                    })
                }
            }
        }, {
            key: "panDragging", value: function (t) {
                var e = t.context, n = this.w, a = e;
                if (void 0 !== n.globals.lastClientPosition.x) {
                    var i = n.globals.lastClientPosition.x - a.clientX, r = n.globals.lastClientPosition.y - a.clientY;
                    Math.abs(i) > Math.abs(r) && i > 0 ? this.moveDirection = "left" : Math.abs(i) > Math.abs(r) && i < 0 ? this.moveDirection = "right" : Math.abs(r) > Math.abs(i) && r > 0 ? this.moveDirection = "up" : Math.abs(r) > Math.abs(i) && r < 0 && (this.moveDirection = "down")
                }
                n.globals.lastClientPosition = {x: a.clientX, y: a.clientY};
                var o = n.globals.minX, s = n.globals.maxX;
                n.config.xaxis.convertedCatToNumeric || a.panScrolled(o, s)
            }
        }, {
            key: "delayedPanScrolled", value: function () {
                var t = this.w, e = t.globals.minX, n = t.globals.maxX, a = (t.globals.maxX - t.globals.minX) / 2;
                "left" === this.moveDirection ? (e = t.globals.minX + a, n = t.globals.maxX + a) : "right" === this.moveDirection && (e = t.globals.minX - a, n = t.globals.maxX - a), e = Math.floor(e), n = Math.floor(n), this.updateScrolledChart({
                    xaxis: {
                        min: e,
                        max: n
                    }
                }, e, n)
            }
        }, {
            key: "panScrolled", value: function (t, e) {
                var n = this.w, a = this.xyRatios, i = b.clone(n.globals.initialConfig.yaxis);
                "left" === this.moveDirection ? (t = n.globals.minX + n.globals.gridWidth / 15 * a.xRatio, e = n.globals.maxX + n.globals.gridWidth / 15 * a.xRatio) : "right" === this.moveDirection && (t = n.globals.minX - n.globals.gridWidth / 15 * a.xRatio, e = n.globals.maxX - n.globals.gridWidth / 15 * a.xRatio), (t < n.globals.initialMinX || e > n.globals.initialMaxX) && (t = n.globals.minX, e = n.globals.maxX);
                var r = {min: t, max: e};
                n.config.chart.zoom.autoScaleYaxis && (i = new Z(this.ctx).autoScaleY(this.ctx, i, {xaxis: r}));
                var o = {xaxis: {min: t, max: e}};
                n.config.chart.group || (o.yaxis = i), this.updateScrolledChart(o, t, e)
            }
        }, {
            key: "updateScrolledChart", value: function (t, e, n) {
                var a = this.w;
                this.ctx.updateHelpers._updateOptions(t, !1, !1), "function" == typeof a.config.chart.events.scrolled && a.config.chart.events.scrolled(this.ctx, {
                    xaxis: {
                        min: e,
                        max: n
                    }
                })
            }
        }]), n
    }(), gt = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx
        }

        return s(t, [{
            key: "getNearestValues", value: function (t) {
                var e = t.hoverArea, n = t.elGrid, a = t.clientX, i = t.clientY, r = this.w, o = r.globals.gridWidth,
                    s = o / (r.globals.dataPoints - 1), l = n.getBoundingClientRect(), c = this.hasBars();
                !r.globals.comboCharts && !c || r.config.xaxis.convertedCatToNumeric || (s = o / r.globals.dataPoints);
                var d = a - l.left - r.globals.barPadForNumericAxis, u = i - l.top;
                d < 0 || u < 0 || d > r.globals.gridWidth || u > r.globals.gridHeight ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : r.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : r.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
                var h = Math.round(d / s);
                c && !r.config.xaxis.convertedCatToNumeric && (h = Math.ceil(d / s), h -= 1);
                for (var p, f = null, g = null, m = [], v = 0; v < r.globals.seriesXvalues.length; v++) m.push([r.globals.seriesXvalues[v][0] - 1e-6].concat(r.globals.seriesXvalues[v]));
                return m = m.map((function (t) {
                    return t.filter((function (t) {
                        return t
                    }))
                })), p = r.globals.seriesYvalues.map((function (t) {
                    return t.filter((function (t) {
                        return b.isNumber(t)
                    }))
                })), r.globals.isXNumeric && (f = (g = this.closestInMultiArray(d, u, m, p)).index, h = g.j, null !== f && (m = r.globals.seriesXvalues[f], h = (g = this.closestInArray(d, m)).index)), r.globals.capturedSeriesIndex = null === f ? -1 : f, (!h || h < 1) && (h = 0), r.globals.capturedDataPointIndex = h, {
                    capturedSeries: f,
                    j: h,
                    hoverX: d,
                    hoverY: u
                }
            }
        }, {
            key: "closestInMultiArray", value: function (t, e, n, a) {
                var i = this.w, r = 0, o = null, s = -1;
                i.globals.series.length > 1 ? r = this.getFirstActiveXArray(n) : o = 0;
                var l = a[r][0], c = n[r][0], d = Math.abs(t - c), u = Math.abs(e - l), h = u + d;
                return a.map((function (i, r) {
                    i.map((function (i, l) {
                        var c = Math.abs(e - a[r][l]), p = Math.abs(t - n[r][l]), f = p + c;
                        f < h && (h = f, d = p, u = c, o = r, s = l)
                    }))
                })), {index: o, j: s}
            }
        }, {
            key: "getFirstActiveXArray", value: function (t) {
                for (var e = 0, n = t.map((function (t, e) {
                    return t.length > 0 ? e : -1
                })), a = 0; a < n.length; a++) if (-1 !== n[a]) {
                    e = n[a];
                    break
                }
                return e
            }
        }, {
            key: "closestInArray", value: function (t, e) {
                for (var n = e[0], a = null, i = Math.abs(t - n), r = 0; r < e.length; r++) {
                    var o = Math.abs(t - e[r]);
                    o < i && (i = o, a = r)
                }
                return {index: a}
            }
        }, {
            key: "isXoverlap", value: function (t) {
                var e = [], n = this.w.globals.seriesX.filter((function (t) {
                    return void 0 !== t[0]
                }));
                if (n.length > 0) for (var a = 0; a < n.length - 1; a++) void 0 !== n[a][t] && void 0 !== n[a + 1][t] && n[a][t] !== n[a + 1][t] && e.push("unEqual");
                return 0 === e.length
            }
        }, {
            key: "isInitialSeriesSameLen", value: function () {
                for (var t = !0, e = this.w.globals.initialSeries, n = 0; n < e.length - 1; n++) if (e[n].data.length !== e[n + 1].data.length) {
                    t = !1;
                    break
                }
                return t
            }
        }, {
            key: "getBarsHeight", value: function (t) {
                return m(t).reduce((function (t, e) {
                    return t + e.getBBox().height
                }), 0)
            }
        }, {
            key: "getElMarkers", value: function () {
                return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers")
            }
        }, {
            key: "getAllMarkers", value: function () {
                var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                (t = m(t)).sort((function (t, e) {
                    return Number(e.getAttribute("data:realIndex")) < Number(t.getAttribute("data:realIndex")) ? 0 : -1
                }));
                var e = [];
                return t.forEach((function (t) {
                    e.push(t.querySelector(".apexcharts-marker"))
                })), e
            }
        }, {
            key: "hasMarkers", value: function () {
                return this.getElMarkers().length > 0
            }
        }, {
            key: "getElBars", value: function () {
                return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-rangebar-series")
            }
        }, {
            key: "hasBars", value: function () {
                return this.getElBars().length > 0
            }
        }, {
            key: "getHoverMarkerSize", value: function (t) {
                var e = this.w, n = e.config.markers.hover.size;
                return void 0 === n && (n = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), n
            }
        }, {
            key: "toggleAllTooltipSeriesGroups", value: function (t) {
                var e = this.w, n = this.ttCtx;
                0 === n.allTooltipSeriesGroups.length && (n.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                for (var a = n.allTooltipSeriesGroups, i = 0; i < a.length; i++) "enable" === t ? (a[i].classList.add("apexcharts-active"), a[i].style.display = e.config.tooltip.items.display) : (a[i].classList.remove("apexcharts-active"), a[i].style.display = "none")
            }
        }]), t
    }(), mt = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new gt(e)
        }

        return s(t, [{
            key: "drawSeriesTexts", value: function (t) {
                var e = t.shared, n = void 0 === e || e, a = t.ttItems, i = t.i, r = void 0 === i ? 0 : i, o = t.j,
                    s = void 0 === o ? null : o, l = t.y1, c = t.y2, d = t.e, u = this.w;
                void 0 !== u.config.tooltip.custom ? this.handleCustomTooltip({
                    i: r,
                    j: s,
                    y1: l,
                    y2: c,
                    w: u
                }) : this.toggleActiveInactiveSeries(n);
                var h = this.getValuesToPrint({i: r, j: s});
                this.printLabels({i: r, j: s, values: h, ttItems: a, shared: n, e: d});
                var p = this.ttCtx.getElTooltip();
                this.ttCtx.tooltipRect.ttWidth = p.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = p.getBoundingClientRect().height
            }
        }, {
            key: "printLabels", value: function (t) {
                var e, n = this, a = t.i, i = t.j, r = t.values, o = t.ttItems, s = t.shared, l = t.e, c = this.w,
                    u = r.xVal, h = r.zVal, p = r.xAxisTTVal, f = "", g = c.globals.colors[a];
                null !== i && c.config.plotOptions.bar.distributed && (g = c.globals.colors[i]);
                for (var m = function (t, r) {
                    var m = n.getFormatters(a);
                    f = n.getSeriesName({
                        fn: m.yLbTitleFormatter,
                        index: a,
                        seriesIndex: a,
                        j: i
                    }), "treemap" === c.config.chart.type && (f = m.yLbTitleFormatter(String(c.config.series[a].data[i].x), {
                        series: c.globals.series,
                        seriesIndex: a,
                        dataPointIndex: i,
                        w: c
                    }));
                    var v = c.config.tooltip.inverseOrder ? r : t;
                    if (c.globals.axisCharts) {
                        var b = function (t) {
                            return m.yLbFormatter(c.globals.series[t][i], {
                                series: c.globals.series,
                                seriesIndex: t,
                                dataPointIndex: i,
                                w: c
                            })
                        };
                        s ? (m = n.getFormatters(v), f = n.getSeriesName({
                            fn: m.yLbTitleFormatter,
                            index: v,
                            seriesIndex: a,
                            j: i
                        }), g = c.globals.colors[v], e = b(v)) : (l && l.target && l.target.getAttribute("fill") && (g = l.target.getAttribute("fill")), e = b(a))
                    }
                    null === i && (e = m.yLbFormatter(c.globals.series[a], d(d({}, c), {}, {
                        seriesIndex: a,
                        dataPointIndex: a
                    }))), n.DOMHandling({
                        i: a,
                        t: v,
                        j: i,
                        ttItems: o,
                        values: {val: e, xVal: u, xAxisTTVal: p, zVal: h},
                        seriesName: f,
                        shared: s,
                        pColor: g
                    })
                }, v = 0, b = c.globals.series.length - 1; v < c.globals.series.length; v++, b--) m(v, b)
            }
        }, {
            key: "getFormatters", value: function (t) {
                var e, n = this.w, a = n.globals.yLabelFormatters[t];
                return void 0 !== n.globals.ttVal ? Array.isArray(n.globals.ttVal) ? (a = n.globals.ttVal[t] && n.globals.ttVal[t].formatter, e = n.globals.ttVal[t] && n.globals.ttVal[t].title && n.globals.ttVal[t].title.formatter) : (a = n.globals.ttVal.formatter, "function" == typeof n.globals.ttVal.title.formatter && (e = n.globals.ttVal.title.formatter)) : e = n.config.tooltip.y.title.formatter, "function" != typeof a && (a = n.globals.yLabelFormatters[0] ? n.globals.yLabelFormatters[0] : function (t) {
                    return t
                }), "function" != typeof e && (e = function (t) {
                    return t
                }), {yLbFormatter: a, yLbTitleFormatter: e}
            }
        }, {
            key: "getSeriesName", value: function (t) {
                var e = t.fn, n = t.index, a = t.seriesIndex, i = t.j, r = this.w;
                return e(String(r.globals.seriesNames[n]), {
                    series: r.globals.series,
                    seriesIndex: a,
                    dataPointIndex: i,
                    w: r
                })
            }
        }, {
            key: "DOMHandling", value: function (t) {
                t.i;
                var e = t.t, n = (t.j, t.ttItems), a = t.values, i = t.seriesName, r = t.shared, o = t.pColor,
                    s = this.w, l = this.ttCtx, c = a.val, d = a.xVal, u = a.xAxisTTVal, h = a.zVal, p = null;
                p = n[e].children, s.config.tooltip.fillSeriesColor && (n[e].style.backgroundColor = o, p[0].style.display = "none"), l.showTooltipTitle && (null === l.tooltipTitle && (l.tooltipTitle = s.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), l.tooltipTitle.innerHTML = d), l.blxaxisTooltip && (l.xaxisTooltipText.innerHTML = "" !== u ? u : d);
                var f = n[e].querySelector(".apexcharts-tooltip-text-label");
                f && (f.innerHTML = i || "");
                var g = n[e].querySelector(".apexcharts-tooltip-text-value");
                g && (g.innerHTML = void 0 !== c ? c : ""), p[0] && p[0].classList.contains("apexcharts-tooltip-marker") && (s.config.tooltip.marker.fillColors && Array.isArray(s.config.tooltip.marker.fillColors) && (o = s.config.tooltip.marker.fillColors[e]), p[0].style.backgroundColor = o), s.config.tooltip.marker.show || (p[0].style.display = "none"), null !== h && (n[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = s.config.tooltip.z.title, n[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== h ? h : ""), r && p[0] && (null == c || s.globals.collapsedSeriesIndices.indexOf(e) > -1 ? p[0].parentNode.style.display = "none" : p[0].parentNode.style.display = s.config.tooltip.items.display)
            }
        }, {
            key: "toggleActiveInactiveSeries", value: function (t) {
                var e = this.w;
                if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable"); else {
                    this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                    var n = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                    n && (n.classList.add("apexcharts-active"), n.style.display = e.config.tooltip.items.display)
                }
            }
        }, {
            key: "getValuesToPrint", value: function (t) {
                var e = t.i, n = t.j, a = this.w, i = this.ctx.series.filteredSeriesX(), r = "", o = "", s = null,
                    l = null, c = {series: a.globals.series, seriesIndex: e, dataPointIndex: n, w: a},
                    d = a.globals.ttZFormatter;
                null === n ? l = a.globals.series[e] : a.globals.isXNumeric && "treemap" !== a.config.chart.type ? (r = i[e][n], 0 === i[e].length && (r = i[this.tooltipUtil.getFirstActiveXArray(i)][n])) : r = void 0 !== a.globals.labels[n] ? a.globals.labels[n] : "";
                var u = r;
                return a.globals.isXNumeric && "datetime" === a.config.xaxis.type ? r = new $(this.ctx).xLabelFormat(a.globals.ttKeyFormatter, u, u, {
                    i: void 0,
                    dateFormatter: new F(this.ctx).formatDate,
                    w: this.w
                }) : a.globals.isBarHorizontal || (r = a.globals.xLabelFormatter(u, c)), void 0 !== a.config.tooltip.x.formatter && (r = a.globals.ttKeyFormatter(u, c)), a.globals.seriesZ.length > 0 && a.globals.seriesZ[e].length > 0 && (s = d(a.globals.seriesZ[e][n], a)), o = "function" == typeof a.config.xaxis.tooltip.formatter ? a.globals.xaxisTooltipFormatter(u, c) : r, {
                    val: Array.isArray(l) ? l.join(" ") : l,
                    xVal: Array.isArray(r) ? r.join(" ") : r,
                    xAxisTTVal: Array.isArray(o) ? o.join(" ") : o,
                    zVal: s
                }
            }
        }, {
            key: "handleCustomTooltip", value: function (t) {
                var e = t.i, n = t.j, a = t.y1, i = t.y2, r = t.w, o = this.ttCtx.getElTooltip(),
                    s = r.config.tooltip.custom;
                Array.isArray(s) && s[e] && (s = s[e]), o.innerHTML = s({
                    ctx: this.ctx,
                    series: r.globals.series,
                    seriesIndex: e,
                    dataPointIndex: n,
                    y1: a,
                    y2: i,
                    w: r
                })
            }
        }]), t
    }(), vt = function () {
        function t(e) {
            r(this, t), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w
        }

        return s(t, [{
            key: "moveXCrosshairs", value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = this.ttCtx,
                    a = this.w, i = n.getElXCrosshairs(), r = t - n.xcrosshairsWidth / 2,
                    o = a.globals.labels.slice().length;
                if (null !== e && (r = a.globals.gridWidth / o * e), null !== i && (i.setAttribute("x", r), i.setAttribute("x1", r), i.setAttribute("x2", r), i.setAttribute("y2", a.globals.gridHeight), i.classList.add("apexcharts-active")), r < 0 && (r = 0), r > a.globals.gridWidth && (r = a.globals.gridWidth), n.blxaxisTooltip) {
                    var s = r;
                    "tickWidth" !== a.config.xaxis.crosshairs.width && "barWidth" !== a.config.xaxis.crosshairs.width || (s = r + n.xcrosshairsWidth / 2), this.moveXAxisTooltip(s)
                }
            }
        }, {
            key: "moveYCrosshairs", value: function (t) {
                var e = this.ttCtx;
                null !== e.ycrosshairs && _.setAttrs(e.ycrosshairs, {
                    y1: t,
                    y2: t
                }), null !== e.ycrosshairsHidden && _.setAttrs(e.ycrosshairsHidden, {y1: t, y2: t})
            }
        }, {
            key: "moveXAxisTooltip", value: function (t) {
                var e = this.w, n = this.ttCtx;
                if (null !== n.xaxisTooltip) {
                    n.xaxisTooltip.classList.add("apexcharts-active");
                    var a,
                        i = n.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY;
                    if (t -= n.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) t += e.globals.translateX, a = new _(this.ctx).getTextRects(n.xaxisTooltipText.innerHTML), n.xaxisTooltipText.style.minWidth = a.width + "px", n.xaxisTooltip.style.left = t + "px", n.xaxisTooltip.style.top = i + "px"
                }
            }
        }, {
            key: "moveYAxisTooltip", value: function (t) {
                var e = this.w, n = this.ttCtx;
                null === n.yaxisTTEls && (n.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                var a = parseInt(n.ycrosshairsHidden.getAttribute("y1"), 10), i = e.globals.translateY + a,
                    r = n.yaxisTTEls[t].getBoundingClientRect().height, o = e.globals.translateYAxisX[t] - 2;
                e.config.yaxis[t].opposite && (o -= 26), i -= r / 2, -1 === e.globals.ignoreYAxisIndexes.indexOf(t) ? (n.yaxisTTEls[t].classList.add("apexcharts-active"), n.yaxisTTEls[t].style.top = i + "px", n.yaxisTTEls[t].style.left = o + e.config.yaxis[t].tooltip.offsetX + "px") : n.yaxisTTEls[t].classList.remove("apexcharts-active")
            }
        }, {
            key: "moveTooltip", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a = this.w,
                    i = this.ttCtx, r = i.getElTooltip(), o = i.tooltipRect, s = null !== n ? parseFloat(n) : 1,
                    l = parseFloat(t) + s + 5, c = parseFloat(e) + s / 2;
                if (l > a.globals.gridWidth / 2 && (l = l - o.ttWidth - s - 15), l > a.globals.gridWidth - o.ttWidth - 10 && (l = a.globals.gridWidth - o.ttWidth), l < -20 && (l = -20), a.config.tooltip.followCursor) {
                    var d = i.getElGrid(), u = d.getBoundingClientRect();
                    c = i.e.clientY + a.globals.translateY - u.top - o.ttHeight / 2
                }
                if (!a.config.tooltip.followCursor) {
                    var h = this.positionChecks(o, l, c);
                    l = h.x, c = h.y
                }
                isNaN(l) || (l += a.globals.translateX, r.style.left = l + "px", r.style.top = c + "px")
            }
        }, {
            key: "positionChecks", value: function (t, e, n) {
                var a = this.w;
                return t.ttHeight / 2 + n > a.globals.gridHeight && (n = a.globals.gridHeight - t.ttHeight + a.globals.translateY), n < 0 && (n = 0), {
                    x: e,
                    y: n
                }
            }
        }, {
            key: "moveMarkers", value: function (t, e) {
                var n = this.w, a = this.ttCtx;
                if (n.globals.markers.size[t] > 0) for (var i = n.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), r = 0; r < i.length; r++) parseInt(i[r].getAttribute("rel"), 10) === e && (a.marker.resetPointsSize(), a.marker.enlargeCurrentPoint(e, i[r])); else a.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t)
            }
        }, {
            key: "moveDynamicPointOnHover", value: function (t, e) {
                var n, a, i = this.w, r = this.ttCtx, o = i.globals.pointsArray,
                    s = r.tooltipUtil.getHoverMarkerSize(e), l = i.config.series[e].type;
                if (!l || "column" !== l && "candlestick" !== l) {
                    n = o[e][t][0], a = o[e][t][1] ? o[e][t][1] : 0;
                    var c = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle"));
                    c && a < i.globals.gridHeight && a > 0 && (c.setAttribute("r", s), c.setAttribute("cx", n), c.setAttribute("cy", a)), this.moveXCrosshairs(n), r.fixedTooltip || this.moveTooltip(n, a, s)
                }
            }
        }, {
            key: "moveDynamicPointsOnHover", value: function (t) {
                var e, n = this.ttCtx, a = n.w, i = 0, r = 0, o = a.globals.pointsArray;
                e = new j(this.ctx).getActiveConfigSeriesIndex(!0);
                var s = n.tooltipUtil.getHoverMarkerSize(e);
                o[e] && (i = o[e][t][0], r = o[e][t][1]);
                var l = n.tooltipUtil.getAllMarkers();
                if (null !== l) for (var c = 0; c < a.globals.series.length; c++) {
                    var d = o[c];
                    if (a.globals.comboCharts && void 0 === d && l.splice(c, 0, null), d && d.length) {
                        var u = o[c][t][1];
                        l[c].setAttribute("cx", i), null !== u && !isNaN(u) && u < a.globals.gridHeight && u > 0 ? (l[c] && l[c].setAttribute("r", s), l[c] && l[c].setAttribute("cy", u)) : l[c] && l[c].setAttribute("r", 0)
                    }
                }
                if (this.moveXCrosshairs(i), !n.fixedTooltip) {
                    var h = r || a.globals.gridHeight;
                    this.moveTooltip(i, h, s)
                }
            }
        }, {
            key: "moveStickyTooltipOverBars", value: function (t) {
                var e, n = this.w, a = this.ttCtx,
                    i = n.globals.columnSeries ? n.globals.columnSeries.length : n.globals.series.length,
                    r = i >= 2 && i % 2 == 0 ? Math.floor(i / 2) : Math.floor(i / 2) + 1,
                    o = n.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r, "'] path[j='").concat(t, "']")),
                    s = o ? parseFloat(o.getAttribute("cx")) : 0, l = o ? parseFloat(o.getAttribute("barWidth")) : 0;
                n.globals.isXNumeric ? s -= i % 2 != 0 ? l / 2 : 0 : (s = a.xAxisTicksPositions[t - 1] + a.dataPointsDividedWidth / 2, isNaN(s) && (s = a.xAxisTicksPositions[t] - a.dataPointsDividedWidth / 2));
                var c = a.getElGrid().getBoundingClientRect();
                if (e = a.e.clientY - c.top - a.tooltipRect.ttHeight / 2, this.moveXCrosshairs(s), !a.fixedTooltip) {
                    var d = e || n.globals.gridHeight;
                    this.moveTooltip(s, d)
                }
            }
        }]), t
    }(), bt = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new vt(e)
        }

        return s(t, [{
            key: "drawDynamicPoints", value: function () {
                var t = this.w, e = new _(this.ctx), n = new M(this.ctx),
                    a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                a = m(a), t.config.chart.stacked && a.sort((function (t, e) {
                    return parseFloat(t.getAttribute("data:realIndex")) - parseFloat(e.getAttribute("data:realIndex"))
                }));
                for (var i = 0; i < a.length; i++) {
                    var r = a[i].querySelector(".apexcharts-series-markers-wrap");
                    if (null !== r) {
                        var o = void 0, s = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                        "line" !== t.config.chart.type && "area" !== t.config.chart.type || t.globals.comboCharts || t.config.tooltip.intersect || (s += " no-pointer-events");
                        var l = n.getMarkerConfig(s, i);
                        (o = e.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
                        var c = document.createElementNS(t.globals.SVGNS, "g");
                        c.classList.add("apexcharts-series-markers"), c.appendChild(o.node), r.appendChild(c)
                    }
                }
            }
        }, {
            key: "enlargeCurrentPoint", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = this.w;
                "bubble" !== i.config.chart.type && this.newPointSize(t, e);
                var r = e.getAttribute("cx"), o = e.getAttribute("cy");
                if (null !== n && null !== a && (r = n, o = a), this.tooltipPosition.moveXCrosshairs(r), !this.fixedTooltip) {
                    if ("radar" === i.config.chart.type) {
                        var s = this.ttCtx.getElGrid(), l = s.getBoundingClientRect();
                        r = this.ttCtx.e.clientX - l.left
                    }
                    this.tooltipPosition.moveTooltip(r, o, i.config.markers.hover.size)
                }
            }
        }, {
            key: "enlargePoints", value: function (t) {
                for (var e = this.w, n = this, a = this.ttCtx, i = t, r = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), o = e.config.markers.hover.size, s = 0; s < r.length; s++) {
                    var l = r[s].getAttribute("rel"), c = r[s].getAttribute("index");
                    if (void 0 === o && (o = e.globals.markers.size[c] + e.config.markers.hover.sizeOffset), i === parseInt(l, 10)) {
                        n.newPointSize(i, r[s]);
                        var d = r[s].getAttribute("cx"), u = r[s].getAttribute("cy");
                        n.tooltipPosition.moveXCrosshairs(d), a.fixedTooltip || n.tooltipPosition.moveTooltip(d, u, o)
                    } else n.oldPointSize(r[s])
                }
            }
        }, {
            key: "newPointSize", value: function (t, e) {
                var n = this.w, a = n.config.markers.hover.size,
                    i = 0 === t ? e.parentNode.firstChild : e.parentNode.lastChild;
                if ("0" !== i.getAttribute("default-marker-size")) {
                    var r = parseInt(i.getAttribute("index"), 10);
                    void 0 === a && (a = n.globals.markers.size[r] + n.config.markers.hover.sizeOffset), i.setAttribute("r", a)
                }
            }
        }, {
            key: "oldPointSize", value: function (t) {
                var e = parseFloat(t.getAttribute("default-marker-size"));
                t.setAttribute("r", e)
            }
        }, {
            key: "resetPointsSize", value: function () {
                for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e = 0; e < t.length; e++) {
                    var n = parseFloat(t[e].getAttribute("default-marker-size"));
                    b.isNumber(n) ? t[e].setAttribute("r", n) : t[e].setAttribute("r", 0)
                }
            }
        }]), t
    }(), yt = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.ttCtx = e
        }

        return s(t, [{
            key: "getAttr", value: function (t, e) {
                return parseFloat(t.target.getAttribute(e))
            }
        }, {
            key: "handleHeatTreeTooltip", value: function (t) {
                var e = t.e, n = t.opt, a = t.x, i = t.y, r = t.type, o = this.ttCtx, s = this.w;
                if (e.target.classList.contains("apexcharts-".concat(r, "-rect"))) {
                    var l = this.getAttr(e, "i"), c = this.getAttr(e, "j"), d = this.getAttr(e, "cx"),
                        u = this.getAttr(e, "cy"), h = this.getAttr(e, "width"), p = this.getAttr(e, "height");
                    if (o.tooltipLabels.drawSeriesTexts({
                        ttItems: n.ttItems,
                        i: l,
                        j: c,
                        shared: !1,
                        e: e
                    }), s.globals.capturedSeriesIndex = l, s.globals.capturedDataPointIndex = c, a = d + o.tooltipRect.ttWidth / 2 + h, i = u + o.tooltipRect.ttHeight / 2 - p / 2, o.tooltipPosition.moveXCrosshairs(d + h / 2), a > s.globals.gridWidth / 2 && (a = d - o.tooltipRect.ttWidth / 2 + h), o.w.config.tooltip.followCursor) {
                        var f = o.getElGrid().getBoundingClientRect();
                        (a = o.e.clientX - f.left + 10) > s.globals.gridWidth / 2 && (a = a - o.tooltipRect.ttWidth - 10), i = o.e.clientY - f.top + s.globals.translateY / 2 - 10
                    }
                }
                return {x: a, y: i}
            }
        }, {
            key: "handleMarkerTooltip", value: function (t) {
                var e, n, a = t.e, i = t.opt, r = t.x, o = t.y, s = this.w, l = this.ttCtx;
                if (a.target.classList.contains("apexcharts-marker")) {
                    var c = parseInt(i.paths.getAttribute("cx"), 10), d = parseInt(i.paths.getAttribute("cy"), 10),
                        u = parseFloat(i.paths.getAttribute("val"));
                    if (n = parseInt(i.paths.getAttribute("rel"), 10), e = parseInt(i.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l.intersect) {
                        var h = b.findAncestor(i.paths, "apexcharts-series");
                        h && (e = parseInt(h.getAttribute("data:realIndex"), 10))
                    }
                    if (l.tooltipLabels.drawSeriesTexts({
                        ttItems: i.ttItems,
                        i: e,
                        j: n,
                        shared: !l.showOnIntersect && s.config.tooltip.shared,
                        e: a
                    }), "mouseup" === a.type && l.markerClick(a, e, n), s.globals.capturedSeriesIndex = e, s.globals.capturedDataPointIndex = n, r = c, o = d + s.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) {
                        var p = l.getElGrid().getBoundingClientRect();
                        o = l.e.clientY + s.globals.translateY - p.top
                    }
                    u < 0 && (o = d), l.marker.enlargeCurrentPoint(n, i.paths, r, o)
                }
                return {x: r, y: o}
            }
        }, {
            key: "handleBarTooltip", value: function (t) {
                var e, n, a = t.e, i = t.opt, r = this.w, o = this.ttCtx, s = o.getElTooltip(), l = 0, c = 0, d = 0,
                    u = this.getBarTooltipXY({e: a, opt: i});
                e = u.i;
                var h = u.barHeight, p = u.j;
                if (r.globals.capturedSeriesIndex = e, r.globals.capturedDataPointIndex = p, r.globals.isBarHorizontal && o.tooltipUtil.hasBars() || !r.config.tooltip.shared ? (c = u.x, d = u.y, n = Array.isArray(r.config.stroke.width) ? r.config.stroke.width[e] : r.config.stroke.width, l = c) : r.globals.comboCharts || r.config.tooltip.shared || (l /= 2), isNaN(d) ? d = r.globals.svgHeight - o.tooltipRect.ttHeight : d < 0 && (d = 0), c + o.tooltipRect.ttWidth > r.globals.gridWidth ? c -= o.tooltipRect.ttWidth : c < 0 && (c = 0), o.w.config.tooltip.followCursor) {
                    var f = o.getElGrid().getBoundingClientRect();
                    d = o.e.clientY - f.top
                }
                if (null === o.tooltip && (o.tooltip = r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r.config.tooltip.shared || (r.globals.comboBarCount > 0 ? o.tooltipPosition.moveXCrosshairs(l + n / 2) : o.tooltipPosition.moveXCrosshairs(l)), !o.fixedTooltip && (!r.config.tooltip.shared || r.globals.isBarHorizontal && o.tooltipUtil.hasBars())) {
                    var g = r.globals.isMultipleYAxis ? r.config.yaxis[m] && r.config.yaxis[m].reversed : r.config.yaxis[0].reversed;
                    g && (c -= o.tooltipRect.ttWidth) < 0 && (c = 0), s.style.left = c + r.globals.translateX + "px";
                    var m = parseInt(i.paths.parentNode.getAttribute("data:realIndex"), 10);
                    !g || r.globals.isBarHorizontal && o.tooltipUtil.hasBars() || (d = d + h - 2 * (r.globals.series[e][p] < 0 ? h : 0)), o.tooltipRect.ttHeight + d > r.globals.gridHeight ? (d = r.globals.gridHeight - o.tooltipRect.ttHeight + r.globals.translateY, s.style.top = d + "px") : s.style.top = d + r.globals.translateY - o.tooltipRect.ttHeight / 2 + "px"
                }
            }
        }, {
            key: "getBarTooltipXY", value: function (t) {
                var e = t.e, n = t.opt, a = this.w, i = null, r = this.ttCtx, o = 0, s = 0, l = 0, c = 0, d = 0,
                    u = e.target.classList;
                if (u.contains("apexcharts-bar-area") || u.contains("apexcharts-candlestick-area") || u.contains("apexcharts-rangebar-area")) {
                    var h = e.target, p = h.getBoundingClientRect(), f = n.elGrid.getBoundingClientRect(), g = p.height;
                    d = p.height;
                    var m = p.width, v = parseInt(h.getAttribute("cx"), 10), b = parseInt(h.getAttribute("cy"), 10);
                    c = parseFloat(h.getAttribute("barWidth"));
                    var y = "touchmove" === e.type ? e.touches[0].clientX : e.clientX;
                    i = parseInt(h.getAttribute("j"), 10), o = parseInt(h.parentNode.getAttribute("rel"), 10) - 1;
                    var x = h.getAttribute("data-range-y1"), _ = h.getAttribute("data-range-y2");
                    a.globals.comboCharts && (o = parseInt(h.parentNode.getAttribute("data:realIndex"), 10)), r.tooltipLabels.drawSeriesTexts({
                        ttItems: n.ttItems,
                        i: o,
                        j: i,
                        y1: x ? parseInt(x, 10) : null,
                        y2: _ ? parseInt(_, 10) : null,
                        shared: !r.showOnIntersect && a.config.tooltip.shared,
                        e: e
                    }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (s = y - f.left + 15, l = b - r.dataPointsDividedHeight + g / 2 - r.tooltipRect.ttHeight / 2) : (s = a.globals.isXNumeric ? v - m / 2 : v - r.dataPointsDividedWidth + m / 2, l = e.clientY - f.top - r.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((s = v) < r.xyRatios.baseLineInvertedY && (s = v - r.tooltipRect.ttWidth), l = b - r.dataPointsDividedHeight + g / 2 - r.tooltipRect.ttHeight / 2) : (s = a.globals.isXNumeric ? v - m / 2 : v - r.dataPointsDividedWidth + m / 2, l = b)
                }
                return {x: s, y: l, barHeight: d, barWidth: c, i: o, j: i}
            }
        }]), t
    }(), xt = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.ttCtx = e
        }

        return s(t, [{
            key: "drawXaxisTooltip", value: function () {
                var t = this.w, e = this.ttCtx, n = "bottom" === t.config.xaxis.position;
                e.xaxisOffY = n ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
                var a = n ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
                    i = t.globals.dom.elWrap;
                e.blxaxisTooltip && null === t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e.xaxisTooltip = document.createElement("div"), e.xaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + t.config.tooltip.theme), i.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement("div"), e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText))
            }
        }, {
            key: "drawYaxisTooltip", value: function () {
                for (var t = this.w, e = this.ttCtx, n = function (n) {
                    var a = t.config.yaxis[n].opposite || t.config.yaxis[n].crosshairs.opposite;
                    e.yaxisOffX = a ? t.globals.gridWidth + 1 : 1;
                    var i = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(n, a ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                    t.globals.yAxisSameScaleIndices.map((function (e, a) {
                        e.map((function (e, a) {
                            a === n && (i += t.config.yaxis[a].show ? " " : " apexcharts-yaxistooltip-hidden")
                        }))
                    }));
                    var r = t.globals.dom.elWrap;
                    null === t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(n)) && (e.yaxisTooltip = document.createElement("div"), e.yaxisTooltip.setAttribute("class", i + " apexcharts-theme-" + t.config.tooltip.theme), r.appendChild(e.yaxisTooltip), 0 === n && (e.yaxisTooltipText = []), e.yaxisTooltipText[n] = document.createElement("div"), e.yaxisTooltipText[n].classList.add("apexcharts-yaxistooltip-text"), e.yaxisTooltip.appendChild(e.yaxisTooltipText[n]))
                }, a = 0; a < t.config.yaxis.length; a++) n(a)
            }
        }, {
            key: "setXCrosshairWidth", value: function () {
                var t = this.w, e = this.ttCtx, n = e.getElXCrosshairs();
                if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
                    var a = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== a && "barWidth" === t.config.xaxis.crosshairs.width) {
                        var i = parseFloat(a.getAttribute("barWidth"));
                        e.xcrosshairsWidth = i
                    } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
                        var r = t.globals.labels.length;
                        e.xcrosshairsWidth = t.globals.gridWidth / r
                    }
                } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
                    var o = t.globals.labels.length;
                    e.xcrosshairsWidth = t.globals.gridWidth / o
                } else if ("barWidth" === t.config.xaxis.crosshairs.width) {
                    var s = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                    if (null !== s) {
                        var l = parseFloat(s.getAttribute("barWidth"));
                        e.xcrosshairsWidth = l
                    } else e.xcrosshairsWidth = 1
                }
                t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), null !== n && e.xcrosshairsWidth > 0 && n.setAttribute("width", e.xcrosshairsWidth)
            }
        }, {
            key: "handleYCrosshair", value: function () {
                var t = this.w, e = this.ttCtx;
                e.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
            }
        }, {
            key: "drawYaxisTooltipText", value: function (t, e, n) {
                var a = this.ttCtx, i = this.w, r = i.globals.yLabelFormatters[t];
                if (a.yaxisTooltips[t]) {
                    var o = a.getElGrid().getBoundingClientRect(), s = (e - o.top) * n.yRatio[t],
                        l = i.globals.maxYArr[t] - i.globals.minYArr[t], c = i.globals.minYArr[t] + (l - s);
                    a.tooltipPosition.moveYCrosshairs(e - o.top), a.yaxisTooltipText[t].innerHTML = r(c), a.tooltipPosition.moveYAxisTooltip(t)
                }
            }
        }]), t
    }(), _t = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w;
            var n = this.w;
            this.tConfig = n.config.tooltip, this.tooltipUtil = new gt(this), this.tooltipLabels = new mt(this), this.tooltipPosition = new vt(this), this.marker = new bt(this), this.intersect = new yt(this), this.axesTooltip = new xt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !n.globals.isBarHorizontal && this.tConfig.shared
        }

        return s(t, [{
            key: "getElTooltip", value: function (t) {
                return t || (t = this), t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip")
            }
        }, {
            key: "getElXCrosshairs", value: function () {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
            }
        }, {
            key: "getElGrid", value: function () {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
            }
        }, {
            key: "drawTooltip", value: function (t) {
                var e = this.w;
                this.xyRatios = t, this.blxaxisTooltip = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.yaxisTooltips = e.config.yaxis.map((function (t, n) {
                    return !!(t.show && t.tooltip.enabled && e.globals.axisCharts)
                })), this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1);
                var n = document.createElement("div");
                if (n.classList.add("apexcharts-tooltip"), n.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(n), e.globals.axisCharts) {
                    this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
                    var a = new G(this.ctx);
                    this.xAxisTicksPositions = a.getXAxisTicksPositions()
                }
                if (!e.globals.comboCharts && !this.tConfig.intersect && "bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) {
                    this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, n.appendChild(this.tooltipTitle));
                    var i = e.globals.series.length;
                    (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (i = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(i), this.addSVGEvents()
                }
            }
        }, {
            key: "createTTElements", value: function (t) {
                for (var e = this.w, n = [], a = this.getElTooltip(), i = 0; i < t; i++) {
                    var r = document.createElement("div");
                    r.classList.add("apexcharts-tooltip-series-group"), r.style.order = e.config.tooltip.inverseOrder ? t - i : i + 1, this.tConfig.shared && this.tConfig.enabledOnSeries && Array.isArray(this.tConfig.enabledOnSeries) && this.tConfig.enabledOnSeries.indexOf(i) < 0 && r.classList.add("apexcharts-tooltip-series-group-hidden");
                    var o = document.createElement("span");
                    o.classList.add("apexcharts-tooltip-marker"), o.style.backgroundColor = e.globals.colors[i], r.appendChild(o);
                    var s = document.createElement("div");
                    s.classList.add("apexcharts-tooltip-text"), s.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, s.style.fontSize = this.tConfig.style.fontSize;
                    var l = document.createElement("div");
                    l.classList.add("apexcharts-tooltip-y-group");
                    var c = document.createElement("span");
                    c.classList.add("apexcharts-tooltip-text-label"), l.appendChild(c);
                    var d = document.createElement("span");
                    d.classList.add("apexcharts-tooltip-text-value"), l.appendChild(d);
                    var u = document.createElement("div");
                    u.classList.add("apexcharts-tooltip-z-group");
                    var h = document.createElement("span");
                    h.classList.add("apexcharts-tooltip-text-z-label"), u.appendChild(h);
                    var p = document.createElement("span");
                    p.classList.add("apexcharts-tooltip-text-z-value"), u.appendChild(p), s.appendChild(l), s.appendChild(u), r.appendChild(s), a.appendChild(r), n.push(r)
                }
                return n
            }
        }, {
            key: "addSVGEvents", value: function () {
                var t = this.w, e = t.config.chart.type, n = this.getElTooltip(),
                    a = !("bar" !== e && "candlestick" !== e && "rangeBar" !== e),
                    i = "area" === e || "line" === e || "scatter" === e || "bubble" === e || "radar" === e,
                    r = t.globals.dom.Paper.node, o = this.getElGrid();
                o && (this.seriesBound = o.getBoundingClientRect());
                var s, l = [], c = [],
                    d = {hoverArea: r, elGrid: o, tooltipEl: n, tooltipY: l, tooltipX: c, ttItems: this.ttItems};
                if (t.globals.axisCharts && (i ? s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a ? s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e && "treemap" !== e || (s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), s && s.length)) for (var u = 0; u < s.length; u++) l.push(s[u].getAttribute("cy")), c.push(s[u].getAttribute("cx"));
                if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || a && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([r], d); else if (a && !t.globals.comboCharts || i && this.showOnIntersect) this.addDatapointEventsListeners(d); else if (!t.globals.axisCharts || "heatmap" === e || "treemap" === e) {
                    var h = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                    this.addPathsEventListeners(h, d)
                }
                if (this.showOnIntersect) {
                    var p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                    p.length > 0 && this.addPathsEventListeners(p, d), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(d)
                }
            }
        }, {
            key: "drawFixedTooltipRect", value: function () {
                var t = this.w, e = this.getElTooltip(), n = e.getBoundingClientRect(), a = n.width + 10,
                    i = n.height + 10, r = this.tConfig.fixed.offsetX, o = this.tConfig.fixed.offsetY,
                    s = this.tConfig.fixed.position.toLowerCase();
                return s.indexOf("right") > -1 && (r = r + t.globals.svgWidth - a + 10), s.indexOf("bottom") > -1 && (o = o + t.globals.svgHeight - i - 10), e.style.left = r + "px", e.style.top = o + "px", {
                    x: r,
                    y: o,
                    ttWidth: a,
                    ttHeight: i
                }
            }
        }, {
            key: "addDatapointEventsListeners", value: function (t) {
                var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-rangebar-area");
                this.addPathsEventListeners(e, t)
            }
        }, {
            key: "addPathsEventListeners", value: function (t, e) {
                for (var n = this, a = function (a) {
                    var i = {
                        paths: t[a],
                        tooltipEl: e.tooltipEl,
                        tooltipY: e.tooltipY,
                        tooltipX: e.tooltipX,
                        elGrid: e.elGrid,
                        hoverArea: e.hoverArea,
                        ttItems: e.ttItems
                    };
                    ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map((function (e) {
                        return t[a].addEventListener(e, n.seriesHover.bind(n, i), {capture: !1, passive: !0})
                    }))
                }, i = 0; i < t.length; i++) a(i)
            }
        }, {
            key: "seriesHover", value: function (t, e) {
                var n = this, a = [], i = this.w;
                i.config.chart.group && (a = this.ctx.getGroupedCharts()), i.globals.axisCharts && (i.globals.minX === -1 / 0 && i.globals.maxX === 1 / 0 || 0 === i.globals.dataPoints) || (a.length ? a.forEach((function (a) {
                    var i = n.getElTooltip(a), r = {
                        paths: t.paths,
                        tooltipEl: i,
                        tooltipY: t.tooltipY,
                        tooltipX: t.tooltipX,
                        elGrid: t.elGrid,
                        hoverArea: t.hoverArea,
                        ttItems: a.w.globals.tooltip.ttItems
                    };
                    a.w.globals.minX === n.w.globals.minX && a.w.globals.maxX === n.w.globals.maxX && a.w.globals.tooltip.seriesHoverByContext({
                        chartCtx: a,
                        ttCtx: a.w.globals.tooltip,
                        opt: r,
                        e: e
                    })
                })) : this.seriesHoverByContext({chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t, e: e}))
            }
        }, {
            key: "seriesHoverByContext", value: function (t) {
                var e = t.chartCtx, n = t.ttCtx, a = t.opt, i = t.e, r = e.w, o = this.getElTooltip();
                n.tooltipRect = {
                    x: 0,
                    y: 0,
                    ttWidth: o.getBoundingClientRect().width,
                    ttHeight: o.getBoundingClientRect().height
                }, n.e = i, !n.tooltipUtil.hasBars() || r.globals.comboCharts || n.isBarShared || this.tConfig.onDatasetHover.highlightDataSeries && new j(e).toggleSeriesOnHover(i, i.target.parentNode), n.fixedTooltip && n.drawFixedTooltipRect(), r.globals.axisCharts ? n.axisChartsTooltips({
                    e: i,
                    opt: a,
                    tooltipRect: n.tooltipRect
                }) : n.nonAxisChartsTooltips({e: i, opt: a, tooltipRect: n.tooltipRect})
            }
        }, {
            key: "axisChartsTooltips", value: function (t) {
                var e, n, a = t.e, i = t.opt, r = this.w, o = i.elGrid.getBoundingClientRect(),
                    s = "touchmove" === a.type ? a.touches[0].clientX : a.clientX,
                    l = "touchmove" === a.type ? a.touches[0].clientY : a.clientY;
                if (this.clientY = l, this.clientX = s, r.globals.capturedSeriesIndex = -1, r.globals.capturedDataPointIndex = -1, l < o.top || l > o.top + o.height) this.handleMouseOut(i); else {
                    if (Array.isArray(this.tConfig.enabledOnSeries) && !r.config.tooltip.shared) {
                        var c = parseInt(i.paths.getAttribute("index"), 10);
                        if (this.tConfig.enabledOnSeries.indexOf(c) < 0) return void this.handleMouseOut(i)
                    }
                    var d = this.getElTooltip(), u = this.getElXCrosshairs(),
                        h = r.globals.xyCharts || "bar" === r.config.chart.type && !r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r.globals.comboCharts && this.tooltipUtil.hasBars();
                    if (r.globals.isBarHorizontal && this.tooltipUtil.hasBars() && (h = !1), "mousemove" === a.type || "touchmove" === a.type || "mouseup" === a.type) {
                        null !== u && u.classList.add("apexcharts-active");
                        var p = this.yaxisTooltips.filter((function (t) {
                            return !0 === t
                        }));
                        if (null !== this.ycrosshairs && p.length && this.ycrosshairs.classList.add("apexcharts-active"), h && !this.showOnIntersect) this.handleStickyTooltip(a, s, l, i); else if ("heatmap" === r.config.chart.type || "treemap" === r.config.chart.type) {
                            var f = this.intersect.handleHeatTreeTooltip({
                                e: a,
                                opt: i,
                                x: e,
                                y: n,
                                type: r.config.chart.type
                            });
                            e = f.x, n = f.y, d.style.left = e + "px", d.style.top = n + "px"
                        } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                            e: a,
                            opt: i
                        }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                            e: a,
                            opt: i,
                            x: e,
                            y: n
                        });
                        if (this.yaxisTooltips.length) for (var g = 0; g < r.config.yaxis.length; g++) this.axesTooltip.drawYaxisTooltipText(g, l, this.xyRatios);
                        i.tooltipEl.classList.add("apexcharts-active")
                    } else "mouseout" !== a.type && "touchend" !== a.type || this.handleMouseOut(i)
                }
            }
        }, {
            key: "nonAxisChartsTooltips", value: function (t) {
                var e = t.e, n = t.opt, a = t.tooltipRect, i = this.w, r = n.paths.getAttribute("rel"),
                    o = this.getElTooltip(), s = i.globals.dom.elWrap.getBoundingClientRect();
                if ("mousemove" === e.type || "touchmove" === e.type) {
                    o.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
                        ttItems: n.ttItems,
                        i: parseInt(r, 10) - 1,
                        shared: !1
                    });
                    var l = i.globals.clientX - s.left - a.ttWidth / 2, c = i.globals.clientY - s.top - a.ttHeight - 10;
                    o.style.left = l + "px", o.style.top = c + "px"
                } else "mouseout" !== e.type && "touchend" !== e.type || o.classList.remove("apexcharts-active")
            }
        }, {
            key: "handleStickyTooltip", value: function (t, e, n, a) {
                var i = this.w, r = this.tooltipUtil.getNearestValues({
                    context: this,
                    hoverArea: a.hoverArea,
                    elGrid: a.elGrid,
                    clientX: e,
                    clientY: n
                }), o = r.j, s = r.capturedSeries;
                r.hoverX < 0 || r.hoverX > i.globals.gridWidth ? this.handleMouseOut(a) : null !== s ? this.handleStickyCapturedSeries(t, s, a, o) : this.tooltipUtil.isXoverlap(o) && this.create(t, this, 0, o, a.ttItems)
            }
        }, {
            key: "handleStickyCapturedSeries", value: function (t, e, n, a) {
                var i = this.w;
                null === i.globals.series[e][a] ? this.handleMouseOut(n) : void 0 !== i.globals.series[e][a] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(a) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, e, a, n.ttItems) : this.create(t, this, e, a, n.ttItems, !1) : this.tooltipUtil.isXoverlap(a) && this.create(t, this, 0, a, n.ttItems)
            }
        }, {
            key: "deactivateHoverFilter", value: function () {
                for (var t = this.w, e = new _(this.ctx), n = t.globals.dom.Paper.select(".apexcharts-bar-area"), a = 0; a < n.length; a++) e.pathMouseLeave(n[a])
            }
        }, {
            key: "handleMouseOut", value: function (t) {
                var e = this.w, n = this.getElXCrosshairs();
                if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e.config.chart.type && this.marker.resetPointsSize(), null !== n && n.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.blxaxisTooltip && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
                    null === this.yaxisTTEls && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                    for (var a = 0; a < this.yaxisTTEls.length; a++) this.yaxisTTEls[a].classList.remove("apexcharts-active")
                }
                e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function (t) {
                    var e = t.getAttribute("data:default-text");
                    t.innerHTML = decodeURIComponent(e)
                }))
            }
        }, {
            key: "markerClick", value: function (t, e, n) {
                var a = this.w;
                "function" == typeof a.config.chart.events.markerClick && a.config.chart.events.markerClick(t, this.ctx, {
                    seriesIndex: e,
                    dataPointIndex: n,
                    w: a
                }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, {seriesIndex: e, dataPointIndex: n, w: a}])
            }
        }, {
            key: "create", value: function (t, e, n, a, i) {
                var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o = this.w, s = e;
                "mouseup" === t.type && this.markerClick(t, n, a), null === r && (r = this.tConfig.shared);
                var l = this.tooltipUtil.hasMarkers(), c = this.tooltipUtil.getElBars();
                if (o.config.legend.tooltipHoverFormatter) {
                    var d = o.config.legend.tooltipHoverFormatter, u = Array.from(this.legendLabels);
                    u.forEach((function (t) {
                        var e = t.getAttribute("data:default-text");
                        t.innerHTML = decodeURIComponent(e)
                    }));
                    for (var h = 0; h < u.length; h++) {
                        var p = u[h], f = parseInt(p.getAttribute("i"), 10),
                            g = decodeURIComponent(p.getAttribute("data:default-text")),
                            m = d(g, {seriesIndex: r ? f : n, dataPointIndex: a, w: o});
                        if (r) p.innerHTML = o.globals.collapsedSeriesIndices.indexOf(f) < 0 ? m : g; else if (p.innerHTML = f === n ? m : g, n === f) break
                    }
                }
                if (r) {
                    if (s.tooltipLabels.drawSeriesTexts({
                        ttItems: i,
                        i: n,
                        j: a,
                        shared: !this.showOnIntersect && this.tConfig.shared
                    }), l && (o.globals.markers.largestSize > 0 ? s.marker.enlargePoints(a) : s.tooltipPosition.moveDynamicPointsOnHover(a)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(c), this.barSeriesHeight > 0)) {
                        var v = new _(this.ctx),
                            b = o.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a, "']"));
                        this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a);
                        for (var y = 0; y < b.length; y++) v.pathMouseEnter(b[y])
                    }
                } else s.tooltipLabels.drawSeriesTexts({
                    shared: !1,
                    ttItems: i,
                    i: n,
                    j: a
                }), this.tooltipUtil.hasBars() && s.tooltipPosition.moveStickyTooltipOverBars(a), l && s.tooltipPosition.moveMarkers(n, a)
            }
        }]), t
    }(), wt = function (t) {
        u(n, L);
        var e = g(n);

        function n() {
            return r(this, n), e.apply(this, arguments)
        }

        return s(n, [{
            key: "draw", value: function (t, e) {
                var n = this, a = this.w;
                this.graphics = new _(this.ctx), this.bar = new L(this.ctx, this.xyRatios);
                var i = new C(this.ctx, a);
                t = i.getLogSeries(t), this.yRatio = i.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t), "100%" === a.config.chart.stackType && (t = a.globals.seriesPercent.slice()), this.series = t, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];
                for (var r = 0; r < t.length; r++) t[r].length > 0 && (this.totalItems += t[r].length);
                for (var o = this.graphics.group({class: "apexcharts-bar-series apexcharts-plot-series"}), s = 0, l = 0, c = function (i, r) {
                    var c = void 0, u = void 0, h = void 0, p = void 0, f = [], g = [],
                        m = a.globals.comboCharts ? e[i] : i;
                    n.yRatio.length > 1 && (n.yaxisIndex = m), n.isReversed = a.config.yaxis[n.yaxisIndex] && a.config.yaxis[n.yaxisIndex].reversed;
                    var v = n.graphics.group({
                        class: "apexcharts-series",
                        seriesName: b.escapeString(a.globals.seriesNames[m]),
                        rel: i + 1,
                        "data:realIndex": m
                    });
                    n.ctx.series.addCollapsedClassToSeries(v, m);
                    var y = n.graphics.group({class: "apexcharts-datalabels", "data:realIndex": m}), x = 0, _ = 0,
                        w = n.initialPositions(s, l, c, u, h, p);
                    l = w.y, x = w.barHeight, u = w.yDivision, p = w.zeroW, s = w.x, _ = w.barWidth, c = w.xDivision, h = w.zeroH, n.yArrj = [], n.yArrjF = [], n.yArrjVal = [], n.xArrj = [], n.xArrjF = [], n.xArrjVal = [], 1 === n.prevY.length && n.prevY[0].every((function (t) {
                        return isNaN(t)
                    })) && (n.prevY[0] = n.prevY[0].map((function (t) {
                        return h
                    })), n.prevYF[0] = n.prevYF[0].map((function (t) {
                        return 0
                    })));
                    for (var S = 0; S < a.globals.dataPoints; S++) {
                        var C = n.barHelpers.getStrokeWidth(i, S, m),
                            k = {indexes: {i: i, j: S, realIndex: m, bc: r}, strokeWidth: C, x: s, y: l, elSeries: v},
                            D = null;
                        n.isHorizontal ? (D = n.drawStackedBarPaths(d(d({}, k), {}, {
                            zeroW: p,
                            barHeight: x,
                            yDivision: u
                        })), _ = n.series[i][S] / n.invertedYRatio) : (D = n.drawStackedColumnPaths(d(d({}, k), {}, {
                            xDivision: c,
                            barWidth: _,
                            zeroH: h
                        })), x = n.series[i][S] / n.yRatio[n.yaxisIndex]), l = D.y, s = D.x, f.push(s), g.push(l);
                        var T = n.barHelpers.getPathFillColor(t, i, S, m);
                        v = n.renderSeries({
                            realIndex: m,
                            pathFill: T,
                            j: S,
                            i: i,
                            pathFrom: D.pathFrom,
                            pathTo: D.pathTo,
                            strokeWidth: C,
                            elSeries: v,
                            x: s,
                            y: l,
                            series: t,
                            barHeight: x,
                            barWidth: _,
                            elDataLabelsWrap: y,
                            type: "bar",
                            visibleSeries: 0
                        })
                    }
                    a.globals.seriesXvalues[m] = f, a.globals.seriesYvalues[m] = g, n.prevY.push(n.yArrj), n.prevYF.push(n.yArrjF), n.prevYVal.push(n.yArrjVal), n.prevX.push(n.xArrj), n.prevXF.push(n.xArrjF), n.prevXVal.push(n.xArrjVal), o.add(v)
                }, u = 0, h = 0; u < t.length; u++, h++) c(u, h);
                return o
            }
        }, {
            key: "initialPositions", value: function (t, e, n, a, i, r) {
                var o, s, l = this.w;
                return this.isHorizontal ? (o = (o = a = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight, 10) / 100, r = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (a - o) / 2) : (s = n = l.globals.gridWidth / l.globals.dataPoints, s = l.globals.isXNumeric && l.globals.dataPoints > 1 ? (n = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : s * parseInt(l.config.plotOptions.bar.columnWidth, 10) / 100, i = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t = l.globals.padHorizontal + (n - s) / 2), {
                    x: t,
                    y: e,
                    yDivision: a,
                    xDivision: n,
                    barHeight: o,
                    barWidth: s,
                    zeroH: i,
                    zeroW: r
                }
            }
        }, {
            key: "drawStackedBarPaths", value: function (t) {
                for (var e, n = t.indexes, a = t.barHeight, i = t.strokeWidth, r = t.zeroW, o = t.x, s = t.y, l = t.yDivision, c = t.elSeries, d = this.w, u = s, h = n.i, p = n.j, f = 0, g = 0; g < this.prevXF.length; g++) f += this.prevXF[g][p];
                if (h > 0) {
                    var m = r;
                    this.prevXVal[h - 1][p] < 0 ? m = this.series[h][p] >= 0 ? this.prevX[h - 1][p] + f - 2 * (this.isReversed ? f : 0) : this.prevX[h - 1][p] : this.prevXVal[h - 1][p] >= 0 && (m = this.series[h][p] >= 0 ? this.prevX[h - 1][p] : this.prevX[h - 1][p] - f + 2 * (this.isReversed ? f : 0)), e = m
                } else e = r;
                o = null === this.series[h][p] ? e : e + this.series[h][p] / this.invertedYRatio - 2 * (this.isReversed ? this.series[h][p] / this.invertedYRatio : 0), this.xArrj.push(o), this.xArrjF.push(Math.abs(e - o)), this.xArrjVal.push(this.series[h][p]);
                var v = this.barHelpers.getBarpaths({
                    barYPosition: u,
                    barHeight: a,
                    x1: e,
                    x2: o,
                    strokeWidth: i,
                    series: this.series,
                    realIndex: n.realIndex,
                    i: h,
                    j: p,
                    w: d
                });
                return this.barHelpers.barBackground({
                    j: p,
                    i: h,
                    y1: u,
                    y2: a,
                    elSeries: c
                }), s += l, {pathTo: v.pathTo, pathFrom: v.pathFrom, x: o, y: s}
            }
        }, {
            key: "drawStackedColumnPaths", value: function (t) {
                var e = t.indexes, n = t.x, a = t.y, i = t.xDivision, r = t.barWidth, o = t.zeroH,
                    s = (t.strokeWidth, t.elSeries), l = this.w, c = e.i, d = e.j, u = e.bc;
                if (l.globals.isXNumeric) {
                    var h = l.globals.seriesX[c][d];
                    h || (h = 0), n = (h - l.globals.minX) / this.xRatio - r / 2
                }
                for (var p, f = n, g = 0, m = 0; m < this.prevYF.length; m++) g += isNaN(this.prevYF[m][d]) ? 0 : this.prevYF[m][d];
                if (c > 0 && !l.globals.isXNumeric || c > 0 && l.globals.isXNumeric && l.globals.seriesX[c - 1][d] === l.globals.seriesX[c][d]) {
                    var v, b, y = Math.min(this.yRatio.length + 1, c + 1);
                    if (void 0 !== this.prevY[c - 1]) for (var x = 1; x < y; x++) if (!isNaN(this.prevY[c - x][d])) {
                        b = this.prevY[c - x][d];
                        break
                    }
                    for (var _ = 1; _ < y; _++) {
                        if (this.prevYVal[c - _][d] < 0) {
                            v = this.series[c][d] >= 0 ? b - g + 2 * (this.isReversed ? g : 0) : b;
                            break
                        }
                        if (this.prevYVal[c - _][d] >= 0) {
                            v = this.series[c][d] >= 0 ? b : b + g - 2 * (this.isReversed ? g : 0);
                            break
                        }
                    }
                    void 0 === v && (v = l.globals.gridHeight), p = this.prevYF[0].every((function (t) {
                        return 0 === t
                    })) && this.prevYF.slice(1, c).every((function (t) {
                        return t.every((function (t) {
                            return isNaN(t)
                        }))
                    })) ? l.globals.gridHeight - o : v
                } else p = l.globals.gridHeight - o;
                a = p - this.series[c][d] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[c][d] / this.yRatio[this.yaxisIndex] : 0), this.yArrj.push(a), this.yArrjF.push(Math.abs(p - a)), this.yArrjVal.push(this.series[c][d]);
                var w = this.barHelpers.getColumnPaths({
                    barXPosition: f,
                    barWidth: r,
                    y1: p,
                    y2: a,
                    yRatio: this.yRatio[this.yaxisIndex],
                    strokeWidth: this.strokeWidth,
                    series: this.series,
                    realIndex: e.realIndex,
                    i: c,
                    j: d,
                    w: l
                });
                return this.barHelpers.barBackground({
                    bc: u,
                    j: d,
                    i: c,
                    x1: f,
                    x2: r,
                    elSeries: s
                }), n += i, {pathTo: w.pathTo, pathFrom: w.pathFrom, x: l.globals.isXNumeric ? n - i : n, y: a}
            }
        }]), n
    }(), St = function (t) {
        u(n, L);
        var e = g(n);

        function n() {
            return r(this, n), e.apply(this, arguments)
        }

        return s(n, [{
            key: "draw", value: function (t, e) {
                var n = this.w, a = new _(this.ctx), i = new I(this.ctx);
                this.candlestickOptions = this.w.config.plotOptions.candlestick;
                var r = new C(this.ctx, n);
                t = r.getLogSeries(t), this.series = t, this.yRatio = r.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
                for (var o = a.group({class: "apexcharts-candlestick-series apexcharts-plot-series"}), s = 0; s < t.length; s++) {
                    var l, c, d, u, h = void 0, p = void 0, f = [], g = [], m = n.globals.comboCharts ? e[s] : s,
                        v = a.group({
                            class: "apexcharts-series",
                            seriesName: b.escapeString(n.globals.seriesNames[m]),
                            rel: s + 1,
                            "data:realIndex": m
                        });
                    t[s].length > 0 && (this.visibleI = this.visibleI + 1), this.yRatio.length > 1 && (this.yaxisIndex = m);
                    var y = this.barHelpers.initialPositions();
                    p = y.y, d = y.barHeight, h = y.x, u = y.barWidth, l = y.xDivision, c = y.zeroH, g.push(h + u / 2);
                    for (var x = a.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": m
                    }), w = 0; w < n.globals.dataPoints; w++) {
                        var S, k = this.barHelpers.getStrokeWidth(s, w, m), D = this.drawCandleStickPaths({
                            indexes: {i: s, j: w, realIndex: m},
                            x: h,
                            y: p,
                            xDivision: l,
                            barWidth: u,
                            zeroH: c,
                            strokeWidth: k,
                            elSeries: v
                        });
                        p = D.y, h = D.x, S = D.color, w > 0 && g.push(h + u / 2), f.push(p);
                        var T = i.fillPath({seriesNumber: m, dataPointIndex: w, color: S, value: t[s][w]}),
                            E = this.candlestickOptions.wick.useFillColor ? S : void 0;
                        this.renderSeries({
                            realIndex: m,
                            pathFill: T,
                            lineFill: E,
                            j: w,
                            i: s,
                            pathFrom: D.pathFrom,
                            pathTo: D.pathTo,
                            strokeWidth: k,
                            elSeries: v,
                            x: h,
                            y: p,
                            series: t,
                            barHeight: d,
                            barWidth: u,
                            elDataLabelsWrap: x,
                            visibleSeries: this.visibleI,
                            type: "candlestick"
                        })
                    }
                    n.globals.seriesXvalues[m] = g, n.globals.seriesYvalues[m] = f, o.add(v)
                }
                return o
            }
        }, {
            key: "drawCandleStickPaths", value: function (t) {
                var e = t.indexes, n = t.x, a = (t.y, t.xDivision), i = t.barWidth, r = t.zeroH, o = t.strokeWidth,
                    s = this.w, l = new _(this.ctx), c = e.i, d = e.j, u = !0,
                    h = s.config.plotOptions.candlestick.colors.upward,
                    p = s.config.plotOptions.candlestick.colors.downward, f = this.yRatio[this.yaxisIndex],
                    g = e.realIndex, m = this.getOHLCValue(g, d), v = r, b = r;
                m.o > m.c && (u = !1);
                var y = Math.min(m.o, m.c), x = Math.max(m.o, m.c);
                s.globals.isXNumeric && (n = (s.globals.seriesX[g][d] - s.globals.minX) / this.xRatio - i / 2);
                var w = n + i * this.visibleI;
                void 0 === this.series[c][d] || null === this.series[c][d] ? y = r : (y = r - y / f, x = r - x / f, v = r - m.h / f, b = r - m.l / f);
                var S = l.move(w, r), C = l.move(w, y);
                return s.globals.previousPaths.length > 0 && (C = this.getPreviousPath(g, d, !0)), S = l.move(w, x) + l.line(w + i / 2, x) + l.line(w + i / 2, v) + l.line(w + i / 2, x) + l.line(w + i, x) + l.line(w + i, y) + l.line(w + i / 2, y) + l.line(w + i / 2, b) + l.line(w + i / 2, y) + l.line(w, y) + l.line(w, x - o / 2), C += l.move(w, y), s.globals.isXNumeric || (n += a), {
                    pathTo: S,
                    pathFrom: C,
                    x: n,
                    y: x,
                    barXPosition: w,
                    color: u ? h : p
                }
            }
        }, {
            key: "getOHLCValue", value: function (t, e) {
                var n = this.w;
                return {
                    o: n.globals.seriesCandleO[t][e],
                    h: n.globals.seriesCandleH[t][e],
                    l: n.globals.seriesCandleL[t][e],
                    c: n.globals.seriesCandleC[t][e]
                }
            }
        }]), n
    }(), Ct = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "checkColorRange", value: function () {
                var t = this.w, e = !1, n = t.config.plotOptions[t.config.chart.type];
                return n.colorScale.ranges.length > 0 && n.colorScale.ranges.map((function (t, n) {
                    t.from <= 0 && (e = !0)
                })), e
            }
        }, {
            key: "getShadeColor", value: function (t, e, n, a) {
                var i = this.w, r = 1, o = i.config.plotOptions[t].shadeIntensity, s = this.determineColor(t, e, n);
                i.globals.hasNegs || a ? r = i.config.plotOptions[t].reverseNegativeShade ? s.percent < 0 ? s.percent / 100 * (1.25 * o) : (1 - s.percent / 100) * (1.25 * o) : s.percent <= 0 ? 1 - (1 + s.percent / 100) * o : (1 - s.percent / 100) * o : (r = 1 - s.percent / 100, "treemap" === t && (r = (1 - s.percent / 100) * (1.25 * o)));
                var l = s.color, c = new b;
                return i.config.plotOptions[t].enableShades && (r < 0 && (r = 0), l = "dark" === this.w.config.theme.mode ? b.hexToRgba(c.shadeColor(-1 * r, s.color), i.config.fill.opacity) : b.hexToRgba(c.shadeColor(r, s.color), i.config.fill.opacity)), {
                    color: l,
                    colorProps: s
                }
            }
        }, {
            key: "determineColor", value: function (t, e, n) {
                var a = this.w, i = a.globals.series[e][n], r = a.config.plotOptions[t],
                    o = r.colorScale.inverse ? n : e;
                a.config.plotOptions[t].distributed && (o = n);
                var s = a.globals.colors[o], l = null, c = Math.min.apply(Math, m(a.globals.series[e])),
                    d = Math.max.apply(Math, m(a.globals.series[e]));
                r.distributed || "heatmap" !== t || (c = a.globals.minY, d = a.globals.maxY), void 0 !== r.colorScale.min && (c = r.colorScale.min < a.globals.minY ? r.colorScale.min : a.globals.minY, d = r.colorScale.max > a.globals.maxY ? r.colorScale.max : a.globals.maxY);
                var u = Math.abs(d) + Math.abs(c), h = 100 * i / (0 === u ? u - 1e-6 : u);
                return r.colorScale.ranges.length > 0 && r.colorScale.ranges.map((function (t, e) {
                    if (i >= t.from && i <= t.to) {
                        s = t.color, l = t.foreColor ? t.foreColor : null, c = t.from, d = t.to;
                        var n = Math.abs(d) + Math.abs(c);
                        h = 100 * i / (0 === n ? n - 1e-6 : n)
                    }
                })), {color: s, foreColor: l, percent: h}
            }
        }, {
            key: "calculateDataLabels", value: function (t) {
                var e = t.text, n = t.x, a = t.y, i = t.i, r = t.j, o = t.colorProps, s = t.fontSize,
                    l = this.w.config.dataLabels, c = new _(this.ctx), d = new P(this.ctx), u = null;
                if (l.enabled) {
                    u = c.group({class: "apexcharts-data-labels"});
                    var h = l.offsetX, p = l.offsetY, f = n + h, g = a + parseFloat(l.style.fontSize) / 3 + p;
                    d.plotDataLabelsText({
                        x: f,
                        y: g,
                        text: e,
                        i: i,
                        j: r,
                        color: o.foreColor,
                        parent: u,
                        fontSize: s,
                        dataLabelsConfig: l
                    })
                }
                return u
            }
        }, {
            key: "addListeners", value: function (t) {
                var e = new _(this.ctx);
                t.node.addEventListener("mouseenter", e.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", e.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", e.pathMouseDown.bind(this, t))
            }
        }]), t
    }(), kt = function () {
        function t(e, n) {
            r(this, t), this.ctx = e, this.w = e.w, this.xRatio = n.xRatio, this.yRatio = n.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new Ct(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
        }

        return s(t, [{
            key: "draw", value: function (t) {
                var e = this.w, n = new _(this.ctx), a = n.group({class: "apexcharts-heatmap"});
                a.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
                var i = e.globals.gridWidth / e.globals.dataPoints, r = e.globals.gridHeight / e.globals.series.length,
                    o = 0, s = !1;
                this.negRange = this.helpers.checkColorRange();
                var l = t.slice();
                e.config.yaxis[0].reversed && (s = !0, l.reverse());
                for (var c = s ? 0 : l.length - 1; s ? c < l.length : c >= 0; s ? c++ : c--) {
                    var d = n.group({
                        class: "apexcharts-series apexcharts-heatmap-series",
                        seriesName: b.escapeString(e.globals.seriesNames[c]),
                        rel: c + 1,
                        "data:realIndex": c
                    });
                    if (this.ctx.series.addCollapsedClassToSeries(d, c), e.config.chart.dropShadow.enabled) {
                        var u = e.config.chart.dropShadow;
                        new y(this.ctx).dropShadow(d, u, c)
                    }
                    for (var h = 0, p = e.config.plotOptions.heatmap.shadeIntensity, f = 0; f < l[c].length; f++) {
                        var g = this.helpers.getShadeColor(e.config.chart.type, c, f, this.negRange), m = g.color,
                            v = g.colorProps;
                        "image" === e.config.fill.type && (m = new I(this.ctx).fillPath({
                            seriesNumber: c,
                            dataPointIndex: f,
                            opacity: e.globals.hasNegs ? v.percent < 0 ? 1 - (1 + v.percent / 100) : p + v.percent / 100 : v.percent / 100,
                            patternID: b.randomId(),
                            width: e.config.fill.image.width ? e.config.fill.image.width : i,
                            height: e.config.fill.image.height ? e.config.fill.image.height : r
                        }));
                        var x = this.rectRadius, w = n.drawRect(h, o, i, r, x);
                        if (w.attr({
                            cx: h,
                            cy: o
                        }), w.node.classList.add("apexcharts-heatmap-rect"), d.add(w), w.attr({
                            fill: m,
                            i: c,
                            index: c,
                            j: f,
                            val: l[c][f],
                            "stroke-width": this.strokeWidth,
                            stroke: e.config.plotOptions.heatmap.useFillColorAsStroke ? m : e.globals.stroke.colors[0],
                            color: m
                        }), this.helpers.addListeners(w), e.config.chart.animations.enabled && !e.globals.dataChanged) {
                            var S = 1;
                            e.globals.resized || (S = e.config.chart.animations.speed), this.animateHeatMap(w, h, o, i, r, S)
                        }
                        if (e.globals.dataChanged) {
                            var C = 1;
                            if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
                                C = this.dynamicAnim.speed;
                                var k = e.globals.previousPaths[c] && e.globals.previousPaths[c][f] && e.globals.previousPaths[c][f].color;
                                k || (k = "rgba(255, 255, 255, 0)"), this.animateHeatColor(w, b.isColorHex(k) ? k : b.rgb2hex(k), b.isColorHex(m) ? m : b.rgb2hex(m), C)
                            }
                        }
                        var D = (0, e.config.dataLabels.formatter)(e.globals.series[c][f], {
                            value: e.globals.series[c][f],
                            seriesIndex: c,
                            dataPointIndex: f,
                            w: e
                        }), T = this.helpers.calculateDataLabels({
                            text: D,
                            x: h + i / 2,
                            y: o + r / 2,
                            i: c,
                            j: f,
                            colorProps: v,
                            series: l
                        });
                        null !== T && d.add(T), h += i
                    }
                    o += r, a.add(d)
                }
                var E = e.globals.yAxisScale[0].result.slice();
                e.config.yaxis[0].reversed ? E.unshift("") : E.push(""), e.globals.yAxisScale[0].result = E;
                var A = e.globals.gridHeight / e.globals.series.length;
                return e.config.yaxis[0].labels.offsetY = -A / 2, a
            }
        }, {
            key: "animateHeatMap", value: function (t, e, n, a, i, r) {
                var o = new x(this.ctx);
                o.animateRect(t, {x: e + a / 2, y: n + i / 2, width: 0, height: 0}, {
                    x: e,
                    y: n,
                    width: a,
                    height: i
                }, r, (function () {
                    o.animationCompleted(t)
                }))
            }
        }, {
            key: "animateHeatColor", value: function (t, e, n, a) {
                t.attr({fill: e}).animate(a).attr({fill: n})
            }
        }]), t
    }(), Dt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "drawYAxisTexts", value: function (t, e, n, a) {
                var i = this.w, r = i.config.yaxis[0], o = i.globals.yLabelFormatters[0];
                return new _(this.ctx).drawText({
                    x: t + r.labels.offsetX,
                    y: e + r.labels.offsetY,
                    text: o(a, n),
                    textAnchor: "middle",
                    fontSize: r.labels.style.fontSize,
                    fontFamily: r.labels.style.fontFamily,
                    foreColor: Array.isArray(r.labels.style.colors) ? r.labels.style.colors[n] : r.labels.style.colors
                })
            }
        }]), t
    }(), Tt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w;
            var n = this.w;
            this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== n.globals.stroke.colors ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = Math.min(n.globals.gridWidth, n.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = n.globals.gridWidth / 2, "radialBar" === n.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(n.config.plotOptions.pie.endAngle - n.config.plotOptions.pie.startAngle), this.initialAngle = n.config.plotOptions.pie.startAngle % this.fullAngle, n.globals.radialSize = this.defaultSize / 2.05 - n.config.stroke.width - (n.config.chart.sparkline.enabled ? 0 : n.config.chart.dropShadow.blur), this.donutSize = n.globals.radialSize * parseInt(n.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = []
        }

        return s(t, [{
            key: "draw", value: function (t) {
                var e = this, n = this.w, a = new _(this.ctx);
                if (this.ret = a.group({class: "apexcharts-pie"}), n.globals.noData) return this.ret;
                for (var i = 0, r = 0; r < t.length; r++) i += b.negToZero(t[r]);
                var o = [], s = a.group();
                0 === i && (i = 1e-5), t.forEach((function (t) {
                    e.maxY = Math.max(e.maxY, t)
                })), n.config.yaxis[0].max && (this.maxY = n.config.yaxis[0].max), "polarArea" === this.chartType && this.drawPolarElements();
                for (var l = 0; l < t.length; l++) {
                    var c = this.fullAngle * b.negToZero(t[l]) / i;
                    o.push(c), "polarArea" === this.chartType ? (o[l] = this.fullAngle / t.length, this.sliceSizes.push(n.globals.radialSize * t[l] / this.maxY)) : this.sliceSizes.push(n.globals.radialSize)
                }
                if (n.globals.dataChanged) {
                    for (var d, u = 0, h = 0; h < n.globals.previousPaths.length; h++) u += b.negToZero(n.globals.previousPaths[h]);
                    for (var p = 0; p < n.globals.previousPaths.length; p++) d = this.fullAngle * b.negToZero(n.globals.previousPaths[p]) / u, this.prevSectorAngleArr.push(d)
                }
                this.donutSize < 0 && (this.donutSize = 0);
                var f = n.config.plotOptions.pie.customScale, g = n.globals.gridWidth / 2, m = n.globals.gridHeight / 2,
                    v = g - n.globals.gridWidth / 2 * f, y = m - n.globals.gridHeight / 2 * f;
                if ("donut" === this.chartType) {
                    var x = a.drawCircle(this.donutSize);
                    x.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: n.config.plotOptions.pie.donut.background ? n.config.plotOptions.pie.donut.background : "transparent"
                    }), s.add(x)
                }
                var w = this.drawArcs(o, t);
                if (this.sliceLabels.forEach((function (t) {
                    w.add(t)
                })), s.attr({transform: "translate(".concat(v, ", ").concat(y, ") scale(").concat(f, ")")}), s.add(w), this.ret.add(s), this.donutDataLabels.show) {
                    var S = this.renderInnerDataLabels(this.donutDataLabels, {
                        hollowSize: this.donutSize,
                        centerX: this.centerX,
                        centerY: this.centerY,
                        opacity: this.donutDataLabels.show,
                        translateX: v,
                        translateY: y
                    });
                    this.ret.add(S)
                }
                return this.ret
            }
        }, {
            key: "drawArcs", value: function (t, e) {
                var n = this.w, a = new y(this.ctx), i = new _(this.ctx), r = new I(this.ctx),
                    o = i.group({class: "apexcharts-slices"}), s = this.initialAngle, l = this.initialAngle,
                    c = this.initialAngle, d = this.initialAngle;
                this.strokeWidth = n.config.stroke.show ? n.config.stroke.width : 0;
                for (var u = 0; u < t.length; u++) {
                    var h = i.group({
                        class: "apexcharts-series apexcharts-pie-series",
                        seriesName: b.escapeString(n.globals.seriesNames[u]),
                        rel: u + 1,
                        "data:realIndex": u
                    });
                    o.add(h), l = d, c = (s = c) + t[u], d = l + this.prevSectorAngleArr[u];
                    var p = c < s ? this.fullAngle + c - s : c - s,
                        f = r.fillPath({seriesNumber: u, size: this.sliceSizes[u], value: e[u]}),
                        g = this.getChangedPath(l, d), m = i.drawPath({
                            d: g,
                            stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[u] : this.lineColorArr,
                            strokeWidth: 0,
                            fill: f,
                            fillOpacity: n.config.fill.opacity,
                            classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(u)
                        });
                    if (m.attr({index: 0, j: u}), n.config.chart.dropShadow.enabled) {
                        var v = n.config.chart.dropShadow;
                        a.dropShadow(m, v, u)
                    }
                    this.addListeners(m, this.donutDataLabels), _.setAttrs(m.node, {
                        "data:angle": p,
                        "data:startAngle": s,
                        "data:strokeWidth": this.strokeWidth,
                        "data:value": e[u]
                    });
                    var x = {x: 0, y: 0};
                    "pie" === this.chartType || "polarArea" === this.chartType ? x = b.polarToCartesian(this.centerX, this.centerY, n.globals.radialSize / 1.25 + n.config.plotOptions.pie.dataLabels.offset, (s + p / 2) % this.fullAngle) : "donut" === this.chartType && (x = b.polarToCartesian(this.centerX, this.centerY, (n.globals.radialSize + this.donutSize) / 2 + n.config.plotOptions.pie.dataLabels.offset, (s + p / 2) % this.fullAngle)), h.add(m);
                    var w = 0;
                    if (!this.initialAnim || n.globals.resized || n.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (w = p / this.fullAngle * n.config.chart.animations.speed) && (w = 1), this.animDur = w + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && n.globals.dataChanged ? this.animatePaths(m, {
                        size: this.sliceSizes[u],
                        endAngle: c,
                        startAngle: s,
                        prevStartAngle: l,
                        prevEndAngle: d,
                        animateStartingPos: !0,
                        i: u,
                        animBeginArr: this.animBeginArr,
                        shouldSetPrevPaths: !0,
                        dur: n.config.chart.animations.dynamicAnimation.speed
                    }) : this.animatePaths(m, {
                        size: this.sliceSizes[u],
                        endAngle: c,
                        startAngle: s,
                        i: u,
                        totalItems: t.length - 1,
                        animBeginArr: this.animBeginArr,
                        dur: w
                    }), n.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && m.click(this.pieClicked.bind(this, u)), n.config.dataLabels.enabled) {
                        var S = x.x, C = x.y, k = 100 * p / this.fullAngle + "%";
                        if (0 !== p && n.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[u]) {
                            var D = n.config.dataLabels.formatter;
                            void 0 !== D && (k = D(n.globals.seriesPercent[u][0], {seriesIndex: u, w: n}));
                            var T = n.globals.dataLabels.style.colors[u], E = i.group({class: "apexcharts-datalabels"}),
                                A = i.drawText({
                                    x: S,
                                    y: C,
                                    text: k,
                                    textAnchor: "middle",
                                    fontSize: n.config.dataLabels.style.fontSize,
                                    fontFamily: n.config.dataLabels.style.fontFamily,
                                    fontWeight: n.config.dataLabels.style.fontWeight,
                                    foreColor: T
                                });
                            if (E.add(A), n.config.dataLabels.dropShadow.enabled) {
                                var M = n.config.dataLabels.dropShadow;
                                a.dropShadow(A, M)
                            }
                            A.node.classList.add("apexcharts-pie-label"), n.config.chart.animations.animate && !1 === n.globals.resized && (A.node.classList.add("apexcharts-pie-label-delay"), A.node.style.animationDelay = n.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(E)
                        }
                    }
                }
                return o
            }
        }, {
            key: "addListeners", value: function (t, e) {
                var n = new _(this.ctx);
                t.node.addEventListener("mouseenter", n.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", n.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", n.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, e)))
            }
        }, {
            key: "animatePaths", value: function (t, e) {
                var n = this.w,
                    a = e.endAngle < e.startAngle ? this.fullAngle + e.endAngle - e.startAngle : e.endAngle - e.startAngle,
                    i = a, r = e.startAngle, o = e.startAngle;
                void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (r = e.prevEndAngle, i = e.prevEndAngle < e.prevStartAngle ? this.fullAngle + e.prevEndAngle - e.prevStartAngle : e.prevEndAngle - e.prevStartAngle), e.i === n.config.series.length - 1 && (a + o > this.fullAngle ? e.endAngle = e.endAngle - (a + o) : a + o < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (a + o)))), a === this.fullAngle && (a = this.fullAngle - .01), this.animateArc(t, r, o, a, i, e)
            }
        }, {
            key: "animateArc", value: function (t, e, n, a, i, r) {
                var o, s = this, l = this.w, c = new x(this.ctx), d = r.size;
                (isNaN(e) || isNaN(i)) && (e = n, i = a, r.dur = 0);
                var u = a, h = n, p = e < n ? this.fullAngle + e - n : e - n;
                l.globals.dataChanged && r.shouldSetPrevPaths && r.prevEndAngle && (o = s.getPiePath({
                    me: s,
                    startAngle: r.prevStartAngle,
                    angle: r.prevEndAngle < r.prevStartAngle ? this.fullAngle + r.prevEndAngle - r.prevStartAngle : r.prevEndAngle - r.prevStartAngle,
                    size: d
                }), t.attr({d: o})), 0 !== r.dur ? t.animate(r.dur, l.globals.easing, r.animBeginArr[r.i]).afterAll((function () {
                    "pie" !== s.chartType && "donut" !== s.chartType && "polarArea" !== s.chartType || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({"stroke-width": s.strokeWidth}), r.i === l.config.series.length - 1 && c.animationCompleted(t)
                })).during((function (l) {
                    u = p + (a - p) * l, r.animateStartingPos && (u = i + (a - i) * l, h = e - i + (n - (e - i)) * l), o = s.getPiePath({
                        me: s,
                        startAngle: h,
                        angle: u,
                        size: d
                    }), t.node.setAttribute("data:pathOrig", o), t.attr({d: o})
                })) : (o = s.getPiePath({
                    me: s,
                    startAngle: h,
                    angle: a,
                    size: d
                }), r.isTrack || (l.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", o), t.attr({
                    d: o,
                    "stroke-width": s.strokeWidth
                }))
            }
        }, {
            key: "pieClicked", value: function (t) {
                var e, n = this.w, a = this, i = a.sliceSizes[t] + (n.config.plotOptions.pie.expandOnClick ? 4 : 0),
                    r = n.globals.dom.Paper.select(".apexcharts-".concat(a.chartType.toLowerCase(), "-slice-").concat(t)).members[0];
                if ("true" !== r.attr("data:pieClicked")) {
                    var o = n.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                    Array.prototype.forEach.call(o, (function (t) {
                        t.setAttribute("data:pieClicked", "false");
                        var e = t.getAttribute("data:pathOrig");
                        t.setAttribute("d", e)
                    })), r.attr("data:pieClicked", "true");
                    var s = parseInt(r.attr("data:startAngle"), 10), l = parseInt(r.attr("data:angle"), 10);
                    e = a.getPiePath({me: a, startAngle: s, angle: l, size: i}), 360 !== l && r.plot(e)
                } else {
                    r.attr({"data:pieClicked": "false"}), this.revertDataLabelsInner(r.node, this.donutDataLabels);
                    var c = r.attr("data:pathOrig");
                    r.attr({d: c})
                }
            }
        }, {
            key: "getChangedPath", value: function (t, e) {
                var n = "";
                return this.dynamicAnim && this.w.globals.dataChanged && (n = this.getPiePath({
                    me: this,
                    startAngle: t,
                    angle: e - t,
                    size: this.size
                })), n
            }
        }, {
            key: "getPiePath", value: function (t) {
                var e = t.me, n = t.startAngle, a = t.angle, i = t.size, r = n, o = Math.PI * (r - 90) / 180, s = a + n;
                Math.ceil(s) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (s = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(s) > this.fullAngle && (s -= this.fullAngle);
                var l = Math.PI * (s - 90) / 180, c = e.centerX + i * Math.cos(o), d = e.centerY + i * Math.sin(o),
                    u = e.centerX + i * Math.cos(l), h = e.centerY + i * Math.sin(l),
                    p = b.polarToCartesian(e.centerX, e.centerY, e.donutSize, s),
                    f = b.polarToCartesian(e.centerX, e.centerY, e.donutSize, r), g = a > 180 ? 1 : 0,
                    m = ["M", c, d, "A", i, i, 0, g, 1, u, h];
                return "donut" === e.chartType ? [].concat(m, ["L", p.x, p.y, "A", e.donutSize, e.donutSize, 0, g, 0, f.x, f.y, "L", c, d, "z"]).join(" ") : "pie" === e.chartType || "polarArea" === e.chartType ? [].concat(m, ["L", e.centerX, e.centerY, "L", c, d]).join(" ") : [].concat(m).join(" ")
            }
        }, {
            key: "drawPolarElements", value: function () {
                var t = this.w, e = new Z(this.ctx), n = new _(this.ctx), a = new Dt(this.ctx), i = n.group(),
                    r = n.group(), o = e.niceScale(0, Math.ceil(this.maxY), t.config.yaxis[0].tickAmount, 0, !0),
                    s = o.result.reverse(), l = o.result.length;
                this.maxY = o.niceMax;
                for (var c = t.globals.radialSize, d = c / (l - 1), u = 0; u < l - 1; u++) {
                    var h = n.drawCircle(c);
                    if (h.attr({
                        cx: this.centerX,
                        cy: this.centerY,
                        fill: "none",
                        "stroke-width": t.config.plotOptions.polarArea.rings.strokeWidth,
                        stroke: t.config.plotOptions.polarArea.rings.strokeColor
                    }), t.config.yaxis[0].show) {
                        var p = a.drawYAxisTexts(this.centerX, this.centerY - c + parseInt(t.config.yaxis[0].labels.style.fontSize, 10) / 2, u, s[u]);
                        r.add(p)
                    }
                    i.add(h), c -= d
                }
                this.ret.add(i), this.ret.add(r)
            }
        }, {
            key: "renderInnerDataLabels", value: function (t, e) {
                var n = this.w, a = new _(this.ctx), i = a.group({
                    class: "apexcharts-datalabels-group",
                    transform: "translate(".concat(e.translateX ? e.translateX : 0, ", ").concat(e.translateY ? e.translateY : 0, ") scale(").concat(n.config.plotOptions.pie.customScale, ")")
                }), r = t.total.show;
                i.node.style.opacity = e.opacity;
                var o, s, l = e.centerX, c = e.centerY;
                o = void 0 === t.name.color ? n.globals.colors[0] : t.name.color;
                var d = t.name.fontSize, u = t.name.fontFamily, h = t.value.fontWeight;
                s = void 0 === t.value.color ? n.config.chart.foreColor : t.value.color;
                var p = t.value.formatter, f = "", g = "";
                if (r ? (o = t.total.color, d = t.total.fontSize, u = t.total.fontFamily, h = t.total.fontWeight, g = t.total.label, f = t.total.formatter(n)) : 1 === n.globals.series.length && (f = p(n.globals.series[0], n), g = n.globals.seriesNames[0]), g && (g = t.name.formatter(g, t.total.show, n)), t.name.show) {
                    var m = a.drawText({
                        x: l,
                        y: c + parseFloat(t.name.offsetY),
                        text: g,
                        textAnchor: "middle",
                        foreColor: o,
                        fontSize: d,
                        fontWeight: h,
                        fontFamily: u
                    });
                    m.node.classList.add("apexcharts-datalabel-label"), i.add(m)
                }
                if (t.value.show) {
                    var v = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY, b = a.drawText({
                        x: l,
                        y: c + v,
                        text: f,
                        textAnchor: "middle",
                        foreColor: s,
                        fontWeight: t.value.fontWeight,
                        fontSize: t.value.fontSize,
                        fontFamily: t.value.fontFamily
                    });
                    b.node.classList.add("apexcharts-datalabel-value"), i.add(b)
                }
                return i
            }
        }, {
            key: "printInnerLabels", value: function (t, e, n, a) {
                var i, r = this.w;
                a ? i = void 0 === t.name.color ? r.globals.colors[parseInt(a.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : r.globals.series.length > 1 && t.total.show && (i = t.total.color);
                var o = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
                    s = r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                n = (0, t.value.formatter)(n, r), a || "function" != typeof t.total.formatter || (n = t.total.formatter(r));
                var l = e === t.total.label;
                e = t.name.formatter(e, l, r), null !== o && (o.textContent = e), null !== s && (s.textContent = n), null !== o && (o.style.fill = i)
            }
        }, {
            key: "printDataLabelsInner", value: function (t, e) {
                var n = this.w, a = t.getAttribute("data:value"),
                    i = n.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
                n.globals.series.length > 1 && this.printInnerLabels(e, i, a, t);
                var r = n.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                null !== r && (r.style.opacity = 1)
            }
        }, {
            key: "revertDataLabelsInner", value: function (t, e, n) {
                var a = this, i = this.w, r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
                    o = !1, s = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"), l = function (t) {
                        var n = t.makeSliceOut, i = t.printLabel;
                        Array.prototype.forEach.call(s, (function (t) {
                            "true" === t.getAttribute("data:pieClicked") && (n && (o = !0), i && a.printDataLabelsInner(t, e))
                        }))
                    };
                if (l({
                    makeSliceOut: !0,
                    printLabel: !1
                }), e.total.show && i.globals.series.length > 1) o && !e.total.showAlways ? l({
                    makeSliceOut: !1,
                    printLabel: !0
                }) : this.printInnerLabels(e, e.total.label, e.total.formatter(i)); else if (l({
                    makeSliceOut: !1,
                    printLabel: !0
                }), !o) if (i.globals.selectedDataPoints.length && i.globals.series.length > 1) if (i.globals.selectedDataPoints[0].length > 0) {
                    var c = i.globals.selectedDataPoints[0],
                        d = i.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c));
                    this.printDataLabelsInner(d, e)
                } else r && i.globals.selectedDataPoints.length && 0 === i.globals.selectedDataPoints[0].length && (r.style.opacity = 0); else r && i.globals.series.length > 1 && (r.style.opacity = 0)
            }
        }]), t
    }(), Et = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
            var n = this.w;
            this.graphics = new _(this.ctx), this.lineColorArr = void 0 !== n.globals.stroke.colors ? n.globals.stroke.colors : n.globals.colors, this.defaultSize = n.globals.svgHeight < n.globals.svgWidth ? n.globals.gridHeight + 1.5 * n.globals.goldenPadding : n.globals.gridWidth, this.maxValue = this.w.globals.maxY, this.minValue = this.w.globals.minY, this.polygons = n.config.plotOptions.radar.polygons, this.strokeWidth = n.config.stroke.show ? n.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - n.config.chart.dropShadow.blur, n.config.xaxis.labels.show && (this.size = this.size - n.globals.xAxisLabelsWidth / 1.75), void 0 !== n.config.plotOptions.radar.size && (this.size = n.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []
        }

        return s(t, [{
            key: "draw", value: function (t) {
                var e = this, n = this.w, a = new I(this.ctx), i = [], r = new P(this.ctx);
                t.length && (this.dataPointsLen = t[n.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
                var o = n.globals.gridWidth / 2, s = n.globals.gridHeight / 2,
                    l = o + n.config.plotOptions.radar.offsetX, c = s + n.config.plotOptions.radar.offsetY,
                    u = this.graphics.group({
                        class: "apexcharts-radar-series apexcharts-plot-series",
                        transform: "translate(".concat(l || 0, ", ").concat(c || 0, ")")
                    }), h = [], p = null, f = null;
                if (this.yaxisLabels = this.graphics.group({class: "apexcharts-yaxis"}), t.forEach((function (t, o) {
                    var s = t.length === n.globals.dataPoints, l = e.graphics.group().attr({
                        class: "apexcharts-series",
                        "data:longestSeries": s,
                        seriesName: b.escapeString(n.globals.seriesNames[o]),
                        rel: o + 1,
                        "data:realIndex": o
                    });
                    e.dataRadiusOfPercent[o] = [], e.dataRadius[o] = [], e.angleArr[o] = [], t.forEach((function (t, n) {
                        var a = Math.abs(e.maxValue - e.minValue);
                        t += Math.abs(e.minValue), e.dataRadiusOfPercent[o][n] = t / a, e.dataRadius[o][n] = e.dataRadiusOfPercent[o][n] * e.size, e.angleArr[o][n] = n * e.disAngle
                    })), h = e.getDataPointsPos(e.dataRadius[o], e.angleArr[o]);
                    var c = e.createPaths(h, {x: 0, y: 0});
                    p = e.graphics.group({class: "apexcharts-series-markers-wrap apexcharts-element-hidden"}), f = e.graphics.group({
                        class: "apexcharts-datalabels",
                        "data:realIndex": o
                    }), n.globals.delayedElements.push({el: p.node, index: o});
                    var u = {
                        i: o,
                        realIndex: o,
                        animationDelay: o,
                        initialSpeed: n.config.chart.animations.speed,
                        dataChangeSpeed: n.config.chart.animations.dynamicAnimation.speed,
                        className: "apexcharts-radar",
                        shouldClipToGrid: !1,
                        bindEventsOnPaths: !1,
                        stroke: n.globals.stroke.colors[o],
                        strokeLineCap: n.config.stroke.lineCap
                    }, g = null;
                    n.globals.previousPaths.length > 0 && (g = e.getPreviousPath(o));
                    for (var m = 0; m < c.linePathsTo.length; m++) {
                        var v = e.graphics.renderPaths(d(d({}, u), {}, {
                            pathFrom: null === g ? c.linePathsFrom[m] : g,
                            pathTo: c.linePathsTo[m],
                            strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[o] : e.strokeWidth,
                            fill: "none",
                            drawShadow: !1
                        }));
                        l.add(v);
                        var x = a.fillPath({seriesNumber: o}), _ = e.graphics.renderPaths(d(d({}, u), {}, {
                            pathFrom: null === g ? c.areaPathsFrom[m] : g,
                            pathTo: c.areaPathsTo[m],
                            strokeWidth: 0,
                            fill: x,
                            drawShadow: !1
                        }));
                        if (n.config.chart.dropShadow.enabled) {
                            var w = new y(e.ctx), S = n.config.chart.dropShadow;
                            w.dropShadow(_, Object.assign({}, S, {noUserSpaceOnUse: !0}), o)
                        }
                        l.add(_)
                    }
                    t.forEach((function (t, a) {
                        var i = new M(e.ctx).getMarkerConfig("apexcharts-marker", o, a),
                            s = e.graphics.drawMarker(h[a].x, h[a].y, i);
                        s.attr("rel", a), s.attr("j", a), s.attr("index", o), s.node.setAttribute("default-marker-size", i.pSize);
                        var c = e.graphics.group({class: "apexcharts-series-markers"});
                        c && c.add(s), p.add(c), l.add(p);
                        var u = n.config.dataLabels;
                        if (u.enabled) {
                            var g = u.formatter(n.globals.series[o][a], {seriesIndex: o, dataPointIndex: a, w: n});
                            r.plotDataLabelsText({
                                x: h[a].x,
                                y: h[a].y,
                                text: g,
                                textAnchor: "middle",
                                i: o,
                                j: o,
                                parent: f,
                                offsetCorrection: !1,
                                dataLabelsConfig: d({}, u)
                            })
                        }
                        l.add(f)
                    })), i.push(l)
                })), this.drawPolygons({parent: u}), n.config.xaxis.labels.show) {
                    var g = this.drawXAxisTexts();
                    u.add(g)
                }
                return u.add(this.yaxisLabels), i.forEach((function (t) {
                    u.add(t)
                })), u
            }
        }, {
            key: "drawPolygons", value: function (t) {
                for (var e = this, n = this.w, a = t.parent, i = new Dt(this.ctx), r = n.globals.yAxisScale[0].result.reverse(), o = r.length, s = [], l = this.size / (o - 1), c = 0; c < o; c++) s[c] = l * c;
                s.reverse();
                var d = [], u = [];
                s.forEach((function (t, n) {
                    var a = e.getPolygonPos(t), i = "";
                    a.forEach((function (t, a) {
                        if (0 === n) {
                            var r = e.graphics.drawLine(t.x, t.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[a] : e.polygons.connectorColors);
                            u.push(r)
                        }
                        0 === a && e.yaxisLabelsTextsPos.push({x: t.x, y: t.y}), i += t.x + "," + t.y + " "
                    })), d.push(i)
                })), d.forEach((function (t, i) {
                    var r = e.polygons.strokeColors, o = e.polygons.strokeWidth,
                        s = e.graphics.drawPolygon(t, Array.isArray(r) ? r[i] : r, Array.isArray(o) ? o[i] : o, n.globals.radarPolygons.fill.colors[i]);
                    a.add(s)
                })), u.forEach((function (t) {
                    a.add(t)
                })), n.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach((function (t, n) {
                    var a = i.drawYAxisTexts(t.x, t.y, n, r[n]);
                    e.yaxisLabels.add(a)
                }))
            }
        }, {
            key: "drawXAxisTexts", value: function () {
                var t = this, e = this.w, n = e.config.xaxis.labels,
                    a = this.graphics.group({class: "apexcharts-xaxis"}), i = this.getPolygonPos(this.size);
                return e.globals.labels.forEach((function (r, o) {
                    var s = e.config.xaxis.labels.formatter, l = new P(t.ctx);
                    if (i[o]) {
                        var c = t.getTextPos(i[o], t.size), u = s(r, {seriesIndex: -1, dataPointIndex: o, w: e});
                        l.plotDataLabelsText({
                            x: c.newX,
                            y: c.newY,
                            text: u,
                            textAnchor: c.textAnchor,
                            i: o,
                            j: o,
                            parent: a,
                            color: Array.isArray(n.style.colors) && n.style.colors[o] ? n.style.colors[o] : "#a8a8a8",
                            dataLabelsConfig: d({textAnchor: c.textAnchor, dropShadow: {enabled: !1}}, n),
                            offsetCorrection: !1
                        })
                    }
                })), a
            }
        }, {
            key: "createPaths", value: function (t, e) {
                var n = this, a = [], i = [], r = [], o = [];
                if (t.length) {
                    i = [this.graphics.move(e.x, e.y)], o = [this.graphics.move(e.x, e.y)];
                    var s = this.graphics.move(t[0].x, t[0].y), l = this.graphics.move(t[0].x, t[0].y);
                    t.forEach((function (e, a) {
                        s += n.graphics.line(e.x, e.y), l += n.graphics.line(e.x, e.y), a === t.length - 1 && (s += "Z", l += "Z")
                    })), a.push(s), r.push(l)
                }
                return {linePathsFrom: i, linePathsTo: a, areaPathsFrom: o, areaPathsTo: r}
            }
        }, {
            key: "getTextPos", value: function (t, e) {
                var n = "middle", a = t.x, i = t.y;
                return Math.abs(t.x) >= 10 ? t.x > 0 ? (n = "start", a += 10) : t.x < 0 && (n = "end", a -= 10) : n = "middle", Math.abs(t.y) >= e - 10 && (t.y < 0 ? i -= 10 : t.y > 0 && (i += 10)), {
                    textAnchor: n,
                    newX: a,
                    newY: i
                }
            }
        }, {
            key: "getPreviousPath", value: function (t) {
                for (var e = this.w, n = null, a = 0; a < e.globals.previousPaths.length; a++) {
                    var i = e.globals.previousPaths[a];
                    i.paths.length > 0 && parseInt(i.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[a].paths[0] && (n = e.globals.previousPaths[a].paths[0].d)
                }
                return n
            }
        }, {
            key: "getDataPointsPos", value: function (t, e) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                t = t || [], e = e || [];
                for (var a = [], i = 0; i < n; i++) {
                    var r = {};
                    r.x = t[i] * Math.sin(e[i]), r.y = -t[i] * Math.cos(e[i]), a.push(r)
                }
                return a
            }
        }, {
            key: "getPolygonPos", value: function (t) {
                for (var e = [], n = 2 * Math.PI / this.dataPointsLen, a = 0; a < this.dataPointsLen; a++) {
                    var i = {};
                    i.x = t * Math.sin(a * n), i.y = -t * Math.cos(a * n), e.push(i)
                }
                return e
            }
        }]), t
    }(), At = function (t) {
        u(n, Tt);
        var e = g(n);

        function n(t) {
            var a;
            r(this, n), (a = e.call(this, t)).ctx = t, a.w = t.w, a.animBeginArr = [0], a.animDur = 0;
            var i = a.w;
            return a.startAngle = i.config.plotOptions.radialBar.startAngle, a.endAngle = i.config.plotOptions.radialBar.endAngle, a.totalAngle = Math.abs(i.config.plotOptions.radialBar.endAngle - i.config.plotOptions.radialBar.startAngle), a.trackStartAngle = i.config.plotOptions.radialBar.track.startAngle, a.trackEndAngle = i.config.plotOptions.radialBar.track.endAngle, a.radialDataLabels = i.config.plotOptions.radialBar.dataLabels, a.trackStartAngle || (a.trackStartAngle = a.startAngle), a.trackEndAngle || (a.trackEndAngle = a.endAngle), 360 === a.endAngle && (a.endAngle = 359.99), a.margin = parseInt(i.config.plotOptions.radialBar.track.margin, 10), a
        }

        return s(n, [{
            key: "draw", value: function (t) {
                var e = this.w, n = new _(this.ctx), a = n.group({class: "apexcharts-radialbar"});
                if (e.globals.noData) return a;
                var i = n.group(), r = this.defaultSize / 2, o = e.globals.gridWidth / 2, s = this.defaultSize / 2.05;
                e.config.chart.sparkline.enabled || (s = s - e.config.stroke.width - e.config.chart.dropShadow.blur);
                var l = e.globals.fill.colors;
                if (e.config.plotOptions.radialBar.track.show) {
                    var c = this.drawTracks({size: s, centerX: o, centerY: r, colorArr: l, series: t});
                    i.add(c)
                }
                var d = this.drawArcs({size: s, centerX: o, centerY: r, colorArr: l, series: t}), u = 360;
                e.config.plotOptions.radialBar.startAngle < 0 && (u = this.totalAngle);
                var h = (360 - u) / 360;
                if (e.globals.radialSize = s - s * h, this.radialDataLabels.value.show) {
                    var p = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                    e.globals.radialSize += p * h
                }
                return i.add(d.g), "front" === e.config.plotOptions.radialBar.hollow.position && (d.g.add(d.elHollow), d.dataLabels && d.g.add(d.dataLabels)), a.add(i), a
            }
        }, {
            key: "drawTracks", value: function (t) {
                var e = this.w, n = new _(this.ctx), a = n.group({class: "apexcharts-tracks"}), i = new y(this.ctx),
                    r = new I(this.ctx), o = this.getStrokeWidth(t);
                t.size = t.size - o / 2;
                for (var s = 0; s < t.series.length; s++) {
                    var l = n.group({class: "apexcharts-radialbar-track apexcharts-track"});
                    a.add(l), l.attr({rel: s + 1}), t.size = t.size - o - this.margin;
                    var c = e.config.plotOptions.radialBar.track, d = r.fillPath({
                        seriesNumber: 0,
                        size: t.size,
                        fillColors: Array.isArray(c.background) ? c.background[s] : c.background,
                        solid: !0
                    }), u = this.trackStartAngle, h = this.trackEndAngle;
                    Math.abs(h) + Math.abs(u) >= 360 && (h = 360 - Math.abs(this.startAngle) - .1);
                    var p = n.drawPath({
                        d: "",
                        stroke: d,
                        strokeWidth: o * parseInt(c.strokeWidth, 10) / 100,
                        fill: "none",
                        strokeOpacity: c.opacity,
                        classes: "apexcharts-radialbar-area"
                    });
                    if (c.dropShadow.enabled) {
                        var f = c.dropShadow;
                        i.dropShadow(p, f)
                    }
                    l.add(p), p.attr("id", "apexcharts-radialbarTrack-" + s), this.animatePaths(p, {
                        centerX: t.centerX,
                        centerY: t.centerY,
                        endAngle: h,
                        startAngle: u,
                        size: t.size,
                        i: s,
                        totalItems: 2,
                        animBeginArr: 0,
                        dur: 0,
                        isTrack: !0,
                        easing: e.globals.easing
                    })
                }
                return a
            }
        }, {
            key: "drawArcs", value: function (t) {
                var e = this.w, n = new _(this.ctx), a = new I(this.ctx), i = new y(this.ctx), r = n.group(),
                    o = this.getStrokeWidth(t);
                t.size = t.size - o / 2;
                var s = e.config.plotOptions.radialBar.hollow.background,
                    l = t.size - o * t.series.length - this.margin * t.series.length - o * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2,
                    c = l - e.config.plotOptions.radialBar.hollow.margin;
                void 0 !== e.config.plotOptions.radialBar.hollow.image && (s = this.drawHollowImage(t, r, l, s));
                var d = this.drawHollow({size: c, centerX: t.centerX, centerY: t.centerY, fill: s || "transparent"});
                if (e.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
                    var u = e.config.plotOptions.radialBar.hollow.dropShadow;
                    i.dropShadow(d, u)
                }
                var h = 1;
                !this.radialDataLabels.total.show && e.globals.series.length > 1 && (h = 0);
                var p = null;
                this.radialDataLabels.show && (p = this.renderInnerDataLabels(this.radialDataLabels, {
                    hollowSize: l,
                    centerX: t.centerX,
                    centerY: t.centerY,
                    opacity: h
                })), "back" === e.config.plotOptions.radialBar.hollow.position && (r.add(d), p && r.add(p));
                var f = !1;
                e.config.plotOptions.radialBar.inverseOrder && (f = !0);
                for (var g = f ? t.series.length - 1 : 0; f ? g >= 0 : g < t.series.length; f ? g-- : g++) {
                    var m = n.group({
                        class: "apexcharts-series apexcharts-radial-series",
                        seriesName: b.escapeString(e.globals.seriesNames[g])
                    });
                    r.add(m), m.attr({
                        rel: g + 1,
                        "data:realIndex": g
                    }), this.ctx.series.addCollapsedClassToSeries(m, g), t.size = t.size - o - this.margin;
                    var v = a.fillPath({seriesNumber: g, size: t.size, value: t.series[g]}), x = this.startAngle,
                        w = void 0, S = b.negToZero(t.series[g] > 100 ? 100 : t.series[g]) / 100,
                        C = Math.round(this.totalAngle * S) + this.startAngle, k = void 0;
                    e.globals.dataChanged && (w = this.startAngle, k = Math.round(this.totalAngle * b.negToZero(e.globals.previousPaths[g]) / 100) + w), Math.abs(C) + Math.abs(x) >= 360 && (C -= .01), Math.abs(k) + Math.abs(w) >= 360 && (k -= .01);
                    var D = C - x,
                        T = Array.isArray(e.config.stroke.dashArray) ? e.config.stroke.dashArray[g] : e.config.stroke.dashArray,
                        E = n.drawPath({
                            d: "",
                            stroke: v,
                            strokeWidth: o,
                            fill: "none",
                            fillOpacity: e.config.fill.opacity,
                            classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + g,
                            strokeDashArray: T
                        });
                    if (_.setAttrs(E.node, {
                        "data:angle": D,
                        "data:value": t.series[g]
                    }), e.config.chart.dropShadow.enabled) {
                        var A = e.config.chart.dropShadow;
                        i.dropShadow(E, A, g)
                    }
                    this.addListeners(E, this.radialDataLabels), m.add(E), E.attr({index: 0, j: g});
                    var M = 0;
                    !this.initialAnim || e.globals.resized || e.globals.dataChanged || (M = (C - x) / 360 * e.config.chart.animations.speed, this.animDur = M / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), e.globals.dataChanged && (M = (C - x) / 360 * e.config.chart.animations.dynamicAnimation.speed, this.animDur = M / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur)), this.animatePaths(E, {
                        centerX: t.centerX,
                        centerY: t.centerY,
                        endAngle: C,
                        startAngle: x,
                        prevEndAngle: k,
                        prevStartAngle: w,
                        size: t.size,
                        i: g,
                        totalItems: 2,
                        animBeginArr: this.animBeginArr,
                        dur: M,
                        shouldSetPrevPaths: !0,
                        easing: e.globals.easing
                    })
                }
                return {g: r, elHollow: d, dataLabels: p}
            }
        }, {
            key: "drawHollow", value: function (t) {
                var e = new _(this.ctx).drawCircle(2 * t.size);
                return e.attr({
                    class: "apexcharts-radialbar-hollow",
                    cx: t.centerX,
                    cy: t.centerY,
                    r: t.size,
                    fill: t.fill
                }), e
            }
        }, {
            key: "drawHollowImage", value: function (t, e, n, a) {
                var i = this.w, r = new I(this.ctx), o = b.randomId(), s = i.config.plotOptions.radialBar.hollow.image;
                if (i.config.plotOptions.radialBar.hollow.imageClipped) r.clippedImgArea({
                    width: n,
                    height: n,
                    image: s,
                    patternID: "pattern".concat(i.globals.cuid).concat(o)
                }), a = "url(#pattern".concat(i.globals.cuid).concat(o, ")"); else {
                    var l = i.config.plotOptions.radialBar.hollow.imageWidth,
                        c = i.config.plotOptions.radialBar.hollow.imageHeight;
                    if (void 0 === l && void 0 === c) {
                        var d = i.globals.dom.Paper.image(s).loaded((function (e) {
                            this.move(t.centerX - e.width / 2 + i.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + i.config.plotOptions.radialBar.hollow.imageOffsetY)
                        }));
                        e.add(d)
                    } else {
                        var u = i.globals.dom.Paper.image(s).loaded((function (e) {
                            this.move(t.centerX - l / 2 + i.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - c / 2 + i.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, c)
                        }));
                        e.add(u)
                    }
                }
                return a
            }
        }, {
            key: "getStrokeWidth", value: function (t) {
                var e = this.w;
                return t.size * (100 - parseInt(e.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t.series.length + 1) - this.margin
            }
        }]), n
    }(), It = function () {
        function t(e) {
            r(this, t), this.w = e.w, this.lineCtx = e
        }

        return s(t, [{
            key: "sameValueSeriesFix", value: function (t, e) {
                var n = this.w;
                if ("line" === n.config.chart.type && ("gradient" === n.config.fill.type || "gradient" === n.config.fill.type[t]) && new C(this.lineCtx.ctx, n).seriesHaveSameValues(t)) {
                    var a = e[t].slice();
                    a[a.length - 1] = a[a.length - 1] + 1e-6, e[t] = a
                }
                return e
            }
        }, {
            key: "calculatePoints", value: function (t) {
                var e = t.series, n = t.realIndex, a = t.x, i = t.y, r = t.i, o = t.j, s = t.prevY, l = this.w, c = [],
                    d = [];
                if (0 === o) {
                    var u = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX;
                    l.globals.isXNumeric && (u = (l.globals.seriesX[n][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX), c.push(u), d.push(b.isNumber(e[r][0]) ? s + l.config.markers.offsetY : null), c.push(a + l.config.markers.offsetX), d.push(b.isNumber(e[r][o + 1]) ? i + l.config.markers.offsetY : null)
                } else c.push(a + l.config.markers.offsetX), d.push(b.isNumber(e[r][o + 1]) ? i + l.config.markers.offsetY : null);
                return {x: c, y: d}
            }
        }, {
            key: "checkPreviousPaths", value: function (t) {
                for (var e = t.pathFromLine, n = t.pathFromArea, a = t.realIndex, i = this.w, r = 0; r < i.globals.previousPaths.length; r++) {
                    var o = i.globals.previousPaths[r];
                    ("line" === o.type || "area" === o.type) && o.paths.length > 0 && parseInt(o.realIndex, 10) === parseInt(a, 10) && ("line" === o.type ? (this.lineCtx.appendPathFrom = !1, e = i.globals.previousPaths[r].paths[0].d) : "area" === o.type && (this.lineCtx.appendPathFrom = !1, n = i.globals.previousPaths[r].paths[0].d, i.config.stroke.show && i.globals.previousPaths[r].paths[1] && (e = i.globals.previousPaths[r].paths[1].d)))
                }
                return {pathFromLine: e, pathFromArea: n}
            }
        }, {
            key: "determineFirstPrevY", value: function (t) {
                var e = t.i, n = t.series, a = t.prevY, i = t.lineYPosition, r = this.w;
                if (void 0 !== n[e][0]) a = (i = r.config.chart.stacked && e > 0 ? this.lineCtx.prevSeriesY[e - 1][0] : this.lineCtx.zeroY) - n[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? n[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0); else if (r.config.chart.stacked && e > 0 && void 0 === n[e][0]) for (var o = e - 1; o >= 0; o--) if (null !== n[o][0] && void 0 !== n[o][0]) {
                    a = i = this.lineCtx.prevSeriesY[o][0];
                    break
                }
                return {prevY: a, lineYPosition: i}
            }
        }]), t
    }(), Mt = function () {
        function t(e, n, a) {
            r(this, t), this.ctx = e, this.w = e.w, this.xyRatios = n, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || a, this.scatter = new R(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new It(this), this.markers = new M(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0
        }

        return s(t, [{
            key: "draw", value: function (t, e, n) {
                var a = this.w, i = new _(this.ctx), r = a.globals.comboCharts ? e : a.config.chart.type,
                    o = i.group({class: "apexcharts-".concat(r, "-series apexcharts-plot-series")}),
                    s = new C(this.ctx, a);
                this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = s.getLogSeries(t), this.yRatio = s.getLogYRatios(this.yRatio);
                for (var l = [], c = 0; c < t.length; c++) {
                    t = this.lineHelpers.sameValueSeriesFix(c, t);
                    var d = a.globals.comboCharts ? n[c] : c;
                    this._initSerieVariables(t, c, d);
                    var u = [], h = [], p = a.globals.padHorizontal + this.categoryAxisCorrection;
                    this.ctx.series.addCollapsedClassToSeries(this.elSeries, d), a.globals.isXNumeric && a.globals.seriesX.length > 0 && (p = (a.globals.seriesX[d][0] - a.globals.minX) / this.xRatio), h.push(p);
                    var f, g = p, m = g, v = this.zeroY;
                    v = this.lineHelpers.determineFirstPrevY({
                        i: c,
                        series: t,
                        prevY: v,
                        lineYPosition: 0
                    }).prevY, u.push(v), f = v;
                    var b = this._calculatePathsFrom({series: t, i: c, realIndex: d, prevX: m, prevY: v}),
                        y = this._iterateOverDataPoints({
                            series: t,
                            realIndex: d,
                            i: c,
                            x: p,
                            y: 1,
                            pX: g,
                            pY: f,
                            pathsFrom: b,
                            linePaths: [],
                            areaPaths: [],
                            seriesIndex: n,
                            lineYPosition: 0,
                            xArrj: h,
                            yArrj: u
                        });
                    this._handlePaths({
                        type: r,
                        realIndex: d,
                        i: c,
                        paths: y
                    }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries)
                }
                if (a.config.chart.stacked) for (var x = l.length; x > 0; x--) o.add(l[x - 1]); else for (var w = 0; w < l.length; w++) o.add(l[w]);
                return o
            }
        }, {
            key: "_initSerieVariables", value: function (t, e, n) {
                var a = this.w, i = new _(this.ctx);
                this.xDivision = a.globals.gridWidth / (a.globals.dataPoints - ("on" === a.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[n] : a.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = n), this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a.globals.gridHeight || "end" === a.config.plotOptions.area.fillTo) && (this.areaBottomY = a.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = i.group({
                    class: "apexcharts-series",
                    seriesName: b.escapeString(a.globals.seriesNames[n])
                }), this.elPointsMain = i.group({
                    class: "apexcharts-series-markers-wrap",
                    "data:realIndex": n
                }), this.elDataLabelsWrap = i.group({class: "apexcharts-datalabels", "data:realIndex": n});
                var r = t[e].length === a.globals.dataPoints;
                this.elSeries.attr({"data:longestSeries": r, rel: e + 1, "data:realIndex": n}), this.appendPathFrom = !0
            }
        }, {
            key: "_calculatePathsFrom", value: function (t) {
                var e, n, a, i, r = t.series, o = t.i, s = t.realIndex, l = t.prevX, c = t.prevY, d = this.w,
                    u = new _(this.ctx);
                if (null === r[o][0]) {
                    for (var h = 0; h < r[o].length; h++) if (null !== r[o][h]) {
                        l = this.xDivision * h, c = this.zeroY - r[o][h] / this.yRatio[this.yaxisIndex], e = u.move(l, c), n = u.move(l, this.areaBottomY);
                        break
                    }
                } else e = u.move(l, c), n = u.move(l, this.areaBottomY) + u.line(l, c);
                if (a = u.move(-1, this.zeroY) + u.line(-1, this.zeroY), i = u.move(-1, this.zeroY) + u.line(-1, this.zeroY), d.globals.previousPaths.length > 0) {
                    var p = this.lineHelpers.checkPreviousPaths({pathFromLine: a, pathFromArea: i, realIndex: s});
                    a = p.pathFromLine, i = p.pathFromArea
                }
                return {prevX: l, prevY: c, linePath: e, areaPath: n, pathFromLine: a, pathFromArea: i}
            }
        }, {
            key: "_handlePaths", value: function (t) {
                var e = t.type, n = t.realIndex, a = t.i, i = t.paths, r = this.w, o = new _(this.ctx),
                    s = new I(this.ctx);
                this.prevSeriesY.push(i.yArrj), r.globals.seriesXvalues[n] = i.xArrj, r.globals.seriesYvalues[n] = i.yArrj, this.pointsChart || r.globals.delayedElements.push({
                    el: this.elPointsMain.node,
                    index: n
                });
                var l = {
                    i: a,
                    realIndex: n,
                    animationDelay: a,
                    initialSpeed: r.config.chart.animations.speed,
                    dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
                    className: "apexcharts-".concat(e)
                };
                if ("area" === e) for (var c = s.fillPath({seriesNumber: n}), u = 0; u < i.areaPaths.length; u++) {
                    var h = o.renderPaths(d(d({}, l), {}, {
                        pathFrom: i.pathFromArea,
                        pathTo: i.areaPaths[u],
                        stroke: "none",
                        strokeWidth: 0,
                        strokeLineCap: null,
                        fill: c
                    }));
                    this.elSeries.add(h)
                }
                if (r.config.stroke.show && !this.pointsChart) {
                    var p;
                    p = "line" === e ? s.fillPath({seriesNumber: n, i: a}) : r.globals.stroke.colors[n];
                    for (var f = 0; f < i.linePaths.length; f++) {
                        var g = o.renderPaths(d(d({}, l), {}, {
                            pathFrom: i.pathFromLine,
                            pathTo: i.linePaths[f],
                            stroke: p,
                            strokeWidth: this.strokeWidth,
                            strokeLineCap: r.config.stroke.lineCap,
                            fill: "none"
                        }));
                        this.elSeries.add(g)
                    }
                }
            }
        }, {
            key: "_iterateOverDataPoints", value: function (t) {
                for (var e = t.series, n = t.realIndex, a = t.i, i = t.x, r = t.y, o = t.pX, s = t.pY, l = t.pathsFrom, c = t.linePaths, d = t.areaPaths, u = t.seriesIndex, h = t.lineYPosition, p = t.xArrj, f = t.yArrj, g = this.w, m = new _(this.ctx), v = this.yRatio, y = l.prevY, x = l.linePath, w = l.areaPath, S = l.pathFromLine, C = l.pathFromArea, k = b.isNumber(g.globals.minYArr[n]) ? g.globals.minYArr[n] : g.globals.minY, D = g.globals.dataPoints > 1 ? g.globals.dataPoints - 1 : g.globals.dataPoints, T = 0; T < D; T++) {
                    var E = void 0 === e[a][T + 1] || null === e[a][T + 1];
                    if (g.globals.isXNumeric) {
                        var A = g.globals.seriesX[n][T + 1];
                        void 0 === g.globals.seriesX[n][T + 1] && (A = g.globals.seriesX[n][D - 1]), i = (A - g.globals.minX) / this.xRatio
                    } else i += this.xDivision;
                    h = g.config.chart.stacked && a > 0 && g.globals.collapsedSeries.length < g.config.series.length - 1 ? this.prevSeriesY[function (t) {
                        for (var e = t, n = 0; n < g.globals.series.length; n++) if (g.globals.collapsedSeriesIndices.indexOf(t) > -1) {
                            e--;
                            break
                        }
                        return e >= 0 ? e : 0
                    }(a - 1)][T + 1] : this.zeroY, r = E ? h - k / v[this.yaxisIndex] + 2 * (this.isReversed ? k / v[this.yaxisIndex] : 0) : h - e[a][T + 1] / v[this.yaxisIndex] + 2 * (this.isReversed ? e[a][T + 1] / v[this.yaxisIndex] : 0), p.push(i), f.push(r);
                    var I = this.lineHelpers.calculatePoints({
                        series: e,
                        x: i,
                        y: r,
                        realIndex: n,
                        i: a,
                        j: T,
                        prevY: y
                    }), M = this._createPaths({
                        series: e,
                        i: a,
                        realIndex: n,
                        j: T,
                        x: i,
                        y: r,
                        pX: o,
                        pY: s,
                        linePath: x,
                        areaPath: w,
                        linePaths: c,
                        areaPaths: d,
                        seriesIndex: u
                    });
                    d = M.areaPaths, c = M.linePaths, o = M.pX, s = M.pY, w = M.areaPath, x = M.linePath, this.appendPathFrom && (S += m.line(i, this.zeroY), C += m.line(i, this.zeroY)), this.handleNullDataPoints(e, I, a, T, n), this._handleMarkersAndLabels({
                        pointsPos: I,
                        series: e,
                        x: i,
                        y: r,
                        prevY: y,
                        i: a,
                        j: T,
                        realIndex: n
                    })
                }
                return {yArrj: f, xArrj: p, pathFromArea: C, areaPaths: d, pathFromLine: S, linePaths: c}
            }
        }, {
            key: "_handleMarkersAndLabels", value: function (t) {
                var e = t.pointsPos, n = (t.series, t.x, t.y, t.prevY, t.i), a = t.j, i = t.realIndex, r = this.w,
                    o = new P(this.ctx);
                if (this.pointsChart) this.scatter.draw(this.elSeries, a, {
                    realIndex: i,
                    pointsPos: e,
                    zRatio: this.zRatio,
                    elParent: this.elPointsMain
                }); else {
                    r.globals.series[n].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                    var s = this.markers.plotChartMarkers(e, i, a + 1);
                    null !== s && this.elPointsMain.add(s)
                }
                var l = o.drawDataLabel(e, i, a + 1, null);
                null !== l && this.elDataLabelsWrap.add(l)
            }
        }, {
            key: "_createPaths", value: function (t) {
                var e = t.series, n = t.i, a = t.realIndex, i = t.j, r = t.x, o = t.y, s = t.pX, l = t.pY,
                    c = t.linePath, d = t.areaPath, u = t.linePaths, h = t.areaPaths, p = t.seriesIndex, f = this.w,
                    g = new _(this.ctx), m = f.config.stroke.curve, v = this.areaBottomY;
                if (Array.isArray(f.config.stroke.curve) && (m = Array.isArray(p) ? f.config.stroke.curve[p[n]] : f.config.stroke.curve[n]), "smooth" === m) {
                    var b = .35 * (r - s);
                    f.globals.hasNullValues ? (null !== e[n][i] && (null !== e[n][i + 1] ? (c = g.move(s, l) + g.curve(s + b, l, r - b, o, r + 1, o), d = g.move(s + 1, l) + g.curve(s + b, l, r - b, o, r + 1, o) + g.line(r, v) + g.line(s, v) + "z") : (c = g.move(s, l), d = g.move(s, l) + "z")), u.push(c), h.push(d)) : (c += g.curve(s + b, l, r - b, o, r, o), d += g.curve(s + b, l, r - b, o, r, o)), s = r, l = o, i === e[n].length - 2 && (d = d + g.curve(s, l, r, o, r, v) + g.move(r, o) + "z", f.globals.hasNullValues || (u.push(c), h.push(d)))
                } else {
                    if (null === e[n][i + 1]) {
                        c += g.move(r, o);
                        var y = f.globals.isXNumeric ? (f.globals.seriesX[a][i] - f.globals.minX) / this.xRatio : r - this.xDivision;
                        d = d + g.line(y, v) + g.move(r, o) + "z"
                    }
                    null === e[n][i] && (c += g.move(r, o), d += g.move(r, v)), "stepline" === m ? (c = c + g.line(r, null, "H") + g.line(null, o, "V"), d = d + g.line(r, null, "H") + g.line(null, o, "V")) : "straight" === m && (c += g.line(r, o), d += g.line(r, o)), i === e[n].length - 2 && (d = d + g.line(r, v) + g.move(r, o) + "z", u.push(c), h.push(d))
                }
                return {linePaths: u, areaPaths: h, pX: s, pY: l, linePath: c, areaPath: d}
            }
        }, {
            key: "handleNullDataPoints", value: function (t, e, n, a, i) {
                var r = this.w;
                if (null === t[n][a] && r.config.markers.showNullDataPoints || 1 === t[n].length) {
                    var o = this.markers.plotChartMarkers(e, i, a + 1, this.strokeWidth - r.config.markers.strokeWidth / 2, !0);
                    null !== o && this.elPointsMain.add(o)
                }
            }
        }]), t
    }();
    window.TreemapSquared = {}, window.TreemapSquared.generate = function () {
        function t(e, n, a, i) {
            this.xoffset = e, this.yoffset = n, this.height = i, this.width = a, this.shortestEdge = function () {
                return Math.min(this.height, this.width)
            }, this.getCoordinates = function (t) {
                var e, n = [], a = this.xoffset, i = this.yoffset, o = r(t) / this.height, s = r(t) / this.width;
                if (this.width >= this.height) for (e = 0; e < t.length; e++) n.push([a, i, a + o, i + t[e] / o]), i += t[e] / o; else for (e = 0; e < t.length; e++) n.push([a, i, a + t[e] / s, i + s]), a += t[e] / s;
                return n
            }, this.cutArea = function (e) {
                var n;
                if (this.width >= this.height) {
                    var a = e / this.height, i = this.width - a;
                    n = new t(this.xoffset + a, this.yoffset, i, this.height)
                } else {
                    var r = e / this.width, o = this.height - r;
                    n = new t(this.xoffset, this.yoffset + r, this.width, o)
                }
                return n
            }
        }

        function e(e, a, i, o, s) {
            return o = void 0 === o ? 0 : o, s = void 0 === s ? 0 : s, function (t) {
                var e, n, a = [];
                for (e = 0; e < t.length; e++) for (n = 0; n < t[e].length; n++) a.push(t[e][n]);
                return a
            }(n(function (t, e) {
                var n, a = [], i = e / r(t);
                for (n = 0; n < t.length; n++) a[n] = t[n] * i;
                return a
            }(e, a * i), [], new t(o, s, a, i), []))
        }

        function n(t, e, i, o) {
            var s, l, c;
            if (0 !== t.length) return s = i.shortestEdge(), function (t, e, n) {
                var i;
                return 0 === t.length || ((i = t.slice()).push(e), a(t, n) >= a(i, n))
            }(e, l = t[0], s) ? (e.push(l), n(t.slice(1), e, i, o)) : (c = i.cutArea(r(e), o), o.push(i.getCoordinates(e)), n(t, [], c, o)), o;
            o.push(i.getCoordinates(e))
        }

        function a(t, e) {
            var n = Math.min.apply(Math, t), a = Math.max.apply(Math, t), i = r(t);
            return Math.max(Math.pow(e, 2) * a / Math.pow(i, 2), Math.pow(i, 2) / (Math.pow(e, 2) * n))
        }

        function i(t) {
            return t && t.constructor === Array
        }

        function r(t) {
            var e, n = 0;
            for (e = 0; e < t.length; e++) n += t[e];
            return n
        }

        function o(t) {
            var e, n = 0;
            if (i(t[0])) for (e = 0; e < t.length; e++) n += o(t[e]); else n = r(t);
            return n
        }

        return function t(n, a, r, s, l) {
            s = void 0 === s ? 0 : s, l = void 0 === l ? 0 : l;
            var c, d, u = [], h = [];
            if (i(n[0])) {
                for (d = 0; d < n.length; d++) u[d] = o(n[d]);
                for (c = e(u, a, r, s, l), d = 0; d < n.length; d++) h.push(t(n[d], c[d][2] - c[d][0], c[d][3] - c[d][1], c[d][0], c[d][1]))
            } else h = e(n, a, r, s, l);
            return h
        }
    }();
    var Rt, Pt, Ot = function () {
        function t(e, n) {
            r(this, t), this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new Ct(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = []
        }

        return s(t, [{
            key: "draw", value: function (t) {
                var e = this, n = this.w, a = new _(this.ctx), i = new I(this.ctx),
                    r = a.group({class: "apexcharts-treemap"}), o = [];
                return t.forEach((function (t) {
                    var e = t.map((function (t) {
                        return Math.abs(t)
                    }));
                    o.push(e)
                })), this.negRange = this.helpers.checkColorRange(), n.config.series.forEach((function (t, n) {
                    t.data.forEach((function (t) {
                        Array.isArray(e.labels[n]) || (e.labels[n] = []), e.labels[n].push(t.x)
                    }))
                })), window.TreemapSquared.generate(o, n.globals.gridWidth, n.globals.gridHeight).forEach((function (o, s) {
                    var l = a.group({
                        class: "apexcharts-series apexcharts-treemap-series",
                        seriesName: b.escapeString(n.globals.seriesNames[s]),
                        rel: s + 1,
                        "data:realIndex": s
                    });
                    if (n.config.chart.dropShadow.enabled) {
                        var c = n.config.chart.dropShadow;
                        new y(e.ctx).dropShadow(r, c, s)
                    }
                    var d = a.group({class: "apexcharts-data-labels"});
                    o.forEach((function (r, o) {
                        var c = r[0], d = r[1], u = r[2], h = r[3],
                            p = a.drawRect(c, d, u - c, h - d, 0, "#fff", 1, e.strokeWidth, n.config.plotOptions.treemap.useFillColorAsStroke ? g : n.globals.stroke.colors[s]);
                        p.attr({cx: c, cy: d, i: s, j: o, width: u - c, height: h - d});
                        var f = e.helpers.getShadeColor(n.config.chart.type, s, o, e.negRange), g = f.color;
                        void 0 !== n.config.series[s].data[o] && n.config.series[s].data[o].fillColor && (g = n.config.series[s].data[o].fillColor);
                        var m = i.fillPath({color: g, seriesNumber: s, dataPointIndex: o});
                        p.node.classList.add("apexcharts-treemap-rect"), p.attr({fill: m}), e.helpers.addListeners(p);
                        var v = {x: c + (u - c) / 2, y: d + (h - d) / 2, width: 0, height: 0},
                            b = {x: c, y: d, width: u - c, height: h - d};
                        if (n.config.chart.animations.enabled && !n.globals.dataChanged) {
                            var y = 1;
                            n.globals.resized || (y = n.config.chart.animations.speed), e.animateTreemap(p, v, b, y)
                        }
                        if (n.globals.dataChanged) {
                            var x = 1;
                            e.dynamicAnim.enabled && n.globals.shouldAnimate && (x = e.dynamicAnim.speed, n.globals.previousPaths[s][o] && n.globals.previousPaths[s][o].rect && (v = n.globals.previousPaths[s][o].rect), e.animateTreemap(p, v, b, x))
                        }
                        var _ = e.getFontSize(r), w = n.config.dataLabels.formatter(e.labels[s][o], {
                            value: n.globals.series[s][o],
                            seriesIndex: s,
                            dataPointIndex: o,
                            w: n
                        }), S = e.helpers.calculateDataLabels({
                            text: w,
                            x: (c + u) / 2,
                            y: (d + h) / 2 + e.strokeWidth / 2 + _ / 3,
                            i: s,
                            j: o,
                            colorProps: f,
                            fontSize: _,
                            series: t
                        });
                        n.config.dataLabels.enabled && S && e.rotateToFitLabel(S, w, c, d, u, h), l.add(p), null !== S && l.add(S)
                    })), l.add(d), r.add(l)
                })), r
            }
        }, {
            key: "getFontSize", value: function (t) {
                var e, n, a = this.w, i = function t(e) {
                    var n, a = 0;
                    if (Array.isArray(e[0])) for (n = 0; n < e.length; n++) a += t(e[n]); else for (n = 0; n < e.length; n++) a += e[n].length;
                    return a
                }(this.labels) / function t(e) {
                    var n, a = 0;
                    if (Array.isArray(e[0])) for (n = 0; n < e.length; n++) a += t(e[n]); else for (n = 0; n < e.length; n++) a += 1;
                    return a
                }(this.labels);
                return e = (t[2] - t[0]) * (t[3] - t[1]), n = Math.pow(e, .5), Math.min(n / i, parseInt(a.config.dataLabels.style.fontSize, 10))
            }
        }, {
            key: "rotateToFitLabel", value: function (t, e, n, a, i, r) {
                var o = new _(this.ctx), s = o.getTextRects(e);
                if (s.width + 5 > i - n && s.width <= r - a) {
                    var l = o.rotateAroundCenter(t.node);
                    t.node.setAttribute("transform", "rotate(-90 ".concat(l.x, " ").concat(l.y, ")"))
                }
            }
        }, {
            key: "animateTreemap", value: function (t, e, n, a) {
                var i = new x(this.ctx);
                i.animateRect(t, {x: e.x, y: e.y, width: e.width, height: e.height}, {
                    x: n.x,
                    y: n.y,
                    width: n.width,
                    height: n.height
                }, a, (function () {
                    i.animationCompleted(t)
                }))
            }
        }]), t
    }(), jt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC
        }

        return s(t, [{
            key: "calculateTimeScaleTicks", value: function (t, e) {
                var n = this, a = this.w;
                if (a.globals.allSeriesCollapsed) return a.globals.labels = [], a.globals.timescaleLabels = [], [];
                var i = new F(this.ctx), r = (e - t) / 864e5;
                this.determineInterval(r), a.globals.disableZoomIn = !1, a.globals.disableZoomOut = !1, r < .005 ? a.globals.disableZoomIn = !0 : r > 5e4 && (a.globals.disableZoomOut = !0);
                var o = i.getTimeUnitsfromTimestamp(t, e, this.utc), s = a.globals.gridWidth / r, l = s / 24,
                    c = l / 60, u = c / 60, h = Math.floor(24 * r), p = Math.floor(24 * r * 60),
                    f = Math.floor(24 * r * 60 * 60), g = Math.floor(r), m = Math.floor(r / 30),
                    v = Math.floor(r / 365), b = {
                        minSecond: o.minSecond,
                        minMinute: o.minMinute,
                        minHour: o.minHour,
                        minDate: o.minDate,
                        minMonth: o.minMonth,
                        minYear: o.minYear
                    }, y = {
                        firstVal: b,
                        currentSecond: b.minSecond,
                        currentMinute: b.minMinute,
                        currentHour: b.minHour,
                        currentMonthDate: b.minDate,
                        currentDate: b.minDate,
                        currentMonth: b.minMonth,
                        currentYear: b.minYear,
                        daysWidthOnXAxis: s,
                        hoursWidthOnXAxis: l,
                        minutesWidthOnXAxis: c,
                        secondsWidthOnXAxis: u,
                        numberOfSeconds: f,
                        numberOfMinutes: p,
                        numberOfHours: h,
                        numberOfDays: g,
                        numberOfMonths: m,
                        numberOfYears: v
                    };
                switch (this.tickInterval) {
                    case"years":
                        this.generateYearScale(y);
                        break;
                    case"months":
                    case"half_year":
                        this.generateMonthScale(y);
                        break;
                    case"months_days":
                    case"months_fortnight":
                    case"days":
                    case"week_days":
                        this.generateDayScale(y);
                        break;
                    case"hours":
                        this.generateHourScale(y);
                        break;
                    case"minutes":
                        this.generateMinuteScale(y)
                }
                var x = this.timeScaleArray.map((function (t) {
                    var e = {
                        position: t.position,
                        unit: t.unit,
                        year: t.year,
                        day: t.day ? t.day : 1,
                        hour: t.hour ? t.hour : 0,
                        month: t.month + 1
                    };
                    return "month" === t.unit ? d(d({}, e), {}, {
                        day: 1,
                        value: t.value + 1
                    }) : "day" === t.unit || "hour" === t.unit ? d(d({}, e), {}, {value: t.value}) : "minute" === t.unit ? d(d({}, e), {}, {
                        value: t.value,
                        minute: t.value
                    }) : t
                }));
                return x.filter((function (t) {
                    var e = 1, i = Math.ceil(a.globals.gridWidth / 120), r = t.value;
                    void 0 !== a.config.xaxis.tickAmount && (i = a.config.xaxis.tickAmount), x.length > i && (e = Math.floor(x.length / i));
                    var o = !1, s = !1;
                    switch (n.tickInterval) {
                        case"years":
                            "year" === t.unit && (o = !0);
                            break;
                        case"half_year":
                            e = 7, "year" === t.unit && (o = !0);
                            break;
                        case"months":
                            e = 1, "year" === t.unit && (o = !0);
                            break;
                        case"months_fortnight":
                            e = 15, "year" !== t.unit && "month" !== t.unit || (o = !0), 30 === r && (s = !0);
                            break;
                        case"months_days":
                            e = 10, "month" === t.unit && (o = !0), 30 === r && (s = !0);
                            break;
                        case"week_days":
                            e = 8, "month" === t.unit && (o = !0);
                            break;
                        case"days":
                            e = 1, "month" === t.unit && (o = !0);
                            break;
                        case"hours":
                            "day" === t.unit && (o = !0);
                            break;
                        case"minutes":
                            r % 5 != 0 && (s = !0)
                    }
                    if ("minutes" === n.tickInterval || "hours" === n.tickInterval) {
                        if (!s) return !0
                    } else if ((r % e == 0 || o) && !s) return !0
                }))
            }
        }, {
            key: "recalcDimensionsBasedOnFormat", value: function (t, e) {
                var n = this.w, a = this.formatDates(t), i = this.removeOverlappingTS(a);
                n.globals.timescaleLabels = i.slice(), new dt(this.ctx).plotCoords()
            }
        }, {
            key: "determineInterval", value: function (t) {
                switch (!0) {
                    case t > 1825:
                        this.tickInterval = "years";
                        break;
                    case t > 800 && t <= 1825:
                        this.tickInterval = "half_year";
                        break;
                    case t > 180 && t <= 800:
                        this.tickInterval = "months";
                        break;
                    case t > 90 && t <= 180:
                        this.tickInterval = "months_fortnight";
                        break;
                    case t > 60 && t <= 90:
                        this.tickInterval = "months_days";
                        break;
                    case t > 30 && t <= 60:
                        this.tickInterval = "week_days";
                        break;
                    case t > 2 && t <= 30:
                        this.tickInterval = "days";
                        break;
                    case t > .1 && t <= 2:
                        this.tickInterval = "hours";
                        break;
                    case t < .1:
                        this.tickInterval = "minutes";
                        break;
                    default:
                        this.tickInterval = "days"
                }
            }
        }, {
            key: "generateYearScale", value: function (t) {
                var e = t.firstVal, n = t.currentMonth, a = t.currentYear, i = t.daysWidthOnXAxis, r = t.numberOfYears,
                    o = e.minYear, s = 0, l = new F(this.ctx), c = "year";
                if (e.minDate > 1 || e.minMonth > 0) {
                    var d = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
                    s = (l.determineDaysOfYear(e.minYear) - d + 1) * i, o = e.minYear + 1, this.timeScaleArray.push({
                        position: s,
                        value: o,
                        unit: c,
                        year: o,
                        month: b.monthMod(n + 1)
                    })
                } else 1 === e.minDate && 0 === e.minMonth && this.timeScaleArray.push({
                    position: s,
                    value: o,
                    unit: c,
                    year: a,
                    month: b.monthMod(n + 1)
                });
                for (var u = o, h = s, p = 0; p < r; p++) u++, h = l.determineDaysOfYear(u - 1) * i + h, this.timeScaleArray.push({
                    position: h,
                    value: u,
                    unit: c,
                    year: u,
                    month: 1
                })
            }
        }, {
            key: "generateMonthScale", value: function (t) {
                var e = t.firstVal, n = t.currentMonthDate, a = t.currentMonth, i = t.currentYear,
                    r = t.daysWidthOnXAxis, o = t.numberOfMonths, s = a, l = 0, c = new F(this.ctx), d = "month", u = 0;
                if (e.minDate > 1) {
                    l = (c.determineDaysOfMonths(a + 1, e.minYear) - n + 1) * r, s = b.monthMod(a + 1);
                    var h = i + u, p = b.monthMod(s), f = s;
                    0 === s && (d = "year", f = h, p = 1, h += u += 1), this.timeScaleArray.push({
                        position: l,
                        value: f,
                        unit: d,
                        year: h,
                        month: p
                    })
                } else this.timeScaleArray.push({position: l, value: s, unit: d, year: i, month: b.monthMod(a)});
                for (var g = s + 1, m = l, v = 0, y = 1; v < o; v++, y++) {
                    0 === (g = b.monthMod(g)) ? (d = "year", u += 1) : d = "month";
                    var x = this._getYear(i, g, u);
                    m = c.determineDaysOfMonths(g, x) * r + m;
                    var _ = 0 === g ? x : g;
                    this.timeScaleArray.push({position: m, value: _, unit: d, year: x, month: 0 === g ? 1 : g}), g++
                }
            }
        }, {
            key: "generateDayScale", value: function (t) {
                var e = t.firstVal, n = t.currentMonth, a = t.currentYear, i = t.hoursWidthOnXAxis, r = t.numberOfDays,
                    o = new F(this.ctx), s = "day", l = e.minDate + 1, c = l, d = function (t, e, n) {
                        return t > o.determineDaysOfMonths(e + 1, n) ? (c = 1, s = "month", h = e += 1, e) : e
                    }, u = (24 - e.minHour) * i, h = l, p = d(c, n, a);
                0 === e.minHour && 1 === e.minDate && (u = 0, h = b.monthMod(e.minMonth), s = "month", c = e.minDate, r++), this.timeScaleArray.push({
                    position: u,
                    value: h,
                    unit: s,
                    year: this._getYear(a, p, 0),
                    month: b.monthMod(p),
                    day: c
                });
                for (var f = u, g = 0; g < r; g++) {
                    s = "day", p = d(c += 1, p, this._getYear(a, p, 0));
                    var m = this._getYear(a, p, 0);
                    f = 24 * i + f;
                    var v = 1 === c ? b.monthMod(p) : c;
                    this.timeScaleArray.push({position: f, value: v, unit: s, year: m, month: b.monthMod(p), day: v})
                }
            }
        }, {
            key: "generateHourScale", value: function (t) {
                var e = t.firstVal, n = t.currentDate, a = t.currentMonth, i = t.currentYear, r = t.minutesWidthOnXAxis,
                    o = t.numberOfHours, s = new F(this.ctx), l = "hour", c = function (t, e) {
                        return t > s.determineDaysOfMonths(e + 1, i) && (g = 1, e += 1), {month: e, date: g}
                    }, d = function (t, e) {
                        return t > s.determineDaysOfMonths(e + 1, i) ? e += 1 : e
                    }, u = 60 - (e.minMinute + e.minSecond / 60), h = u * r, p = e.minHour + 1, f = p + 1;
                60 === u && (h = 0, f = (p = e.minHour) + 1);
                var g = n, m = d(g, a);
                this.timeScaleArray.push({
                    position: h,
                    value: p,
                    unit: l,
                    day: g,
                    hour: f,
                    year: i,
                    month: b.monthMod(m)
                });
                for (var v = h, y = 0; y < o; y++) {
                    l = "hour", f >= 24 && (f = 0, l = "day", m = c(g += 1, m).month, m = d(g, m));
                    var x = this._getYear(i, m, 0);
                    v = 0 === f && 0 === y ? u * r : 60 * r + v;
                    var _ = 0 === f ? g : f;
                    this.timeScaleArray.push({
                        position: v,
                        value: _,
                        unit: l,
                        hour: f,
                        day: g,
                        year: x,
                        month: b.monthMod(m)
                    }), f++
                }
            }
        }, {
            key: "generateMinuteScale", value: function (t) {
                var e = t.firstVal, n = (t.currentSecond, t.currentMinute, t.currentHour), a = t.currentDate,
                    i = t.currentMonth, r = t.currentYear, o = t.minutesWidthOnXAxis, s = t.secondsWidthOnXAxis,
                    l = t.numberOfMinutes, c = "minute", d = (60 - e.minSecond) * s, u = e.minMinute + 1, h = u + 1,
                    p = a, f = i, g = r, m = n;
                this.timeScaleArray.push({
                    position: d,
                    value: u,
                    unit: c,
                    day: p,
                    hour: m,
                    minute: h,
                    year: g,
                    month: b.monthMod(f)
                });
                for (var v = d, y = 0; y < l; y++) h >= 60 && (h = 0, 24 === (m += 1) && (m = 0)), v = o + v, this.timeScaleArray.push({
                    position: v,
                    value: h,
                    unit: c,
                    hour: m,
                    minute: h,
                    day: p,
                    year: this._getYear(r, f, 0),
                    month: b.monthMod(f)
                }), h++
            }
        }, {
            key: "createRawDateString", value: function (t, e) {
                var n = t.year;
                return n += "-" + ("0" + t.month.toString()).slice(-2), "day" === t.unit ? n += "day" === t.unit ? "-" + ("0" + e).slice(-2) : "-01" : n += "-" + ("0" + (t.day ? t.day : "1")).slice(-2), "hour" === t.unit ? n += "hour" === t.unit ? "T" + ("0" + e).slice(-2) : "T00" : n += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), n += "minute" === t.unit ? ":" + ("0" + e).slice(-2) + ":00" : ":00:00", this.utc && (n += ".000Z"), n
            }
        }, {
            key: "formatDates", value: function (t) {
                var e = this, n = this.w;
                return t.map((function (t) {
                    var a = t.value.toString(), i = new F(e.ctx), r = e.createRawDateString(t, a),
                        o = i.getDate(i.parseDate(r));
                    if (e.utc || (o = i.getDate(i.parseDateWithTimezone(r))), void 0 === n.config.xaxis.labels.format) {
                        var s = "dd MMM", l = n.config.xaxis.labels.datetimeFormatter;
                        "year" === t.unit && (s = l.year), "month" === t.unit && (s = l.month), "day" === t.unit && (s = l.day), "hour" === t.unit && (s = l.hour), "minute" === t.unit && (s = l.minute), a = i.formatDate(o, s)
                    } else a = i.formatDate(o, n.config.xaxis.labels.format);
                    return {dateString: r, position: t.position, value: a, unit: t.unit, year: t.year, month: t.month}
                }))
            }
        }, {
            key: "removeOverlappingTS", value: function (t) {
                var e, n = this, a = new _(this.ctx), i = !1;
                t.length > 0 && t[0].value && t.every((function (e) {
                    return e.value.length === t[0].value.length
                })) && (i = !0, e = a.getTextRects(t[0].value).width);
                var r = 0, o = t.map((function (o, s) {
                    if (s > 0 && n.w.config.xaxis.labels.hideOverlappingLabels) {
                        var l = i ? e : a.getTextRects(t[r].value).width, c = t[r].position;
                        return o.position > c + l + 10 ? (r = s, o) : null
                    }
                    return o
                }));
                return o.filter((function (t) {
                    return null !== t
                }))
            }
        }, {
            key: "_getYear", value: function (t, e, n) {
                return t + Math.floor(e / 12) + n
            }
        }]), t
    }(), Nt = function () {
        function t(e, n) {
            r(this, t), this.ctx = n, this.w = n.w, this.el = e
        }

        return s(t, [{
            key: "setupElements", value: function () {
                var t = this.w.globals, e = this.w.config, n = e.chart.type;
                t.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(n) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "scatter", "bubble"].indexOf(n) > -1, t.isBarHorizontal = ("bar" === e.chart.type || "rangeBar" === e.chart.type) && e.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), _.setAttrs(t.dom.elWrap, {
                    id: t.chartClass.substring(1),
                    class: "apexcharts-canvas " + t.chartClass.substring(1)
                }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({
                    class: "apexcharts-svg",
                    "xmlns:data": "ApexChartsNS",
                    transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")")
                }), t.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t.dom.elGraphical = t.dom.Paper.group().attr({class: "apexcharts-inner apexcharts-graphical"}), t.dom.elAnnotations = t.dom.Paper.group().attr({class: "apexcharts-annotations"}), t.dom.elDefs = t.dom.Paper.defs(), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs)
            }
        }, {
            key: "plotChartType", value: function (t, e) {
                var n = this.w, a = n.config, i = n.globals, r = {series: [], i: []}, o = {series: [], i: []},
                    s = {series: [], i: []}, l = {series: [], i: []}, c = {series: [], i: []}, d = {series: [], i: []};
                i.series.map((function (e, u) {
                    void 0 !== t[u].type ? ("column" === t[u].type || "bar" === t[u].type ? (i.series.length > 1 && a.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), c.series.push(e), c.i.push(u), n.globals.columnSeries = c.series) : "area" === t[u].type ? (o.series.push(e), o.i.push(u)) : "line" === t[u].type ? (r.series.push(e), r.i.push(u)) : "scatter" === t[u].type ? (s.series.push(e), s.i.push(u)) : "bubble" === t[u].type ? (l.series.push(e), l.i.push(u)) : "candlestick" === t[u].type ? (d.series.push(e), d.i.push(u)) : console.warn("You have specified an unrecognized chart type. Available types for this propery are line/area/column/bar/scatter/bubble"), i.comboCharts = !0) : (r.series.push(e), r.i.push(u))
                }));
                var u = new Mt(this.ctx, e), h = new St(this.ctx, e);
                this.ctx.pie = new Tt(this.ctx);
                var p = new At(this.ctx);
                this.ctx.rangeBar = new H(this.ctx, e);
                var f = new Et(this.ctx), g = [];
                if (i.comboCharts) {
                    if (o.series.length > 0 && g.push(u.draw(o.series, "area", o.i)), c.series.length > 0) if (n.config.chart.stacked) {
                        var m = new wt(this.ctx, e);
                        g.push(m.draw(c.series, c.i))
                    } else {
                        var v = new L(this.ctx, e);
                        g.push(v.draw(c.series, c.i))
                    }
                    if (r.series.length > 0 && g.push(u.draw(r.series, "line", r.i)), d.series.length > 0 && g.push(h.draw(d.series, d.i)), s.series.length > 0) {
                        var b = new Mt(this.ctx, e, !0);
                        g.push(b.draw(s.series, "scatter", s.i))
                    }
                    if (l.series.length > 0) {
                        var y = new Mt(this.ctx, e, !0);
                        g.push(y.draw(l.series, "bubble", l.i))
                    }
                } else switch (a.chart.type) {
                    case"line":
                        g = u.draw(i.series, "line");
                        break;
                    case"area":
                        g = u.draw(i.series, "area");
                        break;
                    case"bar":
                        g = a.chart.stacked ? new wt(this.ctx, e).draw(i.series) : new L(this.ctx, e).draw(i.series);
                        break;
                    case"candlestick":
                        g = new St(this.ctx, e).draw(i.series);
                        break;
                    case"rangeBar":
                        g = this.ctx.rangeBar.draw(i.series);
                        break;
                    case"heatmap":
                        g = new kt(this.ctx, e).draw(i.series);
                        break;
                    case"treemap":
                        g = new Ot(this.ctx, e).draw(i.series);
                        break;
                    case"pie":
                    case"donut":
                    case"polarArea":
                        g = this.ctx.pie.draw(i.series);
                        break;
                    case"radialBar":
                        g = p.draw(i.series);
                        break;
                    case"radar":
                        g = f.draw(i.series);
                        break;
                    default:
                        g = u.draw(i.series)
                }
                return g
            }
        }, {
            key: "setSVGDimensions", value: function () {
                var t = this.w.globals, e = this.w.config;
                t.svgWidth = e.chart.width, t.svgHeight = e.chart.height;
                var n = b.getDimensions(this.el), a = e.chart.width.toString().split(/[0-9]+/g).pop();
                if ("%" === a ? b.isNumber(n[0]) && (0 === n[0].width && (n = b.getDimensions(this.el.parentNode)), t.svgWidth = n[0] * parseInt(e.chart.width, 10) / 100) : "px" !== a && "" !== a || (t.svgWidth = parseInt(e.chart.width, 10)), "auto" !== t.svgHeight && "" !== t.svgHeight) if ("%" === e.chart.height.toString().split(/[0-9]+/g).pop()) {
                    var i = b.getDimensions(this.el.parentNode);
                    t.svgHeight = i[1] * parseInt(e.chart.height, 10) / 100
                } else t.svgHeight = parseInt(e.chart.height, 10); else t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2;
                t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), _.setAttrs(t.dom.Paper.node, {
                    width: t.svgWidth,
                    height: t.svgHeight
                });
                var r = e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0;
                t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + r + "px", t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px"
            }
        }, {
            key: "shiftGraphPosition", value: function () {
                var t = this.w.globals, e = t.translateY, n = {transform: "translate(" + t.translateX + ", " + e + ")"};
                _.setAttrs(t.dom.elGraphical.node, n)
            }
        }, {
            key: "resizeNonAxisCharts", value: function () {
                var t = this.w, e = t.globals, n = 0, a = t.config.chart.sparkline.enabled ? 1 : 15;
                a += t.config.grid.padding.bottom, "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || !t.config.legend.show || t.config.legend.floating || (n = new ht(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                var i = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),
                    r = 2.05 * t.globals.radialSize;
                if (i && !t.config.chart.sparkline.enabled) {
                    var o = b.getBoundingClientRect(i);
                    r = o.bottom;
                    var s = o.bottom - o.top;
                    r = Math.max(2.05 * t.globals.radialSize, s)
                }
                var l = r + e.translateY + n + a;
                e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", l), e.dom.elWrap.style.height = l + "px", _.setAttrs(e.dom.Paper.node, {height: l}), e.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px"
            }
        }, {
            key: "coreCalculations", value: function () {
                new K(this.ctx).init()
            }
        }, {
            key: "resetGlobals", value: function () {
                var t = this, e = function () {
                    return t.w.config.series.map((function (t) {
                        return []
                    }))
                }, n = new z, a = this.w.globals;
                n.initGlobalVars(a), a.seriesXvalues = e(), a.seriesYvalues = e()
            }
        }, {
            key: "isMultipleY", value: function () {
                if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0
            }
        }, {
            key: "xySettings", value: function () {
                var t = null, e = this.w;
                if (e.globals.axisCharts) {
                    if ("back" === e.config.xaxis.crosshairs.position && new nt(this.ctx).drawXCrosshairs(), "back" === e.config.yaxis[0].crosshairs.position && new nt(this.ctx).drawYCrosshairs(), "datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter) {
                        this.ctx.timeScale = new jt(this.ctx);
                        var n = [];
                        isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? n = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (n = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(n)
                    }
                    t = new C(this.ctx).getCalculatedRatios()
                }
                return t
            }
        }, {
            key: "updateSourceChart", value: function (t) {
                this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
                    chart: {
                        selection: {
                            xaxis: {
                                min: t.w.globals.minX,
                                max: t.w.globals.maxX
                            }
                        }
                    }
                }, !1, !1)
            }
        }, {
            key: "setupBrushHandler", value: function () {
                var t = this, e = this.w;
                if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
                    var n = e.config.chart.brush.targets || [e.config.chart.brush.target];
                    n.forEach((function (e) {
                        var n = ApexCharts.getChartByID(e);
                        n.w.globals.brushSource = t.ctx, "function" != typeof n.w.config.chart.events.zoomed && (n.w.config.chart.events.zoomed = function () {
                            t.updateSourceChart(n)
                        }), "function" != typeof n.w.config.chart.events.scrolled && (n.w.config.chart.events.scrolled = function () {
                            t.updateSourceChart(n)
                        })
                    })), e.config.chart.events.selection = function (t, a) {
                        n.forEach((function (t) {
                            var n = ApexCharts.getChartByID(t), i = b.clone(e.config.yaxis);
                            if (e.config.chart.brush.autoScaleYaxis && 1 === n.w.globals.series.length) {
                                var r = new Z(n);
                                i = r.autoScaleY(n, i, a)
                            }
                            var o = n.w.config.yaxis.reduce((function (t, e, a) {
                                return [].concat(m(t), [d(d({}, n.w.config.yaxis[a]), {}, {
                                    min: i[0].min,
                                    max: i[0].max
                                })])
                            }), []);
                            n.ctx.updateHelpers._updateOptions({
                                xaxis: {min: a.xaxis.min, max: a.xaxis.max},
                                yaxis: o
                            }, !1, !1, !1, !1)
                        }))
                    }
                }
            }
        }]), t
    }(), Lt = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "_updateOptions", value: function (t) {
                var e = this, n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    o = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], s = [this.ctx];
                r && (s = this.ctx.getSyncedCharts()), this.ctx.w.globals.isExecCalled && (s = [this.ctx], this.ctx.w.globals.isExecCalled = !1), s.forEach((function (r) {
                    var s = r.w;
                    return s.globals.shouldAnimate = a, n || (s.globals.resized = !0, s.globals.dataChanged = !0, a && r.series.getPreviousPaths()), t && "object" === i(t) && (r.config = new q(t), t = C.extendArrayProps(r.config, t, s), r.w.globals.chartID !== e.ctx.w.globals.chartID && delete t.series, s.config = b.extend(s.config, t), o && (s.globals.lastXAxis = t.xaxis ? b.clone(t.xaxis) : [], s.globals.lastYAxis = t.yaxis ? b.clone(t.yaxis) : [], s.globals.initialConfig = b.extend({}, s.config), s.globals.initialSeries = b.clone(s.config.series))), r.update(t)
                }))
            }
        }, {
            key: "_updateSeries", value: function (t, e) {
                var n, a = this, i = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], r = this.w;
                return r.globals.shouldAnimate = e, r.globals.dataChanged = !0, e && this.ctx.series.getPreviousPaths(), r.globals.axisCharts ? (0 === (n = t.map((function (t, e) {
                    return a._extendSeries(t, e)
                }))).length && (n = [{data: []}]), r.config.series = n) : r.config.series = t.slice(), i && (r.globals.initialSeries = b.clone(r.config.series)), this.ctx.update()
            }
        }, {
            key: "_extendSeries", value: function (t, e) {
                var n = this.w, a = n.config.series[e];
                return d(d({}, n.config.series[e]), {}, {
                    name: t.name ? t.name : a && a.name,
                    color: t.color ? t.color : a && a.color,
                    type: t.type ? t.type : a && a.type,
                    data: t.data ? t.data : a && a.data
                })
            }
        }, {
            key: "toggleDataPointSelection", value: function (t, e) {
                var n = this.w, a = null, i = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
                return n.globals.axisCharts ? a = n.globals.dom.Paper.select("".concat(i, " path[j='").concat(e, "'], ").concat(i, " circle[j='").concat(e, "'], ").concat(i, " rect[j='").concat(e, "']")).members[0] : void 0 === e && (a = n.globals.dom.Paper.select("".concat(i, " path[j='").concat(t, "']")).members[0], "pie" !== n.config.chart.type && "polarArea" !== n.config.chart.type && "donut" !== n.config.chart.type || this.ctx.pie.pieClicked(t)), a ? (new _(this.ctx).pathMouseDown(a, null), a.node ? a.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null)
            }
        }, {
            key: "forceXAxisUpdate", value: function (t) {
                var e = this.w;
                if (["min", "max"].forEach((function (n) {
                    void 0 !== t.xaxis[n] && (e.config.xaxis[n] = t.xaxis[n], e.globals.lastXAxis[n] = t.xaxis[n])
                })), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) {
                    var n = new B(t);
                    t = n.convertCatToNumericXaxis(t, this.ctx)
                }
                return t
            }
        }, {
            key: "forceYAxisUpdate", value: function (t) {
                var e = this.w;
                return e.config.chart.stacked && "100%" === e.config.chart.stackType && (Array.isArray(t.yaxis) ? t.yaxis.forEach((function (e, n) {
                    t.yaxis[n].min = 0, t.yaxis[n].max = 100
                })) : (t.yaxis.min = 0, t.yaxis.max = 100)), t
            }
        }, {
            key: "revertDefaultAxisMinMax", value: function (t) {
                var e = this, n = this.w, a = n.globals.lastXAxis, i = n.globals.lastYAxis;
                t && t.xaxis && (a = t.xaxis), t && t.yaxis && (i = t.yaxis), n.config.xaxis.min = a.min, n.config.xaxis.max = a.max;
                n.config.yaxis.map((function (t, a) {
                    n.globals.zoomed || void 0 !== i[a] ? function (t) {
                        void 0 !== i[t] && (n.config.yaxis[t].min = i[t].min, n.config.yaxis[t].max = i[t].max)
                    }(a) : void 0 !== e.ctx.opts.yaxis[a] && (t.min = e.ctx.opts.yaxis[a].min, t.max = e.ctx.opts.yaxis[a].max)
                }))
            }
        }]), t
    }();
    Rt = "undefined" != typeof window ? window : void 0, Pt = function (t, e) {
        var n = (void 0 !== this ? this : t).SVG = function (t) {
            if (n.supported) return t = new n.Doc(t), n.parser.draw || n.prepare(), t
        };
        if (n.ns = "http://www.w3.org/2000/svg", n.xmlns = "http://www.w3.org/2000/xmlns/", n.xlink = "http://www.w3.org/1999/xlink", n.svgjs = "http://svgjs.com/svgjs", n.supported = !0, !n.supported) return !1;
        n.did = 1e3, n.eid = function (t) {
            return "Svgjs" + u(t) + n.did++
        }, n.create = function (t) {
            var n = e.createElementNS(this.ns, t);
            return n.setAttribute("id", this.eid(t)), n
        }, n.extend = function () {
            var t, e;
            e = (t = [].slice.call(arguments)).pop();
            for (var a = t.length - 1; a >= 0; a--) if (t[a]) for (var i in e) t[a].prototype[i] = e[i];
            n.Set && n.Set.inherit && n.Set.inherit()
        }, n.invent = function (t) {
            var e = "function" == typeof t.create ? t.create : function () {
                this.constructor.call(this, n.create(t.create))
            };
            return t.inherit && (e.prototype = new t.inherit), t.extend && n.extend(e, t.extend), t.construct && n.extend(t.parent || n.Container, t.construct), e
        }, n.adopt = function (e) {
            return e ? e.instance ? e.instance : ((a = "svg" == e.nodeName ? e.parentNode instanceof t.SVGElement ? new n.Nested : new n.Doc : "linearGradient" == e.nodeName ? new n.Gradient("linear") : "radialGradient" == e.nodeName ? new n.Gradient("radial") : n[u(e.nodeName)] ? new (n[u(e.nodeName)]) : new n.Element(e)).type = e.nodeName, a.node = e, e.instance = a, a instanceof n.Doc && a.namespace().defs(), a.setData(JSON.parse(e.getAttribute("svgjs:data")) || {}), a) : null;
            var a
        }, n.prepare = function () {
            var t = e.getElementsByTagName("body")[0],
                a = (t ? new n.Doc(t) : n.adopt(e.documentElement).nested()).size(2, 0);
            n.parser = {
                body: t || e.documentElement,
                draw: a.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                poly: a.polyline().node,
                path: a.path().node,
                native: n.create("svg")
            }
        }, n.parser = {native: n.create("svg")}, e.addEventListener("DOMContentLoaded", (function () {
            n.parser.draw || n.prepare()
        }), !1), n.regex = {
            numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
            hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
            rgb: /rgb\((\d+),(\d+),(\d+)\)/,
            reference: /#([a-z0-9\-_]+)/i,
            transforms: /\)\s*,?\s*/,
            whitespace: /\s/g,
            isHex: /^#[a-f0-9]{3,6}$/i,
            isRgb: /^rgb\(/,
            isCss: /[^:]+:[^;]+;?/,
            isBlank: /^(\s+)?$/,
            isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
            isPercent: /^-?[\d\.]+%$/,
            isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
            delimiter: /[\s,]+/,
            hyphen: /([^e])\-/gi,
            pathLetters: /[MLHVCSQTAZ]/gi,
            isPathLetter: /[MLHVCSQTAZ]/i,
            numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
            dots: /\./g
        }, n.utils = {
            map: function (t, e) {
                for (var n = t.length, a = [], i = 0; i < n; i++) a.push(e(t[i]));
                return a
            }, filter: function (t, e) {
                for (var n = t.length, a = [], i = 0; i < n; i++) e(t[i]) && a.push(t[i]);
                return a
            }, filterSVGElements: function (e) {
                return this.filter(e, (function (e) {
                    return e instanceof t.SVGElement
                }))
            }
        }, n.defaults = {
            attrs: {
                "fill-opacity": 1,
                "stroke-opacity": 1,
                "stroke-width": 0,
                "stroke-linejoin": "miter",
                "stroke-linecap": "butt",
                fill: "#000000",
                stroke: "#000000",
                opacity: 1,
                x: 0,
                y: 0,
                cx: 0,
                cy: 0,
                width: 0,
                height: 0,
                r: 0,
                rx: 0,
                ry: 0,
                offset: 0,
                "stop-opacity": 1,
                "stop-color": "#000000",
                "font-size": 16,
                "font-family": "Helvetica, Arial, sans-serif",
                "text-anchor": "start"
            }
        }, n.Color = function (t) {
            var e, a;
            this.r = 0, this.g = 0, this.b = 0, t && ("string" == typeof t ? n.regex.isRgb.test(t) ? (e = n.regex.rgb.exec(t.replace(n.regex.whitespace, "")), this.r = parseInt(e[1]), this.g = parseInt(e[2]), this.b = parseInt(e[3])) : n.regex.isHex.test(t) && (e = n.regex.hex.exec(4 == (a = t).length ? ["#", a.substring(1, 2), a.substring(1, 2), a.substring(2, 3), a.substring(2, 3), a.substring(3, 4), a.substring(3, 4)].join("") : a), this.r = parseInt(e[1], 16), this.g = parseInt(e[2], 16), this.b = parseInt(e[3], 16)) : "object" === i(t) && (this.r = t.r, this.g = t.g, this.b = t.b))
        }, n.extend(n.Color, {
            toString: function () {
                return this.toHex()
            }, toHex: function () {
                return "#" + h(this.r) + h(this.g) + h(this.b)
            }, toRgb: function () {
                return "rgb(" + [this.r, this.g, this.b].join() + ")"
            }, brightness: function () {
                return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
            }, morph: function (t) {
                return this.destination = new n.Color(t), this
            }, at: function (t) {
                return this.destination ? (t = t < 0 ? 0 : t > 1 ? 1 : t, new n.Color({
                    r: ~~(this.r + (this.destination.r - this.r) * t),
                    g: ~~(this.g + (this.destination.g - this.g) * t),
                    b: ~~(this.b + (this.destination.b - this.b) * t)
                })) : this
            }
        }), n.Color.test = function (t) {
            return t += "", n.regex.isHex.test(t) || n.regex.isRgb.test(t)
        }, n.Color.isRgb = function (t) {
            return t && "number" == typeof t.r && "number" == typeof t.g && "number" == typeof t.b
        }, n.Color.isColor = function (t) {
            return n.Color.isRgb(t) || n.Color.test(t)
        }, n.Array = function (t, e) {
            0 == (t = (t || []).valueOf()).length && e && (t = e.valueOf()), this.value = this.parse(t)
        }, n.extend(n.Array, {
            toString: function () {
                return this.value.join(" ")
            }, valueOf: function () {
                return this.value
            }, parse: function (t) {
                return t = t.valueOf(), Array.isArray(t) ? t : this.split(t)
            }
        }), n.PointArray = function (t, e) {
            n.Array.call(this, t, e || [[0, 0]])
        }, n.PointArray.prototype = new n.Array, n.PointArray.prototype.constructor = n.PointArray;
        for (var a = {
            M: function (t, e, n) {
                return e.x = n.x = t[0], e.y = n.y = t[1], ["M", e.x, e.y]
            }, L: function (t, e) {
                return e.x = t[0], e.y = t[1], ["L", t[0], t[1]]
            }, H: function (t, e) {
                return e.x = t[0], ["H", t[0]]
            }, V: function (t, e) {
                return e.y = t[0], ["V", t[0]]
            }, C: function (t, e) {
                return e.x = t[4], e.y = t[5], ["C", t[0], t[1], t[2], t[3], t[4], t[5]]
            }, Q: function (t, e) {
                return e.x = t[2], e.y = t[3], ["Q", t[0], t[1], t[2], t[3]]
            }, Z: function (t, e, n) {
                return e.x = n.x, e.y = n.y, ["Z"]
            }
        }, r = "mlhvqtcsaz".split(""), o = 0, s = r.length; o < s; ++o) a[r[o]] = function (t) {
            return function (e, n, i) {
                if ("H" == t) e[0] = e[0] + n.x; else if ("V" == t) e[0] = e[0] + n.y; else if ("A" == t) e[5] = e[5] + n.x, e[6] = e[6] + n.y; else for (var r = 0, o = e.length; r < o; ++r) e[r] = e[r] + (r % 2 ? n.y : n.x);
                return a[t](e, n, i)
            }
        }(r[o].toUpperCase());
        n.PathArray = function (t, e) {
            n.Array.call(this, t, e || [["M", 0, 0]])
        }, n.PathArray.prototype = new n.Array, n.PathArray.prototype.constructor = n.PathArray, n.extend(n.PathArray, {
            toString: function () {
                return function (t) {
                    for (var e = 0, n = t.length, a = ""; e < n; e++) a += t[e][0], null != t[e][1] && (a += t[e][1], null != t[e][2] && (a += " ", a += t[e][2], null != t[e][3] && (a += " ", a += t[e][3], a += " ", a += t[e][4], null != t[e][5] && (a += " ", a += t[e][5], a += " ", a += t[e][6], null != t[e][7] && (a += " ", a += t[e][7])))));
                    return a + " "
                }(this.value)
            }, move: function (t, e) {
                var n = this.bbox();
                return n.x, n.y, this
            }, at: function (t) {
                if (!this.destination) return this;
                for (var e = this.value, a = this.destination.value, i = [], r = new n.PathArray, o = 0, s = e.length; o < s; o++) {
                    i[o] = [e[o][0]];
                    for (var l = 1, c = e[o].length; l < c; l++) i[o][l] = e[o][l] + (a[o][l] - e[o][l]) * t;
                    "A" === i[o][0] && (i[o][4] = +(0 != i[o][4]), i[o][5] = +(0 != i[o][5]))
                }
                return r.value = i, r
            }, parse: function (t) {
                if (t instanceof n.PathArray) return t.valueOf();
                var e, i = {M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0};
                t = "string" == typeof t ? t.replace(n.regex.numbersWithDots, c).replace(n.regex.pathLetters, " $& ").replace(n.regex.hyphen, "$1 -").trim().split(n.regex.delimiter) : t.reduce((function (t, e) {
                    return [].concat.call(t, e)
                }), []);
                var r = [], o = new n.Point, s = new n.Point, l = 0, d = t.length;
                do {
                    n.regex.isPathLetter.test(t[l]) ? (e = t[l], ++l) : "M" == e ? e = "L" : "m" == e && (e = "l"), r.push(a[e].call(null, t.slice(l, l += i[e.toUpperCase()]).map(parseFloat), o, s))
                } while (d > l);
                return r
            }, bbox: function () {
                return n.parser.draw || n.prepare(), n.parser.path.setAttribute("d", this.toString()), n.parser.path.getBBox()
            }
        }), n.Number = n.invent({
            create: function (t, e) {
                this.value = 0, this.unit = e || "", "number" == typeof t ? this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37 : "string" == typeof t ? (e = t.match(n.regex.numberAndUnit)) && (this.value = parseFloat(e[1]), "%" == e[5] ? this.value /= 100 : "s" == e[5] && (this.value *= 1e3), this.unit = e[5]) : t instanceof n.Number && (this.value = t.valueOf(), this.unit = t.unit)
            }, extend: {
                toString: function () {
                    return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                }, toJSON: function () {
                    return this.toString()
                }, valueOf: function () {
                    return this.value
                }, plus: function (t) {
                    return t = new n.Number(t), new n.Number(this + t, this.unit || t.unit)
                }, minus: function (t) {
                    return t = new n.Number(t), new n.Number(this - t, this.unit || t.unit)
                }, times: function (t) {
                    return t = new n.Number(t), new n.Number(this * t, this.unit || t.unit)
                }, divide: function (t) {
                    return t = new n.Number(t), new n.Number(this / t, this.unit || t.unit)
                }, to: function (t) {
                    var e = new n.Number(this);
                    return "string" == typeof t && (e.unit = t), e
                }, morph: function (t) {
                    return this.destination = new n.Number(t), t.relative && (this.destination.value += this.value), this
                }, at: function (t) {
                    return this.destination ? new n.Number(this.destination).minus(this).times(t).plus(this) : this
                }
            }
        }), n.Element = n.invent({
            create: function (t) {
                this._stroke = n.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t) && (this.type = t.nodeName, this.node.instance = this, this._stroke = t.getAttribute("stroke") || this._stroke)
            }, extend: {
                x: function (t) {
                    return this.attr("x", t)
                }, y: function (t) {
                    return this.attr("y", t)
                }, cx: function (t) {
                    return null == t ? this.x() + this.width() / 2 : this.x(t - this.width() / 2)
                }, cy: function (t) {
                    return null == t ? this.y() + this.height() / 2 : this.y(t - this.height() / 2)
                }, move: function (t, e) {
                    return this.x(t).y(e)
                }, center: function (t, e) {
                    return this.cx(t).cy(e)
                }, width: function (t) {
                    return this.attr("width", t)
                }, height: function (t) {
                    return this.attr("height", t)
                }, size: function (t, e) {
                    var a = p(this, t, e);
                    return this.width(new n.Number(a.width)).height(new n.Number(a.height))
                }, clone: function (t) {
                    this.writeDataToDom();
                    var e = m(this.node.cloneNode(!0));
                    return t ? t.add(e) : this.after(e), e
                }, remove: function () {
                    return this.parent() && this.parent().removeElement(this), this
                }, replace: function (t) {
                    return this.after(t).remove(), t
                }, addTo: function (t) {
                    return t.put(this)
                }, putIn: function (t) {
                    return t.add(this)
                }, id: function (t) {
                    return this.attr("id", t)
                }, show: function () {
                    return this.style("display", "")
                }, hide: function () {
                    return this.style("display", "none")
                }, visible: function () {
                    return "none" != this.style("display")
                }, toString: function () {
                    return this.attr("id")
                }, classes: function () {
                    var t = this.attr("class");
                    return null == t ? [] : t.trim().split(n.regex.delimiter)
                }, hasClass: function (t) {
                    return -1 != this.classes().indexOf(t)
                }, addClass: function (t) {
                    if (!this.hasClass(t)) {
                        var e = this.classes();
                        e.push(t), this.attr("class", e.join(" "))
                    }
                    return this
                }, removeClass: function (t) {
                    return this.hasClass(t) && this.attr("class", this.classes().filter((function (e) {
                        return e != t
                    })).join(" ")), this
                }, toggleClass: function (t) {
                    return this.hasClass(t) ? this.removeClass(t) : this.addClass(t)
                }, reference: function (t) {
                    return n.get(this.attr(t))
                }, parent: function (e) {
                    var a = this;
                    if (!a.node.parentNode) return null;
                    if (a = n.adopt(a.node.parentNode), !e) return a;
                    for (; a && a.node instanceof t.SVGElement;) {
                        if ("string" == typeof e ? a.matches(e) : a instanceof e) return a;
                        if (!a.node.parentNode || "#document" == a.node.parentNode.nodeName) return null;
                        a = n.adopt(a.node.parentNode)
                    }
                }, doc: function () {
                    return this instanceof n.Doc ? this : this.parent(n.Doc)
                }, parents: function (t) {
                    var e = [], n = this;
                    do {
                        if (!(n = n.parent(t)) || !n.node) break;
                        e.push(n)
                    } while (n.parent);
                    return e
                }, matches: function (t) {
                    return function (t, e) {
                        return (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e)
                    }(this.node, t)
                }, native: function () {
                    return this.node
                }, svg: function (t) {
                    var a = e.createElement("svg");
                    if (!(t && this instanceof n.Parent)) return a.appendChild(t = e.createElement("svg")), this.writeDataToDom(), t.appendChild(this.node.cloneNode(!0)), a.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                    a.innerHTML = "<svg>" + t.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                    for (var i = 0, r = a.firstChild.childNodes.length; i < r; i++) this.node.appendChild(a.firstChild.firstChild);
                    return this
                }, writeDataToDom: function () {
                    return (this.each || this.lines) && (this.each ? this : this.lines()).each((function () {
                        this.writeDataToDom()
                    })), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this
                }, setData: function (t) {
                    return this.dom = t, this
                }, is: function (t) {
                    return function (t, e) {
                        return t instanceof e
                    }(this, t)
                }
            }
        }), n.easing = {
            "-": function (t) {
                return t
            }, "<>": function (t) {
                return -Math.cos(t * Math.PI) / 2 + .5
            }, ">": function (t) {
                return Math.sin(t * Math.PI / 2)
            }, "<": function (t) {
                return 1 - Math.cos(t * Math.PI / 2)
            }
        }, n.morph = function (t) {
            return function (e, a) {
                return new n.MorphObj(e, a).at(t)
            }
        }, n.Situation = n.invent({
            create: function (t) {
                this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new n.Number(t.duration).valueOf(), this.delay = new n.Number(t.delay).valueOf(), this.start = +new Date + this.delay, this.finish = this.start + this.duration, this.ease = t.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}
            }
        }), n.FX = n.invent({
            create: function (t) {
                this._target = t, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1
            }, extend: {
                animate: function (t, e, a) {
                    "object" === i(t) && (e = t.ease, a = t.delay, t = t.duration);
                    var r = new n.Situation({duration: t || 1e3, delay: a || 0, ease: n.easing[e || "-"] || e});
                    return this.queue(r), this
                }, target: function (t) {
                    return t && t instanceof n.Element ? (this._target = t, this) : this._target
                }, timeToAbsPos: function (t) {
                    return (t - this.situation.start) / (this.situation.duration / this._speed)
                }, absPosToTime: function (t) {
                    return this.situation.duration / this._speed * t + this.situation.start
                }, startAnimFrame: function () {
                    this.stopAnimFrame(), this.animationFrame = t.requestAnimationFrame(function () {
                        this.step()
                    }.bind(this))
                }, stopAnimFrame: function () {
                    t.cancelAnimationFrame(this.animationFrame)
                }, start: function () {
                    return !this.active && this.situation && (this.active = !0, this.startCurrent()), this
                }, startCurrent: function () {
                    return this.situation.start = +new Date + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step()
                }, queue: function (t) {
                    return ("function" == typeof t || t instanceof n.Situation) && this.situations.push(t), this.situation || (this.situation = this.situations.shift()), this
                }, dequeue: function () {
                    return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof n.Situation ? this.start() : this.situation.call(this)), this
                }, initAnimations: function () {
                    var t, e = this.situation;
                    if (e.init) return this;
                    for (var a in e.animations) {
                        t = this.target()[a](), Array.isArray(t) || (t = [t]), Array.isArray(e.animations[a]) || (e.animations[a] = [e.animations[a]]);
                        for (var i = t.length; i--;) e.animations[a][i] instanceof n.Number && (t[i] = new n.Number(t[i])), e.animations[a][i] = t[i].morph(e.animations[a][i])
                    }
                    for (var a in e.attrs) e.attrs[a] = new n.MorphObj(this.target().attr(a), e.attrs[a]);
                    for (var a in e.styles) e.styles[a] = new n.MorphObj(this.target().style(a), e.styles[a]);
                    return e.initialTransformation = this.target().matrixify(), e.init = !0, this
                }, clearQueue: function () {
                    return this.situations = [], this
                }, clearCurrent: function () {
                    return this.situation = null, this
                }, stop: function (t, e) {
                    var n = this.active;
                    return this.active = !1, e && this.clearQueue(), t && this.situation && (!n && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent()
                }, after: function (t) {
                    var e = this.last();
                    return this.target().on("finished.fx", (function n(a) {
                        a.detail.situation == e && (t.call(this, e), this.off("finished.fx", n))
                    })), this._callStart()
                }, during: function (t) {
                    var e = this.last(), a = function (a) {
                        a.detail.situation == e && t.call(this, a.detail.pos, n.morph(a.detail.pos), a.detail.eased, e)
                    };
                    return this.target().off("during.fx", a).on("during.fx", a), this.after((function () {
                        this.off("during.fx", a)
                    })), this._callStart()
                }, afterAll: function (t) {
                    var e = function e(n) {
                        t.call(this), this.off("allfinished.fx", e)
                    };
                    return this.target().off("allfinished.fx", e).on("allfinished.fx", e), this._callStart()
                }, last: function () {
                    return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                }, add: function (t, e, n) {
                    return this.last()[n || "animations"][t] = e, this._callStart()
                }, step: function (t) {
                    var e, n, a;
                    t || (this.absPos = this.timeToAbsPos(+new Date)), !1 !== this.situation.loops ? (e = Math.max(this.absPos, 0), n = Math.floor(e), !0 === this.situation.loops || n < this.situation.loops ? (this.pos = e - n, a = this.situation.loop, this.situation.loop = n) : (this.absPos = this.situation.loops, this.pos = 1, a = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
                    var i = this.situation.ease(this.pos);
                    for (var r in this.situation.once) r > this.lastPos && r <= i && (this.situation.once[r].call(this.target(), this.pos, i), delete this.situation.once[r]);
                    return this.active && this.target().fire("during", {
                        pos: this.pos,
                        eased: i,
                        fx: this,
                        situation: this.situation
                    }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
                        fx: this,
                        situation: this.situation
                    }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = i, this) : this
                }, eachAt: function () {
                    var t, e = this, a = this.target(), i = this.situation;
                    for (var r in i.animations) t = [].concat(i.animations[r]).map((function (t) {
                        return "string" != typeof t && t.at ? t.at(i.ease(e.pos), e.pos) : t
                    })), a[r].apply(a, t);
                    for (var r in i.attrs) t = [r].concat(i.attrs[r]).map((function (t) {
                        return "string" != typeof t && t.at ? t.at(i.ease(e.pos), e.pos) : t
                    })), a.attr.apply(a, t);
                    for (var r in i.styles) t = [r].concat(i.styles[r]).map((function (t) {
                        return "string" != typeof t && t.at ? t.at(i.ease(e.pos), e.pos) : t
                    })), a.style.apply(a, t);
                    if (i.transforms.length) {
                        t = i.initialTransformation, r = 0;
                        for (var o = i.transforms.length; r < o; r++) {
                            var s = i.transforms[r];
                            s instanceof n.Matrix ? t = s.relative ? t.multiply((new n.Matrix).morph(s).at(i.ease(this.pos))) : t.morph(s).at(i.ease(this.pos)) : (s.relative || s.undo(t.extract()), t = t.multiply(s.at(i.ease(this.pos))))
                        }
                        a.matrix(t)
                    }
                    return this
                }, once: function (t, e, n) {
                    var a = this.last();
                    return n || (t = a.ease(t)), a.once[t] = e, this
                }, _callStart: function () {
                    return setTimeout(function () {
                        this.start()
                    }.bind(this), 0), this
                }
            }, parent: n.Element, construct: {
                animate: function (t, e, a) {
                    return (this.fx || (this.fx = new n.FX(this))).animate(t, e, a)
                }, delay: function (t) {
                    return (this.fx || (this.fx = new n.FX(this))).delay(t)
                }, stop: function (t, e) {
                    return this.fx && this.fx.stop(t, e), this
                }, finish: function () {
                    return this.fx && this.fx.finish(), this
                }
            }
        }), n.MorphObj = n.invent({
            create: function (t, e) {
                return n.Color.isColor(e) ? new n.Color(t).morph(e) : n.regex.delimiter.test(t) ? n.regex.pathLetters.test(t) ? new n.PathArray(t).morph(e) : new n.Array(t).morph(e) : n.regex.numberAndUnit.test(e) ? new n.Number(t).morph(e) : (this.value = t, void (this.destination = e))
            }, extend: {
                at: function (t, e) {
                    return e < 1 ? this.value : this.destination
                }, valueOf: function () {
                    return this.value
                }
            }
        }), n.extend(n.FX, {
            attr: function (t, e, n) {
                if ("object" === i(t)) for (var a in t) this.attr(a, t[a]); else this.add(t, e, "attrs");
                return this
            }, plot: function (t, e, n, a) {
                return 4 == arguments.length ? this.plot([t, e, n, a]) : this.add("plot", new (this.target().morphArray)(t))
            }
        }), n.Box = n.invent({
            create: function (t, e, a, r) {
                if (!("object" !== i(t) || t instanceof n.Element)) return n.Box.call(this, null != t.left ? t.left : t.x, null != t.top ? t.top : t.y, t.width, t.height);
                4 == arguments.length && (this.x = t, this.y = e, this.width = a, this.height = r), v(this)
            }
        }), n.BBox = n.invent({
            create: function (t) {
                if (n.Box.apply(this, [].slice.call(arguments)), t instanceof n.Element) {
                    var a;
                    try {
                        if (!e.documentElement.contains) {
                            for (var i = t.node; i.parentNode;) i = i.parentNode;
                            if (i != e) throw new Error("Element not in the dom")
                        }
                        a = t.node.getBBox()
                    } catch (e) {
                        if (t instanceof n.Shape) {
                            n.parser.draw || n.prepare();
                            var r = t.clone(n.parser.draw.instance).show();
                            a = r.node.getBBox(), r.remove()
                        } else a = {
                            x: t.node.clientLeft,
                            y: t.node.clientTop,
                            width: t.node.clientWidth,
                            height: t.node.clientHeight
                        }
                    }
                    n.Box.call(this, a)
                }
            }, inherit: n.Box, parent: n.Element, construct: {
                bbox: function () {
                    return new n.BBox(this)
                }
            }
        }), n.BBox.prototype.constructor = n.BBox, n.Matrix = n.invent({
            create: function (t) {
                var e = g([1, 0, 0, 1, 0, 0]);
                t = t instanceof n.Element ? t.matrixify() : "string" == typeof t ? g(t.split(n.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? g([].slice.call(arguments)) : Array.isArray(t) ? g(t) : "object" === i(t) ? t : e;
                for (var a = y.length - 1; a >= 0; --a) this[y[a]] = null != t[y[a]] ? t[y[a]] : e[y[a]]
            }, extend: {
                extract: function () {
                    var t = f(this, 0, 1), e = (f(this, 1, 0), 180 / Math.PI * Math.atan2(t.y, t.x) - 90);
                    return {
                        x: this.e,
                        y: this.f,
                        transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                        transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                        rotation: e,
                        a: this.a,
                        b: this.b,
                        c: this.c,
                        d: this.d,
                        e: this.e,
                        f: this.f,
                        matrix: new n.Matrix(this)
                    }
                }, clone: function () {
                    return new n.Matrix(this)
                }, morph: function (t) {
                    return this.destination = new n.Matrix(t), this
                }, multiply: function (t) {
                    return new n.Matrix(this.native().multiply(function (t) {
                        return t instanceof n.Matrix || (t = new n.Matrix(t)), t
                    }(t).native()))
                }, inverse: function () {
                    return new n.Matrix(this.native().inverse())
                }, translate: function (t, e) {
                    return new n.Matrix(this.native().translate(t || 0, e || 0))
                }, native: function () {
                    for (var t = n.parser.native.createSVGMatrix(), e = y.length - 1; e >= 0; e--) t[y[e]] = this[y[e]];
                    return t
                }, toString: function () {
                    return "matrix(" + b(this.a) + "," + b(this.b) + "," + b(this.c) + "," + b(this.d) + "," + b(this.e) + "," + b(this.f) + ")"
                }
            }, parent: n.Element, construct: {
                ctm: function () {
                    return new n.Matrix(this.node.getCTM())
                }, screenCTM: function () {
                    if (this instanceof n.Nested) {
                        var t = this.rect(1, 1), e = t.node.getScreenCTM();
                        return t.remove(), new n.Matrix(e)
                    }
                    return new n.Matrix(this.node.getScreenCTM())
                }
            }
        }), n.Point = n.invent({
            create: function (t, e) {
                var n;
                n = Array.isArray(t) ? {x: t[0], y: t[1]} : "object" === i(t) ? {x: t.x, y: t.y} : null != t ? {
                    x: t,
                    y: null != e ? e : t
                } : {x: 0, y: 0}, this.x = n.x, this.y = n.y
            }, extend: {
                clone: function () {
                    return new n.Point(this)
                }, morph: function (t, e) {
                    return this.destination = new n.Point(t, e), this
                }
            }
        }), n.extend(n.Element, {
            point: function (t, e) {
                return new n.Point(t, e).transform(this.screenCTM().inverse())
            }
        }), n.extend(n.Element, {
            attr: function (t, e, a) {
                if (null == t) {
                    for (t = {}, a = (e = this.node.attributes).length - 1; a >= 0; a--) t[e[a].nodeName] = n.regex.isNumber.test(e[a].nodeValue) ? parseFloat(e[a].nodeValue) : e[a].nodeValue;
                    return t
                }
                if ("object" === i(t)) for (var r in t) this.attr(r, t[r]); else if (null === e) this.node.removeAttribute(t); else {
                    if (null == e) return null == (e = this.node.getAttribute(t)) ? n.defaults.attrs[t] : n.regex.isNumber.test(e) ? parseFloat(e) : e;
                    "stroke-width" == t ? this.attr("stroke", parseFloat(e) > 0 ? this._stroke : null) : "stroke" == t && (this._stroke = e), "fill" != t && "stroke" != t || (n.regex.isImage.test(e) && (e = this.doc().defs().image(e, 0, 0)), e instanceof n.Image && (e = this.doc().defs().pattern(0, 0, (function () {
                        this.add(e)
                    })))), "number" == typeof e ? e = new n.Number(e) : n.Color.isColor(e) ? e = new n.Color(e) : Array.isArray(e) && (e = new n.Array(e)), "leading" == t ? this.leading && this.leading(e) : "string" == typeof a ? this.node.setAttributeNS(a, t, e.toString()) : this.node.setAttribute(t, e.toString()), !this.rebuild || "font-size" != t && "x" != t || this.rebuild(t, e)
                }
                return this
            }
        }), n.extend(n.Element, {
            transform: function (t, e) {
                var a;
                return "object" !== i(t) ? (a = new n.Matrix(this).extract(), "string" == typeof t ? a[t] : a) : (a = new n.Matrix(this), e = !!e || !!t.relative, null != t.a && (a = e ? a.multiply(new n.Matrix(t)) : new n.Matrix(t)), this.attr("transform", a))
            }
        }), n.extend(n.Element, {
            untransform: function () {
                return this.attr("transform", null)
            }, matrixify: function () {
                return (this.attr("transform") || "").split(n.regex.transforms).slice(0, -1).map((function (t) {
                    var e = t.trim().split("(");
                    return [e[0], e[1].split(n.regex.delimiter).map((function (t) {
                        return parseFloat(t)
                    }))]
                })).reduce((function (t, e) {
                    return "matrix" == e[0] ? t.multiply(g(e[1])) : t[e[0]].apply(t, e[1])
                }), new n.Matrix)
            }, toParent: function (t) {
                if (this == t) return this;
                var e = this.screenCTM(), n = t.screenCTM().inverse();
                return this.addTo(t).untransform().transform(n.multiply(e)), this
            }, toDoc: function () {
                return this.toParent(this.doc())
            }
        }), n.Transformation = n.invent({
            create: function (t, e) {
                if (arguments.length > 1 && "boolean" != typeof e) return this.constructor.call(this, [].slice.call(arguments));
                if (Array.isArray(t)) for (var n = 0, a = this.arguments.length; n < a; ++n) this[this.arguments[n]] = t[n]; else if ("object" === i(t)) for (n = 0, a = this.arguments.length; n < a; ++n) this[this.arguments[n]] = t[this.arguments[n]];
                this.inversed = !1, !0 === e && (this.inversed = !0)
            }
        }), n.Translate = n.invent({
            parent: n.Matrix, inherit: n.Transformation, create: function (t, e) {
                this.constructor.apply(this, [].slice.call(arguments))
            }, extend: {arguments: ["transformedX", "transformedY"], method: "translate"}
        }), n.extend(n.Element, {
            style: function (t, e) {
                if (0 == arguments.length) return this.node.style.cssText || "";
                if (arguments.length < 2) if ("object" === i(t)) for (var a in t) this.style(a, t[a]); else {
                    if (!n.regex.isCss.test(t)) return this.node.style[d(t)];
                    for (t = t.split(/\s*;\s*/).filter((function (t) {
                        return !!t
                    })).map((function (t) {
                        return t.split(/\s*:\s*/)
                    })); e = t.pop();) this.style(e[0], e[1])
                } else this.node.style[d(t)] = null === e || n.regex.isBlank.test(e) ? "" : e;
                return this
            }
        }), n.Parent = n.invent({
            create: function (t) {
                this.constructor.call(this, t)
            }, inherit: n.Element, extend: {
                children: function () {
                    return n.utils.map(n.utils.filterSVGElements(this.node.childNodes), (function (t) {
                        return n.adopt(t)
                    }))
                }, add: function (t, e) {
                    return null == e ? this.node.appendChild(t.node) : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]), this
                }, put: function (t, e) {
                    return this.add(t, e), t
                }, has: function (t) {
                    return this.index(t) >= 0
                }, index: function (t) {
                    return [].slice.call(this.node.childNodes).indexOf(t.node)
                }, get: function (t) {
                    return n.adopt(this.node.childNodes[t])
                }, first: function () {
                    return this.get(0)
                }, last: function () {
                    return this.get(this.node.childNodes.length - 1)
                }, each: function (t, e) {
                    for (var a = this.children(), i = 0, r = a.length; i < r; i++) a[i] instanceof n.Element && t.apply(a[i], [i, a]), e && a[i] instanceof n.Container && a[i].each(t, e);
                    return this
                }, removeElement: function (t) {
                    return this.node.removeChild(t.node), this
                }, clear: function () {
                    for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                    return delete this._defs, this
                }, defs: function () {
                    return this.doc().defs()
                }
            }
        }), n.extend(n.Parent, {
            ungroup: function (t, e) {
                return 0 === e || this instanceof n.Defs || this.node == n.parser.draw || (t = t || (this instanceof n.Doc ? this : this.parent(n.Parent)), e = e || 1 / 0, this.each((function () {
                    return this instanceof n.Defs ? this : this instanceof n.Parent ? this.ungroup(t, e - 1) : this.toParent(t)
                })), this.node.firstChild || this.remove()), this
            }, flatten: function (t, e) {
                return this.ungroup(t, e)
            }
        }), n.Container = n.invent({
            create: function (t) {
                this.constructor.call(this, t)
            }, inherit: n.Parent
        }), n.ViewBox = n.invent({
            parent: n.Container,
            construct: {}
        }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach((function (t) {
            n.Element.prototype[t] = function (e) {
                return n.on(this.node, t, e), this
            }
        })), n.listeners = [], n.handlerMap = [], n.listenerId = 0, n.on = function (t, e, a, i, r) {
            var o = a.bind(i || t.instance || t), s = (n.handlerMap.indexOf(t) + 1 || n.handlerMap.push(t)) - 1,
                l = e.split(".")[0], c = e.split(".")[1] || "*";
            n.listeners[s] = n.listeners[s] || {}, n.listeners[s][l] = n.listeners[s][l] || {}, n.listeners[s][l][c] = n.listeners[s][l][c] || {}, a._svgjsListenerId || (a._svgjsListenerId = ++n.listenerId), n.listeners[s][l][c][a._svgjsListenerId] = o, t.addEventListener(l, o, r || !1)
        }, n.off = function (t, e, a) {
            var i = n.handlerMap.indexOf(t), r = e && e.split(".")[0], o = e && e.split(".")[1], s = "";
            if (-1 != i) if (a) {
                if ("function" == typeof a && (a = a._svgjsListenerId), !a) return;
                n.listeners[i][r] && n.listeners[i][r][o || "*"] && (t.removeEventListener(r, n.listeners[i][r][o || "*"][a], !1), delete n.listeners[i][r][o || "*"][a])
            } else if (o && r) {
                if (n.listeners[i][r] && n.listeners[i][r][o]) {
                    for (var l in n.listeners[i][r][o]) n.off(t, [r, o].join("."), l);
                    delete n.listeners[i][r][o]
                }
            } else if (o) for (var c in n.listeners[i]) for (var s in n.listeners[i][c]) o === s && n.off(t, [c, o].join(".")); else if (r) {
                if (n.listeners[i][r]) {
                    for (var s in n.listeners[i][r]) n.off(t, [r, s].join("."));
                    delete n.listeners[i][r]
                }
            } else {
                for (var c in n.listeners[i]) n.off(t, c);
                delete n.listeners[i], delete n.handlerMap[i]
            }
        }, n.extend(n.Element, {
            on: function (t, e, a, i) {
                return n.on(this.node, t, e, a, i), this
            }, off: function (t, e) {
                return n.off(this.node, t, e), this
            }, fire: function (e, a) {
                return e instanceof t.Event ? this.node.dispatchEvent(e) : this.node.dispatchEvent(e = new n.CustomEvent(e, {
                    detail: a,
                    cancelable: !0
                })), this._event = e, this
            }, event: function () {
                return this._event
            }
        }), n.Defs = n.invent({create: "defs", inherit: n.Container}), n.G = n.invent({
            create: "g",
            inherit: n.Container,
            extend: {
                x: function (t) {
                    return null == t ? this.transform("x") : this.transform({x: t - this.x()}, !0)
                }
            },
            construct: {
                group: function () {
                    return this.put(new n.G)
                }
            }
        }), n.Doc = n.invent({
            create: function (t) {
                t && ("svg" == (t = "string" == typeof t ? e.getElementById(t) : t).nodeName ? this.constructor.call(this, t) : (this.constructor.call(this, n.create("svg")), t.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs())
            }, inherit: n.Container, extend: {
                namespace: function () {
                    return this.attr({
                        xmlns: n.ns,
                        version: "1.1"
                    }).attr("xmlns:xlink", n.xlink, n.xmlns).attr("xmlns:svgjs", n.svgjs, n.xmlns)
                }, defs: function () {
                    var t;
                    return this._defs || ((t = this.node.getElementsByTagName("defs")[0]) ? this._defs = n.adopt(t) : this._defs = new n.Defs, this.node.appendChild(this._defs.node)), this._defs
                }, parent: function () {
                    return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                }, remove: function () {
                    return this.parent() && this.parent().removeChild(this.node), this
                }, clear: function () {
                    for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                    return delete this._defs, n.parser.draw && !n.parser.draw.parentNode && this.node.appendChild(n.parser.draw), this
                }, clone: function (t) {
                    this.writeDataToDom();
                    var e = this.node, n = m(e.cloneNode(!0));
                    return t ? (t.node || t).appendChild(n.node) : e.parentNode.insertBefore(n.node, e.nextSibling), n
                }
            }
        }), n.extend(n.Element, {}), n.Gradient = n.invent({
            create: function (t) {
                this.constructor.call(this, n.create(t + "Gradient")), this.type = t
            }, inherit: n.Container, extend: {
                at: function (t, e, a) {
                    return this.put(new n.Stop).update(t, e, a)
                }, update: function (t) {
                    return this.clear(), "function" == typeof t && t.call(this, this), this
                }, fill: function () {
                    return "url(#" + this.id() + ")"
                }, toString: function () {
                    return this.fill()
                }, attr: function (t, e, a) {
                    return "transform" == t && (t = "gradientTransform"), n.Container.prototype.attr.call(this, t, e, a)
                }
            }, construct: {
                gradient: function (t, e) {
                    return this.defs().gradient(t, e)
                }
            }
        }), n.extend(n.Gradient, n.FX, {
            from: function (t, e) {
                return "radial" == (this._target || this).type ? this.attr({
                    fx: new n.Number(t),
                    fy: new n.Number(e)
                }) : this.attr({x1: new n.Number(t), y1: new n.Number(e)})
            }, to: function (t, e) {
                return "radial" == (this._target || this).type ? this.attr({
                    cx: new n.Number(t),
                    cy: new n.Number(e)
                }) : this.attr({x2: new n.Number(t), y2: new n.Number(e)})
            }
        }), n.extend(n.Defs, {
            gradient: function (t, e) {
                return this.put(new n.Gradient(t)).update(e)
            }
        }), n.Stop = n.invent({
            create: "stop", inherit: n.Element, extend: {
                update: function (t) {
                    return ("number" == typeof t || t instanceof n.Number) && (t = {
                        offset: arguments[0],
                        color: arguments[1],
                        opacity: arguments[2]
                    }), null != t.opacity && this.attr("stop-opacity", t.opacity), null != t.color && this.attr("stop-color", t.color), null != t.offset && this.attr("offset", new n.Number(t.offset)), this
                }
            }
        }), n.Pattern = n.invent({
            create: "pattern", inherit: n.Container, extend: {
                fill: function () {
                    return "url(#" + this.id() + ")"
                }, update: function (t) {
                    return this.clear(), "function" == typeof t && t.call(this, this), this
                }, toString: function () {
                    return this.fill()
                }, attr: function (t, e, a) {
                    return "transform" == t && (t = "patternTransform"), n.Container.prototype.attr.call(this, t, e, a)
                }
            }, construct: {
                pattern: function (t, e, n) {
                    return this.defs().pattern(t, e, n)
                }
            }
        }), n.extend(n.Defs, {
            pattern: function (t, e, a) {
                return this.put(new n.Pattern).update(a).attr({
                    x: 0,
                    y: 0,
                    width: t,
                    height: e,
                    patternUnits: "userSpaceOnUse"
                })
            }
        }), n.Shape = n.invent({
            create: function (t) {
                this.constructor.call(this, t)
            }, inherit: n.Element
        }), n.Symbol = n.invent({
            create: "symbol", inherit: n.Container, construct: {
                symbol: function () {
                    return this.put(new n.Symbol)
                }
            }
        }), n.Use = n.invent({
            create: "use", inherit: n.Shape, extend: {
                element: function (t, e) {
                    return this.attr("href", (e || "") + "#" + t, n.xlink)
                }
            }, construct: {
                use: function (t, e) {
                    return this.put(new n.Use).element(t, e)
                }
            }
        }), n.Rect = n.invent({
            create: "rect", inherit: n.Shape, construct: {
                rect: function (t, e) {
                    return this.put(new n.Rect).size(t, e)
                }
            }
        }), n.Circle = n.invent({
            create: "circle", inherit: n.Shape, construct: {
                circle: function (t) {
                    return this.put(new n.Circle).rx(new n.Number(t).divide(2)).move(0, 0)
                }
            }
        }), n.extend(n.Circle, n.FX, {
            rx: function (t) {
                return this.attr("r", t)
            }, ry: function (t) {
                return this.rx(t)
            }
        }), n.Ellipse = n.invent({
            create: "ellipse", inherit: n.Shape, construct: {
                ellipse: function (t, e) {
                    return this.put(new n.Ellipse).size(t, e).move(0, 0)
                }
            }
        }), n.extend(n.Ellipse, n.Rect, n.FX, {
            rx: function (t) {
                return this.attr("rx", t)
            }, ry: function (t) {
                return this.attr("ry", t)
            }
        }), n.extend(n.Circle, n.Ellipse, {
            x: function (t) {
                return null == t ? this.cx() - this.rx() : this.cx(t + this.rx())
            }, y: function (t) {
                return null == t ? this.cy() - this.ry() : this.cy(t + this.ry())
            }, cx: function (t) {
                return null == t ? this.attr("cx") : this.attr("cx", t)
            }, cy: function (t) {
                return null == t ? this.attr("cy") : this.attr("cy", t)
            }, width: function (t) {
                return null == t ? 2 * this.rx() : this.rx(new n.Number(t).divide(2))
            }, height: function (t) {
                return null == t ? 2 * this.ry() : this.ry(new n.Number(t).divide(2))
            }, size: function (t, e) {
                var a = p(this, t, e);
                return this.rx(new n.Number(a.width).divide(2)).ry(new n.Number(a.height).divide(2))
            }
        }), n.Line = n.invent({
            create: "line", inherit: n.Shape, extend: {
                array: function () {
                    return new n.PointArray([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]])
                }, plot: function (t, e, a, i) {
                    return null == t ? this.array() : (t = void 0 !== e ? {
                        x1: t,
                        y1: e,
                        x2: a,
                        y2: i
                    } : new n.PointArray(t).toLine(), this.attr(t))
                }, move: function (t, e) {
                    return this.attr(this.array().move(t, e).toLine())
                }, size: function (t, e) {
                    var n = p(this, t, e);
                    return this.attr(this.array().size(n.width, n.height).toLine())
                }
            }, construct: {
                line: function (t, e, a, i) {
                    return n.Line.prototype.plot.apply(this.put(new n.Line), null != t ? [t, e, a, i] : [0, 0, 0, 0])
                }
            }
        }), n.Polyline = n.invent({
            create: "polyline", inherit: n.Shape, construct: {
                polyline: function (t) {
                    return this.put(new n.Polyline).plot(t || new n.PointArray)
                }
            }
        }), n.Polygon = n.invent({
            create: "polygon", inherit: n.Shape, construct: {
                polygon: function (t) {
                    return this.put(new n.Polygon).plot(t || new n.PointArray)
                }
            }
        }), n.extend(n.Polyline, n.Polygon, {
            array: function () {
                return this._array || (this._array = new n.PointArray(this.attr("points")))
            }, plot: function (t) {
                return null == t ? this.array() : this.clear().attr("points", "string" == typeof t ? t : this._array = new n.PointArray(t))
            }, clear: function () {
                return delete this._array, this
            }, move: function (t, e) {
                return this.attr("points", this.array().move(t, e))
            }, size: function (t, e) {
                var n = p(this, t, e);
                return this.attr("points", this.array().size(n.width, n.height))
            }
        }), n.extend(n.Line, n.Polyline, n.Polygon, {
            morphArray: n.PointArray, x: function (t) {
                return null == t ? this.bbox().x : this.move(t, this.bbox().y)
            }, y: function (t) {
                return null == t ? this.bbox().y : this.move(this.bbox().x, t)
            }, width: function (t) {
                var e = this.bbox();
                return null == t ? e.width : this.size(t, e.height)
            }, height: function (t) {
                var e = this.bbox();
                return null == t ? e.height : this.size(e.width, t)
            }
        }), n.Path = n.invent({
            create: "path", inherit: n.Shape, extend: {
                morphArray: n.PathArray, array: function () {
                    return this._array || (this._array = new n.PathArray(this.attr("d")))
                }, plot: function (t) {
                    return null == t ? this.array() : this.clear().attr("d", "string" == typeof t ? t : this._array = new n.PathArray(t))
                }, clear: function () {
                    return delete this._array, this
                }
            }, construct: {
                path: function (t) {
                    return this.put(new n.Path).plot(t || new n.PathArray)
                }
            }
        }), n.Image = n.invent({
            create: "image", inherit: n.Shape, extend: {
                load: function (e) {
                    if (!e) return this;
                    var a = this, i = new t.Image;
                    return n.on(i, "load", (function () {
                        n.off(i);
                        var t = a.parent(n.Pattern);
                        null !== t && (0 == a.width() && 0 == a.height() && a.size(i.width, i.height), t && 0 == t.width() && 0 == t.height() && t.size(a.width(), a.height()), "function" == typeof a._loaded && a._loaded.call(a, {
                            width: i.width,
                            height: i.height,
                            ratio: i.width / i.height,
                            url: e
                        }))
                    })), n.on(i, "error", (function (t) {
                        n.off(i), "function" == typeof a._error && a._error.call(a, t)
                    })), this.attr("href", i.src = this.src = e, n.xlink)
                }, loaded: function (t) {
                    return this._loaded = t, this
                }, error: function (t) {
                    return this._error = t, this
                }
            }, construct: {
                image: function (t, e, a) {
                    return this.put(new n.Image).load(t).size(e || 0, a || e || 0)
                }
            }
        }), n.Text = n.invent({
            create: function () {
                this.constructor.call(this, n.create("text")), this.dom.leading = new n.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", n.defaults.attrs["font-family"])
            }, inherit: n.Shape, extend: {
                x: function (t) {
                    return null == t ? this.attr("x") : this.attr("x", t)
                }, text: function (t) {
                    if (void 0 === t) {
                        t = "";
                        for (var e = this.node.childNodes, a = 0, i = e.length; a < i; ++a) 0 != a && 3 != e[a].nodeType && 1 == n.adopt(e[a]).dom.newLined && (t += "\n"), t += e[a].textContent;
                        return t
                    }
                    if (this.clear().build(!0), "function" == typeof t) t.call(this, this); else {
                        a = 0;
                        for (var r = (t = t.split("\n")).length; a < r; a++) this.tspan(t[a]).newLine()
                    }
                    return this.build(!1).rebuild()
                }, size: function (t) {
                    return this.attr("font-size", t).rebuild()
                }, leading: function (t) {
                    return null == t ? this.dom.leading : (this.dom.leading = new n.Number(t), this.rebuild())
                }, lines: function () {
                    var t = (this.textPath && this.textPath() || this).node,
                        e = n.utils.map(n.utils.filterSVGElements(t.childNodes), (function (t) {
                            return n.adopt(t)
                        }));
                    return new n.Set(e)
                }, rebuild: function (t) {
                    if ("boolean" == typeof t && (this._rebuild = t), this._rebuild) {
                        var e = this, a = 0, i = this.dom.leading * new n.Number(this.attr("font-size"));
                        this.lines().each((function () {
                            this.dom.newLined && (e.textPath() || this.attr("x", e.attr("x")), "\n" == this.text() ? a += i : (this.attr("dy", i + a), a = 0))
                        })), this.fire("rebuild")
                    }
                    return this
                }, build: function (t) {
                    return this._build = !!t, this
                }, setData: function (t) {
                    return this.dom = t, this.dom.leading = new n.Number(t.leading || 1.3), this
                }
            }, construct: {
                text: function (t) {
                    return this.put(new n.Text).text(t)
                }, plain: function (t) {
                    return this.put(new n.Text).plain(t)
                }
            }
        }), n.Tspan = n.invent({
            create: "tspan", inherit: n.Shape, extend: {
                text: function (t) {
                    return null == t ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t ? t.call(this, this) : this.plain(t), this)
                }, dx: function (t) {
                    return this.attr("dx", t)
                }, dy: function (t) {
                    return this.attr("dy", t)
                }, newLine: function () {
                    var t = this.parent(n.Text);
                    return this.dom.newLined = !0, this.dy(t.dom.leading * t.attr("font-size")).attr("x", t.x())
                }
            }
        }), n.extend(n.Text, n.Tspan, {
            plain: function (t) {
                return !1 === this._build && this.clear(), this.node.appendChild(e.createTextNode(t)), this
            }, tspan: function (t) {
                var e = (this.textPath && this.textPath() || this).node, a = new n.Tspan;
                return !1 === this._build && this.clear(), e.appendChild(a.node), a.text(t)
            }, clear: function () {
                for (var t = (this.textPath && this.textPath() || this).node; t.hasChildNodes();) t.removeChild(t.lastChild);
                return this
            }, length: function () {
                return this.node.getComputedTextLength()
            }
        }), n.TextPath = n.invent({
            create: "textPath",
            inherit: n.Parent,
            parent: n.Text,
            construct: {
                morphArray: n.PathArray, array: function () {
                    var t = this.track();
                    return t ? t.array() : null
                }, plot: function (t) {
                    var e = this.track(), n = null;
                    return e && (n = e.plot(t)), null == t ? n : this
                }, track: function () {
                    var t = this.textPath();
                    if (t) return t.reference("href")
                }, textPath: function () {
                    if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return n.adopt(this.node.firstChild)
                }
            }
        }), n.Nested = n.invent({
            create: function () {
                this.constructor.call(this, n.create("svg")), this.style("overflow", "visible")
            }, inherit: n.Container, construct: {
                nested: function () {
                    return this.put(new n.Nested)
                }
            }
        });
        var l = {
            stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
            fill: ["color", "opacity", "rule"],
            prefix: function (t, e) {
                return "color" == e ? t : t + "-" + e
            }
        };

        function c(t, e, a, i) {
            return a + i.replace(n.regex.dots, " .")
        }

        function d(t) {
            return t.toLowerCase().replace(/-(.)/g, (function (t, e) {
                return e.toUpperCase()
            }))
        }

        function u(t) {
            return t.charAt(0).toUpperCase() + t.slice(1)
        }

        function h(t) {
            var e = t.toString(16);
            return 1 == e.length ? "0" + e : e
        }

        function p(t, e, n) {
            if (null == e || null == n) {
                var a = t.bbox();
                null == e ? e = a.width / a.height * n : null == n && (n = a.height / a.width * e)
            }
            return {width: e, height: n}
        }

        function f(t, e, n) {
            return {x: e * t.a + n * t.c + 0, y: e * t.b + n * t.d + 0}
        }

        function g(t) {
            return {a: t[0], b: t[1], c: t[2], d: t[3], e: t[4], f: t[5]}
        }

        function m(e) {
            for (var a = e.childNodes.length - 1; a >= 0; a--) e.childNodes[a] instanceof t.SVGElement && m(e.childNodes[a]);
            return n.adopt(e).id(n.eid(e.nodeName))
        }

        function v(t) {
            return null == t.x && (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t.w = t.width, t.h = t.height, t.x2 = t.x + t.width, t.y2 = t.y + t.height, t.cx = t.x + t.width / 2, t.cy = t.y + t.height / 2, t
        }

        function b(t) {
            return Math.abs(t) > 1e-37 ? t : 0
        }

        ["fill", "stroke"].forEach((function (t) {
            var e = {};
            e[t] = function (e) {
                if (void 0 === e) return this;
                if ("string" == typeof e || n.Color.isRgb(e) || e && "function" == typeof e.fill) this.attr(t, e); else for (var a = l[t].length - 1; a >= 0; a--) null != e[l[t][a]] && this.attr(l.prefix(t, l[t][a]), e[l[t][a]]);
                return this
            }, n.extend(n.Element, n.FX, e)
        })), n.extend(n.Element, n.FX, {
            translate: function (t, e) {
                return this.transform({x: t, y: e})
            }, matrix: function (t) {
                return this.attr("transform", new n.Matrix(6 == arguments.length ? [].slice.call(arguments) : t))
            }, opacity: function (t) {
                return this.attr("opacity", t)
            }, dx: function (t) {
                return this.x(new n.Number(t).plus(this instanceof n.FX ? 0 : this.x()), !0)
            }, dy: function (t) {
                return this.y(new n.Number(t).plus(this instanceof n.FX ? 0 : this.y()), !0)
            }
        }), n.extend(n.Path, {
            length: function () {
                return this.node.getTotalLength()
            }, pointAt: function (t) {
                return this.node.getPointAtLength(t)
            }
        }), n.Set = n.invent({
            create: function (t) {
                Array.isArray(t) ? this.members = t : this.clear()
            }, extend: {
                add: function () {
                    for (var t = [].slice.call(arguments), e = 0, n = t.length; e < n; e++) this.members.push(t[e]);
                    return this
                }, remove: function (t) {
                    var e = this.index(t);
                    return e > -1 && this.members.splice(e, 1), this
                }, each: function (t) {
                    for (var e = 0, n = this.members.length; e < n; e++) t.apply(this.members[e], [e, this.members]);
                    return this
                }, clear: function () {
                    return this.members = [], this
                }, length: function () {
                    return this.members.length
                }, has: function (t) {
                    return this.index(t) >= 0
                }, index: function (t) {
                    return this.members.indexOf(t)
                }, get: function (t) {
                    return this.members[t]
                }, first: function () {
                    return this.get(0)
                }, last: function () {
                    return this.get(this.members.length - 1)
                }, valueOf: function () {
                    return this.members
                }
            }, construct: {
                set: function (t) {
                    return new n.Set(t)
                }
            }
        }), n.FX.Set = n.invent({
            create: function (t) {
                this.set = t
            }
        }), n.Set.inherit = function () {
            var t = [];
            for (var e in n.Shape.prototype) "function" == typeof n.Shape.prototype[e] && "function" != typeof n.Set.prototype[e] && t.push(e);
            for (var e in t.forEach((function (t) {
                n.Set.prototype[t] = function () {
                    for (var e = 0, a = this.members.length; e < a; e++) this.members[e] && "function" == typeof this.members[e][t] && this.members[e][t].apply(this.members[e], arguments);
                    return "animate" == t ? this.fx || (this.fx = new n.FX.Set(this)) : this
                }
            })), t = [], n.FX.prototype) "function" == typeof n.FX.prototype[e] && "function" != typeof n.FX.Set.prototype[e] && t.push(e);
            t.forEach((function (t) {
                n.FX.Set.prototype[t] = function () {
                    for (var e = 0, n = this.set.members.length; e < n; e++) this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments);
                    return this
                }
            }))
        }, n.extend(n.Element, {}), n.extend(n.Element, {
            remember: function (t, e) {
                if ("object" === i(arguments[0])) for (var n in t) this.remember(n, t[n]); else {
                    if (1 == arguments.length) return this.memory()[t];
                    this.memory()[t] = e
                }
                return this
            }, forget: function () {
                if (0 == arguments.length) this._memory = {}; else for (var t = arguments.length - 1; t >= 0; t--) delete this.memory()[arguments[t]];
                return this
            }, memory: function () {
                return this._memory || (this._memory = {})
            }
        }), n.get = function (t) {
            var a = e.getElementById(function (t) {
                var e = (t || "").toString().match(n.regex.reference);
                if (e) return e[1]
            }(t) || t);
            return n.adopt(a)
        }, n.select = function (t, a) {
            return new n.Set(n.utils.map((a || e).querySelectorAll(t), (function (t) {
                return n.adopt(t)
            })))
        }, n.extend(n.Parent, {
            select: function (t) {
                return n.select(t, this.node)
            }
        });
        var y = "abcdef".split("");
        if ("function" != typeof t.CustomEvent) {
            var x = function (t, n) {
                n = n || {bubbles: !1, cancelable: !1, detail: void 0};
                var a = e.createEvent("CustomEvent");
                return a.initCustomEvent(t, n.bubbles, n.cancelable, n.detail), a
            };
            x.prototype = t.Event.prototype, n.CustomEvent = x
        } else n.CustomEvent = t.CustomEvent;
        return n
    }, void 0 !== (a = function () {
        return Pt(Rt, Rt.document)
    }.call(e, n, e, t)) && (t.exports = a), function () {
        SVG.Filter = SVG.invent({
            create: "filter", inherit: SVG.Parent, extend: {
                source: "SourceGraphic",
                sourceAlpha: "SourceAlpha",
                background: "BackgroundImage",
                backgroundAlpha: "BackgroundAlpha",
                fill: "FillPaint",
                stroke: "StrokePaint",
                autoSetIn: !0,
                put: function (t, e) {
                    return this.add(t, e), !t.attr("in") && this.autoSetIn && t.attr("in", this.source), t.attr("result") || t.attr("result", t), t
                },
                blend: function (t, e, n) {
                    return this.put(new SVG.BlendEffect(t, e, n))
                },
                colorMatrix: function (t, e) {
                    return this.put(new SVG.ColorMatrixEffect(t, e))
                },
                convolveMatrix: function (t) {
                    return this.put(new SVG.ConvolveMatrixEffect(t))
                },
                componentTransfer: function (t) {
                    return this.put(new SVG.ComponentTransferEffect(t))
                },
                composite: function (t, e, n) {
                    return this.put(new SVG.CompositeEffect(t, e, n))
                },
                flood: function (t, e) {
                    return this.put(new SVG.FloodEffect(t, e))
                },
                offset: function (t, e) {
                    return this.put(new SVG.OffsetEffect(t, e))
                },
                image: function (t) {
                    return this.put(new SVG.ImageEffect(t))
                },
                merge: function () {
                    var t = [void 0];
                    for (var e in arguments) t.push(arguments[e]);
                    return this.put(new (SVG.MergeEffect.bind.apply(SVG.MergeEffect, t)))
                },
                gaussianBlur: function (t, e) {
                    return this.put(new SVG.GaussianBlurEffect(t, e))
                },
                morphology: function (t, e) {
                    return this.put(new SVG.MorphologyEffect(t, e))
                },
                diffuseLighting: function (t, e, n) {
                    return this.put(new SVG.DiffuseLightingEffect(t, e, n))
                },
                displacementMap: function (t, e, n, a, i) {
                    return this.put(new SVG.DisplacementMapEffect(t, e, n, a, i))
                },
                specularLighting: function (t, e, n, a) {
                    return this.put(new SVG.SpecularLightingEffect(t, e, n, a))
                },
                tile: function () {
                    return this.put(new SVG.TileEffect)
                },
                turbulence: function (t, e, n, a, i) {
                    return this.put(new SVG.TurbulenceEffect(t, e, n, a, i))
                },
                toString: function () {
                    return "url(#" + this.attr("id") + ")"
                }
            }
        }), SVG.extend(SVG.Defs, {
            filter: function (t) {
                var e = this.put(new SVG.Filter);
                return "function" == typeof t && t.call(e, e), e
            }
        }), SVG.extend(SVG.Container, {
            filter: function (t) {
                return this.defs().filter(t)
            }
        }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
            filter: function (t) {
                return this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer
            }, unfilter: function (t) {
                return this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr("filter", null)
            }
        }), SVG.Effect = SVG.invent({
            create: function () {
                this.constructor.call(this)
            }, inherit: SVG.Element, extend: {
                in: function (t) {
                    return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t)
                }, result: function (t) {
                    return null == t ? this.attr("result") : this.attr("result", t)
                }, toString: function () {
                    return this.result()
                }
            }
        }), SVG.ParentEffect = SVG.invent({
            create: function () {
                this.constructor.call(this)
            }, inherit: SVG.Parent, extend: {
                in: function (t) {
                    return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t)
                }, result: function (t) {
                    return null == t ? this.attr("result") : this.attr("result", t)
                }, toString: function () {
                    return this.result()
                }
            }
        });
        var t = {
            blend: function (t, e) {
                return this.parent() && this.parent().blend(this, t, e)
            }, colorMatrix: function (t, e) {
                return this.parent() && this.parent().colorMatrix(t, e).in(this)
            }, convolveMatrix: function (t) {
                return this.parent() && this.parent().convolveMatrix(t).in(this)
            }, componentTransfer: function (t) {
                return this.parent() && this.parent().componentTransfer(t).in(this)
            }, composite: function (t, e) {
                return this.parent() && this.parent().composite(this, t, e)
            }, flood: function (t, e) {
                return this.parent() && this.parent().flood(t, e)
            }, offset: function (t, e) {
                return this.parent() && this.parent().offset(t, e).in(this)
            }, image: function (t) {
                return this.parent() && this.parent().image(t)
            }, merge: function () {
                return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
            }, gaussianBlur: function (t, e) {
                return this.parent() && this.parent().gaussianBlur(t, e).in(this)
            }, morphology: function (t, e) {
                return this.parent() && this.parent().morphology(t, e).in(this)
            }, diffuseLighting: function (t, e, n) {
                return this.parent() && this.parent().diffuseLighting(t, e, n).in(this)
            }, displacementMap: function (t, e, n, a) {
                return this.parent() && this.parent().displacementMap(this, t, e, n, a)
            }, specularLighting: function (t, e, n, a) {
                return this.parent() && this.parent().specularLighting(t, e, n, a).in(this)
            }, tile: function () {
                return this.parent() && this.parent().tile().in(this)
            }, turbulence: function (t, e, n, a, i) {
                return this.parent() && this.parent().turbulence(t, e, n, a, i).in(this)
            }
        };
        SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({
            create: function () {
                this.constructor.call(this)
            }, inherit: SVG.Element, extend: {
                in: function (t) {
                    this.attr("in", t)
                }
            }
        });
        var e = {
            blend: function (t, e, n) {
                this.attr({in: t, in2: e, mode: n || "normal"})
            }, colorMatrix: function (t, e) {
                "matrix" == t && (e = i(e)), this.attr({type: t, values: void 0 === e ? null : e})
            }, convolveMatrix: function (t) {
                t = i(t), this.attr({order: Math.sqrt(t.split(" ").length), kernelMatrix: t})
            }, composite: function (t, e, n) {
                this.attr({in: t, in2: e, operator: n})
            }, flood: function (t, e) {
                this.attr("flood-color", t), null != e && this.attr("flood-opacity", e)
            }, offset: function (t, e) {
                this.attr({dx: t, dy: e})
            }, image: function (t) {
                this.attr("href", t, SVG.xlink)
            }, displacementMap: function (t, e, n, a, i) {
                this.attr({in: t, in2: e, scale: n, xChannelSelector: a, yChannelSelector: i})
            }, gaussianBlur: function (t, e) {
                null != t || null != e ? this.attr("stdDeviation", r(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0")
            }, morphology: function (t, e) {
                this.attr({operator: t, radius: e})
            }, tile: function () {
            }, turbulence: function (t, e, n, a, i) {
                this.attr({numOctaves: e, seed: n, stitchTiles: a, baseFrequency: t, type: i})
            }
        }, n = {
            merge: function () {
                var t;
                if (arguments[0] instanceof SVG.Set) {
                    var e = this;
                    arguments[0].each((function (t) {
                        this instanceof SVG.MergeNode ? e.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e.put(new SVG.MergeNode(this))
                    }))
                } else {
                    t = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                    for (var n = 0; n < t.length; n++) t[n] instanceof SVG.MergeNode ? this.put(t[n]) : this.put(new SVG.MergeNode(t[n]))
                }
            }, componentTransfer: function (t) {
                if (this.rgb = new SVG.Set, ["r", "g", "b", "a"].forEach(function (t) {
                    this[t] = new (SVG["Func" + t.toUpperCase()])("identity"), this.rgb.add(this[t]), this.node.appendChild(this[t].node)
                }.bind(this)), t) for (var e in t.rgb && (["r", "g", "b"].forEach(function (e) {
                    this[e].attr(t.rgb)
                }.bind(this)), delete t.rgb), t) this[e].attr(t[e])
            }, diffuseLighting: function (t, e, n) {
                this.attr({surfaceScale: t, diffuseConstant: e, kernelUnitLength: n})
            }, specularLighting: function (t, e, n, a) {
                this.attr({surfaceScale: t, diffuseConstant: e, specularExponent: n, kernelUnitLength: a})
            }
        }, a = {
            distantLight: function (t, e) {
                this.attr({azimuth: t, elevation: e})
            }, pointLight: function (t, e, n) {
                this.attr({x: t, y: e, z: n})
            }, spotLight: function (t, e, n, a, i, r) {
                this.attr({x: t, y: e, z: n, pointsAtX: a, pointsAtY: i, pointsAtZ: r})
            }, mergeNode: function (t) {
                this.attr("in", t)
            }
        };

        function i(t) {
            return Array.isArray(t) && (t = new SVG.Array(t)), t.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
        }

        function r(t) {
            if (!Array.isArray(t)) return t;
            for (var e = 0, n = t.length, a = []; e < n; e++) a.push(t[e]);
            return a.join(" ")
        }

        function o() {
            var t = function () {
            };
            for (var e in "function" == typeof arguments[arguments.length - 1] && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments) for (var n in arguments[e]) t(arguments[e][n], n, arguments[e])
        }

        ["r", "g", "b", "a"].forEach((function (t) {
            a["Func" + t.toUpperCase()] = function (t) {
                switch (this.attr("type", t), t) {
                    case"table":
                        this.attr("tableValues", arguments[1]);
                        break;
                    case"linear":
                        this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                        break;
                    case"gamma":
                        this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2])
                }
            }
        })), o(e, (function (t, e) {
            var n = e.charAt(0).toUpperCase() + e.slice(1);
            SVG[n + "Effect"] = SVG.invent({
                create: function () {
                    this.constructor.call(this, SVG.create("fe" + n)), t.apply(this, arguments), this.result(this.attr("id") + "Out")
                }, inherit: SVG.Effect, extend: {}
            })
        })), o(n, (function (t, e) {
            var n = e.charAt(0).toUpperCase() + e.slice(1);
            SVG[n + "Effect"] = SVG.invent({
                create: function () {
                    this.constructor.call(this, SVG.create("fe" + n)), t.apply(this, arguments), this.result(this.attr("id") + "Out")
                }, inherit: SVG.ParentEffect, extend: {}
            })
        })), o(a, (function (t, e) {
            var n = e.charAt(0).toUpperCase() + e.slice(1);
            SVG[n] = SVG.invent({
                create: function () {
                    this.constructor.call(this, SVG.create("fe" + n)), t.apply(this, arguments)
                }, inherit: SVG.ChildEffect, extend: {}
            })
        })), SVG.extend(SVG.MergeEffect, {
            in: function (t) {
                return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this
            }
        }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
            in2: function (t) {
                return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t)
            }
        }), SVG.filter = {sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]}
    }.call(void 0), function () {
        function t(t, i, r, o, s, l, c) {
            for (var d = t.slice(i, r || c), u = o.slice(s, l || c), h = 0, p = {
                pos: [0, 0],
                start: [0, 0]
            }, f = {
                pos: [0, 0],
                start: [0, 0]
            }; d[h] = e.call(p, d[h]), u[h] = e.call(f, u[h]), d[h][0] != u[h][0] || "M" == d[h][0] || "A" == d[h][0] && (d[h][4] != u[h][4] || d[h][5] != u[h][5]) ? (Array.prototype.splice.apply(d, [h, 1].concat(a.call(p, d[h]))), Array.prototype.splice.apply(u, [h, 1].concat(a.call(f, u[h])))) : (d[h] = n.call(p, d[h]), u[h] = n.call(f, u[h])), ++h != d.length || h != u.length;) h == d.length && d.push(["C", p.pos[0], p.pos[1], p.pos[0], p.pos[1], p.pos[0], p.pos[1]]), h == u.length && u.push(["C", f.pos[0], f.pos[1], f.pos[0], f.pos[1], f.pos[0], f.pos[1]]);
            return {start: d, dest: u}
        }

        function e(t) {
            switch (t[0]) {
                case"z":
                case"Z":
                    t[0] = "L", t[1] = this.start[0], t[2] = this.start[1];
                    break;
                case"H":
                    t[0] = "L", t[2] = this.pos[1];
                    break;
                case"V":
                    t[0] = "L", t[2] = t[1], t[1] = this.pos[0];
                    break;
                case"T":
                    t[0] = "Q", t[3] = t[1], t[4] = t[2], t[1] = this.reflection[1], t[2] = this.reflection[0];
                    break;
                case"S":
                    t[0] = "C", t[6] = t[4], t[5] = t[3], t[4] = t[2], t[3] = t[1], t[2] = this.reflection[1], t[1] = this.reflection[0]
            }
            return t
        }

        function n(t) {
            var e = t.length;
            return this.pos = [t[e - 2], t[e - 1]], -1 != "SCQT".indexOf(t[0]) && (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]), t
        }

        function a(t) {
            var e = [t];
            switch (t[0]) {
                case"M":
                    return this.pos = this.start = [t[1], t[2]], e;
                case"L":
                    t[5] = t[3] = t[1], t[6] = t[4] = t[2], t[1] = this.pos[0], t[2] = this.pos[1];
                    break;
                case"Q":
                    t[6] = t[4], t[5] = t[3], t[4] = 1 * t[4] / 3 + 2 * t[2] / 3, t[3] = 1 * t[3] / 3 + 2 * t[1] / 3, t[2] = 1 * this.pos[1] / 3 + 2 * t[2] / 3, t[1] = 1 * this.pos[0] / 3 + 2 * t[1] / 3;
                    break;
                case"A":
                    t = (e = function (t, e) {
                        var n, a, i, r, o, s, l, c, d, u, h, p, f, g, m, v, b, y, x, _, w, S, C, k, D, T,
                            E = Math.abs(e[1]), A = Math.abs(e[2]), I = e[3] % 360, M = e[4], R = e[5], P = e[6],
                            O = e[7], j = new SVG.Point(t), N = new SVG.Point(P, O), L = [];
                        if (0 === E || 0 === A || j.x === N.x && j.y === N.y) return [["C", j.x, j.y, N.x, N.y, N.x, N.y]];
                        for ((a = (n = new SVG.Point((j.x - N.x) / 2, (j.y - N.y) / 2).transform((new SVG.Matrix).rotate(I))).x * n.x / (E * E) + n.y * n.y / (A * A)) > 1 && (E *= a = Math.sqrt(a), A *= a), i = (new SVG.Matrix).rotate(I).scale(1 / E, 1 / A).rotate(-I), j = j.transform(i), s = (r = [(N = N.transform(i)).x - j.x, N.y - j.y])[0] * r[0] + r[1] * r[1], o = Math.sqrt(s), r[0] /= o, r[1] /= o, l = s < 4 ? Math.sqrt(1 - s / 4) : 0, M === R && (l *= -1), c = new SVG.Point((N.x + j.x) / 2 + l * -r[1], (N.y + j.y) / 2 + l * r[0]), d = new SVG.Point(j.x - c.x, j.y - c.y), u = new SVG.Point(N.x - c.x, N.y - c.y), h = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)), d.y < 0 && (h *= -1), p = Math.acos(u.x / Math.sqrt(u.x * u.x + u.y * u.y)), u.y < 0 && (p *= -1), R && h > p && (p += 2 * Math.PI), !R && h < p && (p -= 2 * Math.PI), v = [], b = h, f = (p - h) / (g = Math.ceil(2 * Math.abs(h - p) / Math.PI)), m = 4 * Math.tan(f / 4) / 3, w = 0; w <= g; w++) x = Math.cos(b), y = Math.sin(b), _ = new SVG.Point(c.x + x, c.y + y), v[w] = [new SVG.Point(_.x + m * y, _.y - m * x), _, new SVG.Point(_.x - m * y, _.y + m * x)], b += f;
                        for (v[0][0] = v[0][1].clone(), v[v.length - 1][2] = v[v.length - 1][1].clone(), i = (new SVG.Matrix).rotate(I).scale(E, A).rotate(-I), w = 0, S = v.length; w < S; w++) v[w][0] = v[w][0].transform(i), v[w][1] = v[w][1].transform(i), v[w][2] = v[w][2].transform(i);
                        for (w = 1, S = v.length; w < S; w++) C = (_ = v[w - 1][2]).x, k = _.y, D = (_ = v[w][0]).x, T = _.y, P = (_ = v[w][1]).x, O = _.y, L.push(["C", C, k, D, T, P, O]);
                        return L
                    }(this.pos, t))[0]
            }
            return t[0] = "C", this.pos = [t[5], t[6]], this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]], e
        }

        function i(t, e) {
            if (!1 === e) return !1;
            for (var n = e, a = t.length; n < a; ++n) if ("M" == t[n][0]) return n;
            return !1
        }

        SVG.extend(SVG.PathArray, {
            morph: function (e) {
                for (var n = this.value, a = this.parse(e), r = 0, o = 0, s = !1, l = !1; !1 !== r || !1 !== o;) {
                    var c;
                    s = i(n, !1 !== r && r + 1), l = i(a, !1 !== o && o + 1), !1 === r && (r = 0 == (c = new SVG.PathArray(d.start).bbox()).height || 0 == c.width ? n.push(n[0]) - 1 : n.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1), !1 === o && (o = 0 == (c = new SVG.PathArray(d.dest).bbox()).height || 0 == c.width ? a.push(a[0]) - 1 : a.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1);
                    var d = t(n, r, s, a, o, l);
                    n = n.slice(0, r).concat(d.start, !1 === s ? [] : n.slice(s)), a = a.slice(0, o).concat(d.dest, !1 === l ? [] : a.slice(l)), r = !1 !== s && r + d.start.length, o = !1 !== l && o + d.dest.length
                }
                return this.value = n, this.destination = new SVG.PathArray, this.destination.value = a, this
            }
        })
    }(), function () {
        function t(t) {
            t.remember("_draggable", this), this.el = t
        }

        t.prototype.init = function (t, e) {
            var n = this;
            this.constraint = t, this.value = e, this.el.on("mousedown.drag", (function (t) {
                n.start(t)
            })), this.el.on("touchstart.drag", (function (t) {
                n.start(t)
            }))
        }, t.prototype.transformPoint = function (t, e) {
            var n = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
            return this.p.x = n.clientX - (e || 0), this.p.y = n.clientY, this.p.matrixTransform(this.m)
        }, t.prototype.getBBox = function () {
            var t = this.el.bbox();
            return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t
        }, t.prototype.start = function (t) {
            if ("click" != t.type && "mousedown" != t.type && "mousemove" != t.type || 1 == (t.which || t.buttons)) {
                var e = this;
                if (this.el.fire("beforedrag", {event: t, handler: this}), !this.el.event().defaultPrevented) {
                    t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
                    var n, a = this.getBBox();
                    if (this.el instanceof SVG.Text) switch (n = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                        case"middle":
                            n /= 2;
                            break;
                        case"start":
                            n = 0
                    }
                    this.startPoints = {
                        point: this.transformPoint(t, n),
                        box: a,
                        transform: this.el.transform()
                    }, SVG.on(window, "mousemove.drag", (function (t) {
                        e.drag(t)
                    })), SVG.on(window, "touchmove.drag", (function (t) {
                        e.drag(t)
                    })), SVG.on(window, "mouseup.drag", (function (t) {
                        e.end(t)
                    })), SVG.on(window, "touchend.drag", (function (t) {
                        e.end(t)
                    })), this.el.fire("dragstart", {event: t, p: this.startPoints.point, m: this.m, handler: this})
                }
            }
        }, t.prototype.drag = function (t) {
            var e = this.getBBox(), n = this.transformPoint(t),
                a = this.startPoints.box.x + n.x - this.startPoints.point.x,
                i = this.startPoints.box.y + n.y - this.startPoints.point.y, r = this.constraint,
                o = n.x - this.startPoints.point.x, s = n.y - this.startPoints.point.y;
            if (this.el.fire("dragmove", {
                event: t,
                p: n,
                m: this.m,
                handler: this
            }), this.el.event().defaultPrevented) return n;
            if ("function" == typeof r) {
                var l = r.call(this.el, a, i, this.m);
                "boolean" == typeof l && (l = {
                    x: l,
                    y: l
                }), !0 === l.x ? this.el.x(a) : !1 !== l.x && this.el.x(l.x), !0 === l.y ? this.el.y(i) : !1 !== l.y && this.el.y(l.y)
            } else "object" == typeof r && (null != r.minX && a < r.minX ? o = (a = r.minX) - this.startPoints.box.x : null != r.maxX && a > r.maxX - e.width && (o = (a = r.maxX - e.width) - this.startPoints.box.x), null != r.minY && i < r.minY ? s = (i = r.minY) - this.startPoints.box.y : null != r.maxY && i > r.maxY - e.height && (s = (i = r.maxY - e.height) - this.startPoints.box.y), null != r.snapToGrid && (a -= a % r.snapToGrid, i -= i % r.snapToGrid, o -= o % r.snapToGrid, s -= s % r.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                x: o,
                y: s
            }, !0) : this.el.move(a, i));
            return n
        }, t.prototype.end = function (t) {
            var e = this.drag(t);
            this.el.fire("dragend", {
                event: t,
                p: e,
                m: this.m,
                handler: this
            }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag")
        }, SVG.extend(SVG.Element, {
            draggable: function (e, n) {
                "function" != typeof e && "object" != typeof e || (n = e, e = !0);
                var a = this.remember("_draggable") || new t(this);
                return (e = void 0 === e || e) ? a.init(n || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this
            }
        })
    }.call(void 0), function () {
        function t(t) {
            this.el = t, t.remember("_selectHandler", this), this.pointSelection = {isSelected: !1}, this.rectSelection = {isSelected: !1}, this.pointsList = {
                lt: [0, 0],
                rt: ["width", 0],
                rb: ["width", "height"],
                lb: [0, "height"],
                t: ["width", 0],
                r: ["width", "height"],
                b: ["width", "height"],
                l: [0, "height"]
            }, this.pointCoord = function (t, e, n) {
                var a = "string" != typeof t ? t : e[t];
                return n ? a / 2 : a
            }, this.pointCoords = function (t, e) {
                var n = this.pointsList[t];
                return {
                    x: this.pointCoord(n[0], e, "t" === t || "b" === t),
                    y: this.pointCoord(n[1], e, "r" === t || "l" === t)
                }
            }
        }

        t.prototype.init = function (t, e) {
            var n = this.el.bbox();
            this.options = {};
            var a = this.el.selectize.defaults.points;
            for (var i in this.el.selectize.defaults) this.options[i] = this.el.selectize.defaults[i], void 0 !== e[i] && (this.options[i] = e[i]);
            var r = ["points", "pointsExclude"];
            for (var i in r) {
                var o = this.options[r[i]];
                "string" == typeof o ? o = o.length > 0 ? o.split(/\s*,\s*/i) : [] : "boolean" == typeof o && "points" === r[i] && (o = o ? a : []), this.options[r[i]] = o
            }
            this.options.points = [a, this.options.points].reduce((function (t, e) {
                return t.filter((function (t) {
                    return e.indexOf(t) > -1
                }))
            })), this.options.points = [this.options.points, this.options.pointsExclude].reduce((function (t, e) {
                return t.filter((function (t) {
                    return e.indexOf(t) < 0
                }))
            })), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(n.x, n.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup()
        }, t.prototype.selectPoints = function (t) {
            return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this
        }, t.prototype.getPointArray = function () {
            var t = this.el.bbox();
            return this.el.array().valueOf().map((function (e) {
                return [e[0] - t.x, e[1] - t.y]
            }))
        }, t.prototype.drawPoints = function () {
            for (var t = this, e = this.getPointArray(), n = 0, a = e.length; n < a; ++n) {
                var i = function (e) {
                        return function (n) {
                            (n = n || window.event).preventDefault ? n.preventDefault() : n.returnValue = !1, n.stopPropagation();
                            var a = n.pageX || n.touches[0].pageX, i = n.pageY || n.touches[0].pageY;
                            t.el.fire("point", {x: a, y: i, i: e, event: n})
                        }
                    }(n),
                    r = this.drawPoint(e[n][0], e[n][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", i).on("mousedown", i);
                this.pointSelection.set.add(r)
            }
        }, t.prototype.drawPoint = function (t, e) {
            var n = this.options.pointType;
            switch (n) {
                case"circle":
                    return this.drawCircle(t, e);
                case"rect":
                    return this.drawRect(t, e);
                default:
                    if ("function" == typeof n) return n.call(this, t, e);
                    throw new Error("Unknown " + n + " point type!")
            }
        }, t.prototype.drawCircle = function (t, e) {
            return this.nested.circle(this.options.pointSize).center(t, e)
        }, t.prototype.drawRect = function (t, e) {
            return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, e)
        }, t.prototype.updatePointSelection = function () {
            var t = this.getPointArray();
            this.pointSelection.set.each((function (e) {
                this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1])
            }))
        }, t.prototype.updateRectSelection = function () {
            var t = this, e = this.el.bbox();
            if (this.rectSelection.set.get(0).attr({
                width: e.width,
                height: e.height
            }), this.options.points.length && this.options.points.map((function (n, a) {
                var i = t.pointCoords(n, e);
                t.rectSelection.set.get(a + 1).center(i.x, i.y)
            })), this.options.rotationPoint) {
                var n = this.rectSelection.set.length();
                this.rectSelection.set.get(n - 1).center(e.width / 2, 20)
            }
        }, t.prototype.selectRect = function (t) {
            var e = this, n = this.el.bbox();

            function a(t) {
                return function (n) {
                    (n = n || window.event).preventDefault ? n.preventDefault() : n.returnValue = !1, n.stopPropagation();
                    var a = n.pageX || n.touches[0].pageX, i = n.pageY || n.touches[0].pageY;
                    e.el.fire(t, {x: a, y: i, event: n})
                }
            }

            if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(n.width, n.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map((function (t, i) {
                var r = e.pointCoords(t, n),
                    o = e.drawPoint(r.x, r.y).attr("class", e.options.classPoints + "_" + t).on("mousedown", a(t)).on("touchstart", a(t));
                e.rectSelection.set.add(o)
            })), this.rectSelection.set.each((function () {
                this.addClass(e.options.classPoints)
            }))), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
                var i = function (t) {
                        (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation();
                        var n = t.pageX || t.touches[0].pageX, a = t.pageY || t.touches[0].pageY;
                        e.el.fire("rot", {x: n, y: a, event: t})
                    },
                    r = this.drawPoint(n.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", i).on("mousedown", i);
                this.rectSelection.set.add(r)
            }
        }, t.prototype.handler = function () {
            var t = this.el.bbox();
            this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection()
        }, t.prototype.observe = function () {
            var t = this;
            if (MutationObserver) if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver((function () {
                t.handler()
            })), this.observerInst.observe(this.el.node, {attributes: !0}); else try {
                this.observerInst.disconnect(), delete this.observerInst
            } catch (t) {
            } else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", (function () {
                t.handler()
            }))
        }, t.prototype.cleanup = function () {
            !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each((function () {
                this.remove()
            })), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each((function () {
                this.remove()
            })), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested)
        }, SVG.extend(SVG.Element, {
            selectize: function (e, n) {
                return "object" == typeof e && (n = e, e = !0), (this.remember("_selectHandler") || new t(this)).init(void 0 === e || e, n || {}), this
            }
        }), SVG.Element.prototype.selectize.defaults = {
            points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
            pointsExclude: [],
            classRect: "svg_select_boundingRect",
            classPoints: "svg_select_points",
            pointSize: 7,
            rotationPoint: !0,
            deepSelect: !1,
            pointType: "circle"
        }
    }(), function () {
        (function () {
            function t(t) {
                t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint()
            }

            t.prototype.transformPoint = function (t, e, n) {
                return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(n || this.m)
            }, t.prototype._extractPosition = function (t) {
                return {
                    x: null != t.clientX ? t.clientX : t.touches[0].clientX,
                    y: null != t.clientY ? t.clientY : t.touches[0].clientY
                }
            }, t.prototype.init = function (t) {
                var e = this;
                if (this.stop(), "stop" !== t) {
                    for (var n in this.options = {}, this.el.resize.defaults) this.options[n] = this.el.resize.defaults[n], void 0 !== t[n] && (this.options[n] = t[n]);
                    this.el.on("lt.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("rt.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("rb.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("lb.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("t.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("r.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("b.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("l.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("rot.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.el.on("point.resize", (function (t) {
                        e.resize(t || window.event)
                    })), this.update()
                }
            }, t.prototype.stop = function () {
                return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this
            }, t.prototype.resize = function (t) {
                var e = this;
                this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
                    x: window.pageXOffset,
                    y: window.pageYOffset
                };
                var n = this._extractPosition(t.detail.event);
                if (this.parameters = {
                    type: this.el.type,
                    p: this.transformPoint(n.x, n.y),
                    x: t.detail.x,
                    y: t.detail.y,
                    box: this.el.bbox(),
                    rotation: this.el.transform().rotation
                }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t.detail.i) {
                    var a = this.el.array().valueOf();
                    this.parameters.i = t.detail.i, this.parameters.pointCoords = [a[t.detail.i][0], a[t.detail.i][1]]
                }
                switch (t.type) {
                    case"lt":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e);
                            if (this.parameters.box.width - n[0] > 0 && this.parameters.box.height - n[1] > 0) {
                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + n[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - n[0]);
                                n = this.checkAspectRatio(n), this.el.move(this.parameters.box.x + n[0], this.parameters.box.y + n[1]).size(this.parameters.box.width - n[0], this.parameters.box.height - n[1])
                            }
                        };
                        break;
                    case"rt":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, 2);
                            if (this.parameters.box.width + n[0] > 0 && this.parameters.box.height - n[1] > 0) {
                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - n[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + n[0]);
                                n = this.checkAspectRatio(n, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + n[1]).size(this.parameters.box.width + n[0], this.parameters.box.height - n[1])
                            }
                        };
                        break;
                    case"rb":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, 0);
                            if (this.parameters.box.width + n[0] > 0 && this.parameters.box.height + n[1] > 0) {
                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - n[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + n[0]);
                                n = this.checkAspectRatio(n), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + n[0], this.parameters.box.height + n[1])
                            }
                        };
                        break;
                    case"lb":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, 1);
                            if (this.parameters.box.width - n[0] > 0 && this.parameters.box.height + n[1] > 0) {
                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + n[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - n[0]);
                                n = this.checkAspectRatio(n, !0), this.el.move(this.parameters.box.x + n[0], this.parameters.box.y).size(this.parameters.box.width - n[0], this.parameters.box.height + n[1])
                            }
                        };
                        break;
                    case"t":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, 2);
                            if (this.parameters.box.height - n[1] > 0) {
                                if ("text" === this.parameters.type) return;
                                this.el.move(this.parameters.box.x, this.parameters.box.y + n[1]).height(this.parameters.box.height - n[1])
                            }
                        };
                        break;
                    case"r":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, 0);
                            if (this.parameters.box.width + n[0] > 0) {
                                if ("text" === this.parameters.type) return;
                                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + n[0])
                            }
                        };
                        break;
                    case"b":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, 0);
                            if (this.parameters.box.height + n[1] > 0) {
                                if ("text" === this.parameters.type) return;
                                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + n[1])
                            }
                        };
                        break;
                    case"l":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, 1);
                            if (this.parameters.box.width - n[0] > 0) {
                                if ("text" === this.parameters.type) return;
                                this.el.move(this.parameters.box.x + n[0], this.parameters.box.y).width(this.parameters.box.width - n[0])
                            }
                        };
                        break;
                    case"rot":
                        this.calc = function (t, e) {
                            var n = t + this.parameters.p.x, a = e + this.parameters.p.y,
                                i = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                                r = Math.atan2(a - this.parameters.box.y - this.parameters.box.height / 2, n - this.parameters.box.x - this.parameters.box.width / 2),
                                o = this.parameters.rotation + 180 * (r - i) / Math.PI + this.options.snapToAngle / 2;
                            this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(o - o % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                        };
                        break;
                    case"point":
                        this.calc = function (t, e) {
                            var n = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                                a = this.el.array().valueOf();
                            a[this.parameters.i][0] = this.parameters.pointCoords[0] + n[0], a[this.parameters.i][1] = this.parameters.pointCoords[1] + n[1], this.el.plot(a)
                        }
                }
                this.el.fire("resizestart", {
                    dx: this.parameters.x,
                    dy: this.parameters.y,
                    event: t
                }), SVG.on(window, "touchmove.resize", (function (t) {
                    e.update(t || window.event)
                })), SVG.on(window, "touchend.resize", (function () {
                    e.done()
                })), SVG.on(window, "mousemove.resize", (function (t) {
                    e.update(t || window.event)
                })), SVG.on(window, "mouseup.resize", (function () {
                    e.done()
                }))
            }, t.prototype.update = function (t) {
                if (t) {
                    var e = this._extractPosition(t), n = this.transformPoint(e.x, e.y), a = n.x - this.parameters.p.x,
                        i = n.y - this.parameters.p.y;
                    this.lastUpdateCall = [a, i], this.calc(a, i), this.el.fire("resizing", {dx: a, dy: i, event: t})
                } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
            }, t.prototype.done = function () {
                this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone")
            }, t.prototype.snapToGrid = function (t, e, n, a) {
                var i;
                return void 0 !== a ? i = [(n + t) % this.options.snapToGrid, (a + e) % this.options.snapToGrid] : (n = null == n ? 3 : n, i = [(this.parameters.box.x + t + (1 & n ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & n ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (i[0] -= this.options.snapToGrid), e < 0 && (i[1] -= this.options.snapToGrid), t -= Math.abs(i[0]) < this.options.snapToGrid / 2 ? i[0] : i[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(i[1]) < this.options.snapToGrid / 2 ? i[1] : i[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, n, a)
            }, t.prototype.constraintToBox = function (t, e, n, a) {
                var i, r, o = this.options.constraint || {};
                return void 0 !== a ? (i = n, r = a) : (i = this.parameters.box.x + (1 & n ? 0 : this.parameters.box.width), r = this.parameters.box.y + (2 & n ? 0 : this.parameters.box.height)), void 0 !== o.minX && i + t < o.minX && (t = o.minX - i), void 0 !== o.maxX && i + t > o.maxX && (t = o.maxX - i), void 0 !== o.minY && r + e < o.minY && (e = o.minY - r), void 0 !== o.maxY && r + e > o.maxY && (e = o.maxY - r), [t, e]
            }, t.prototype.checkAspectRatio = function (t, e) {
                if (!this.options.saveAspectRatio) return t;
                var n = t.slice(), a = this.parameters.box.width / this.parameters.box.height,
                    i = this.parameters.box.width + t[0], r = this.parameters.box.height - t[1], o = i / r;
                return o < a ? (n[1] = i / a - this.parameters.box.height, e && (n[1] = -n[1])) : o > a && (n[0] = this.parameters.box.width - r * a, e && (n[0] = -n[0])), n
            }, SVG.extend(SVG.Element, {
                resize: function (e) {
                    return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this
                }
            }), SVG.Element.prototype.resize.defaults = {
                snapToAngle: .1,
                snapToGrid: 1,
                constraint: {},
                saveAspectRatio: !1
            }
        }).call(this)
    }(), function (t, e) {
        void 0 === e && (e = {});
        var n = e.insertAt;
        if ("undefined" != typeof document) {
            var a = document.head || document.getElementsByTagName("head")[0], i = document.createElement("style");
            i.type = "text/css", "top" === n && a.firstChild ? a.insertBefore(i, a.firstChild) : a.appendChild(i), i.styleSheet ? i.styleSheet.cssText = t : i.appendChild(document.createTextNode(t))
        }
    }('.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-text-z-label:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-candlestick {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-candlestick>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-candlestick span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}'), function () {
        function t(t) {
            var e = t.__resizeTriggers__, n = e.firstElementChild, a = e.lastElementChild,
                i = n ? n.firstElementChild : null;
            a && (a.scrollLeft = a.scrollWidth, a.scrollTop = a.scrollHeight), i && (i.style.width = n.offsetWidth + 1 + "px", i.style.height = n.offsetHeight + 1 + "px"), n && (n.scrollLeft = n.scrollWidth, n.scrollTop = n.scrollHeight)
        }

        function e(e) {
            var n = this;
            t(this), this.__resizeRAF__ && r(this.__resizeRAF__), this.__resizeRAF__ = i((function () {
                (function (t) {
                    return t.offsetWidth != t.__resizeLast__.width || t.offsetHeight != t.__resizeLast__.height
                })(n) && (n.__resizeLast__.width = n.offsetWidth, n.__resizeLast__.height = n.offsetHeight, n.__resizeListeners__.forEach((function (t) {
                    t.call(e)
                })))
            }))
        }

        var n, a,
            i = (n = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (t) {
                return window.setTimeout(t, 20)
            }, function (t) {
                return n(t)
            }),
            r = (a = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout, function (t) {
                return a(t)
            }), o = !1, s = "animationstart", l = "Webkit Moz O ms".split(" "),
            c = "webkitAnimationStart animationstart oAnimationStart MSAnimationStart".split(" "),
            d = document.createElement("fakeelement");
        if (void 0 !== d.style.animationName && (o = !0), !1 === o) for (var u = 0; u < l.length; u++) if (void 0 !== d.style[l[u] + "AnimationName"]) {
            s = c[u];
            break
        }
        window.addResizeListener = function (n, a) {
            n.__resizeTriggers__ || ("static" == getComputedStyle(n).position && (n.style.position = "relative"), n.__resizeLast__ = {}, n.__resizeListeners__ = [], (n.__resizeTriggers__ = document.createElement("div")).className = "resize-triggers", n.__resizeTriggers__.innerHTML = '<div class="expand-trigger"><div></div></div><div class="contract-trigger"></div>', n.appendChild(n.__resizeTriggers__), t(n), n.addEventListener("scroll", e, !0), s && n.__resizeTriggers__.addEventListener(s, (function (e) {
                "resizeanim" == e.animationName && t(n)
            }))), n.__resizeListeners__.push(a)
        }, window.removeResizeListener = function (t, n) {
            t && (t.__resizeListeners__.splice(t.__resizeListeners__.indexOf(n), 1), t.__resizeListeners__.length || (t.removeEventListener("scroll", e), t.__resizeTriggers__.parentNode && (t.__resizeTriggers__ = !t.removeChild(t.__resizeTriggers__))))
        }
    }(), void 0 === window.Apex && (window.Apex = {});
    var Ft = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "initModules", value: function () {
                this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], this.ctx.animations = new x(this.ctx), this.ctx.axes = new et(this.ctx), this.ctx.core = new Nt(this.ctx.el, this.ctx), this.ctx.config = new q({}), this.ctx.data = new V(this.ctx), this.ctx.grid = new X(this.ctx), this.ctx.graphics = new _(this.ctx), this.ctx.coreUtils = new C(this.ctx), this.ctx.crosshairs = new nt(this.ctx), this.ctx.events = new J(this.ctx), this.ctx.exports = new U(this.ctx), this.ctx.localization = new tt(this.ctx), this.ctx.options = new E, this.ctx.responsive = new at(this.ctx), this.ctx.series = new j(this.ctx), this.ctx.theme = new it(this.ctx), this.ctx.formatters = new $(this.ctx), this.ctx.titleSubtitle = new rt(this.ctx), this.ctx.legend = new ht(this.ctx), this.ctx.toolbar = new pt(this.ctx), this.ctx.dimensions = new dt(this.ctx), this.ctx.updateHelpers = new Lt(this.ctx), this.ctx.zoomPanSelection = new ft(this.ctx), this.ctx.w.globals.tooltip = new _t(this.ctx)
            }
        }]), t
    }(), Ht = function () {
        function t(e) {
            r(this, t), this.ctx = e, this.w = e.w
        }

        return s(t, [{
            key: "clear", value: function (t) {
                var e = t.isUpdating;
                this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({isUpdating: e})
            }
        }, {
            key: "killSVG", value: function (t) {
                t.each((function (t, e) {
                    this.removeClass("*"), this.off(), this.stop()
                }), !0), t.ungroup(), t.clear()
            }
        }, {
            key: "clearDomElements", value: function (t) {
                var e = this, n = t.isUpdating, a = this.w.globals.dom.Paper.node;
                a.parentNode && a.parentNode.parentNode && !n && (a.parentNode.parentNode.style.minHeight = "unset");
                var i = this.w.globals.dom.baseEl;
                i && this.ctx.eventList.forEach((function (t) {
                    i.removeEventListener(t, e.ctx.events.documentEvent)
                }));
                var r = this.w.globals.dom;
                if (null !== this.ctx.el) for (; this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild);
                this.killSVG(r.Paper), r.Paper.remove(), r.elWrap = null, r.elGraphical = null, r.elAnnotations = null, r.elLegendWrap = null, r.baseEl = null, r.elGridRect = null, r.elGridRectMask = null, r.elGridRectMarkerMask = null, r.elDefs = null
            }
        }]), t
    }(), Bt = function () {
        function t(e, n) {
            r(this, t), this.opts = n, this.ctx = this, this.w = new W(n).init(), this.el = e, this.w.globals.cuid = b.randomId(), this.w.globals.chartID = this.w.config.chart.id ? b.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Ft(this).initModules(), this.create = b.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this)
        }

        return s(t, [{
            key: "render", value: function () {
                var t = this;
                return new Promise((function (e, n) {
                    if (null !== t.el) {
                        void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({
                            id: t.w.globals.chartID,
                            group: t.w.config.chart.group,
                            chart: t
                        }), t.setLocale(t.w.config.chart.defaultLocale);
                        var a = t.w.config.chart.events.beforeMount;
                        "function" == typeof a && a(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), window.addResizeListener(t.el.parentNode, t._parentResizeCallback.bind(t));
                        var i = t.create(t.w.config.series, {});
                        if (!i) return e(t);
                        t.mount(i).then((function () {
                            "function" == typeof t.w.config.chart.events.mounted && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), e(i)
                        })).catch((function (t) {
                            n(t)
                        }))
                    } else n(new Error("Element not found"))
                }))
            }
        }, {
            key: "create", value: function (t, e) {
                var n = this.w;
                new Ft(this).initModules();
                var a = this.w.globals;
                if (a.noData = !1, a.animationEnded = !1, this.responsive.checkResponsiveConfig(e), n.config.xaxis.convertedCatToNumeric && new B(n.config).convertCatToNumericXaxis(n.config, this.ctx), null === this.el) return a.animationEnded = !0, null;
                if (this.core.setupElements(), "treemap" === n.config.chart.type && (n.config.grid.show = !1, n.config.yaxis[0].show = !1), 0 === a.svgWidth) return a.animationEnded = !0, null;
                var i = C.checkComboSeries(t);
                a.comboCharts = i.comboCharts, a.comboBarCount = i.comboBarCount;
                var r = t.every((function (t) {
                    return t.data && 0 === t.data.length
                }));
                (0 === t.length || r) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new M(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length && !n.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), "category" !== n.config.xaxis.type && this.formatters.setLabelFormatters()), this.formatters.heatmapLabelFormatters(), this.dimensions.plotCoords();
                var o = this.core.xySettings();
                this.grid.createGridMask();
                var s = this.core.plotChartType(t, o), l = new P(this);
                l.bringForward(), n.config.dataLabels.background.enabled && l.dataLabelsBackground(), this.core.shiftGraphPosition();
                var c = {
                    plot: {
                        left: n.globals.translateX,
                        top: n.globals.translateY,
                        width: n.globals.gridWidth,
                        height: n.globals.gridHeight
                    }
                };
                return {elGraph: s, xyRatios: o, elInner: n.globals.dom.elGraphical, dimensions: c}
            }
        }, {
            key: "mount", value: function () {
                var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = this,
                    a = n.w;
                return new Promise((function (i, r) {
                    if (null === n.el) return r(new Error("Not enough data to display or target element not found"));
                    (null === e || a.globals.allSeriesCollapsed) && n.series.handleNoData(), "treemap" !== a.config.chart.type && n.axes.drawAxis(a.config.chart.type, e.xyRatios), n.grid = new X(n);
                    var o = n.grid.drawGrid();
                    n.annotations = new A(n), n.annotations.drawImageAnnos(), n.annotations.drawTextAnnos(), "back" === a.config.grid.position && o && a.globals.dom.elGraphical.add(o.el);
                    var s = new G(t.ctx), l = new Q(t.ctx);
                    if (null !== o && (s.xAxisLabelCorrections(o.xAxisTickWidth), l.setYAxisTextAlignments()), "back" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), n.annotations.drawAxesAnnotations()), Array.isArray(e.elGraph)) for (var c = 0; c < e.elGraph.length; c++) a.globals.dom.elGraphical.add(e.elGraph[c]); else a.globals.dom.elGraphical.add(e.elGraph);
                    if ("front" === a.config.grid.position && o && a.globals.dom.elGraphical.add(o.el), "front" === a.config.xaxis.crosshairs.position && n.crosshairs.drawXCrosshairs(), "front" === a.config.yaxis[0].crosshairs.position && n.crosshairs.drawYCrosshairs(), "front" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), n.annotations.drawAxesAnnotations()), !a.globals.noData) {
                        if (a.config.tooltip.enabled && !a.globals.noData && n.w.globals.tooltip.drawTooltip(e.xyRatios), a.globals.axisCharts && (a.globals.isXNumeric || a.config.xaxis.convertedCatToNumeric)) (a.config.chart.zoom.enabled || a.config.chart.selection && a.config.chart.selection.enabled || a.config.chart.pan && a.config.chart.pan.enabled) && n.zoomPanSelection.init({xyRatios: e.xyRatios}); else {
                            var d = a.config.chart.toolbar.tools;
                            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach((function (t) {
                                d[t] = !1
                            }))
                        }
                        a.config.chart.toolbar.show && !a.globals.allSeriesCollapsed && n.toolbar.createToolbar()
                    }
                    a.globals.memory.methodsToExec.length > 0 && a.globals.memory.methodsToExec.forEach((function (t) {
                        t.method(t.params, !1, t.context)
                    })), a.globals.axisCharts || a.globals.noData || n.core.resizeNonAxisCharts(), i(n)
                }))
            }
        }, {
            key: "destroy", value: function () {
                window.removeEventListener("resize", this.windowResizeHandler), window.removeResizeListener(this.el.parentNode, this._parentResizeCallback.bind(this));
                var t = this.w.config.chart.id;
                t && Apex._chartInstances.forEach((function (e, n) {
                    e.id === b.escapeString(t) && Apex._chartInstances.splice(n, 1)
                })), new Ht(this.ctx).clear({isUpdating: !1})
            }
        }, {
            key: "updateOptions", value: function (t) {
                var e = this, n = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                    a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                    r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], o = this.w;
                return o.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map((function (t, n) {
                    return e.updateHelpers._extendSeries(t, n)
                }))), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), o.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, n, a, i, r)
            }
        }, {
            key: "updateSeries", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, n)
            }
        }, {
            key: "appendSeries", value: function (t) {
                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                    a = this.w.config.series.slice();
                return a.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a, e, n)
            }
        }, {
            key: "appendData", value: function (t) {
                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], n = this;
                n.w.globals.dataChanged = !0, n.series.getPreviousPaths();
                for (var a = n.w.config.series.slice(), i = 0; i < a.length; i++) if (null !== t[i] && void 0 !== t[i]) for (var r = 0; r < t[i].data.length; r++) a[i].data.push(t[i].data[r]);
                return n.w.config.series = a, e && (n.w.globals.initialSeries = b.clone(n.w.config.series)), this.update()
            }
        }, {
            key: "update", value: function (t) {
                var e = this;
                return new Promise((function (n, a) {
                    new Ht(e.ctx).clear({isUpdating: !0});
                    var i = e.create(e.w.config.series, t);
                    if (!i) return n(e);
                    e.mount(i).then((function () {
                        "function" == typeof e.w.config.chart.events.updated && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent("updated", [e, e.w]), e.w.globals.isDirty = !0, n(e)
                    })).catch((function (t) {
                        a(t)
                    }))
                }))
            }
        }, {
            key: "getSyncedCharts", value: function () {
                var t = this.getGroupedCharts(), e = [this];
                return t.length && (e = [], t.forEach((function (t) {
                    e.push(t)
                }))), e
            }
        }, {
            key: "getGroupedCharts", value: function () {
                var t = this;
                return Apex._chartInstances.filter((function (t) {
                    if (t.group) return !0
                })).map((function (e) {
                    return t.w.config.chart.group === e.group ? e.chart : t
                }))
            }
        }, {
            key: "toggleSeries", value: function (t) {
                return this.series.toggleSeries(t)
            }
        }, {
            key: "showSeries", value: function (t) {
                this.series.showSeries(t)
            }
        }, {
            key: "hideSeries", value: function (t) {
                this.series.hideSeries(t)
            }
        }, {
            key: "resetSeries", value: function () {
                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                    e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                this.series.resetSeries(t, e)
            }
        }, {
            key: "addEventListener", value: function (t, e) {
                this.events.addEventListener(t, e)
            }
        }, {
            key: "removeEventListener", value: function (t, e) {
                this.events.removeEventListener(t, e)
            }
        }, {
            key: "addXaxisAnnotation", value: function (t) {
                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a = this;
                n && (a = n), a.annotations.addXaxisAnnotationExternal(t, e, a)
            }
        }, {
            key: "addYaxisAnnotation", value: function (t) {
                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a = this;
                n && (a = n), a.annotations.addYaxisAnnotationExternal(t, e, a)
            }
        }, {
            key: "addPointAnnotation", value: function (t) {
                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                    n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a = this;
                n && (a = n), a.annotations.addPointAnnotationExternal(t, e, a)
            }
        }, {
            key: "clearAnnotations", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e = this;
                t && (e = t), e.annotations.clearAnnotations(e)
            }
        }, {
            key: "removeAnnotation", value: function (t) {
                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, n = this;
                e && (n = e), n.annotations.removeAnnotation(n, t)
            }
        }, {
            key: "getChartArea", value: function () {
                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
            }
        }, {
            key: "getSeriesTotalXRange", value: function (t, e) {
                return this.coreUtils.getSeriesTotalsXRange(t, e)
            }
        }, {
            key: "getHighestValueInSeries", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = new K(this.ctx);
                return e.getMinYMaxY(t).highestY
            }
        }, {
            key: "getLowestValueInSeries", value: function () {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e = new K(this.ctx);
                return e.getMinYMaxY(t).lowestY
            }
        }, {
            key: "getSeriesTotal", value: function () {
                return this.w.globals.seriesTotals
            }
        }, {
            key: "toggleDataPointSelection", value: function (t, e) {
                return this.updateHelpers.toggleDataPointSelection(t, e)
            }
        }, {
            key: "zoomX", value: function (t, e) {
                this.ctx.toolbar.zoomUpdateOptions(t, e)
            }
        }, {
            key: "setLocale", value: function (t) {
                this.localization.setCurrentLocaleValues(t)
            }
        }, {
            key: "dataURI", value: function () {
                return new U(this.ctx).dataURI()
            }
        }, {
            key: "paper", value: function () {
                return this.w.globals.dom.Paper
            }
        }, {
            key: "_parentResizeCallback", value: function () {
                !this.w.globals.noData && this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
            }
        }, {
            key: "_windowResize", value: function () {
                var t = this;
                clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout((function () {
                    t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update()
                }), 150)
            }
        }, {
            key: "_windowResizeHandler", value: function () {
                var t = this.w.config.chart.redrawOnWindowResize;
                "function" == typeof t && (t = t()), t && this._windowResize()
            }
        }], [{
            key: "getChartByID", value: function (t) {
                var e = b.escapeString(t), n = Apex._chartInstances.filter((function (t) {
                    return t.id === e
                }))[0];
                return n && n.chart
            }
        }, {
            key: "initOnLoad", value: function () {
                for (var e = document.querySelectorAll("[data-apexcharts]"), n = 0; n < e.length; n++) new t(e[n], JSON.parse(e[n].getAttribute("data-options"))).render()
            }
        }, {
            key: "exec", value: function (t, e) {
                var n = this.getChartByID(t);
                if (n) {
                    n.w.globals.isExecCalled = !0;
                    var a = null;
                    if (-1 !== n.publicMethods.indexOf(e)) {
                        for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++) r[o - 2] = arguments[o];
                        a = n[e].apply(n, r)
                    }
                    return a
                }
            }
        }, {
            key: "merge", value: function (t, e) {
                return b.extend(t, e)
            }
        }]), t
    }();
    t.exports = Bt
}, , function (t, e, n) {
    "use strict";
    (function (t) {
        n(161);
        t('[data-toggle="popover"]').popover(), t('[data-toggle="tooltip"]').tooltip()
    }).call(this, n(16))
}, function (t, e, n) {
    (function (e) {
        t.exports = e.$ = n(160)
    }).call(this, n(3))
}, function (t, e, n) {
    var a;
    !function (e, n) {
        "use strict";
        "object" == typeof t.exports ? t.exports = e.document ? n(e, !0) : function (t) {
            if (!t.document) throw new Error("jQuery requires a window with a document");
            return n(t)
        } : n(e)
    }("undefined" != typeof window ? window : this, (function (n, i) {
        "use strict";
        var r = [], o = Object.getPrototypeOf, s = r.slice, l = r.flat ? function (t) {
                return r.flat.call(t)
            } : function (t) {
                return r.concat.apply([], t)
            }, c = r.push, d = r.indexOf, u = {}, h = u.toString, p = u.hasOwnProperty, f = p.toString, g = f.call(Object),
            m = {}, v = function (t) {
                return "function" == typeof t && "number" != typeof t.nodeType
            }, b = function (t) {
                return null != t && t === t.window
            }, y = n.document, x = {type: !0, src: !0, nonce: !0, noModule: !0};

        function _(t, e, n) {
            var a, i, r = (n = n || y).createElement("script");
            if (r.text = t, e) for (a in x) (i = e[a] || e.getAttribute && e.getAttribute(a)) && r.setAttribute(a, i);
            n.head.appendChild(r).parentNode.removeChild(r)
        }

        function w(t) {
            return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? u[h.call(t)] || "object" : typeof t
        }

        var S = "3.5.1", C = function (t, e) {
            return new C.fn.init(t, e)
        };

        function k(t) {
            var e = !!t && "length" in t && t.length, n = w(t);
            return !v(t) && !b(t) && ("array" === n || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
        }

        C.fn = C.prototype = {
            jquery: S, constructor: C, length: 0, toArray: function () {
                return s.call(this)
            }, get: function (t) {
                return null == t ? s.call(this) : t < 0 ? this[t + this.length] : this[t]
            }, pushStack: function (t) {
                var e = C.merge(this.constructor(), t);
                return e.prevObject = this, e
            }, each: function (t) {
                return C.each(this, t)
            }, map: function (t) {
                return this.pushStack(C.map(this, (function (e, n) {
                    return t.call(e, n, e)
                })))
            }, slice: function () {
                return this.pushStack(s.apply(this, arguments))
            }, first: function () {
                return this.eq(0)
            }, last: function () {
                return this.eq(-1)
            }, even: function () {
                return this.pushStack(C.grep(this, (function (t, e) {
                    return (e + 1) % 2
                })))
            }, odd: function () {
                return this.pushStack(C.grep(this, (function (t, e) {
                    return e % 2
                })))
            }, eq: function (t) {
                var e = this.length, n = +t + (t < 0 ? e : 0);
                return this.pushStack(n >= 0 && n < e ? [this[n]] : [])
            }, end: function () {
                return this.prevObject || this.constructor()
            }, push: c, sort: r.sort, splice: r.splice
        }, C.extend = C.fn.extend = function () {
            var t, e, n, a, i, r, o = arguments[0] || {}, s = 1, l = arguments.length, c = !1;
            for ("boolean" == typeof o && (c = o, o = arguments[s] || {}, s++), "object" == typeof o || v(o) || (o = {}), s === l && (o = this, s--); s < l; s++) if (null != (t = arguments[s])) for (e in t) a = t[e], "__proto__" !== e && o !== a && (c && a && (C.isPlainObject(a) || (i = Array.isArray(a))) ? (n = o[e], r = i && !Array.isArray(n) ? [] : i || C.isPlainObject(n) ? n : {}, i = !1, o[e] = C.extend(c, r, a)) : void 0 !== a && (o[e] = a));
            return o
        }, C.extend({
            expando: "jQuery" + (S + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (t) {
                throw new Error(t)
            }, noop: function () {
            }, isPlainObject: function (t) {
                var e, n;
                return !(!t || "[object Object]" !== h.call(t)) && (!(e = o(t)) || "function" == typeof (n = p.call(e, "constructor") && e.constructor) && f.call(n) === g)
            }, isEmptyObject: function (t) {
                var e;
                for (e in t) return !1;
                return !0
            }, globalEval: function (t, e, n) {
                _(t, {nonce: e && e.nonce}, n)
            }, each: function (t, e) {
                var n, a = 0;
                if (k(t)) for (n = t.length; a < n && !1 !== e.call(t[a], a, t[a]); a++) ; else for (a in t) if (!1 === e.call(t[a], a, t[a])) break;
                return t
            }, makeArray: function (t, e) {
                var n = e || [];
                return null != t && (k(Object(t)) ? C.merge(n, "string" == typeof t ? [t] : t) : c.call(n, t)), n
            }, inArray: function (t, e, n) {
                return null == e ? -1 : d.call(e, t, n)
            }, merge: function (t, e) {
                for (var n = +e.length, a = 0, i = t.length; a < n; a++) t[i++] = e[a];
                return t.length = i, t
            }, grep: function (t, e, n) {
                for (var a = [], i = 0, r = t.length, o = !n; i < r; i++) !e(t[i], i) !== o && a.push(t[i]);
                return a
            }, map: function (t, e, n) {
                var a, i, r = 0, o = [];
                if (k(t)) for (a = t.length; r < a; r++) null != (i = e(t[r], r, n)) && o.push(i); else for (r in t) null != (i = e(t[r], r, n)) && o.push(i);
                return l(o)
            }, guid: 1, support: m
        }), "function" == typeof Symbol && (C.fn[Symbol.iterator] = r[Symbol.iterator]), C.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function (t, e) {
            u["[object " + e + "]"] = e.toLowerCase()
        }));
        var D = function (t) {
            var e, n, a, i, r, o, s, l, c, d, u, h, p, f, g, m, v, b, y, x = "sizzle" + 1 * new Date, _ = t.document,
                w = 0, S = 0, C = lt(), k = lt(), D = lt(), T = lt(), E = function (t, e) {
                    return t === e && (u = !0), 0
                }, A = {}.hasOwnProperty, I = [], M = I.pop, R = I.push, P = I.push, O = I.slice, j = function (t, e) {
                    for (var n = 0, a = t.length; n < a; n++) if (t[n] === e) return n;
                    return -1
                },
                N = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                L = "[\\x20\\t\\r\\n\\f]",
                F = "(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                H = "\\[[\\x20\\t\\r\\n\\f]*(" + F + ")(?:" + L + "*([*^$|!~]?=)" + L + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + F + "))|)" + L + "*\\]",
                B = ":(" + F + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + H + ")*)|.*)\\)|)",
                q = new RegExp(L + "+", "g"),
                z = new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$", "g"),
                W = new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"),
                V = new RegExp("^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"),
                $ = new RegExp(L + "|>"), Y = new RegExp(B), U = new RegExp("^" + F + "$"), G = {
                    ID: new RegExp("^#(" + F + ")"),
                    CLASS: new RegExp("^\\.(" + F + ")"),
                    TAG: new RegExp("^(" + F + "|[*])"),
                    ATTR: new RegExp("^" + H),
                    PSEUDO: new RegExp("^" + B),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)", "i"),
                    bool: new RegExp("^(?:" + N + ")$", "i"),
                    needsContext: new RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)", "i")
                }, X = /HTML$/i, Z = /^(?:input|select|textarea|button)$/i, K = /^h\d$/i, Q = /^[^{]+\{\s*\[native \w/,
                J = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, tt = /[+~]/,
                et = new RegExp("\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])", "g"),
                nt = function (t, e) {
                    var n = "0x" + t.slice(1) - 65536;
                    return e || (n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320))
                }, at = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, it = function (t, e) {
                    return e ? "\0" === t ? "ï¿½" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
                }, rt = function () {
                    h()
                }, ot = xt((function (t) {
                    return !0 === t.disabled && "fieldset" === t.nodeName.toLowerCase()
                }), {dir: "parentNode", next: "legend"});
            try {
                P.apply(I = O.call(_.childNodes), _.childNodes), I[_.childNodes.length].nodeType
            } catch (t) {
                P = {
                    apply: I.length ? function (t, e) {
                        R.apply(t, O.call(e))
                    } : function (t, e) {
                        for (var n = t.length, a = 0; t[n++] = e[a++];) ;
                        t.length = n - 1
                    }
                }
            }

            function st(t, e, a, i) {
                var r, s, c, d, u, f, v, b = e && e.ownerDocument, _ = e ? e.nodeType : 9;
                if (a = a || [], "string" != typeof t || !t || 1 !== _ && 9 !== _ && 11 !== _) return a;
                if (!i && (h(e), e = e || p, g)) {
                    if (11 !== _ && (u = J.exec(t))) if (r = u[1]) {
                        if (9 === _) {
                            if (!(c = e.getElementById(r))) return a;
                            if (c.id === r) return a.push(c), a
                        } else if (b && (c = b.getElementById(r)) && y(e, c) && c.id === r) return a.push(c), a
                    } else {
                        if (u[2]) return P.apply(a, e.getElementsByTagName(t)), a;
                        if ((r = u[3]) && n.getElementsByClassName && e.getElementsByClassName) return P.apply(a, e.getElementsByClassName(r)), a
                    }
                    if (n.qsa && !T[t + " "] && (!m || !m.test(t)) && (1 !== _ || "object" !== e.nodeName.toLowerCase())) {
                        if (v = t, b = e, 1 === _ && ($.test(t) || V.test(t))) {
                            for ((b = tt.test(t) && vt(e.parentNode) || e) === e && n.scope || ((d = e.getAttribute("id")) ? d = d.replace(at, it) : e.setAttribute("id", d = x)), s = (f = o(t)).length; s--;) f[s] = (d ? "#" + d : ":scope") + " " + yt(f[s]);
                            v = f.join(",")
                        }
                        try {
                            return P.apply(a, b.querySelectorAll(v)), a
                        } catch (e) {
                            T(t, !0)
                        } finally {
                            d === x && e.removeAttribute("id")
                        }
                    }
                }
                return l(t.replace(z, "$1"), e, a, i)
            }

            function lt() {
                var t = [];
                return function e(n, i) {
                    return t.push(n + " ") > a.cacheLength && delete e[t.shift()], e[n + " "] = i
                }
            }

            function ct(t) {
                return t[x] = !0, t
            }

            function dt(t) {
                var e = p.createElement("fieldset");
                try {
                    return !!t(e)
                } catch (t) {
                    return !1
                } finally {
                    e.parentNode && e.parentNode.removeChild(e), e = null
                }
            }

            function ut(t, e) {
                for (var n = t.split("|"), i = n.length; i--;) a.attrHandle[n[i]] = e
            }

            function ht(t, e) {
                var n = e && t, a = n && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
                if (a) return a;
                if (n) for (; n = n.nextSibling;) if (n === e) return -1;
                return t ? 1 : -1
            }

            function pt(t) {
                return function (e) {
                    return "input" === e.nodeName.toLowerCase() && e.type === t
                }
            }

            function ft(t) {
                return function (e) {
                    var n = e.nodeName.toLowerCase();
                    return ("input" === n || "button" === n) && e.type === t
                }
            }

            function gt(t) {
                return function (e) {
                    return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && ot(e) === t : e.disabled === t : "label" in e && e.disabled === t
                }
            }

            function mt(t) {
                return ct((function (e) {
                    return e = +e, ct((function (n, a) {
                        for (var i, r = t([], n.length, e), o = r.length; o--;) n[i = r[o]] && (n[i] = !(a[i] = n[i]))
                    }))
                }))
            }

            function vt(t) {
                return t && void 0 !== t.getElementsByTagName && t
            }

            for (e in n = st.support = {}, r = st.isXML = function (t) {
                var e = t.namespaceURI, n = (t.ownerDocument || t).documentElement;
                return !X.test(e || n && n.nodeName || "HTML")
            }, h = st.setDocument = function (t) {
                var e, i, o = t ? t.ownerDocument || t : _;
                return o != p && 9 === o.nodeType && o.documentElement ? (f = (p = o).documentElement, g = !r(p), _ != p && (i = p.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", rt, !1) : i.attachEvent && i.attachEvent("onunload", rt)), n.scope = dt((function (t) {
                    return f.appendChild(t).appendChild(p.createElement("div")), void 0 !== t.querySelectorAll && !t.querySelectorAll(":scope fieldset div").length
                })), n.attributes = dt((function (t) {
                    return t.className = "i", !t.getAttribute("className")
                })), n.getElementsByTagName = dt((function (t) {
                    return t.appendChild(p.createComment("")), !t.getElementsByTagName("*").length
                })), n.getElementsByClassName = Q.test(p.getElementsByClassName), n.getById = dt((function (t) {
                    return f.appendChild(t).id = x, !p.getElementsByName || !p.getElementsByName(x).length
                })), n.getById ? (a.filter.ID = function (t) {
                    var e = t.replace(et, nt);
                    return function (t) {
                        return t.getAttribute("id") === e
                    }
                }, a.find.ID = function (t, e) {
                    if (void 0 !== e.getElementById && g) {
                        var n = e.getElementById(t);
                        return n ? [n] : []
                    }
                }) : (a.filter.ID = function (t) {
                    var e = t.replace(et, nt);
                    return function (t) {
                        var n = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                        return n && n.value === e
                    }
                }, a.find.ID = function (t, e) {
                    if (void 0 !== e.getElementById && g) {
                        var n, a, i, r = e.getElementById(t);
                        if (r) {
                            if ((n = r.getAttributeNode("id")) && n.value === t) return [r];
                            for (i = e.getElementsByName(t), a = 0; r = i[a++];) if ((n = r.getAttributeNode("id")) && n.value === t) return [r]
                        }
                        return []
                    }
                }), a.find.TAG = n.getElementsByTagName ? function (t, e) {
                    return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : n.qsa ? e.querySelectorAll(t) : void 0
                } : function (t, e) {
                    var n, a = [], i = 0, r = e.getElementsByTagName(t);
                    if ("*" === t) {
                        for (; n = r[i++];) 1 === n.nodeType && a.push(n);
                        return a
                    }
                    return r
                }, a.find.CLASS = n.getElementsByClassName && function (t, e) {
                    if (void 0 !== e.getElementsByClassName && g) return e.getElementsByClassName(t)
                }, v = [], m = [], (n.qsa = Q.test(p.querySelectorAll)) && (dt((function (t) {
                    var e;
                    f.appendChild(t).innerHTML = "<a id='" + x + "'></a><select id='" + x + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && m.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"), t.querySelectorAll("[selected]").length || m.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|" + N + ")"), t.querySelectorAll("[id~=" + x + "-]").length || m.push("~="), (e = p.createElement("input")).setAttribute("name", ""), t.appendChild(e), t.querySelectorAll("[name='']").length || m.push("\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"), t.querySelectorAll(":checked").length || m.push(":checked"), t.querySelectorAll("a#" + x + "+*").length || m.push(".#.+[+~]"), t.querySelectorAll("\\\f"), m.push("[\\r\\n\\f]")
                })), dt((function (t) {
                    t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                    var e = p.createElement("input");
                    e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && m.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && m.push(":enabled", ":disabled"), f.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && m.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), m.push(",.*:")
                }))), (n.matchesSelector = Q.test(b = f.matches || f.webkitMatchesSelector || f.mozMatchesSelector || f.oMatchesSelector || f.msMatchesSelector)) && dt((function (t) {
                    n.disconnectedMatch = b.call(t, "*"), b.call(t, "[s!='']:x"), v.push("!=", B)
                })), m = m.length && new RegExp(m.join("|")), v = v.length && new RegExp(v.join("|")), e = Q.test(f.compareDocumentPosition), y = e || Q.test(f.contains) ? function (t, e) {
                    var n = 9 === t.nodeType ? t.documentElement : t, a = e && e.parentNode;
                    return t === a || !(!a || 1 !== a.nodeType || !(n.contains ? n.contains(a) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(a)))
                } : function (t, e) {
                    if (e) for (; e = e.parentNode;) if (e === t) return !0;
                    return !1
                }, E = e ? function (t, e) {
                    if (t === e) return u = !0, 0;
                    var a = !t.compareDocumentPosition - !e.compareDocumentPosition;
                    return a || (1 & (a = (t.ownerDocument || t) == (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !n.sortDetached && e.compareDocumentPosition(t) === a ? t == p || t.ownerDocument == _ && y(_, t) ? -1 : e == p || e.ownerDocument == _ && y(_, e) ? 1 : d ? j(d, t) - j(d, e) : 0 : 4 & a ? -1 : 1)
                } : function (t, e) {
                    if (t === e) return u = !0, 0;
                    var n, a = 0, i = t.parentNode, r = e.parentNode, o = [t], s = [e];
                    if (!i || !r) return t == p ? -1 : e == p ? 1 : i ? -1 : r ? 1 : d ? j(d, t) - j(d, e) : 0;
                    if (i === r) return ht(t, e);
                    for (n = t; n = n.parentNode;) o.unshift(n);
                    for (n = e; n = n.parentNode;) s.unshift(n);
                    for (; o[a] === s[a];) a++;
                    return a ? ht(o[a], s[a]) : o[a] == _ ? -1 : s[a] == _ ? 1 : 0
                }, p) : p
            }, st.matches = function (t, e) {
                return st(t, null, null, e)
            }, st.matchesSelector = function (t, e) {
                if (h(t), n.matchesSelector && g && !T[e + " "] && (!v || !v.test(e)) && (!m || !m.test(e))) try {
                    var a = b.call(t, e);
                    if (a || n.disconnectedMatch || t.document && 11 !== t.document.nodeType) return a
                } catch (t) {
                    T(e, !0)
                }
                return st(e, p, null, [t]).length > 0
            }, st.contains = function (t, e) {
                return (t.ownerDocument || t) != p && h(t), y(t, e)
            }, st.attr = function (t, e) {
                (t.ownerDocument || t) != p && h(t);
                var i = a.attrHandle[e.toLowerCase()],
                    r = i && A.call(a.attrHandle, e.toLowerCase()) ? i(t, e, !g) : void 0;
                return void 0 !== r ? r : n.attributes || !g ? t.getAttribute(e) : (r = t.getAttributeNode(e)) && r.specified ? r.value : null
            }, st.escape = function (t) {
                return (t + "").replace(at, it)
            }, st.error = function (t) {
                throw new Error("Syntax error, unrecognized expression: " + t)
            }, st.uniqueSort = function (t) {
                var e, a = [], i = 0, r = 0;
                if (u = !n.detectDuplicates, d = !n.sortStable && t.slice(0), t.sort(E), u) {
                    for (; e = t[r++];) e === t[r] && (i = a.push(r));
                    for (; i--;) t.splice(a[i], 1)
                }
                return d = null, t
            }, i = st.getText = function (t) {
                var e, n = "", a = 0, r = t.nodeType;
                if (r) {
                    if (1 === r || 9 === r || 11 === r) {
                        if ("string" == typeof t.textContent) return t.textContent;
                        for (t = t.firstChild; t; t = t.nextSibling) n += i(t)
                    } else if (3 === r || 4 === r) return t.nodeValue
                } else for (; e = t[a++];) n += i(e);
                return n
            }, (a = st.selectors = {
                cacheLength: 50,
                createPseudo: ct,
                match: G,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {dir: "parentNode", first: !0},
                    " ": {dir: "parentNode"},
                    "+": {dir: "previousSibling", first: !0},
                    "~": {dir: "previousSibling"}
                },
                preFilter: {
                    ATTR: function (t) {
                        return t[1] = t[1].replace(et, nt), t[3] = (t[3] || t[4] || t[5] || "").replace(et, nt), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                    }, CHILD: function (t) {
                        return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || st.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && st.error(t[0]), t
                    }, PSEUDO: function (t) {
                        var e, n = !t[6] && t[2];
                        return G.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : n && Y.test(n) && (e = o(n, !0)) && (e = n.indexOf(")", n.length - e) - n.length) && (t[0] = t[0].slice(0, e), t[2] = n.slice(0, e)), t.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function (t) {
                        var e = t.replace(et, nt).toLowerCase();
                        return "*" === t ? function () {
                            return !0
                        } : function (t) {
                            return t.nodeName && t.nodeName.toLowerCase() === e
                        }
                    }, CLASS: function (t) {
                        var e = C[t + " "];
                        return e || (e = new RegExp("(^|[\\x20\\t\\r\\n\\f])" + t + "(" + L + "|$)")) && C(t, (function (t) {
                            return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                        }))
                    }, ATTR: function (t, e, n) {
                        return function (a) {
                            var i = st.attr(a, t);
                            return null == i ? "!=" === e : !e || (i += "", "=" === e ? i === n : "!=" === e ? i !== n : "^=" === e ? n && 0 === i.indexOf(n) : "*=" === e ? n && i.indexOf(n) > -1 : "$=" === e ? n && i.slice(-n.length) === n : "~=" === e ? (" " + i.replace(q, " ") + " ").indexOf(n) > -1 : "|=" === e && (i === n || i.slice(0, n.length + 1) === n + "-"))
                        }
                    }, CHILD: function (t, e, n, a, i) {
                        var r = "nth" !== t.slice(0, 3), o = "last" !== t.slice(-4), s = "of-type" === e;
                        return 1 === a && 0 === i ? function (t) {
                            return !!t.parentNode
                        } : function (e, n, l) {
                            var c, d, u, h, p, f, g = r !== o ? "nextSibling" : "previousSibling", m = e.parentNode,
                                v = s && e.nodeName.toLowerCase(), b = !l && !s, y = !1;
                            if (m) {
                                if (r) {
                                    for (; g;) {
                                        for (h = e; h = h[g];) if (s ? h.nodeName.toLowerCase() === v : 1 === h.nodeType) return !1;
                                        f = g = "only" === t && !f && "nextSibling"
                                    }
                                    return !0
                                }
                                if (f = [o ? m.firstChild : m.lastChild], o && b) {
                                    for (y = (p = (c = (d = (u = (h = m)[x] || (h[x] = {}))[h.uniqueID] || (u[h.uniqueID] = {}))[t] || [])[0] === w && c[1]) && c[2], h = p && m.childNodes[p]; h = ++p && h && h[g] || (y = p = 0) || f.pop();) if (1 === h.nodeType && ++y && h === e) {
                                        d[t] = [w, p, y];
                                        break
                                    }
                                } else if (b && (y = p = (c = (d = (u = (h = e)[x] || (h[x] = {}))[h.uniqueID] || (u[h.uniqueID] = {}))[t] || [])[0] === w && c[1]), !1 === y) for (; (h = ++p && h && h[g] || (y = p = 0) || f.pop()) && ((s ? h.nodeName.toLowerCase() !== v : 1 !== h.nodeType) || !++y || (b && ((d = (u = h[x] || (h[x] = {}))[h.uniqueID] || (u[h.uniqueID] = {}))[t] = [w, y]), h !== e));) ;
                                return (y -= i) === a || y % a == 0 && y / a >= 0
                            }
                        }
                    }, PSEUDO: function (t, e) {
                        var n,
                            i = a.pseudos[t] || a.setFilters[t.toLowerCase()] || st.error("unsupported pseudo: " + t);
                        return i[x] ? i(e) : i.length > 1 ? (n = [t, t, "", e], a.setFilters.hasOwnProperty(t.toLowerCase()) ? ct((function (t, n) {
                            for (var a, r = i(t, e), o = r.length; o--;) t[a = j(t, r[o])] = !(n[a] = r[o])
                        })) : function (t) {
                            return i(t, 0, n)
                        }) : i
                    }
                },
                pseudos: {
                    not: ct((function (t) {
                        var e = [], n = [], a = s(t.replace(z, "$1"));
                        return a[x] ? ct((function (t, e, n, i) {
                            for (var r, o = a(t, null, i, []), s = t.length; s--;) (r = o[s]) && (t[s] = !(e[s] = r))
                        })) : function (t, i, r) {
                            return e[0] = t, a(e, null, r, n), e[0] = null, !n.pop()
                        }
                    })), has: ct((function (t) {
                        return function (e) {
                            return st(t, e).length > 0
                        }
                    })), contains: ct((function (t) {
                        return t = t.replace(et, nt), function (e) {
                            return (e.textContent || i(e)).indexOf(t) > -1
                        }
                    })), lang: ct((function (t) {
                        return U.test(t || "") || st.error("unsupported lang: " + t), t = t.replace(et, nt).toLowerCase(), function (e) {
                            var n;
                            do {
                                if (n = g ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (n = n.toLowerCase()) === t || 0 === n.indexOf(t + "-")
                            } while ((e = e.parentNode) && 1 === e.nodeType);
                            return !1
                        }
                    })), target: function (e) {
                        var n = t.location && t.location.hash;
                        return n && n.slice(1) === e.id
                    }, root: function (t) {
                        return t === f
                    }, focus: function (t) {
                        return t === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                    }, enabled: gt(!1), disabled: gt(!0), checked: function (t) {
                        var e = t.nodeName.toLowerCase();
                        return "input" === e && !!t.checked || "option" === e && !!t.selected
                    }, selected: function (t) {
                        return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                    }, empty: function (t) {
                        for (t = t.firstChild; t; t = t.nextSibling) if (t.nodeType < 6) return !1;
                        return !0
                    }, parent: function (t) {
                        return !a.pseudos.empty(t)
                    }, header: function (t) {
                        return K.test(t.nodeName)
                    }, input: function (t) {
                        return Z.test(t.nodeName)
                    }, button: function (t) {
                        var e = t.nodeName.toLowerCase();
                        return "input" === e && "button" === t.type || "button" === e
                    }, text: function (t) {
                        var e;
                        return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                    }, first: mt((function () {
                        return [0]
                    })), last: mt((function (t, e) {
                        return [e - 1]
                    })), eq: mt((function (t, e, n) {
                        return [n < 0 ? n + e : n]
                    })), even: mt((function (t, e) {
                        for (var n = 0; n < e; n += 2) t.push(n);
                        return t
                    })), odd: mt((function (t, e) {
                        for (var n = 1; n < e; n += 2) t.push(n);
                        return t
                    })), lt: mt((function (t, e, n) {
                        for (var a = n < 0 ? n + e : n > e ? e : n; --a >= 0;) t.push(a);
                        return t
                    })), gt: mt((function (t, e, n) {
                        for (var a = n < 0 ? n + e : n; ++a < e;) t.push(a);
                        return t
                    }))
                }
            }).pseudos.nth = a.pseudos.eq, {
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
            }) a.pseudos[e] = pt(e);
            for (e in {submit: !0, reset: !0}) a.pseudos[e] = ft(e);

            function bt() {
            }

            function yt(t) {
                for (var e = 0, n = t.length, a = ""; e < n; e++) a += t[e].value;
                return a
            }

            function xt(t, e, n) {
                var a = e.dir, i = e.next, r = i || a, o = n && "parentNode" === r, s = S++;
                return e.first ? function (e, n, i) {
                    for (; e = e[a];) if (1 === e.nodeType || o) return t(e, n, i);
                    return !1
                } : function (e, n, l) {
                    var c, d, u, h = [w, s];
                    if (l) {
                        for (; e = e[a];) if ((1 === e.nodeType || o) && t(e, n, l)) return !0
                    } else for (; e = e[a];) if (1 === e.nodeType || o) if (d = (u = e[x] || (e[x] = {}))[e.uniqueID] || (u[e.uniqueID] = {}), i && i === e.nodeName.toLowerCase()) e = e[a] || e; else {
                        if ((c = d[r]) && c[0] === w && c[1] === s) return h[2] = c[2];
                        if (d[r] = h, h[2] = t(e, n, l)) return !0
                    }
                    return !1
                }
            }

            function _t(t) {
                return t.length > 1 ? function (e, n, a) {
                    for (var i = t.length; i--;) if (!t[i](e, n, a)) return !1;
                    return !0
                } : t[0]
            }

            function wt(t, e, n, a, i) {
                for (var r, o = [], s = 0, l = t.length, c = null != e; s < l; s++) (r = t[s]) && (n && !n(r, a, i) || (o.push(r), c && e.push(s)));
                return o
            }

            function St(t, e, n, a, i, r) {
                return a && !a[x] && (a = St(a)), i && !i[x] && (i = St(i, r)), ct((function (r, o, s, l) {
                    var c, d, u, h = [], p = [], f = o.length, g = r || function (t, e, n) {
                            for (var a = 0, i = e.length; a < i; a++) st(t, e[a], n);
                            return n
                        }(e || "*", s.nodeType ? [s] : s, []), m = !t || !r && e ? g : wt(g, h, t, s, l),
                        v = n ? i || (r ? t : f || a) ? [] : o : m;
                    if (n && n(m, v, s, l), a) for (c = wt(v, p), a(c, [], s, l), d = c.length; d--;) (u = c[d]) && (v[p[d]] = !(m[p[d]] = u));
                    if (r) {
                        if (i || t) {
                            if (i) {
                                for (c = [], d = v.length; d--;) (u = v[d]) && c.push(m[d] = u);
                                i(null, v = [], c, l)
                            }
                            for (d = v.length; d--;) (u = v[d]) && (c = i ? j(r, u) : h[d]) > -1 && (r[c] = !(o[c] = u))
                        }
                    } else v = wt(v === o ? v.splice(f, v.length) : v), i ? i(null, o, v, l) : P.apply(o, v)
                }))
            }

            function Ct(t) {
                for (var e, n, i, r = t.length, o = a.relative[t[0].type], s = o || a.relative[" "], l = o ? 1 : 0, d = xt((function (t) {
                    return t === e
                }), s, !0), u = xt((function (t) {
                    return j(e, t) > -1
                }), s, !0), h = [function (t, n, a) {
                    var i = !o && (a || n !== c) || ((e = n).nodeType ? d(t, n, a) : u(t, n, a));
                    return e = null, i
                }]; l < r; l++) if (n = a.relative[t[l].type]) h = [xt(_t(h), n)]; else {
                    if ((n = a.filter[t[l].type].apply(null, t[l].matches))[x]) {
                        for (i = ++l; i < r && !a.relative[t[i].type]; i++) ;
                        return St(l > 1 && _t(h), l > 1 && yt(t.slice(0, l - 1).concat({value: " " === t[l - 2].type ? "*" : ""})).replace(z, "$1"), n, l < i && Ct(t.slice(l, i)), i < r && Ct(t = t.slice(i)), i < r && yt(t))
                    }
                    h.push(n)
                }
                return _t(h)
            }

            return bt.prototype = a.filters = a.pseudos, a.setFilters = new bt, o = st.tokenize = function (t, e) {
                var n, i, r, o, s, l, c, d = k[t + " "];
                if (d) return e ? 0 : d.slice(0);
                for (s = t, l = [], c = a.preFilter; s;) {
                    for (o in n && !(i = W.exec(s)) || (i && (s = s.slice(i[0].length) || s), l.push(r = [])), n = !1, (i = V.exec(s)) && (n = i.shift(), r.push({
                        value: n,
                        type: i[0].replace(z, " ")
                    }), s = s.slice(n.length)), a.filter) !(i = G[o].exec(s)) || c[o] && !(i = c[o](i)) || (n = i.shift(), r.push({
                        value: n,
                        type: o,
                        matches: i
                    }), s = s.slice(n.length));
                    if (!n) break
                }
                return e ? s.length : s ? st.error(t) : k(t, l).slice(0)
            }, s = st.compile = function (t, e) {
                var n, i = [], r = [], s = D[t + " "];
                if (!s) {
                    for (e || (e = o(t)), n = e.length; n--;) (s = Ct(e[n]))[x] ? i.push(s) : r.push(s);
                    (s = D(t, function (t, e) {
                        var n = e.length > 0, i = t.length > 0, r = function (r, o, s, l, d) {
                            var u, f, m, v = 0, b = "0", y = r && [], x = [], _ = c, S = r || i && a.find.TAG("*", d),
                                C = w += null == _ ? 1 : Math.random() || .1, k = S.length;
                            for (d && (c = o == p || o || d); b !== k && null != (u = S[b]); b++) {
                                if (i && u) {
                                    for (f = 0, o || u.ownerDocument == p || (h(u), s = !g); m = t[f++];) if (m(u, o || p, s)) {
                                        l.push(u);
                                        break
                                    }
                                    d && (w = C)
                                }
                                n && ((u = !m && u) && v--, r && y.push(u))
                            }
                            if (v += b, n && b !== v) {
                                for (f = 0; m = e[f++];) m(y, x, o, s);
                                if (r) {
                                    if (v > 0) for (; b--;) y[b] || x[b] || (x[b] = M.call(l));
                                    x = wt(x)
                                }
                                P.apply(l, x), d && !r && x.length > 0 && v + e.length > 1 && st.uniqueSort(l)
                            }
                            return d && (w = C, c = _), y
                        };
                        return n ? ct(r) : r
                    }(r, i))).selector = t
                }
                return s
            }, l = st.select = function (t, e, n, i) {
                var r, l, c, d, u, h = "function" == typeof t && t, p = !i && o(t = h.selector || t);
                if (n = n || [], 1 === p.length) {
                    if ((l = p[0] = p[0].slice(0)).length > 2 && "ID" === (c = l[0]).type && 9 === e.nodeType && g && a.relative[l[1].type]) {
                        if (!(e = (a.find.ID(c.matches[0].replace(et, nt), e) || [])[0])) return n;
                        h && (e = e.parentNode), t = t.slice(l.shift().value.length)
                    }
                    for (r = G.needsContext.test(t) ? 0 : l.length; r-- && (c = l[r], !a.relative[d = c.type]);) if ((u = a.find[d]) && (i = u(c.matches[0].replace(et, nt), tt.test(l[0].type) && vt(e.parentNode) || e))) {
                        if (l.splice(r, 1), !(t = i.length && yt(l))) return P.apply(n, i), n;
                        break
                    }
                }
                return (h || s(t, p))(i, e, !g, n, !e || tt.test(t) && vt(e.parentNode) || e), n
            }, n.sortStable = x.split("").sort(E).join("") === x, n.detectDuplicates = !!u, h(), n.sortDetached = dt((function (t) {
                return 1 & t.compareDocumentPosition(p.createElement("fieldset"))
            })), dt((function (t) {
                return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
            })) || ut("type|href|height|width", (function (t, e, n) {
                if (!n) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
            })), n.attributes && dt((function (t) {
                return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
            })) || ut("value", (function (t, e, n) {
                if (!n && "input" === t.nodeName.toLowerCase()) return t.defaultValue
            })), dt((function (t) {
                return null == t.getAttribute("disabled")
            })) || ut(N, (function (t, e, n) {
                var a;
                if (!n) return !0 === t[e] ? e.toLowerCase() : (a = t.getAttributeNode(e)) && a.specified ? a.value : null
            })), st
        }(n);
        C.find = D, C.expr = D.selectors, C.expr[":"] = C.expr.pseudos, C.uniqueSort = C.unique = D.uniqueSort, C.text = D.getText, C.isXMLDoc = D.isXML, C.contains = D.contains, C.escapeSelector = D.escape;
        var T = function (t, e, n) {
            for (var a = [], i = void 0 !== n; (t = t[e]) && 9 !== t.nodeType;) if (1 === t.nodeType) {
                if (i && C(t).is(n)) break;
                a.push(t)
            }
            return a
        }, E = function (t, e) {
            for (var n = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && n.push(t);
            return n
        }, A = C.expr.match.needsContext;

        function I(t, e) {
            return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
        }

        var M = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

        function R(t, e, n) {
            return v(e) ? C.grep(t, (function (t, a) {
                return !!e.call(t, a, t) !== n
            })) : e.nodeType ? C.grep(t, (function (t) {
                return t === e !== n
            })) : "string" != typeof e ? C.grep(t, (function (t) {
                return d.call(e, t) > -1 !== n
            })) : C.filter(e, t, n)
        }

        C.filter = function (t, e, n) {
            var a = e[0];
            return n && (t = ":not(" + t + ")"), 1 === e.length && 1 === a.nodeType ? C.find.matchesSelector(a, t) ? [a] : [] : C.find.matches(t, C.grep(e, (function (t) {
                return 1 === t.nodeType
            })))
        }, C.fn.extend({
            find: function (t) {
                var e, n, a = this.length, i = this;
                if ("string" != typeof t) return this.pushStack(C(t).filter((function () {
                    for (e = 0; e < a; e++) if (C.contains(i[e], this)) return !0
                })));
                for (n = this.pushStack([]), e = 0; e < a; e++) C.find(t, i[e], n);
                return a > 1 ? C.uniqueSort(n) : n
            }, filter: function (t) {
                return this.pushStack(R(this, t || [], !1))
            }, not: function (t) {
                return this.pushStack(R(this, t || [], !0))
            }, is: function (t) {
                return !!R(this, "string" == typeof t && A.test(t) ? C(t) : t || [], !1).length
            }
        });
        var P, O = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (C.fn.init = function (t, e, n) {
            var a, i;
            if (!t) return this;
            if (n = n || P, "string" == typeof t) {
                if (!(a = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : O.exec(t)) || !a[1] && e) return !e || e.jquery ? (e || n).find(t) : this.constructor(e).find(t);
                if (a[1]) {
                    if (e = e instanceof C ? e[0] : e, C.merge(this, C.parseHTML(a[1], e && e.nodeType ? e.ownerDocument || e : y, !0)), M.test(a[1]) && C.isPlainObject(e)) for (a in e) v(this[a]) ? this[a](e[a]) : this.attr(a, e[a]);
                    return this
                }
                return (i = y.getElementById(a[2])) && (this[0] = i, this.length = 1), this
            }
            return t.nodeType ? (this[0] = t, this.length = 1, this) : v(t) ? void 0 !== n.ready ? n.ready(t) : t(C) : C.makeArray(t, this)
        }).prototype = C.fn, P = C(y);
        var j = /^(?:parents|prev(?:Until|All))/, N = {children: !0, contents: !0, next: !0, prev: !0};

        function L(t, e) {
            for (; (t = t[e]) && 1 !== t.nodeType;) ;
            return t
        }

        C.fn.extend({
            has: function (t) {
                var e = C(t, this), n = e.length;
                return this.filter((function () {
                    for (var t = 0; t < n; t++) if (C.contains(this, e[t])) return !0
                }))
            }, closest: function (t, e) {
                var n, a = 0, i = this.length, r = [], o = "string" != typeof t && C(t);
                if (!A.test(t)) for (; a < i; a++) for (n = this[a]; n && n !== e; n = n.parentNode) if (n.nodeType < 11 && (o ? o.index(n) > -1 : 1 === n.nodeType && C.find.matchesSelector(n, t))) {
                    r.push(n);
                    break
                }
                return this.pushStack(r.length > 1 ? C.uniqueSort(r) : r)
            }, index: function (t) {
                return t ? "string" == typeof t ? d.call(C(t), this[0]) : d.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            }, add: function (t, e) {
                return this.pushStack(C.uniqueSort(C.merge(this.get(), C(t, e))))
            }, addBack: function (t) {
                return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
            }
        }), C.each({
            parent: function (t) {
                var e = t.parentNode;
                return e && 11 !== e.nodeType ? e : null
            }, parents: function (t) {
                return T(t, "parentNode")
            }, parentsUntil: function (t, e, n) {
                return T(t, "parentNode", n)
            }, next: function (t) {
                return L(t, "nextSibling")
            }, prev: function (t) {
                return L(t, "previousSibling")
            }, nextAll: function (t) {
                return T(t, "nextSibling")
            }, prevAll: function (t) {
                return T(t, "previousSibling")
            }, nextUntil: function (t, e, n) {
                return T(t, "nextSibling", n)
            }, prevUntil: function (t, e, n) {
                return T(t, "previousSibling", n)
            }, siblings: function (t) {
                return E((t.parentNode || {}).firstChild, t)
            }, children: function (t) {
                return E(t.firstChild)
            }, contents: function (t) {
                return null != t.contentDocument && o(t.contentDocument) ? t.contentDocument : (I(t, "template") && (t = t.content || t), C.merge([], t.childNodes))
            }
        }, (function (t, e) {
            C.fn[t] = function (n, a) {
                var i = C.map(this, e, n);
                return "Until" !== t.slice(-5) && (a = n), a && "string" == typeof a && (i = C.filter(a, i)), this.length > 1 && (N[t] || C.uniqueSort(i), j.test(t) && i.reverse()), this.pushStack(i)
            }
        }));
        var F = /[^\x20\t\r\n\f]+/g;

        function H(t) {
            return t
        }

        function B(t) {
            throw t
        }

        function q(t, e, n, a) {
            var i;
            try {
                t && v(i = t.promise) ? i.call(t).done(e).fail(n) : t && v(i = t.then) ? i.call(t, e, n) : e.apply(void 0, [t].slice(a))
            } catch (t) {
                n.apply(void 0, [t])
            }
        }

        C.Callbacks = function (t) {
            t = "string" == typeof t ? function (t) {
                var e = {};
                return C.each(t.match(F) || [], (function (t, n) {
                    e[n] = !0
                })), e
            }(t) : C.extend({}, t);
            var e, n, a, i, r = [], o = [], s = -1, l = function () {
                for (i = i || t.once, a = e = !0; o.length; s = -1) for (n = o.shift(); ++s < r.length;) !1 === r[s].apply(n[0], n[1]) && t.stopOnFalse && (s = r.length, n = !1);
                t.memory || (n = !1), e = !1, i && (r = n ? [] : "")
            }, c = {
                add: function () {
                    return r && (n && !e && (s = r.length - 1, o.push(n)), function e(n) {
                        C.each(n, (function (n, a) {
                            v(a) ? t.unique && c.has(a) || r.push(a) : a && a.length && "string" !== w(a) && e(a)
                        }))
                    }(arguments), n && !e && l()), this
                }, remove: function () {
                    return C.each(arguments, (function (t, e) {
                        for (var n; (n = C.inArray(e, r, n)) > -1;) r.splice(n, 1), n <= s && s--
                    })), this
                }, has: function (t) {
                    return t ? C.inArray(t, r) > -1 : r.length > 0
                }, empty: function () {
                    return r && (r = []), this
                }, disable: function () {
                    return i = o = [], r = n = "", this
                }, disabled: function () {
                    return !r
                }, lock: function () {
                    return i = o = [], n || e || (r = n = ""), this
                }, locked: function () {
                    return !!i
                }, fireWith: function (t, n) {
                    return i || (n = [t, (n = n || []).slice ? n.slice() : n], o.push(n), e || l()), this
                }, fire: function () {
                    return c.fireWith(this, arguments), this
                }, fired: function () {
                    return !!a
                }
            };
            return c
        }, C.extend({
            Deferred: function (t) {
                var e = [["notify", "progress", C.Callbacks("memory"), C.Callbacks("memory"), 2], ["resolve", "done", C.Callbacks("once memory"), C.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", C.Callbacks("once memory"), C.Callbacks("once memory"), 1, "rejected"]],
                    a = "pending", i = {
                        state: function () {
                            return a
                        }, always: function () {
                            return r.done(arguments).fail(arguments), this
                        }, catch: function (t) {
                            return i.then(null, t)
                        }, pipe: function () {
                            var t = arguments;
                            return C.Deferred((function (n) {
                                C.each(e, (function (e, a) {
                                    var i = v(t[a[4]]) && t[a[4]];
                                    r[a[1]]((function () {
                                        var t = i && i.apply(this, arguments);
                                        t && v(t.promise) ? t.promise().progress(n.notify).done(n.resolve).fail(n.reject) : n[a[0] + "With"](this, i ? [t] : arguments)
                                    }))
                                })), t = null
                            })).promise()
                        }, then: function (t, a, i) {
                            var r = 0;

                            function o(t, e, a, i) {
                                return function () {
                                    var s = this, l = arguments, c = function () {
                                        var n, c;
                                        if (!(t < r)) {
                                            if ((n = a.apply(s, l)) === e.promise()) throw new TypeError("Thenable self-resolution");
                                            c = n && ("object" == typeof n || "function" == typeof n) && n.then, v(c) ? i ? c.call(n, o(r, e, H, i), o(r, e, B, i)) : (r++, c.call(n, o(r, e, H, i), o(r, e, B, i), o(r, e, H, e.notifyWith))) : (a !== H && (s = void 0, l = [n]), (i || e.resolveWith)(s, l))
                                        }
                                    }, d = i ? c : function () {
                                        try {
                                            c()
                                        } catch (n) {
                                            C.Deferred.exceptionHook && C.Deferred.exceptionHook(n, d.stackTrace), t + 1 >= r && (a !== B && (s = void 0, l = [n]), e.rejectWith(s, l))
                                        }
                                    };
                                    t ? d() : (C.Deferred.getStackHook && (d.stackTrace = C.Deferred.getStackHook()), n.setTimeout(d))
                                }
                            }

                            return C.Deferred((function (n) {
                                e[0][3].add(o(0, n, v(i) ? i : H, n.notifyWith)), e[1][3].add(o(0, n, v(t) ? t : H)), e[2][3].add(o(0, n, v(a) ? a : B))
                            })).promise()
                        }, promise: function (t) {
                            return null != t ? C.extend(t, i) : i
                        }
                    }, r = {};
                return C.each(e, (function (t, n) {
                    var o = n[2], s = n[5];
                    i[n[1]] = o.add, s && o.add((function () {
                        a = s
                    }), e[3 - t][2].disable, e[3 - t][3].disable, e[0][2].lock, e[0][3].lock), o.add(n[3].fire), r[n[0]] = function () {
                        return r[n[0] + "With"](this === r ? void 0 : this, arguments), this
                    }, r[n[0] + "With"] = o.fireWith
                })), i.promise(r), t && t.call(r, r), r
            }, when: function (t) {
                var e = arguments.length, n = e, a = Array(n), i = s.call(arguments), r = C.Deferred(),
                    o = function (t) {
                        return function (n) {
                            a[t] = this, i[t] = arguments.length > 1 ? s.call(arguments) : n, --e || r.resolveWith(a, i)
                        }
                    };
                if (e <= 1 && (q(t, r.done(o(n)).resolve, r.reject, !e), "pending" === r.state() || v(i[n] && i[n].then))) return r.then();
                for (; n--;) q(i[n], o(n), r.reject);
                return r.promise()
            }
        });
        var z = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        C.Deferred.exceptionHook = function (t, e) {
            n.console && n.console.warn && t && z.test(t.name) && n.console.warn("jQuery.Deferred exception: " + t.message, t.stack, e)
        }, C.readyException = function (t) {
            n.setTimeout((function () {
                throw t
            }))
        };
        var W = C.Deferred();

        function V() {
            y.removeEventListener("DOMContentLoaded", V), n.removeEventListener("load", V), C.ready()
        }

        C.fn.ready = function (t) {
            return W.then(t).catch((function (t) {
                C.readyException(t)
            })), this
        }, C.extend({
            isReady: !1, readyWait: 1, ready: function (t) {
                (!0 === t ? --C.readyWait : C.isReady) || (C.isReady = !0, !0 !== t && --C.readyWait > 0 || W.resolveWith(y, [C]))
            }
        }), C.ready.then = W.then, "complete" === y.readyState || "loading" !== y.readyState && !y.documentElement.doScroll ? n.setTimeout(C.ready) : (y.addEventListener("DOMContentLoaded", V), n.addEventListener("load", V));
        var $ = function (t, e, n, a, i, r, o) {
            var s = 0, l = t.length, c = null == n;
            if ("object" === w(n)) for (s in i = !0, n) $(t, e, s, n[s], !0, r, o); else if (void 0 !== a && (i = !0, v(a) || (o = !0), c && (o ? (e.call(t, a), e = null) : (c = e, e = function (t, e, n) {
                return c.call(C(t), n)
            })), e)) for (; s < l; s++) e(t[s], n, o ? a : a.call(t[s], s, e(t[s], n)));
            return i ? t : c ? e.call(t) : l ? e(t[0], n) : r
        }, Y = /^-ms-/, U = /-([a-z])/g;

        function G(t, e) {
            return e.toUpperCase()
        }

        function X(t) {
            return t.replace(Y, "ms-").replace(U, G)
        }

        var Z = function (t) {
            return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
        };

        function K() {
            this.expando = C.expando + K.uid++
        }

        K.uid = 1, K.prototype = {
            cache: function (t) {
                var e = t[this.expando];
                return e || (e = {}, Z(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                    value: e,
                    configurable: !0
                }))), e
            }, set: function (t, e, n) {
                var a, i = this.cache(t);
                if ("string" == typeof e) i[X(e)] = n; else for (a in e) i[X(a)] = e[a];
                return i
            }, get: function (t, e) {
                return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][X(e)]
            }, access: function (t, e, n) {
                return void 0 === e || e && "string" == typeof e && void 0 === n ? this.get(t, e) : (this.set(t, e, n), void 0 !== n ? n : e)
            }, remove: function (t, e) {
                var n, a = t[this.expando];
                if (void 0 !== a) {
                    if (void 0 !== e) {
                        n = (e = Array.isArray(e) ? e.map(X) : (e = X(e)) in a ? [e] : e.match(F) || []).length;
                        for (; n--;) delete a[e[n]]
                    }
                    (void 0 === e || C.isEmptyObject(a)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
                }
            }, hasData: function (t) {
                var e = t[this.expando];
                return void 0 !== e && !C.isEmptyObject(e)
            }
        };
        var Q = new K, J = new K, tt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, et = /[A-Z]/g;

        function nt(t, e, n) {
            var a;
            if (void 0 === n && 1 === t.nodeType) if (a = "data-" + e.replace(et, "-$&").toLowerCase(), "string" == typeof (n = t.getAttribute(a))) {
                try {
                    n = function (t) {
                        return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : tt.test(t) ? JSON.parse(t) : t)
                    }(n)
                } catch (t) {
                }
                J.set(t, e, n)
            } else n = void 0;
            return n
        }

        C.extend({
            hasData: function (t) {
                return J.hasData(t) || Q.hasData(t)
            }, data: function (t, e, n) {
                return J.access(t, e, n)
            }, removeData: function (t, e) {
                J.remove(t, e)
            }, _data: function (t, e, n) {
                return Q.access(t, e, n)
            }, _removeData: function (t, e) {
                Q.remove(t, e)
            }
        }), C.fn.extend({
            data: function (t, e) {
                var n, a, i, r = this[0], o = r && r.attributes;
                if (void 0 === t) {
                    if (this.length && (i = J.get(r), 1 === r.nodeType && !Q.get(r, "hasDataAttrs"))) {
                        for (n = o.length; n--;) o[n] && 0 === (a = o[n].name).indexOf("data-") && (a = X(a.slice(5)), nt(r, a, i[a]));
                        Q.set(r, "hasDataAttrs", !0)
                    }
                    return i
                }
                return "object" == typeof t ? this.each((function () {
                    J.set(this, t)
                })) : $(this, (function (e) {
                    var n;
                    if (r && void 0 === e) return void 0 !== (n = J.get(r, t)) || void 0 !== (n = nt(r, t)) ? n : void 0;
                    this.each((function () {
                        J.set(this, t, e)
                    }))
                }), null, e, arguments.length > 1, null, !0)
            }, removeData: function (t) {
                return this.each((function () {
                    J.remove(this, t)
                }))
            }
        }), C.extend({
            queue: function (t, e, n) {
                var a;
                if (t) return e = (e || "fx") + "queue", a = Q.get(t, e), n && (!a || Array.isArray(n) ? a = Q.access(t, e, C.makeArray(n)) : a.push(n)), a || []
            }, dequeue: function (t, e) {
                e = e || "fx";
                var n = C.queue(t, e), a = n.length, i = n.shift(), r = C._queueHooks(t, e);
                "inprogress" === i && (i = n.shift(), a--), i && ("fx" === e && n.unshift("inprogress"), delete r.stop, i.call(t, (function () {
                    C.dequeue(t, e)
                }), r)), !a && r && r.empty.fire()
            }, _queueHooks: function (t, e) {
                var n = e + "queueHooks";
                return Q.get(t, n) || Q.access(t, n, {
                    empty: C.Callbacks("once memory").add((function () {
                        Q.remove(t, [e + "queue", n])
                    }))
                })
            }
        }), C.fn.extend({
            queue: function (t, e) {
                var n = 2;
                return "string" != typeof t && (e = t, t = "fx", n--), arguments.length < n ? C.queue(this[0], t) : void 0 === e ? this : this.each((function () {
                    var n = C.queue(this, t, e);
                    C._queueHooks(this, t), "fx" === t && "inprogress" !== n[0] && C.dequeue(this, t)
                }))
            }, dequeue: function (t) {
                return this.each((function () {
                    C.dequeue(this, t)
                }))
            }, clearQueue: function (t) {
                return this.queue(t || "fx", [])
            }, promise: function (t, e) {
                var n, a = 1, i = C.Deferred(), r = this, o = this.length, s = function () {
                    --a || i.resolveWith(r, [r])
                };
                for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; o--;) (n = Q.get(r[o], t + "queueHooks")) && n.empty && (a++, n.empty.add(s));
                return s(), i.promise(e)
            }
        });
        var at = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            it = new RegExp("^(?:([+-])=|)(" + at + ")([a-z%]*)$", "i"), rt = ["Top", "Right", "Bottom", "Left"],
            ot = y.documentElement, st = function (t) {
                return C.contains(t.ownerDocument, t)
            }, lt = {composed: !0};
        ot.getRootNode && (st = function (t) {
            return C.contains(t.ownerDocument, t) || t.getRootNode(lt) === t.ownerDocument
        });
        var ct = function (t, e) {
            return "none" === (t = e || t).style.display || "" === t.style.display && st(t) && "none" === C.css(t, "display")
        };

        function dt(t, e, n, a) {
            var i, r, o = 20, s = a ? function () {
                    return a.cur()
                } : function () {
                    return C.css(t, e, "")
                }, l = s(), c = n && n[3] || (C.cssNumber[e] ? "" : "px"),
                d = t.nodeType && (C.cssNumber[e] || "px" !== c && +l) && it.exec(C.css(t, e));
            if (d && d[3] !== c) {
                for (l /= 2, c = c || d[3], d = +l || 1; o--;) C.style(t, e, d + c), (1 - r) * (1 - (r = s() / l || .5)) <= 0 && (o = 0), d /= r;
                d *= 2, C.style(t, e, d + c), n = n || []
            }
            return n && (d = +d || +l || 0, i = n[1] ? d + (n[1] + 1) * n[2] : +n[2], a && (a.unit = c, a.start = d, a.end = i)), i
        }

        var ut = {};

        function ht(t) {
            var e, n = t.ownerDocument, a = t.nodeName, i = ut[a];
            return i || (e = n.body.appendChild(n.createElement(a)), i = C.css(e, "display"), e.parentNode.removeChild(e), "none" === i && (i = "block"), ut[a] = i, i)
        }

        function pt(t, e) {
            for (var n, a, i = [], r = 0, o = t.length; r < o; r++) (a = t[r]).style && (n = a.style.display, e ? ("none" === n && (i[r] = Q.get(a, "display") || null, i[r] || (a.style.display = "")), "" === a.style.display && ct(a) && (i[r] = ht(a))) : "none" !== n && (i[r] = "none", Q.set(a, "display", n)));
            for (r = 0; r < o; r++) null != i[r] && (t[r].style.display = i[r]);
            return t
        }

        C.fn.extend({
            show: function () {
                return pt(this, !0)
            }, hide: function () {
                return pt(this)
            }, toggle: function (t) {
                return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each((function () {
                    ct(this) ? C(this).show() : C(this).hide()
                }))
            }
        });
        var ft, gt, mt = /^(?:checkbox|radio)$/i, vt = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            bt = /^$|^module$|\/(?:java|ecma)script/i;
        ft = y.createDocumentFragment().appendChild(y.createElement("div")), (gt = y.createElement("input")).setAttribute("type", "radio"), gt.setAttribute("checked", "checked"), gt.setAttribute("name", "t"), ft.appendChild(gt), m.checkClone = ft.cloneNode(!0).cloneNode(!0).lastChild.checked, ft.innerHTML = "<textarea>x</textarea>", m.noCloneChecked = !!ft.cloneNode(!0).lastChild.defaultValue, ft.innerHTML = "<option></option>", m.option = !!ft.lastChild;
        var yt = {
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };

        function xt(t, e) {
            var n;
            return n = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && I(t, e) ? C.merge([t], n) : n
        }

        function _t(t, e) {
            for (var n = 0, a = t.length; n < a; n++) Q.set(t[n], "globalEval", !e || Q.get(e[n], "globalEval"))
        }

        yt.tbody = yt.tfoot = yt.colgroup = yt.caption = yt.thead, yt.th = yt.td, m.option || (yt.optgroup = yt.option = [1, "<select multiple='multiple'>", "</select>"]);
        var wt = /<|&#?\w+;/;

        function St(t, e, n, a, i) {
            for (var r, o, s, l, c, d, u = e.createDocumentFragment(), h = [], p = 0, f = t.length; p < f; p++) if ((r = t[p]) || 0 === r) if ("object" === w(r)) C.merge(h, r.nodeType ? [r] : r); else if (wt.test(r)) {
                for (o = o || u.appendChild(e.createElement("div")), s = (vt.exec(r) || ["", ""])[1].toLowerCase(), l = yt[s] || yt._default, o.innerHTML = l[1] + C.htmlPrefilter(r) + l[2], d = l[0]; d--;) o = o.lastChild;
                C.merge(h, o.childNodes), (o = u.firstChild).textContent = ""
            } else h.push(e.createTextNode(r));
            for (u.textContent = "", p = 0; r = h[p++];) if (a && C.inArray(r, a) > -1) i && i.push(r); else if (c = st(r), o = xt(u.appendChild(r), "script"), c && _t(o), n) for (d = 0; r = o[d++];) bt.test(r.type || "") && n.push(r);
            return u
        }

        var Ct = /^key/, kt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, Dt = /^([^.]*)(?:\.(.+)|)/;

        function Tt() {
            return !0
        }

        function Et() {
            return !1
        }

        function At(t, e) {
            return t === function () {
                try {
                    return y.activeElement
                } catch (t) {
                }
            }() == ("focus" === e)
        }

        function It(t, e, n, a, i, r) {
            var o, s;
            if ("object" == typeof e) {
                for (s in "string" != typeof n && (a = a || n, n = void 0), e) It(t, s, n, a, e[s], r);
                return t
            }
            if (null == a && null == i ? (i = n, a = n = void 0) : null == i && ("string" == typeof n ? (i = a, a = void 0) : (i = a, a = n, n = void 0)), !1 === i) i = Et; else if (!i) return t;
            return 1 === r && (o = i, (i = function (t) {
                return C().off(t), o.apply(this, arguments)
            }).guid = o.guid || (o.guid = C.guid++)), t.each((function () {
                C.event.add(this, e, i, a, n)
            }))
        }

        function Mt(t, e, n) {
            n ? (Q.set(t, e, !1), C.event.add(t, e, {
                namespace: !1, handler: function (t) {
                    var a, i, r = Q.get(this, e);
                    if (1 & t.isTrigger && this[e]) {
                        if (r.length) (C.event.special[e] || {}).delegateType && t.stopPropagation(); else if (r = s.call(arguments), Q.set(this, e, r), a = n(this, e), this[e](), r !== (i = Q.get(this, e)) || a ? Q.set(this, e, !1) : i = {}, r !== i) return t.stopImmediatePropagation(), t.preventDefault(), i.value
                    } else r.length && (Q.set(this, e, {value: C.event.trigger(C.extend(r[0], C.Event.prototype), r.slice(1), this)}), t.stopImmediatePropagation())
                }
            })) : void 0 === Q.get(t, e) && C.event.add(t, e, Tt)
        }

        C.event = {
            global: {}, add: function (t, e, n, a, i) {
                var r, o, s, l, c, d, u, h, p, f, g, m = Q.get(t);
                if (Z(t)) for (n.handler && (n = (r = n).handler, i = r.selector), i && C.find.matchesSelector(ot, i), n.guid || (n.guid = C.guid++), (l = m.events) || (l = m.events = Object.create(null)), (o = m.handle) || (o = m.handle = function (e) {
                    return void 0 !== C && C.event.triggered !== e.type ? C.event.dispatch.apply(t, arguments) : void 0
                }), c = (e = (e || "").match(F) || [""]).length; c--;) p = g = (s = Dt.exec(e[c]) || [])[1], f = (s[2] || "").split(".").sort(), p && (u = C.event.special[p] || {}, p = (i ? u.delegateType : u.bindType) || p, u = C.event.special[p] || {}, d = C.extend({
                    type: p,
                    origType: g,
                    data: a,
                    handler: n,
                    guid: n.guid,
                    selector: i,
                    needsContext: i && C.expr.match.needsContext.test(i),
                    namespace: f.join(".")
                }, r), (h = l[p]) || ((h = l[p] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(t, a, f, o) || t.addEventListener && t.addEventListener(p, o)), u.add && (u.add.call(t, d), d.handler.guid || (d.handler.guid = n.guid)), i ? h.splice(h.delegateCount++, 0, d) : h.push(d), C.event.global[p] = !0)
            }, remove: function (t, e, n, a, i) {
                var r, o, s, l, c, d, u, h, p, f, g, m = Q.hasData(t) && Q.get(t);
                if (m && (l = m.events)) {
                    for (c = (e = (e || "").match(F) || [""]).length; c--;) if (p = g = (s = Dt.exec(e[c]) || [])[1], f = (s[2] || "").split(".").sort(), p) {
                        for (u = C.event.special[p] || {}, h = l[p = (a ? u.delegateType : u.bindType) || p] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), o = r = h.length; r--;) d = h[r], !i && g !== d.origType || n && n.guid !== d.guid || s && !s.test(d.namespace) || a && a !== d.selector && ("**" !== a || !d.selector) || (h.splice(r, 1), d.selector && h.delegateCount--, u.remove && u.remove.call(t, d));
                        o && !h.length && (u.teardown && !1 !== u.teardown.call(t, f, m.handle) || C.removeEvent(t, p, m.handle), delete l[p])
                    } else for (p in l) C.event.remove(t, p + e[c], n, a, !0);
                    C.isEmptyObject(l) && Q.remove(t, "handle events")
                }
            }, dispatch: function (t) {
                var e, n, a, i, r, o, s = new Array(arguments.length), l = C.event.fix(t),
                    c = (Q.get(this, "events") || Object.create(null))[l.type] || [], d = C.event.special[l.type] || {};
                for (s[0] = l, e = 1; e < arguments.length; e++) s[e] = arguments[e];
                if (l.delegateTarget = this, !d.preDispatch || !1 !== d.preDispatch.call(this, l)) {
                    for (o = C.event.handlers.call(this, l, c), e = 0; (i = o[e++]) && !l.isPropagationStopped();) for (l.currentTarget = i.elem, n = 0; (r = i.handlers[n++]) && !l.isImmediatePropagationStopped();) l.rnamespace && !1 !== r.namespace && !l.rnamespace.test(r.namespace) || (l.handleObj = r, l.data = r.data, void 0 !== (a = ((C.event.special[r.origType] || {}).handle || r.handler).apply(i.elem, s)) && !1 === (l.result = a) && (l.preventDefault(), l.stopPropagation()));
                    return d.postDispatch && d.postDispatch.call(this, l), l.result
                }
            }, handlers: function (t, e) {
                var n, a, i, r, o, s = [], l = e.delegateCount, c = t.target;
                if (l && c.nodeType && !("click" === t.type && t.button >= 1)) for (; c !== this; c = c.parentNode || this) if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
                    for (r = [], o = {}, n = 0; n < l; n++) void 0 === o[i = (a = e[n]).selector + " "] && (o[i] = a.needsContext ? C(i, this).index(c) > -1 : C.find(i, this, null, [c]).length), o[i] && r.push(a);
                    r.length && s.push({elem: c, handlers: r})
                }
                return c = this, l < e.length && s.push({elem: c, handlers: e.slice(l)}), s
            }, addProp: function (t, e) {
                Object.defineProperty(C.Event.prototype, t, {
                    enumerable: !0, configurable: !0, get: v(e) ? function () {
                        if (this.originalEvent) return e(this.originalEvent)
                    } : function () {
                        if (this.originalEvent) return this.originalEvent[t]
                    }, set: function (e) {
                        Object.defineProperty(this, t, {enumerable: !0, configurable: !0, writable: !0, value: e})
                    }
                })
            }, fix: function (t) {
                return t[C.expando] ? t : new C.Event(t)
            }, special: {
                load: {noBubble: !0}, click: {
                    setup: function (t) {
                        var e = this || t;
                        return mt.test(e.type) && e.click && I(e, "input") && Mt(e, "click", Tt), !1
                    }, trigger: function (t) {
                        var e = this || t;
                        return mt.test(e.type) && e.click && I(e, "input") && Mt(e, "click"), !0
                    }, _default: function (t) {
                        var e = t.target;
                        return mt.test(e.type) && e.click && I(e, "input") && Q.get(e, "click") || I(e, "a")
                    }
                }, beforeunload: {
                    postDispatch: function (t) {
                        void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                    }
                }
            }
        }, C.removeEvent = function (t, e, n) {
            t.removeEventListener && t.removeEventListener(e, n)
        }, C.Event = function (t, e) {
            if (!(this instanceof C.Event)) return new C.Event(t, e);
            t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? Tt : Et, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && C.extend(this, e), this.timeStamp = t && t.timeStamp || Date.now(), this[C.expando] = !0
        }, C.Event.prototype = {
            constructor: C.Event,
            isDefaultPrevented: Et,
            isPropagationStopped: Et,
            isImmediatePropagationStopped: Et,
            isSimulated: !1,
            preventDefault: function () {
                var t = this.originalEvent;
                this.isDefaultPrevented = Tt, t && !this.isSimulated && t.preventDefault()
            },
            stopPropagation: function () {
                var t = this.originalEvent;
                this.isPropagationStopped = Tt, t && !this.isSimulated && t.stopPropagation()
            },
            stopImmediatePropagation: function () {
                var t = this.originalEvent;
                this.isImmediatePropagationStopped = Tt, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
            }
        }, C.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: function (t) {
                var e = t.button;
                return null == t.which && Ct.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && kt.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which
            }
        }, C.event.addProp), C.each({focus: "focusin", blur: "focusout"}, (function (t, e) {
            C.event.special[t] = {
                setup: function () {
                    return Mt(this, t, At), !1
                }, trigger: function () {
                    return Mt(this, t), !0
                }, delegateType: e
            }
        })), C.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, (function (t, e) {
            C.event.special[t] = {
                delegateType: e, bindType: e, handle: function (t) {
                    var n, a = this, i = t.relatedTarget, r = t.handleObj;
                    return i && (i === a || C.contains(a, i)) || (t.type = r.origType, n = r.handler.apply(this, arguments), t.type = e), n
                }
            }
        })), C.fn.extend({
            on: function (t, e, n, a) {
                return It(this, t, e, n, a)
            }, one: function (t, e, n, a) {
                return It(this, t, e, n, a, 1)
            }, off: function (t, e, n) {
                var a, i;
                if (t && t.preventDefault && t.handleObj) return a = t.handleObj, C(t.delegateTarget).off(a.namespace ? a.origType + "." + a.namespace : a.origType, a.selector, a.handler), this;
                if ("object" == typeof t) {
                    for (i in t) this.off(i, e, t[i]);
                    return this
                }
                return !1 !== e && "function" != typeof e || (n = e, e = void 0), !1 === n && (n = Et), this.each((function () {
                    C.event.remove(this, t, n, e)
                }))
            }
        });
        var Rt = /<script|<style|<link/i, Pt = /checked\s*(?:[^=]|=\s*.checked.)/i,
            Ot = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

        function jt(t, e) {
            return I(t, "table") && I(11 !== e.nodeType ? e : e.firstChild, "tr") && C(t).children("tbody")[0] || t
        }

        function Nt(t) {
            return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
        }

        function Lt(t) {
            return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
        }

        function Ft(t, e) {
            var n, a, i, r, o, s;
            if (1 === e.nodeType) {
                if (Q.hasData(t) && (s = Q.get(t).events)) for (i in Q.remove(e, "handle events"), s) for (n = 0, a = s[i].length; n < a; n++) C.event.add(e, i, s[i][n]);
                J.hasData(t) && (r = J.access(t), o = C.extend({}, r), J.set(e, o))
            }
        }

        function Ht(t, e) {
            var n = e.nodeName.toLowerCase();
            "input" === n && mt.test(t.type) ? e.checked = t.checked : "input" !== n && "textarea" !== n || (e.defaultValue = t.defaultValue)
        }

        function Bt(t, e, n, a) {
            e = l(e);
            var i, r, o, s, c, d, u = 0, h = t.length, p = h - 1, f = e[0], g = v(f);
            if (g || h > 1 && "string" == typeof f && !m.checkClone && Pt.test(f)) return t.each((function (i) {
                var r = t.eq(i);
                g && (e[0] = f.call(this, i, r.html())), Bt(r, e, n, a)
            }));
            if (h && (r = (i = St(e, t[0].ownerDocument, !1, t, a)).firstChild, 1 === i.childNodes.length && (i = r), r || a)) {
                for (s = (o = C.map(xt(i, "script"), Nt)).length; u < h; u++) c = i, u !== p && (c = C.clone(c, !0, !0), s && C.merge(o, xt(c, "script"))), n.call(t[u], c, u);
                if (s) for (d = o[o.length - 1].ownerDocument, C.map(o, Lt), u = 0; u < s; u++) c = o[u], bt.test(c.type || "") && !Q.access(c, "globalEval") && C.contains(d, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? C._evalUrl && !c.noModule && C._evalUrl(c.src, {nonce: c.nonce || c.getAttribute("nonce")}, d) : _(c.textContent.replace(Ot, ""), c, d))
            }
            return t
        }

        function qt(t, e, n) {
            for (var a, i = e ? C.filter(e, t) : t, r = 0; null != (a = i[r]); r++) n || 1 !== a.nodeType || C.cleanData(xt(a)), a.parentNode && (n && st(a) && _t(xt(a, "script")), a.parentNode.removeChild(a));
            return t
        }

        C.extend({
            htmlPrefilter: function (t) {
                return t
            }, clone: function (t, e, n) {
                var a, i, r, o, s = t.cloneNode(!0), l = st(t);
                if (!(m.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || C.isXMLDoc(t))) for (o = xt(s), a = 0, i = (r = xt(t)).length; a < i; a++) Ht(r[a], o[a]);
                if (e) if (n) for (r = r || xt(t), o = o || xt(s), a = 0, i = r.length; a < i; a++) Ft(r[a], o[a]); else Ft(t, s);
                return (o = xt(s, "script")).length > 0 && _t(o, !l && xt(t, "script")), s
            }, cleanData: function (t) {
                for (var e, n, a, i = C.event.special, r = 0; void 0 !== (n = t[r]); r++) if (Z(n)) {
                    if (e = n[Q.expando]) {
                        if (e.events) for (a in e.events) i[a] ? C.event.remove(n, a) : C.removeEvent(n, a, e.handle);
                        n[Q.expando] = void 0
                    }
                    n[J.expando] && (n[J.expando] = void 0)
                }
            }
        }), C.fn.extend({
            detach: function (t) {
                return qt(this, t, !0)
            }, remove: function (t) {
                return qt(this, t)
            }, text: function (t) {
                return $(this, (function (t) {
                    return void 0 === t ? C.text(this) : this.empty().each((function () {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                    }))
                }), null, t, arguments.length)
            }, append: function () {
                return Bt(this, arguments, (function (t) {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || jt(this, t).appendChild(t)
                }))
            }, prepend: function () {
                return Bt(this, arguments, (function (t) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var e = jt(this, t);
                        e.insertBefore(t, e.firstChild)
                    }
                }))
            }, before: function () {
                return Bt(this, arguments, (function (t) {
                    this.parentNode && this.parentNode.insertBefore(t, this)
                }))
            }, after: function () {
                return Bt(this, arguments, (function (t) {
                    this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
                }))
            }, empty: function () {
                for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (C.cleanData(xt(t, !1)), t.textContent = "");
                return this
            }, clone: function (t, e) {
                return t = null != t && t, e = null == e ? t : e, this.map((function () {
                    return C.clone(this, t, e)
                }))
            }, html: function (t) {
                return $(this, (function (t) {
                    var e = this[0] || {}, n = 0, a = this.length;
                    if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                    if ("string" == typeof t && !Rt.test(t) && !yt[(vt.exec(t) || ["", ""])[1].toLowerCase()]) {
                        t = C.htmlPrefilter(t);
                        try {
                            for (; n < a; n++) 1 === (e = this[n] || {}).nodeType && (C.cleanData(xt(e, !1)), e.innerHTML = t);
                            e = 0
                        } catch (t) {
                        }
                    }
                    e && this.empty().append(t)
                }), null, t, arguments.length)
            }, replaceWith: function () {
                var t = [];
                return Bt(this, arguments, (function (e) {
                    var n = this.parentNode;
                    C.inArray(this, t) < 0 && (C.cleanData(xt(this)), n && n.replaceChild(e, this))
                }), t)
            }
        }), C.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, (function (t, e) {
            C.fn[t] = function (t) {
                for (var n, a = [], i = C(t), r = i.length - 1, o = 0; o <= r; o++) n = o === r ? this : this.clone(!0), C(i[o])[e](n), c.apply(a, n.get());
                return this.pushStack(a)
            }
        }));
        var zt = new RegExp("^(" + at + ")(?!px)[a-z%]+$", "i"), Wt = function (t) {
            var e = t.ownerDocument.defaultView;
            return e && e.opener || (e = n), e.getComputedStyle(t)
        }, Vt = function (t, e, n) {
            var a, i, r = {};
            for (i in e) r[i] = t.style[i], t.style[i] = e[i];
            for (i in a = n.call(t), e) t.style[i] = r[i];
            return a
        }, $t = new RegExp(rt.join("|"), "i");

        function Yt(t, e, n) {
            var a, i, r, o, s = t.style;
            return (n = n || Wt(t)) && ("" !== (o = n.getPropertyValue(e) || n[e]) || st(t) || (o = C.style(t, e)), !m.pixelBoxStyles() && zt.test(o) && $t.test(e) && (a = s.width, i = s.minWidth, r = s.maxWidth, s.minWidth = s.maxWidth = s.width = o, o = n.width, s.width = a, s.minWidth = i, s.maxWidth = r)), void 0 !== o ? o + "" : o
        }

        function Ut(t, e) {
            return {
                get: function () {
                    if (!t()) return (this.get = e).apply(this, arguments);
                    delete this.get
                }
            }
        }

        !function () {
            function t() {
                if (d) {
                    c.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", d.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ot.appendChild(c).appendChild(d);
                    var t = n.getComputedStyle(d);
                    a = "1%" !== t.top, l = 12 === e(t.marginLeft), d.style.right = "60%", o = 36 === e(t.right), i = 36 === e(t.width), d.style.position = "absolute", r = 12 === e(d.offsetWidth / 3), ot.removeChild(c), d = null
                }
            }

            function e(t) {
                return Math.round(parseFloat(t))
            }

            var a, i, r, o, s, l, c = y.createElement("div"), d = y.createElement("div");
            d.style && (d.style.backgroundClip = "content-box", d.cloneNode(!0).style.backgroundClip = "", m.clearCloneStyle = "content-box" === d.style.backgroundClip, C.extend(m, {
                boxSizingReliable: function () {
                    return t(), i
                }, pixelBoxStyles: function () {
                    return t(), o
                }, pixelPosition: function () {
                    return t(), a
                }, reliableMarginLeft: function () {
                    return t(), l
                }, scrollboxSize: function () {
                    return t(), r
                }, reliableTrDimensions: function () {
                    var t, e, a, i;
                    return null == s && (t = y.createElement("table"), e = y.createElement("tr"), a = y.createElement("div"), t.style.cssText = "position:absolute;left:-11111px", e.style.height = "1px", a.style.height = "9px", ot.appendChild(t).appendChild(e).appendChild(a), i = n.getComputedStyle(e), s = parseInt(i.height) > 3, ot.removeChild(t)), s
                }
            }))
        }();
        var Gt = ["Webkit", "Moz", "ms"], Xt = y.createElement("div").style, Zt = {};

        function Kt(t) {
            var e = C.cssProps[t] || Zt[t];
            return e || (t in Xt ? t : Zt[t] = function (t) {
                for (var e = t[0].toUpperCase() + t.slice(1), n = Gt.length; n--;) if ((t = Gt[n] + e) in Xt) return t
            }(t) || t)
        }

        var Qt = /^(none|table(?!-c[ea]).+)/, Jt = /^--/,
            te = {position: "absolute", visibility: "hidden", display: "block"},
            ee = {letterSpacing: "0", fontWeight: "400"};

        function ne(t, e, n) {
            var a = it.exec(e);
            return a ? Math.max(0, a[2] - (n || 0)) + (a[3] || "px") : e
        }

        function ae(t, e, n, a, i, r) {
            var o = "width" === e ? 1 : 0, s = 0, l = 0;
            if (n === (a ? "border" : "content")) return 0;
            for (; o < 4; o += 2) "margin" === n && (l += C.css(t, n + rt[o], !0, i)), a ? ("content" === n && (l -= C.css(t, "padding" + rt[o], !0, i)), "margin" !== n && (l -= C.css(t, "border" + rt[o] + "Width", !0, i))) : (l += C.css(t, "padding" + rt[o], !0, i), "padding" !== n ? l += C.css(t, "border" + rt[o] + "Width", !0, i) : s += C.css(t, "border" + rt[o] + "Width", !0, i));
            return !a && r >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - r - l - s - .5)) || 0), l
        }

        function ie(t, e, n) {
            var a = Wt(t), i = (!m.boxSizingReliable() || n) && "border-box" === C.css(t, "boxSizing", !1, a), r = i,
                o = Yt(t, e, a), s = "offset" + e[0].toUpperCase() + e.slice(1);
            if (zt.test(o)) {
                if (!n) return o;
                o = "auto"
            }
            return (!m.boxSizingReliable() && i || !m.reliableTrDimensions() && I(t, "tr") || "auto" === o || !parseFloat(o) && "inline" === C.css(t, "display", !1, a)) && t.getClientRects().length && (i = "border-box" === C.css(t, "boxSizing", !1, a), (r = s in t) && (o = t[s])), (o = parseFloat(o) || 0) + ae(t, e, n || (i ? "border" : "content"), r, a, o) + "px"
        }

        function re(t, e, n, a, i) {
            return new re.prototype.init(t, e, n, a, i)
        }

        C.extend({
            cssHooks: {
                opacity: {
                    get: function (t, e) {
                        if (e) {
                            var n = Yt(t, "opacity");
                            return "" === n ? "1" : n
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                gridArea: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnStart: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowStart: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {},
            style: function (t, e, n, a) {
                if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                    var i, r, o, s = X(e), l = Jt.test(e), c = t.style;
                    if (l || (e = Kt(s)), o = C.cssHooks[e] || C.cssHooks[s], void 0 === n) return o && "get" in o && void 0 !== (i = o.get(t, !1, a)) ? i : c[e];
                    "string" === (r = typeof n) && (i = it.exec(n)) && i[1] && (n = dt(t, e, i), r = "number"), null != n && n == n && ("number" !== r || l || (n += i && i[3] || (C.cssNumber[s] ? "" : "px")), m.clearCloneStyle || "" !== n || 0 !== e.indexOf("background") || (c[e] = "inherit"), o && "set" in o && void 0 === (n = o.set(t, n, a)) || (l ? c.setProperty(e, n) : c[e] = n))
                }
            },
            css: function (t, e, n, a) {
                var i, r, o, s = X(e);
                return Jt.test(e) || (e = Kt(s)), (o = C.cssHooks[e] || C.cssHooks[s]) && "get" in o && (i = o.get(t, !0, n)), void 0 === i && (i = Yt(t, e, a)), "normal" === i && e in ee && (i = ee[e]), "" === n || n ? (r = parseFloat(i), !0 === n || isFinite(r) ? r || 0 : i) : i
            }
        }), C.each(["height", "width"], (function (t, e) {
            C.cssHooks[e] = {
                get: function (t, n, a) {
                    if (n) return !Qt.test(C.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? ie(t, e, a) : Vt(t, te, (function () {
                        return ie(t, e, a)
                    }))
                }, set: function (t, n, a) {
                    var i, r = Wt(t), o = !m.scrollboxSize() && "absolute" === r.position,
                        s = (o || a) && "border-box" === C.css(t, "boxSizing", !1, r), l = a ? ae(t, e, a, s, r) : 0;
                    return s && o && (l -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(r[e]) - ae(t, e, "border", !1, r) - .5)), l && (i = it.exec(n)) && "px" !== (i[3] || "px") && (t.style[e] = n, n = C.css(t, e)), ne(0, n, l)
                }
            }
        })), C.cssHooks.marginLeft = Ut(m.reliableMarginLeft, (function (t, e) {
            if (e) return (parseFloat(Yt(t, "marginLeft")) || t.getBoundingClientRect().left - Vt(t, {marginLeft: 0}, (function () {
                return t.getBoundingClientRect().left
            }))) + "px"
        })), C.each({margin: "", padding: "", border: "Width"}, (function (t, e) {
            C.cssHooks[t + e] = {
                expand: function (n) {
                    for (var a = 0, i = {}, r = "string" == typeof n ? n.split(" ") : [n]; a < 4; a++) i[t + rt[a] + e] = r[a] || r[a - 2] || r[0];
                    return i
                }
            }, "margin" !== t && (C.cssHooks[t + e].set = ne)
        })), C.fn.extend({
            css: function (t, e) {
                return $(this, (function (t, e, n) {
                    var a, i, r = {}, o = 0;
                    if (Array.isArray(e)) {
                        for (a = Wt(t), i = e.length; o < i; o++) r[e[o]] = C.css(t, e[o], !1, a);
                        return r
                    }
                    return void 0 !== n ? C.style(t, e, n) : C.css(t, e)
                }), t, e, arguments.length > 1)
            }
        }), C.Tween = re, re.prototype = {
            constructor: re, init: function (t, e, n, a, i, r) {
                this.elem = t, this.prop = n, this.easing = i || C.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = a, this.unit = r || (C.cssNumber[n] ? "" : "px")
            }, cur: function () {
                var t = re.propHooks[this.prop];
                return t && t.get ? t.get(this) : re.propHooks._default.get(this)
            }, run: function (t) {
                var e, n = re.propHooks[this.prop];
                return this.options.duration ? this.pos = e = C.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), n && n.set ? n.set(this) : re.propHooks._default.set(this), this
            }
        }, re.prototype.init.prototype = re.prototype, re.propHooks = {
            _default: {
                get: function (t) {
                    var e;
                    return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = C.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
                }, set: function (t) {
                    C.fx.step[t.prop] ? C.fx.step[t.prop](t) : 1 !== t.elem.nodeType || !C.cssHooks[t.prop] && null == t.elem.style[Kt(t.prop)] ? t.elem[t.prop] = t.now : C.style(t.elem, t.prop, t.now + t.unit)
                }
            }
        }, re.propHooks.scrollTop = re.propHooks.scrollLeft = {
            set: function (t) {
                t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
            }
        }, C.easing = {
            linear: function (t) {
                return t
            }, swing: function (t) {
                return .5 - Math.cos(t * Math.PI) / 2
            }, _default: "swing"
        }, C.fx = re.prototype.init, C.fx.step = {};
        var oe, se, le = /^(?:toggle|show|hide)$/, ce = /queueHooks$/;

        function de() {
            se && (!1 === y.hidden && n.requestAnimationFrame ? n.requestAnimationFrame(de) : n.setTimeout(de, C.fx.interval), C.fx.tick())
        }

        function ue() {
            return n.setTimeout((function () {
                oe = void 0
            })), oe = Date.now()
        }

        function he(t, e) {
            var n, a = 0, i = {height: t};
            for (e = e ? 1 : 0; a < 4; a += 2 - e) i["margin" + (n = rt[a])] = i["padding" + n] = t;
            return e && (i.opacity = i.width = t), i
        }

        function pe(t, e, n) {
            for (var a, i = (fe.tweeners[e] || []).concat(fe.tweeners["*"]), r = 0, o = i.length; r < o; r++) if (a = i[r].call(n, e, t)) return a
        }

        function fe(t, e, n) {
            var a, i, r = 0, o = fe.prefilters.length, s = C.Deferred().always((function () {
                delete l.elem
            })), l = function () {
                if (i) return !1;
                for (var e = oe || ue(), n = Math.max(0, c.startTime + c.duration - e), a = 1 - (n / c.duration || 0), r = 0, o = c.tweens.length; r < o; r++) c.tweens[r].run(a);
                return s.notifyWith(t, [c, a, n]), a < 1 && o ? n : (o || s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c]), !1)
            }, c = s.promise({
                elem: t,
                props: C.extend({}, e),
                opts: C.extend(!0, {specialEasing: {}, easing: C.easing._default}, n),
                originalProperties: e,
                originalOptions: n,
                startTime: oe || ue(),
                duration: n.duration,
                tweens: [],
                createTween: function (e, n) {
                    var a = C.Tween(t, c.opts, e, n, c.opts.specialEasing[e] || c.opts.easing);
                    return c.tweens.push(a), a
                },
                stop: function (e) {
                    var n = 0, a = e ? c.tweens.length : 0;
                    if (i) return this;
                    for (i = !0; n < a; n++) c.tweens[n].run(1);
                    return e ? (s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c, e])) : s.rejectWith(t, [c, e]), this
                }
            }), d = c.props;
            for (!function (t, e) {
                var n, a, i, r, o;
                for (n in t) if (i = e[a = X(n)], r = t[n], Array.isArray(r) && (i = r[1], r = t[n] = r[0]), n !== a && (t[a] = r, delete t[n]), (o = C.cssHooks[a]) && "expand" in o) for (n in r = o.expand(r), delete t[a], r) n in t || (t[n] = r[n], e[n] = i); else e[a] = i
            }(d, c.opts.specialEasing); r < o; r++) if (a = fe.prefilters[r].call(c, t, d, c.opts)) return v(a.stop) && (C._queueHooks(c.elem, c.opts.queue).stop = a.stop.bind(a)), a;
            return C.map(d, pe, c), v(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), C.fx.timer(C.extend(l, {
                elem: t,
                anim: c,
                queue: c.opts.queue
            })), c
        }

        C.Animation = C.extend(fe, {
            tweeners: {
                "*": [function (t, e) {
                    var n = this.createTween(t, e);
                    return dt(n.elem, t, it.exec(e), n), n
                }]
            }, tweener: function (t, e) {
                v(t) ? (e = t, t = ["*"]) : t = t.match(F);
                for (var n, a = 0, i = t.length; a < i; a++) n = t[a], fe.tweeners[n] = fe.tweeners[n] || [], fe.tweeners[n].unshift(e)
            }, prefilters: [function (t, e, n) {
                var a, i, r, o, s, l, c, d, u = "width" in e || "height" in e, h = this, p = {}, f = t.style,
                    g = t.nodeType && ct(t), m = Q.get(t, "fxshow");
                for (a in n.queue || (null == (o = C._queueHooks(t, "fx")).unqueued && (o.unqueued = 0, s = o.empty.fire, o.empty.fire = function () {
                    o.unqueued || s()
                }), o.unqueued++, h.always((function () {
                    h.always((function () {
                        o.unqueued--, C.queue(t, "fx").length || o.empty.fire()
                    }))
                }))), e) if (i = e[a], le.test(i)) {
                    if (delete e[a], r = r || "toggle" === i, i === (g ? "hide" : "show")) {
                        if ("show" !== i || !m || void 0 === m[a]) continue;
                        g = !0
                    }
                    p[a] = m && m[a] || C.style(t, a)
                }
                if ((l = !C.isEmptyObject(e)) || !C.isEmptyObject(p)) for (a in u && 1 === t.nodeType && (n.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = m && m.display) && (c = Q.get(t, "display")), "none" === (d = C.css(t, "display")) && (c ? d = c : (pt([t], !0), c = t.style.display || c, d = C.css(t, "display"), pt([t]))), ("inline" === d || "inline-block" === d && null != c) && "none" === C.css(t, "float") && (l || (h.done((function () {
                    f.display = c
                })), null == c && (d = f.display, c = "none" === d ? "" : d)), f.display = "inline-block")), n.overflow && (f.overflow = "hidden", h.always((function () {
                    f.overflow = n.overflow[0], f.overflowX = n.overflow[1], f.overflowY = n.overflow[2]
                }))), l = !1, p) l || (m ? "hidden" in m && (g = m.hidden) : m = Q.access(t, "fxshow", {display: c}), r && (m.hidden = !g), g && pt([t], !0), h.done((function () {
                    for (a in g || pt([t]), Q.remove(t, "fxshow"), p) C.style(t, a, p[a])
                }))), l = pe(g ? m[a] : 0, a, h), a in m || (m[a] = l.start, g && (l.end = l.start, l.start = 0))
            }], prefilter: function (t, e) {
                e ? fe.prefilters.unshift(t) : fe.prefilters.push(t)
            }
        }), C.speed = function (t, e, n) {
            var a = t && "object" == typeof t ? C.extend({}, t) : {
                complete: n || !n && e || v(t) && t,
                duration: t,
                easing: n && e || e && !v(e) && e
            };
            return C.fx.off ? a.duration = 0 : "number" != typeof a.duration && (a.duration in C.fx.speeds ? a.duration = C.fx.speeds[a.duration] : a.duration = C.fx.speeds._default), null != a.queue && !0 !== a.queue || (a.queue = "fx"), a.old = a.complete, a.complete = function () {
                v(a.old) && a.old.call(this), a.queue && C.dequeue(this, a.queue)
            }, a
        }, C.fn.extend({
            fadeTo: function (t, e, n, a) {
                return this.filter(ct).css("opacity", 0).show().end().animate({opacity: e}, t, n, a)
            }, animate: function (t, e, n, a) {
                var i = C.isEmptyObject(t), r = C.speed(e, n, a), o = function () {
                    var e = fe(this, C.extend({}, t), r);
                    (i || Q.get(this, "finish")) && e.stop(!0)
                };
                return o.finish = o, i || !1 === r.queue ? this.each(o) : this.queue(r.queue, o)
            }, stop: function (t, e, n) {
                var a = function (t) {
                    var e = t.stop;
                    delete t.stop, e(n)
                };
                return "string" != typeof t && (n = e, e = t, t = void 0), e && this.queue(t || "fx", []), this.each((function () {
                    var e = !0, i = null != t && t + "queueHooks", r = C.timers, o = Q.get(this);
                    if (i) o[i] && o[i].stop && a(o[i]); else for (i in o) o[i] && o[i].stop && ce.test(i) && a(o[i]);
                    for (i = r.length; i--;) r[i].elem !== this || null != t && r[i].queue !== t || (r[i].anim.stop(n), e = !1, r.splice(i, 1));
                    !e && n || C.dequeue(this, t)
                }))
            }, finish: function (t) {
                return !1 !== t && (t = t || "fx"), this.each((function () {
                    var e, n = Q.get(this), a = n[t + "queue"], i = n[t + "queueHooks"], r = C.timers,
                        o = a ? a.length : 0;
                    for (n.finish = !0, C.queue(this, t, []), i && i.stop && i.stop.call(this, !0), e = r.length; e--;) r[e].elem === this && r[e].queue === t && (r[e].anim.stop(!0), r.splice(e, 1));
                    for (e = 0; e < o; e++) a[e] && a[e].finish && a[e].finish.call(this);
                    delete n.finish
                }))
            }
        }), C.each(["toggle", "show", "hide"], (function (t, e) {
            var n = C.fn[e];
            C.fn[e] = function (t, a, i) {
                return null == t || "boolean" == typeof t ? n.apply(this, arguments) : this.animate(he(e, !0), t, a, i)
            }
        })), C.each({
            slideDown: he("show"),
            slideUp: he("hide"),
            slideToggle: he("toggle"),
            fadeIn: {opacity: "show"},
            fadeOut: {opacity: "hide"},
            fadeToggle: {opacity: "toggle"}
        }, (function (t, e) {
            C.fn[t] = function (t, n, a) {
                return this.animate(e, t, n, a)
            }
        })), C.timers = [], C.fx.tick = function () {
            var t, e = 0, n = C.timers;
            for (oe = Date.now(); e < n.length; e++) (t = n[e])() || n[e] !== t || n.splice(e--, 1);
            n.length || C.fx.stop(), oe = void 0
        }, C.fx.timer = function (t) {
            C.timers.push(t), C.fx.start()
        }, C.fx.interval = 13, C.fx.start = function () {
            se || (se = !0, de())
        }, C.fx.stop = function () {
            se = null
        }, C.fx.speeds = {slow: 600, fast: 200, _default: 400}, C.fn.delay = function (t, e) {
            return t = C.fx && C.fx.speeds[t] || t, e = e || "fx", this.queue(e, (function (e, a) {
                var i = n.setTimeout(e, t);
                a.stop = function () {
                    n.clearTimeout(i)
                }
            }))
        }, function () {
            var t = y.createElement("input"), e = y.createElement("select").appendChild(y.createElement("option"));
            t.type = "checkbox", m.checkOn = "" !== t.value, m.optSelected = e.selected, (t = y.createElement("input")).value = "t", t.type = "radio", m.radioValue = "t" === t.value
        }();
        var ge, me = C.expr.attrHandle;
        C.fn.extend({
            attr: function (t, e) {
                return $(this, C.attr, t, e, arguments.length > 1)
            }, removeAttr: function (t) {
                return this.each((function () {
                    C.removeAttr(this, t)
                }))
            }
        }), C.extend({
            attr: function (t, e, n) {
                var a, i, r = t.nodeType;
                if (3 !== r && 8 !== r && 2 !== r) return void 0 === t.getAttribute ? C.prop(t, e, n) : (1 === r && C.isXMLDoc(t) || (i = C.attrHooks[e.toLowerCase()] || (C.expr.match.bool.test(e) ? ge : void 0)), void 0 !== n ? null === n ? void C.removeAttr(t, e) : i && "set" in i && void 0 !== (a = i.set(t, n, e)) ? a : (t.setAttribute(e, n + ""), n) : i && "get" in i && null !== (a = i.get(t, e)) ? a : null == (a = C.find.attr(t, e)) ? void 0 : a)
            }, attrHooks: {
                type: {
                    set: function (t, e) {
                        if (!m.radioValue && "radio" === e && I(t, "input")) {
                            var n = t.value;
                            return t.setAttribute("type", e), n && (t.value = n), e
                        }
                    }
                }
            }, removeAttr: function (t, e) {
                var n, a = 0, i = e && e.match(F);
                if (i && 1 === t.nodeType) for (; n = i[a++];) t.removeAttribute(n)
            }
        }), ge = {
            set: function (t, e, n) {
                return !1 === e ? C.removeAttr(t, n) : t.setAttribute(n, n), n
            }
        }, C.each(C.expr.match.bool.source.match(/\w+/g), (function (t, e) {
            var n = me[e] || C.find.attr;
            me[e] = function (t, e, a) {
                var i, r, o = e.toLowerCase();
                return a || (r = me[o], me[o] = i, i = null != n(t, e, a) ? o : null, me[o] = r), i
            }
        }));
        var ve = /^(?:input|select|textarea|button)$/i, be = /^(?:a|area)$/i;

        function ye(t) {
            return (t.match(F) || []).join(" ")
        }

        function xe(t) {
            return t.getAttribute && t.getAttribute("class") || ""
        }

        function _e(t) {
            return Array.isArray(t) ? t : "string" == typeof t && t.match(F) || []
        }

        C.fn.extend({
            prop: function (t, e) {
                return $(this, C.prop, t, e, arguments.length > 1)
            }, removeProp: function (t) {
                return this.each((function () {
                    delete this[C.propFix[t] || t]
                }))
            }
        }), C.extend({
            prop: function (t, e, n) {
                var a, i, r = t.nodeType;
                if (3 !== r && 8 !== r && 2 !== r) return 1 === r && C.isXMLDoc(t) || (e = C.propFix[e] || e, i = C.propHooks[e]), void 0 !== n ? i && "set" in i && void 0 !== (a = i.set(t, n, e)) ? a : t[e] = n : i && "get" in i && null !== (a = i.get(t, e)) ? a : t[e]
            }, propHooks: {
                tabIndex: {
                    get: function (t) {
                        var e = C.find.attr(t, "tabindex");
                        return e ? parseInt(e, 10) : ve.test(t.nodeName) || be.test(t.nodeName) && t.href ? 0 : -1
                    }
                }
            }, propFix: {for: "htmlFor", class: "className"}
        }), m.optSelected || (C.propHooks.selected = {
            get: function (t) {
                var e = t.parentNode;
                return e && e.parentNode && e.parentNode.selectedIndex, null
            }, set: function (t) {
                var e = t.parentNode;
                e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
            }
        }), C.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function () {
            C.propFix[this.toLowerCase()] = this
        })), C.fn.extend({
            addClass: function (t) {
                var e, n, a, i, r, o, s, l = 0;
                if (v(t)) return this.each((function (e) {
                    C(this).addClass(t.call(this, e, xe(this)))
                }));
                if ((e = _e(t)).length) for (; n = this[l++];) if (i = xe(n), a = 1 === n.nodeType && " " + ye(i) + " ") {
                    for (o = 0; r = e[o++];) a.indexOf(" " + r + " ") < 0 && (a += r + " ");
                    i !== (s = ye(a)) && n.setAttribute("class", s)
                }
                return this
            }, removeClass: function (t) {
                var e, n, a, i, r, o, s, l = 0;
                if (v(t)) return this.each((function (e) {
                    C(this).removeClass(t.call(this, e, xe(this)))
                }));
                if (!arguments.length) return this.attr("class", "");
                if ((e = _e(t)).length) for (; n = this[l++];) if (i = xe(n), a = 1 === n.nodeType && " " + ye(i) + " ") {
                    for (o = 0; r = e[o++];) for (; a.indexOf(" " + r + " ") > -1;) a = a.replace(" " + r + " ", " ");
                    i !== (s = ye(a)) && n.setAttribute("class", s)
                }
                return this
            }, toggleClass: function (t, e) {
                var n = typeof t, a = "string" === n || Array.isArray(t);
                return "boolean" == typeof e && a ? e ? this.addClass(t) : this.removeClass(t) : v(t) ? this.each((function (n) {
                    C(this).toggleClass(t.call(this, n, xe(this), e), e)
                })) : this.each((function () {
                    var e, i, r, o;
                    if (a) for (i = 0, r = C(this), o = _e(t); e = o[i++];) r.hasClass(e) ? r.removeClass(e) : r.addClass(e); else void 0 !== t && "boolean" !== n || ((e = xe(this)) && Q.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : Q.get(this, "__className__") || ""))
                }))
            }, hasClass: function (t) {
                var e, n, a = 0;
                for (e = " " + t + " "; n = this[a++];) if (1 === n.nodeType && (" " + ye(xe(n)) + " ").indexOf(e) > -1) return !0;
                return !1
            }
        });
        var we = /\r/g;
        C.fn.extend({
            val: function (t) {
                var e, n, a, i = this[0];
                return arguments.length ? (a = v(t), this.each((function (n) {
                    var i;
                    1 === this.nodeType && (null == (i = a ? t.call(this, n, C(this).val()) : t) ? i = "" : "number" == typeof i ? i += "" : Array.isArray(i) && (i = C.map(i, (function (t) {
                        return null == t ? "" : t + ""
                    }))), (e = C.valHooks[this.type] || C.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, i, "value") || (this.value = i))
                }))) : i ? (e = C.valHooks[i.type] || C.valHooks[i.nodeName.toLowerCase()]) && "get" in e && void 0 !== (n = e.get(i, "value")) ? n : "string" == typeof (n = i.value) ? n.replace(we, "") : null == n ? "" : n : void 0
            }
        }), C.extend({
            valHooks: {
                option: {
                    get: function (t) {
                        var e = C.find.attr(t, "value");
                        return null != e ? e : ye(C.text(t))
                    }
                }, select: {
                    get: function (t) {
                        var e, n, a, i = t.options, r = t.selectedIndex, o = "select-one" === t.type, s = o ? null : [],
                            l = o ? r + 1 : i.length;
                        for (a = r < 0 ? l : o ? r : 0; a < l; a++) if (((n = i[a]).selected || a === r) && !n.disabled && (!n.parentNode.disabled || !I(n.parentNode, "optgroup"))) {
                            if (e = C(n).val(), o) return e;
                            s.push(e)
                        }
                        return s
                    }, set: function (t, e) {
                        for (var n, a, i = t.options, r = C.makeArray(e), o = i.length; o--;) ((a = i[o]).selected = C.inArray(C.valHooks.option.get(a), r) > -1) && (n = !0);
                        return n || (t.selectedIndex = -1), r
                    }
                }
            }
        }), C.each(["radio", "checkbox"], (function () {
            C.valHooks[this] = {
                set: function (t, e) {
                    if (Array.isArray(e)) return t.checked = C.inArray(C(t).val(), e) > -1
                }
            }, m.checkOn || (C.valHooks[this].get = function (t) {
                return null === t.getAttribute("value") ? "on" : t.value
            })
        })), m.focusin = "onfocusin" in n;
        var Se = /^(?:focusinfocus|focusoutblur)$/, Ce = function (t) {
            t.stopPropagation()
        };
        C.extend(C.event, {
            trigger: function (t, e, a, i) {
                var r, o, s, l, c, d, u, h, f = [a || y], g = p.call(t, "type") ? t.type : t,
                    m = p.call(t, "namespace") ? t.namespace.split(".") : [];
                if (o = h = s = a = a || y, 3 !== a.nodeType && 8 !== a.nodeType && !Se.test(g + C.event.triggered) && (g.indexOf(".") > -1 && (m = g.split("."), g = m.shift(), m.sort()), c = g.indexOf(":") < 0 && "on" + g, (t = t[C.expando] ? t : new C.Event(g, "object" == typeof t && t)).isTrigger = i ? 2 : 3, t.namespace = m.join("."), t.rnamespace = t.namespace ? new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, t.result = void 0, t.target || (t.target = a), e = null == e ? [t] : C.makeArray(e, [t]), u = C.event.special[g] || {}, i || !u.trigger || !1 !== u.trigger.apply(a, e))) {
                    if (!i && !u.noBubble && !b(a)) {
                        for (l = u.delegateType || g, Se.test(l + g) || (o = o.parentNode); o; o = o.parentNode) f.push(o), s = o;
                        s === (a.ownerDocument || y) && f.push(s.defaultView || s.parentWindow || n)
                    }
                    for (r = 0; (o = f[r++]) && !t.isPropagationStopped();) h = o, t.type = r > 1 ? l : u.bindType || g, (d = (Q.get(o, "events") || Object.create(null))[t.type] && Q.get(o, "handle")) && d.apply(o, e), (d = c && o[c]) && d.apply && Z(o) && (t.result = d.apply(o, e), !1 === t.result && t.preventDefault());
                    return t.type = g, i || t.isDefaultPrevented() || u._default && !1 !== u._default.apply(f.pop(), e) || !Z(a) || c && v(a[g]) && !b(a) && ((s = a[c]) && (a[c] = null), C.event.triggered = g, t.isPropagationStopped() && h.addEventListener(g, Ce), a[g](), t.isPropagationStopped() && h.removeEventListener(g, Ce), C.event.triggered = void 0, s && (a[c] = s)), t.result
                }
            }, simulate: function (t, e, n) {
                var a = C.extend(new C.Event, n, {type: t, isSimulated: !0});
                C.event.trigger(a, null, e)
            }
        }), C.fn.extend({
            trigger: function (t, e) {
                return this.each((function () {
                    C.event.trigger(t, e, this)
                }))
            }, triggerHandler: function (t, e) {
                var n = this[0];
                if (n) return C.event.trigger(t, e, n, !0)
            }
        }), m.focusin || C.each({focus: "focusin", blur: "focusout"}, (function (t, e) {
            var n = function (t) {
                C.event.simulate(e, t.target, C.event.fix(t))
            };
            C.event.special[e] = {
                setup: function () {
                    var a = this.ownerDocument || this.document || this, i = Q.access(a, e);
                    i || a.addEventListener(t, n, !0), Q.access(a, e, (i || 0) + 1)
                }, teardown: function () {
                    var a = this.ownerDocument || this.document || this, i = Q.access(a, e) - 1;
                    i ? Q.access(a, e, i) : (a.removeEventListener(t, n, !0), Q.remove(a, e))
                }
            }
        }));
        var ke = n.location, De = {guid: Date.now()}, Te = /\?/;
        C.parseXML = function (t) {
            var e;
            if (!t || "string" != typeof t) return null;
            try {
                e = (new n.DOMParser).parseFromString(t, "text/xml")
            } catch (t) {
                e = void 0
            }
            return e && !e.getElementsByTagName("parsererror").length || C.error("Invalid XML: " + t), e
        };
        var Ee = /\[\]$/, Ae = /\r?\n/g, Ie = /^(?:submit|button|image|reset|file)$/i,
            Me = /^(?:input|select|textarea|keygen)/i;

        function Re(t, e, n, a) {
            var i;
            if (Array.isArray(e)) C.each(e, (function (e, i) {
                n || Ee.test(t) ? a(t, i) : Re(t + "[" + ("object" == typeof i && null != i ? e : "") + "]", i, n, a)
            })); else if (n || "object" !== w(e)) a(t, e); else for (i in e) Re(t + "[" + i + "]", e[i], n, a)
        }

        C.param = function (t, e) {
            var n, a = [], i = function (t, e) {
                var n = v(e) ? e() : e;
                a[a.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == n ? "" : n)
            };
            if (null == t) return "";
            if (Array.isArray(t) || t.jquery && !C.isPlainObject(t)) C.each(t, (function () {
                i(this.name, this.value)
            })); else for (n in t) Re(n, t[n], e, i);
            return a.join("&")
        }, C.fn.extend({
            serialize: function () {
                return C.param(this.serializeArray())
            }, serializeArray: function () {
                return this.map((function () {
                    var t = C.prop(this, "elements");
                    return t ? C.makeArray(t) : this
                })).filter((function () {
                    var t = this.type;
                    return this.name && !C(this).is(":disabled") && Me.test(this.nodeName) && !Ie.test(t) && (this.checked || !mt.test(t))
                })).map((function (t, e) {
                    var n = C(this).val();
                    return null == n ? null : Array.isArray(n) ? C.map(n, (function (t) {
                        return {name: e.name, value: t.replace(Ae, "\r\n")}
                    })) : {name: e.name, value: n.replace(Ae, "\r\n")}
                })).get()
            }
        });
        var Pe = /%20/g, Oe = /#.*$/, je = /([?&])_=[^&]*/, Ne = /^(.*?):[ \t]*([^\r\n]*)$/gm, Le = /^(?:GET|HEAD)$/,
            Fe = /^\/\//, He = {}, Be = {}, qe = "*/".concat("*"), ze = y.createElement("a");

        function We(t) {
            return function (e, n) {
                "string" != typeof e && (n = e, e = "*");
                var a, i = 0, r = e.toLowerCase().match(F) || [];
                if (v(n)) for (; a = r[i++];) "+" === a[0] ? (a = a.slice(1) || "*", (t[a] = t[a] || []).unshift(n)) : (t[a] = t[a] || []).push(n)
            }
        }

        function Ve(t, e, n, a) {
            var i = {}, r = t === Be;

            function o(s) {
                var l;
                return i[s] = !0, C.each(t[s] || [], (function (t, s) {
                    var c = s(e, n, a);
                    return "string" != typeof c || r || i[c] ? r ? !(l = c) : void 0 : (e.dataTypes.unshift(c), o(c), !1)
                })), l
            }

            return o(e.dataTypes[0]) || !i["*"] && o("*")
        }

        function $e(t, e) {
            var n, a, i = C.ajaxSettings.flatOptions || {};
            for (n in e) void 0 !== e[n] && ((i[n] ? t : a || (a = {}))[n] = e[n]);
            return a && C.extend(!0, t, a), t
        }

        ze.href = ke.href, C.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: ke.href,
                type: "GET",
                isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(ke.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": qe,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/},
                responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
                converters: {"* text": String, "text html": !0, "text json": JSON.parse, "text xml": C.parseXML},
                flatOptions: {url: !0, context: !0}
            },
            ajaxSetup: function (t, e) {
                return e ? $e($e(t, C.ajaxSettings), e) : $e(C.ajaxSettings, t)
            },
            ajaxPrefilter: We(He),
            ajaxTransport: We(Be),
            ajax: function (t, e) {
                "object" == typeof t && (e = t, t = void 0), e = e || {};
                var a, i, r, o, s, l, c, d, u, h, p = C.ajaxSetup({}, e), f = p.context || p,
                    g = p.context && (f.nodeType || f.jquery) ? C(f) : C.event, m = C.Deferred(),
                    v = C.Callbacks("once memory"), b = p.statusCode || {}, x = {}, _ = {}, w = "canceled", S = {
                        readyState: 0, getResponseHeader: function (t) {
                            var e;
                            if (c) {
                                if (!o) for (o = {}; e = Ne.exec(r);) o[e[1].toLowerCase() + " "] = (o[e[1].toLowerCase() + " "] || []).concat(e[2]);
                                e = o[t.toLowerCase() + " "]
                            }
                            return null == e ? null : e.join(", ")
                        }, getAllResponseHeaders: function () {
                            return c ? r : null
                        }, setRequestHeader: function (t, e) {
                            return null == c && (t = _[t.toLowerCase()] = _[t.toLowerCase()] || t, x[t] = e), this
                        }, overrideMimeType: function (t) {
                            return null == c && (p.mimeType = t), this
                        }, statusCode: function (t) {
                            var e;
                            if (t) if (c) S.always(t[S.status]); else for (e in t) b[e] = [b[e], t[e]];
                            return this
                        }, abort: function (t) {
                            var e = t || w;
                            return a && a.abort(e), k(0, e), this
                        }
                    };
                if (m.promise(S), p.url = ((t || p.url || ke.href) + "").replace(Fe, ke.protocol + "//"), p.type = e.method || e.type || p.method || p.type, p.dataTypes = (p.dataType || "*").toLowerCase().match(F) || [""], null == p.crossDomain) {
                    l = y.createElement("a");
                    try {
                        l.href = p.url, l.href = l.href, p.crossDomain = ze.protocol + "//" + ze.host != l.protocol + "//" + l.host
                    } catch (t) {
                        p.crossDomain = !0
                    }
                }
                if (p.data && p.processData && "string" != typeof p.data && (p.data = C.param(p.data, p.traditional)), Ve(He, p, e, S), c) return S;
                for (u in (d = C.event && p.global) && 0 == C.active++ && C.event.trigger("ajaxStart"), p.type = p.type.toUpperCase(), p.hasContent = !Le.test(p.type), i = p.url.replace(Oe, ""), p.hasContent ? p.data && p.processData && 0 === (p.contentType || "").indexOf("application/x-www-form-urlencoded") && (p.data = p.data.replace(Pe, "+")) : (h = p.url.slice(i.length), p.data && (p.processData || "string" == typeof p.data) && (i += (Te.test(i) ? "&" : "?") + p.data, delete p.data), !1 === p.cache && (i = i.replace(je, "$1"), h = (Te.test(i) ? "&" : "?") + "_=" + De.guid++ + h), p.url = i + h), p.ifModified && (C.lastModified[i] && S.setRequestHeader("If-Modified-Since", C.lastModified[i]), C.etag[i] && S.setRequestHeader("If-None-Match", C.etag[i])), (p.data && p.hasContent && !1 !== p.contentType || e.contentType) && S.setRequestHeader("Content-Type", p.contentType), S.setRequestHeader("Accept", p.dataTypes[0] && p.accepts[p.dataTypes[0]] ? p.accepts[p.dataTypes[0]] + ("*" !== p.dataTypes[0] ? ", " + qe + "; q=0.01" : "") : p.accepts["*"]), p.headers) S.setRequestHeader(u, p.headers[u]);
                if (p.beforeSend && (!1 === p.beforeSend.call(f, S, p) || c)) return S.abort();
                if (w = "abort", v.add(p.complete), S.done(p.success), S.fail(p.error), a = Ve(Be, p, e, S)) {
                    if (S.readyState = 1, d && g.trigger("ajaxSend", [S, p]), c) return S;
                    p.async && p.timeout > 0 && (s = n.setTimeout((function () {
                        S.abort("timeout")
                    }), p.timeout));
                    try {
                        c = !1, a.send(x, k)
                    } catch (t) {
                        if (c) throw t;
                        k(-1, t)
                    }
                } else k(-1, "No Transport");

                function k(t, e, o, l) {
                    var u, h, y, x, _, w = e;
                    c || (c = !0, s && n.clearTimeout(s), a = void 0, r = l || "", S.readyState = t > 0 ? 4 : 0, u = t >= 200 && t < 300 || 304 === t, o && (x = function (t, e, n) {
                        for (var a, i, r, o, s = t.contents, l = t.dataTypes; "*" === l[0];) l.shift(), void 0 === a && (a = t.mimeType || e.getResponseHeader("Content-Type"));
                        if (a) for (i in s) if (s[i] && s[i].test(a)) {
                            l.unshift(i);
                            break
                        }
                        if (l[0] in n) r = l[0]; else {
                            for (i in n) {
                                if (!l[0] || t.converters[i + " " + l[0]]) {
                                    r = i;
                                    break
                                }
                                o || (o = i)
                            }
                            r = r || o
                        }
                        if (r) return r !== l[0] && l.unshift(r), n[r]
                    }(p, S, o)), !u && C.inArray("script", p.dataTypes) > -1 && (p.converters["text script"] = function () {
                    }), x = function (t, e, n, a) {
                        var i, r, o, s, l, c = {}, d = t.dataTypes.slice();
                        if (d[1]) for (o in t.converters) c[o.toLowerCase()] = t.converters[o];
                        for (r = d.shift(); r;) if (t.responseFields[r] && (n[t.responseFields[r]] = e), !l && a && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = r, r = d.shift()) if ("*" === r) r = l; else if ("*" !== l && l !== r) {
                            if (!(o = c[l + " " + r] || c["* " + r])) for (i in c) if ((s = i.split(" "))[1] === r && (o = c[l + " " + s[0]] || c["* " + s[0]])) {
                                !0 === o ? o = c[i] : !0 !== c[i] && (r = s[0], d.unshift(s[1]));
                                break
                            }
                            if (!0 !== o) if (o && t.throws) e = o(e); else try {
                                e = o(e)
                            } catch (t) {
                                return {state: "parsererror", error: o ? t : "No conversion from " + l + " to " + r}
                            }
                        }
                        return {state: "success", data: e}
                    }(p, x, S, u), u ? (p.ifModified && ((_ = S.getResponseHeader("Last-Modified")) && (C.lastModified[i] = _), (_ = S.getResponseHeader("etag")) && (C.etag[i] = _)), 204 === t || "HEAD" === p.type ? w = "nocontent" : 304 === t ? w = "notmodified" : (w = x.state, h = x.data, u = !(y = x.error))) : (y = w, !t && w || (w = "error", t < 0 && (t = 0))), S.status = t, S.statusText = (e || w) + "", u ? m.resolveWith(f, [h, w, S]) : m.rejectWith(f, [S, w, y]), S.statusCode(b), b = void 0, d && g.trigger(u ? "ajaxSuccess" : "ajaxError", [S, p, u ? h : y]), v.fireWith(f, [S, w]), d && (g.trigger("ajaxComplete", [S, p]), --C.active || C.event.trigger("ajaxStop")))
                }

                return S
            },
            getJSON: function (t, e, n) {
                return C.get(t, e, n, "json")
            },
            getScript: function (t, e) {
                return C.get(t, void 0, e, "script")
            }
        }), C.each(["get", "post"], (function (t, e) {
            C[e] = function (t, n, a, i) {
                return v(n) && (i = i || a, a = n, n = void 0), C.ajax(C.extend({
                    url: t,
                    type: e,
                    dataType: i,
                    data: n,
                    success: a
                }, C.isPlainObject(t) && t))
            }
        })), C.ajaxPrefilter((function (t) {
            var e;
            for (e in t.headers) "content-type" === e.toLowerCase() && (t.contentType = t.headers[e] || "")
        })), C._evalUrl = function (t, e, n) {
            return C.ajax({
                url: t,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                converters: {
                    "text script": function () {
                    }
                },
                dataFilter: function (t) {
                    C.globalEval(t, e, n)
                }
            })
        }, C.fn.extend({
            wrapAll: function (t) {
                var e;
                return this[0] && (v(t) && (t = t.call(this[0])), e = C(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map((function () {
                    for (var t = this; t.firstElementChild;) t = t.firstElementChild;
                    return t
                })).append(this)), this
            }, wrapInner: function (t) {
                return v(t) ? this.each((function (e) {
                    C(this).wrapInner(t.call(this, e))
                })) : this.each((function () {
                    var e = C(this), n = e.contents();
                    n.length ? n.wrapAll(t) : e.append(t)
                }))
            }, wrap: function (t) {
                var e = v(t);
                return this.each((function (n) {
                    C(this).wrapAll(e ? t.call(this, n) : t)
                }))
            }, unwrap: function (t) {
                return this.parent(t).not("body").each((function () {
                    C(this).replaceWith(this.childNodes)
                })), this
            }
        }), C.expr.pseudos.hidden = function (t) {
            return !C.expr.pseudos.visible(t)
        }, C.expr.pseudos.visible = function (t) {
            return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
        }, C.ajaxSettings.xhr = function () {
            try {
                return new n.XMLHttpRequest
            } catch (t) {
            }
        };
        var Ye = {0: 200, 1223: 204}, Ue = C.ajaxSettings.xhr();
        m.cors = !!Ue && "withCredentials" in Ue, m.ajax = Ue = !!Ue, C.ajaxTransport((function (t) {
            var e, a;
            if (m.cors || Ue && !t.crossDomain) return {
                send: function (i, r) {
                    var o, s = t.xhr();
                    if (s.open(t.type, t.url, t.async, t.username, t.password), t.xhrFields) for (o in t.xhrFields) s[o] = t.xhrFields[o];
                    for (o in t.mimeType && s.overrideMimeType && s.overrideMimeType(t.mimeType), t.crossDomain || i["X-Requested-With"] || (i["X-Requested-With"] = "XMLHttpRequest"), i) s.setRequestHeader(o, i[o]);
                    e = function (t) {
                        return function () {
                            e && (e = a = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === t ? s.abort() : "error" === t ? "number" != typeof s.status ? r(0, "error") : r(s.status, s.statusText) : r(Ye[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {binary: s.response} : {text: s.responseText}, s.getAllResponseHeaders()))
                        }
                    }, s.onload = e(), a = s.onerror = s.ontimeout = e("error"), void 0 !== s.onabort ? s.onabort = a : s.onreadystatechange = function () {
                        4 === s.readyState && n.setTimeout((function () {
                            e && a()
                        }))
                    }, e = e("abort");
                    try {
                        s.send(t.hasContent && t.data || null)
                    } catch (t) {
                        if (e) throw t
                    }
                }, abort: function () {
                    e && e()
                }
            }
        })), C.ajaxPrefilter((function (t) {
            t.crossDomain && (t.contents.script = !1)
        })), C.ajaxSetup({
            accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
            contents: {script: /\b(?:java|ecma)script\b/},
            converters: {
                "text script": function (t) {
                    return C.globalEval(t), t
                }
            }
        }), C.ajaxPrefilter("script", (function (t) {
            void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
        })), C.ajaxTransport("script", (function (t) {
            var e, n;
            if (t.crossDomain || t.scriptAttrs) return {
                send: function (a, i) {
                    e = C("<script>").attr(t.scriptAttrs || {}).prop({
                        charset: t.scriptCharset,
                        src: t.url
                    }).on("load error", n = function (t) {
                        e.remove(), n = null, t && i("error" === t.type ? 404 : 200, t.type)
                    }), y.head.appendChild(e[0])
                }, abort: function () {
                    n && n()
                }
            }
        }));
        var Ge, Xe = [], Ze = /(=)\?(?=&|$)|\?\?/;
        C.ajaxSetup({
            jsonp: "callback", jsonpCallback: function () {
                var t = Xe.pop() || C.expando + "_" + De.guid++;
                return this[t] = !0, t
            }
        }), C.ajaxPrefilter("json jsonp", (function (t, e, a) {
            var i, r, o,
                s = !1 !== t.jsonp && (Ze.test(t.url) ? "url" : "string" == typeof t.data && 0 === (t.contentType || "").indexOf("application/x-www-form-urlencoded") && Ze.test(t.data) && "data");
            if (s || "jsonp" === t.dataTypes[0]) return i = t.jsonpCallback = v(t.jsonpCallback) ? t.jsonpCallback() : t.jsonpCallback, s ? t[s] = t[s].replace(Ze, "$1" + i) : !1 !== t.jsonp && (t.url += (Te.test(t.url) ? "&" : "?") + t.jsonp + "=" + i), t.converters["script json"] = function () {
                return o || C.error(i + " was not called"), o[0]
            }, t.dataTypes[0] = "json", r = n[i], n[i] = function () {
                o = arguments
            }, a.always((function () {
                void 0 === r ? C(n).removeProp(i) : n[i] = r, t[i] && (t.jsonpCallback = e.jsonpCallback, Xe.push(i)), o && v(r) && r(o[0]), o = r = void 0
            })), "script"
        })), m.createHTMLDocument = ((Ge = y.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === Ge.childNodes.length), C.parseHTML = function (t, e, n) {
            return "string" != typeof t ? [] : ("boolean" == typeof e && (n = e, e = !1), e || (m.createHTMLDocument ? ((a = (e = y.implementation.createHTMLDocument("")).createElement("base")).href = y.location.href, e.head.appendChild(a)) : e = y), r = !n && [], (i = M.exec(t)) ? [e.createElement(i[1])] : (i = St([t], e, r), r && r.length && C(r).remove(), C.merge([], i.childNodes)));
            var a, i, r
        }, C.fn.load = function (t, e, n) {
            var a, i, r, o = this, s = t.indexOf(" ");
            return s > -1 && (a = ye(t.slice(s)), t = t.slice(0, s)), v(e) ? (n = e, e = void 0) : e && "object" == typeof e && (i = "POST"), o.length > 0 && C.ajax({
                url: t,
                type: i || "GET",
                dataType: "html",
                data: e
            }).done((function (t) {
                r = arguments, o.html(a ? C("<div>").append(C.parseHTML(t)).find(a) : t)
            })).always(n && function (t, e) {
                o.each((function () {
                    n.apply(this, r || [t.responseText, e, t])
                }))
            }), this
        }, C.expr.pseudos.animated = function (t) {
            return C.grep(C.timers, (function (e) {
                return t === e.elem
            })).length
        }, C.offset = {
            setOffset: function (t, e, n) {
                var a, i, r, o, s, l, c = C.css(t, "position"), d = C(t), u = {};
                "static" === c && (t.style.position = "relative"), s = d.offset(), r = C.css(t, "top"), l = C.css(t, "left"), ("absolute" === c || "fixed" === c) && (r + l).indexOf("auto") > -1 ? (o = (a = d.position()).top, i = a.left) : (o = parseFloat(r) || 0, i = parseFloat(l) || 0), v(e) && (e = e.call(t, n, C.extend({}, s))), null != e.top && (u.top = e.top - s.top + o), null != e.left && (u.left = e.left - s.left + i), "using" in e ? e.using.call(t, u) : ("number" == typeof u.top && (u.top += "px"), "number" == typeof u.left && (u.left += "px"), d.css(u))
            }
        }, C.fn.extend({
            offset: function (t) {
                if (arguments.length) return void 0 === t ? this : this.each((function (e) {
                    C.offset.setOffset(this, t, e)
                }));
                var e, n, a = this[0];
                return a ? a.getClientRects().length ? (e = a.getBoundingClientRect(), n = a.ownerDocument.defaultView, {
                    top: e.top + n.pageYOffset,
                    left: e.left + n.pageXOffset
                }) : {top: 0, left: 0} : void 0
            }, position: function () {
                if (this[0]) {
                    var t, e, n, a = this[0], i = {top: 0, left: 0};
                    if ("fixed" === C.css(a, "position")) e = a.getBoundingClientRect(); else {
                        for (e = this.offset(), n = a.ownerDocument, t = a.offsetParent || n.documentElement; t && (t === n.body || t === n.documentElement) && "static" === C.css(t, "position");) t = t.parentNode;
                        t && t !== a && 1 === t.nodeType && ((i = C(t).offset()).top += C.css(t, "borderTopWidth", !0), i.left += C.css(t, "borderLeftWidth", !0))
                    }
                    return {
                        top: e.top - i.top - C.css(a, "marginTop", !0),
                        left: e.left - i.left - C.css(a, "marginLeft", !0)
                    }
                }
            }, offsetParent: function () {
                return this.map((function () {
                    for (var t = this.offsetParent; t && "static" === C.css(t, "position");) t = t.offsetParent;
                    return t || ot
                }))
            }
        }), C.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, (function (t, e) {
            var n = "pageYOffset" === e;
            C.fn[t] = function (a) {
                return $(this, (function (t, a, i) {
                    var r;
                    if (b(t) ? r = t : 9 === t.nodeType && (r = t.defaultView), void 0 === i) return r ? r[e] : t[a];
                    r ? r.scrollTo(n ? r.pageXOffset : i, n ? i : r.pageYOffset) : t[a] = i
                }), t, a, arguments.length)
            }
        })), C.each(["top", "left"], (function (t, e) {
            C.cssHooks[e] = Ut(m.pixelPosition, (function (t, n) {
                if (n) return n = Yt(t, e), zt.test(n) ? C(t).position()[e] + "px" : n
            }))
        })), C.each({Height: "height", Width: "width"}, (function (t, e) {
            C.each({padding: "inner" + t, content: e, "": "outer" + t}, (function (n, a) {
                C.fn[a] = function (i, r) {
                    var o = arguments.length && (n || "boolean" != typeof i),
                        s = n || (!0 === i || !0 === r ? "margin" : "border");
                    return $(this, (function (e, n, i) {
                        var r;
                        return b(e) ? 0 === a.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (r = e.documentElement, Math.max(e.body["scroll" + t], r["scroll" + t], e.body["offset" + t], r["offset" + t], r["client" + t])) : void 0 === i ? C.css(e, n, s) : C.style(e, n, i, s)
                    }), e, o ? i : void 0, o)
                }
            }))
        })), C.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function (t, e) {
            C.fn[e] = function (t) {
                return this.on(e, t)
            }
        })), C.fn.extend({
            bind: function (t, e, n) {
                return this.on(t, null, e, n)
            }, unbind: function (t, e) {
                return this.off(t, null, e)
            }, delegate: function (t, e, n, a) {
                return this.on(e, t, n, a)
            }, undelegate: function (t, e, n) {
                return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", n)
            }, hover: function (t, e) {
                return this.mouseenter(t).mouseleave(e || t)
            }
        }), C.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function (t, e) {
            C.fn[e] = function (t, n) {
                return arguments.length > 0 ? this.on(e, null, t, n) : this.trigger(e)
            }
        }));
        var Ke = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        C.proxy = function (t, e) {
            var n, a, i;
            if ("string" == typeof e && (n = t[e], e = t, t = n), v(t)) return a = s.call(arguments, 2), (i = function () {
                return t.apply(e || this, a.concat(s.call(arguments)))
            }).guid = t.guid = t.guid || C.guid++, i
        }, C.holdReady = function (t) {
            t ? C.readyWait++ : C.ready(!0)
        }, C.isArray = Array.isArray, C.parseJSON = JSON.parse, C.nodeName = I, C.isFunction = v, C.isWindow = b, C.camelCase = X, C.type = w, C.now = Date.now, C.isNumeric = function (t) {
            var e = C.type(t);
            return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
        }, C.trim = function (t) {
            return null == t ? "" : (t + "").replace(Ke, "")
        }, void 0 === (a = function () {
            return C
        }.apply(e, [])) || (t.exports = a);
        var Qe = n.jQuery, Je = n.$;
        return C.noConflict = function (t) {
            return n.$ === C && (n.$ = Je), t && n.jQuery === C && (n.jQuery = Qe), C
        }, void 0 === i && (n.jQuery = n.$ = C), C
    }))
}, function (t, e, n) {
    !function (t, e, n) {
        "use strict";

        function a(t) {
            return t && "object" == typeof t && "default" in t ? t : {default: t}
        }

        var i = a(e), r = a(n);

        function o(t, e) {
            for (var n = 0; n < e.length; n++) {
                var a = e[n];
                a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
            }
        }

        function s(t, e, n) {
            return e && o(t.prototype, e), n && o(t, n), t
        }

        function l() {
            return (l = Object.assign || function (t) {
                for (var e = 1; e < arguments.length; e++) {
                    var n = arguments[e];
                    for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
                }
                return t
            }).apply(this, arguments)
        }

        function c(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
        }

        var d = "transitionend", u = 1e6, h = 1e3;

        function p(t) {
            return null == t ? "" + t : {}.toString.call(t).match(/\s([a-z]+)/i)[1].toLowerCase()
        }

        function f() {
            return {
                bindType: d, delegateType: d, handle: function (t) {
                    if (i.default(t.target).is(this)) return t.handleObj.handler.apply(this, arguments)
                }
            }
        }

        function g(t) {
            var e = this, n = !1;
            return i.default(this).one(v.TRANSITION_END, (function () {
                n = !0
            })), setTimeout((function () {
                n || v.triggerTransitionEnd(e)
            }), t), this
        }

        function m() {
            i.default.fn.emulateTransitionEnd = g, i.default.event.special[v.TRANSITION_END] = f()
        }

        var v = {
            TRANSITION_END: "bsTransitionEnd", getUID: function (t) {
                do {
                    t += ~~(Math.random() * u)
                } while (document.getElementById(t));
                return t
            }, getSelectorFromElement: function (t) {
                var e = t.getAttribute("data-target");
                if (!e || "#" === e) {
                    var n = t.getAttribute("href");
                    e = n && "#" !== n ? n.trim() : ""
                }
                try {
                    return document.querySelector(e) ? e : null
                } catch (t) {
                    return null
                }
            }, getTransitionDurationFromElement: function (t) {
                if (!t) return 0;
                var e = i.default(t).css("transition-duration"), n = i.default(t).css("transition-delay"),
                    a = parseFloat(e), r = parseFloat(n);
                return a || r ? (e = e.split(",")[0], n = n.split(",")[0], (parseFloat(e) + parseFloat(n)) * h) : 0
            }, reflow: function (t) {
                return t.offsetHeight
            }, triggerTransitionEnd: function (t) {
                i.default(t).trigger(d)
            }, supportsTransitionEnd: function () {
                return Boolean(d)
            }, isElement: function (t) {
                return (t[0] || t).nodeType
            }, typeCheckConfig: function (t, e, n) {
                for (var a in n) if (Object.prototype.hasOwnProperty.call(n, a)) {
                    var i = n[a], r = e[a], o = r && v.isElement(r) ? "element" : p(r);
                    if (!new RegExp(i).test(o)) throw new Error(t.toUpperCase() + ': Option "' + a + '" provided type "' + o + '" but expected type "' + i + '".')
                }
            }, findShadowRoot: function (t) {
                if (!document.documentElement.attachShadow) return null;
                if ("function" == typeof t.getRootNode) {
                    var e = t.getRootNode();
                    return e instanceof ShadowRoot ? e : null
                }
                return t instanceof ShadowRoot ? t : t.parentNode ? v.findShadowRoot(t.parentNode) : null
            }, jQueryDetection: function () {
                if (void 0 === i.default) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
                var t = i.default.fn.jquery.split(" ")[0].split("."), e = 1, n = 2, a = 9, r = 1, o = 4;
                if (t[0] < n && t[1] < a || t[0] === e && t[1] === a && t[2] < r || t[0] >= o) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")
            }
        };
        v.jQueryDetection(), m();
        var b = "alert", y = "4.5.3", x = "bs.alert", _ = "." + x, w = ".data-api", S = i.default.fn[b],
            C = '[data-dismiss="alert"]', k = "close" + _, D = "closed" + _, T = "click" + _ + w, E = "alert",
            A = "fade", I = "show", M = function () {
                function t(t) {
                    this._element = t
                }

                var e = t.prototype;
                return e.close = function (t) {
                    var e = this._element;
                    t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e)
                }, e.dispose = function () {
                    i.default.removeData(this._element, x), this._element = null
                }, e._getRootElement = function (t) {
                    var e = v.getSelectorFromElement(t), n = !1;
                    return e && (n = document.querySelector(e)), n || (n = i.default(t).closest("." + E)[0]), n
                }, e._triggerCloseEvent = function (t) {
                    var e = i.default.Event(k);
                    return i.default(t).trigger(e), e
                }, e._removeElement = function (t) {
                    var e = this;
                    if (i.default(t).removeClass(I), i.default(t).hasClass(A)) {
                        var n = v.getTransitionDurationFromElement(t);
                        i.default(t).one(v.TRANSITION_END, (function (n) {
                            return e._destroyElement(t, n)
                        })).emulateTransitionEnd(n)
                    } else this._destroyElement(t)
                }, e._destroyElement = function (t) {
                    i.default(t).detach().trigger(D).remove()
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this), a = n.data(x);
                        a || (a = new t(this), n.data(x, a)), "close" === e && a[e](this)
                    }))
                }, t._handleDismiss = function (t) {
                    return function (e) {
                        e && e.preventDefault(), t.close(this)
                    }
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return y
                    }
                }]), t
            }();
        i.default(document).on(T, C, M._handleDismiss(new M)), i.default.fn[b] = M._jQueryInterface, i.default.fn[b].Constructor = M, i.default.fn[b].noConflict = function () {
            return i.default.fn[b] = S, M._jQueryInterface
        };
        var R = "button", P = "4.5.3", O = "bs.button", j = "." + O, N = ".data-api", L = i.default.fn[R], F = "active",
            H = "btn", B = "focus", q = '[data-toggle^="button"]', z = '[data-toggle="buttons"]',
            W = '[data-toggle="button"]', V = '[data-toggle="buttons"] .btn', $ = 'input:not([type="hidden"])',
            Y = ".active", U = ".btn", G = "click" + j + N, X = "focus" + j + N + " blur" + j + N, Z = "load" + j + N,
            K = function () {
                function t(t) {
                    this._element = t, this.shouldAvoidTriggerChange = !1
                }

                var e = t.prototype;
                return e.toggle = function () {
                    var t = !0, e = !0, n = i.default(this._element).closest(z)[0];
                    if (n) {
                        var a = this._element.querySelector($);
                        if (a) {
                            if ("radio" === a.type) if (a.checked && this._element.classList.contains(F)) t = !1; else {
                                var r = n.querySelector(Y);
                                r && i.default(r).removeClass(F)
                            }
                            t && ("checkbox" !== a.type && "radio" !== a.type || (a.checked = !this._element.classList.contains(F)), this.shouldAvoidTriggerChange || i.default(a).trigger("change")), a.focus(), e = !1
                        }
                    }
                    this._element.hasAttribute("disabled") || this._element.classList.contains("disabled") || (e && this._element.setAttribute("aria-pressed", !this._element.classList.contains(F)), t && i.default(this._element).toggleClass(F))
                }, e.dispose = function () {
                    i.default.removeData(this._element, O), this._element = null
                }, t._jQueryInterface = function (e, n) {
                    return this.each((function () {
                        var a = i.default(this), r = a.data(O);
                        r || (r = new t(this), a.data(O, r)), r.shouldAvoidTriggerChange = n, "toggle" === e && r[e]()
                    }))
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return P
                    }
                }]), t
            }();
        i.default(document).on(G, q, (function (t) {
            var e = t.target, n = e;
            if (i.default(e).hasClass(H) || (e = i.default(e).closest(U)[0]), !e || e.hasAttribute("disabled") || e.classList.contains("disabled")) t.preventDefault(); else {
                var a = e.querySelector($);
                if (a && (a.hasAttribute("disabled") || a.classList.contains("disabled"))) return void t.preventDefault();
                "INPUT" !== n.tagName && "LABEL" === e.tagName || K._jQueryInterface.call(i.default(e), "toggle", "INPUT" === n.tagName)
            }
        })).on(X, q, (function (t) {
            var e = i.default(t.target).closest(U)[0];
            i.default(e).toggleClass(B, /^focus(in)?$/.test(t.type))
        })), i.default(window).on(Z, (function () {
            for (var t = [].slice.call(document.querySelectorAll(V)), e = 0, n = t.length; e < n; e++) {
                var a = t[e], i = a.querySelector($);
                i.checked || i.hasAttribute("checked") ? a.classList.add(F) : a.classList.remove(F)
            }
            for (var r = 0, o = (t = [].slice.call(document.querySelectorAll(W))).length; r < o; r++) {
                var s = t[r];
                "true" === s.getAttribute("aria-pressed") ? s.classList.add(F) : s.classList.remove(F)
            }
        })), i.default.fn[R] = K._jQueryInterface, i.default.fn[R].Constructor = K, i.default.fn[R].noConflict = function () {
            return i.default.fn[R] = L, K._jQueryInterface
        };
        var Q = "carousel", J = "4.5.3", tt = "bs.carousel", et = "." + tt, nt = ".data-api", at = i.default.fn[Q],
            it = 37, rt = 39, ot = 500, st = 40,
            lt = {interval: 5e3, keyboard: !0, slide: !1, pause: "hover", wrap: !0, touch: !0}, ct = {
                interval: "(number|boolean)",
                keyboard: "boolean",
                slide: "(boolean|string)",
                pause: "(string|boolean)",
                wrap: "boolean",
                touch: "boolean"
            }, dt = "next", ut = "prev", ht = "left", pt = "right", ft = "slide" + et, gt = "slid" + et,
            mt = "keydown" + et, vt = "mouseenter" + et, bt = "mouseleave" + et, yt = "touchstart" + et,
            xt = "touchmove" + et, _t = "touchend" + et, wt = "pointerdown" + et, St = "pointerup" + et,
            Ct = "dragstart" + et, kt = "load" + et + nt, Dt = "click" + et + nt, Tt = "carousel", Et = "active",
            At = "slide", It = "carousel-item-right", Mt = "carousel-item-left", Rt = "carousel-item-next",
            Pt = "carousel-item-prev", Ot = "pointer-event", jt = ".active", Nt = ".active.carousel-item",
            Lt = ".carousel-item", Ft = ".carousel-item img", Ht = ".carousel-item-next, .carousel-item-prev",
            Bt = ".carousel-indicators", qt = "[data-slide], [data-slide-to]", zt = '[data-ride="carousel"]',
            Wt = {TOUCH: "touch", PEN: "pen"}, Vt = function () {
                function t(t, e) {
                    this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._element = t, this._indicatorsElement = this._element.querySelector(Bt), this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent), this._addEventListeners()
                }

                var e = t.prototype;
                return e.next = function () {
                    this._isSliding || this._slide(dt)
                }, e.nextWhenVisible = function () {
                    var t = i.default(this._element);
                    !document.hidden && t.is(":visible") && "hidden" !== t.css("visibility") && this.next()
                }, e.prev = function () {
                    this._isSliding || this._slide(ut)
                }, e.pause = function (t) {
                    t || (this._isPaused = !0), this._element.querySelector(Ht) && (v.triggerTransitionEnd(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null
                }, e.cycle = function (t) {
                    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config.interval && !this._isPaused && (this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval))
                }, e.to = function (t) {
                    var e = this;
                    this._activeElement = this._element.querySelector(Nt);
                    var n = this._getItemIndex(this._activeElement);
                    if (!(t > this._items.length - 1 || t < 0)) if (this._isSliding) i.default(this._element).one(gt, (function () {
                        return e.to(t)
                    })); else {
                        if (n === t) return this.pause(), void this.cycle();
                        var a = t > n ? dt : ut;
                        this._slide(a, this._items[t])
                    }
                }, e.dispose = function () {
                    i.default(this._element).off(et), i.default.removeData(this._element, tt), this._items = null, this._config = null, this._element = null, this._interval = null, this._isPaused = null, this._isSliding = null, this._activeElement = null, this._indicatorsElement = null
                }, e._getConfig = function (t) {
                    return t = l({}, lt, t), v.typeCheckConfig(Q, t, ct), t
                }, e._handleSwipe = function () {
                    var t = Math.abs(this.touchDeltaX);
                    if (!(t <= st)) {
                        var e = t / this.touchDeltaX;
                        this.touchDeltaX = 0, e > 0 && this.prev(), e < 0 && this.next()
                    }
                }, e._addEventListeners = function () {
                    var t = this;
                    this._config.keyboard && i.default(this._element).on(mt, (function (e) {
                        return t._keydown(e)
                    })), "hover" === this._config.pause && i.default(this._element).on(vt, (function (e) {
                        return t.pause(e)
                    })).on(bt, (function (e) {
                        return t.cycle(e)
                    })), this._config.touch && this._addTouchEventListeners()
                }, e._addTouchEventListeners = function () {
                    var t = this;
                    if (this._touchSupported) {
                        var e = function (e) {
                            t._pointerEvent && Wt[e.originalEvent.pointerType.toUpperCase()] ? t.touchStartX = e.originalEvent.clientX : t._pointerEvent || (t.touchStartX = e.originalEvent.touches[0].clientX)
                        }, n = function (e) {
                            e.originalEvent.touches && e.originalEvent.touches.length > 1 ? t.touchDeltaX = 0 : t.touchDeltaX = e.originalEvent.touches[0].clientX - t.touchStartX
                        }, a = function (e) {
                            t._pointerEvent && Wt[e.originalEvent.pointerType.toUpperCase()] && (t.touchDeltaX = e.originalEvent.clientX - t.touchStartX), t._handleSwipe(), "hover" === t._config.pause && (t.pause(), t.touchTimeout && clearTimeout(t.touchTimeout), t.touchTimeout = setTimeout((function (e) {
                                return t.cycle(e)
                            }), ot + t._config.interval))
                        };
                        i.default(this._element.querySelectorAll(Ft)).on(Ct, (function (t) {
                            return t.preventDefault()
                        })), this._pointerEvent ? (i.default(this._element).on(wt, (function (t) {
                            return e(t)
                        })), i.default(this._element).on(St, (function (t) {
                            return a(t)
                        })), this._element.classList.add(Ot)) : (i.default(this._element).on(yt, (function (t) {
                            return e(t)
                        })), i.default(this._element).on(xt, (function (t) {
                            return n(t)
                        })), i.default(this._element).on(_t, (function (t) {
                            return a(t)
                        })))
                    }
                }, e._keydown = function (t) {
                    if (!/input|textarea/i.test(t.target.tagName)) switch (t.which) {
                        case it:
                            t.preventDefault(), this.prev();
                            break;
                        case rt:
                            t.preventDefault(), this.next()
                    }
                }, e._getItemIndex = function (t) {
                    return this._items = t && t.parentNode ? [].slice.call(t.parentNode.querySelectorAll(Lt)) : [], this._items.indexOf(t)
                }, e._getItemByDirection = function (t, e) {
                    var n = t === dt, a = t === ut, i = this._getItemIndex(e), r = this._items.length - 1;
                    if ((a && 0 === i || n && i === r) && !this._config.wrap) return e;
                    var o = (i + (t === ut ? -1 : 1)) % this._items.length;
                    return -1 === o ? this._items[this._items.length - 1] : this._items[o]
                }, e._triggerSlideEvent = function (t, e) {
                    var n = this._getItemIndex(t), a = this._getItemIndex(this._element.querySelector(Nt)),
                        r = i.default.Event(ft, {relatedTarget: t, direction: e, from: a, to: n});
                    return i.default(this._element).trigger(r), r
                }, e._setActiveIndicatorElement = function (t) {
                    if (this._indicatorsElement) {
                        var e = [].slice.call(this._indicatorsElement.querySelectorAll(jt));
                        i.default(e).removeClass(Et);
                        var n = this._indicatorsElement.children[this._getItemIndex(t)];
                        n && i.default(n).addClass(Et)
                    }
                }, e._slide = function (t, e) {
                    var n, a, r, o = this, s = this._element.querySelector(Nt), l = this._getItemIndex(s),
                        c = e || s && this._getItemByDirection(t, s), d = this._getItemIndex(c),
                        u = Boolean(this._interval);
                    if (t === dt ? (n = Mt, a = Rt, r = ht) : (n = It, a = Pt, r = pt), c && i.default(c).hasClass(Et)) this._isSliding = !1; else if (!this._triggerSlideEvent(c, r).isDefaultPrevented() && s && c) {
                        this._isSliding = !0, u && this.pause(), this._setActiveIndicatorElement(c);
                        var h = i.default.Event(gt, {relatedTarget: c, direction: r, from: l, to: d});
                        if (i.default(this._element).hasClass(At)) {
                            i.default(c).addClass(a), v.reflow(c), i.default(s).addClass(n), i.default(c).addClass(n);
                            var p = parseInt(c.getAttribute("data-interval"), 10);
                            p ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = p) : this._config.interval = this._config.defaultInterval || this._config.interval;
                            var f = v.getTransitionDurationFromElement(s);
                            i.default(s).one(v.TRANSITION_END, (function () {
                                i.default(c).removeClass(n + " " + a).addClass(Et), i.default(s).removeClass(Et + " " + a + " " + n), o._isSliding = !1, setTimeout((function () {
                                    return i.default(o._element).trigger(h)
                                }), 0)
                            })).emulateTransitionEnd(f)
                        } else i.default(s).removeClass(Et), i.default(c).addClass(Et), this._isSliding = !1, i.default(this._element).trigger(h);
                        u && this.cycle()
                    }
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this).data(tt), a = l({}, lt, i.default(this).data());
                        "object" == typeof e && (a = l({}, a, e));
                        var r = "string" == typeof e ? e : a.slide;
                        if (n || (n = new t(this, a), i.default(this).data(tt, n)), "number" == typeof e) n.to(e); else if ("string" == typeof r) {
                            if (void 0 === n[r]) throw new TypeError('No method named "' + r + '"');
                            n[r]()
                        } else a.interval && a.ride && (n.pause(), n.cycle())
                    }))
                }, t._dataApiClickHandler = function (e) {
                    var n = v.getSelectorFromElement(this);
                    if (n) {
                        var a = i.default(n)[0];
                        if (a && i.default(a).hasClass(Tt)) {
                            var r = l({}, i.default(a).data(), i.default(this).data()),
                                o = this.getAttribute("data-slide-to");
                            o && (r.interval = !1), t._jQueryInterface.call(i.default(a), r), o && i.default(a).data(tt).to(o), e.preventDefault()
                        }
                    }
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return J
                    }
                }, {
                    key: "Default", get: function () {
                        return lt
                    }
                }]), t
            }();
        i.default(document).on(Dt, qt, Vt._dataApiClickHandler), i.default(window).on(kt, (function () {
            for (var t = [].slice.call(document.querySelectorAll(zt)), e = 0, n = t.length; e < n; e++) {
                var a = i.default(t[e]);
                Vt._jQueryInterface.call(a, a.data())
            }
        })), i.default.fn[Q] = Vt._jQueryInterface, i.default.fn[Q].Constructor = Vt, i.default.fn[Q].noConflict = function () {
            return i.default.fn[Q] = at, Vt._jQueryInterface
        };
        var $t = "collapse", Yt = "4.5.3", Ut = "bs.collapse", Gt = "." + Ut, Xt = ".data-api", Zt = i.default.fn[$t],
            Kt = {toggle: !0, parent: ""}, Qt = {toggle: "boolean", parent: "(string|element)"}, Jt = "show" + Gt,
            te = "shown" + Gt, ee = "hide" + Gt, ne = "hidden" + Gt, ae = "click" + Gt + Xt, ie = "show",
            re = "collapse", oe = "collapsing", se = "collapsed", le = "width", ce = "height",
            de = ".show, .collapsing", ue = '[data-toggle="collapse"]', he = function () {
                function t(t, e) {
                    this._isTransitioning = !1, this._element = t, this._config = this._getConfig(e), this._triggerArray = [].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#' + t.id + '"],[data-toggle="collapse"][data-target="#' + t.id + '"]'));
                    for (var n = [].slice.call(document.querySelectorAll(ue)), a = 0, i = n.length; a < i; a++) {
                        var r = n[a], o = v.getSelectorFromElement(r),
                            s = [].slice.call(document.querySelectorAll(o)).filter((function (e) {
                                return e === t
                            }));
                        null !== o && s.length > 0 && (this._selector = o, this._triggerArray.push(r))
                    }
                    this._parent = this._config.parent ? this._getParent() : null, this._config.parent || this._addAriaAndCollapsedClass(this._element, this._triggerArray), this._config.toggle && this.toggle()
                }

                var e = t.prototype;
                return e.toggle = function () {
                    i.default(this._element).hasClass(ie) ? this.hide() : this.show()
                }, e.show = function () {
                    var e, n, a = this;
                    if (!(this._isTransitioning || i.default(this._element).hasClass(ie) || (this._parent && 0 === (e = [].slice.call(this._parent.querySelectorAll(de)).filter((function (t) {
                        return "string" == typeof a._config.parent ? t.getAttribute("data-parent") === a._config.parent : t.classList.contains(re)
                    }))).length && (e = null), e && (n = i.default(e).not(this._selector).data(Ut)) && n._isTransitioning))) {
                        var r = i.default.Event(Jt);
                        if (i.default(this._element).trigger(r), !r.isDefaultPrevented()) {
                            e && (t._jQueryInterface.call(i.default(e).not(this._selector), "hide"), n || i.default(e).data(Ut, null));
                            var o = this._getDimension();
                            i.default(this._element).removeClass(re).addClass(oe), this._element.style[o] = 0, this._triggerArray.length && i.default(this._triggerArray).removeClass(se).attr("aria-expanded", !0), this.setTransitioning(!0);
                            var s = function () {
                                    i.default(a._element).removeClass(oe).addClass(re + " " + ie), a._element.style[o] = "", a.setTransitioning(!1), i.default(a._element).trigger(te)
                                }, l = "scroll" + (o[0].toUpperCase() + o.slice(1)),
                                c = v.getTransitionDurationFromElement(this._element);
                            i.default(this._element).one(v.TRANSITION_END, s).emulateTransitionEnd(c), this._element.style[o] = this._element[l] + "px"
                        }
                    }
                }, e.hide = function () {
                    var t = this;
                    if (!this._isTransitioning && i.default(this._element).hasClass(ie)) {
                        var e = i.default.Event(ee);
                        if (i.default(this._element).trigger(e), !e.isDefaultPrevented()) {
                            var n = this._getDimension();
                            this._element.style[n] = this._element.getBoundingClientRect()[n] + "px", v.reflow(this._element), i.default(this._element).addClass(oe).removeClass(re + " " + ie);
                            var a = this._triggerArray.length;
                            if (a > 0) for (var r = 0; r < a; r++) {
                                var o = this._triggerArray[r], s = v.getSelectorFromElement(o);
                                null !== s && (i.default([].slice.call(document.querySelectorAll(s))).hasClass(ie) || i.default(o).addClass(se).attr("aria-expanded", !1))
                            }
                            this.setTransitioning(!0);
                            var l = function () {
                                t.setTransitioning(!1), i.default(t._element).removeClass(oe).addClass(re).trigger(ne)
                            };
                            this._element.style[n] = "";
                            var c = v.getTransitionDurationFromElement(this._element);
                            i.default(this._element).one(v.TRANSITION_END, l).emulateTransitionEnd(c)
                        }
                    }
                }, e.setTransitioning = function (t) {
                    this._isTransitioning = t
                }, e.dispose = function () {
                    i.default.removeData(this._element, Ut), this._config = null, this._parent = null, this._element = null, this._triggerArray = null, this._isTransitioning = null
                }, e._getConfig = function (t) {
                    return (t = l({}, Kt, t)).toggle = Boolean(t.toggle), v.typeCheckConfig($t, t, Qt), t
                }, e._getDimension = function () {
                    return i.default(this._element).hasClass(le) ? le : ce
                }, e._getParent = function () {
                    var e, n = this;
                    v.isElement(this._config.parent) ? (e = this._config.parent, void 0 !== this._config.parent.jquery && (e = this._config.parent[0])) : e = document.querySelector(this._config.parent);
                    var a = '[data-toggle="collapse"][data-parent="' + this._config.parent + '"]',
                        r = [].slice.call(e.querySelectorAll(a));
                    return i.default(r).each((function (e, a) {
                        n._addAriaAndCollapsedClass(t._getTargetFromElement(a), [a])
                    })), e
                }, e._addAriaAndCollapsedClass = function (t, e) {
                    var n = i.default(t).hasClass(ie);
                    e.length && i.default(e).toggleClass(se, !n).attr("aria-expanded", n)
                }, t._getTargetFromElement = function (t) {
                    var e = v.getSelectorFromElement(t);
                    return e ? document.querySelector(e) : null
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this), a = n.data(Ut),
                            r = l({}, Kt, n.data(), "object" == typeof e && e ? e : {});
                        if (!a && r.toggle && "string" == typeof e && /show|hide/.test(e) && (r.toggle = !1), a || (a = new t(this, r), n.data(Ut, a)), "string" == typeof e) {
                            if (void 0 === a[e]) throw new TypeError('No method named "' + e + '"');
                            a[e]()
                        }
                    }))
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return Yt
                    }
                }, {
                    key: "Default", get: function () {
                        return Kt
                    }
                }]), t
            }();
        i.default(document).on(ae, ue, (function (t) {
            "A" === t.currentTarget.tagName && t.preventDefault();
            var e = i.default(this), n = v.getSelectorFromElement(this),
                a = [].slice.call(document.querySelectorAll(n));
            i.default(a).each((function () {
                var t = i.default(this), n = t.data(Ut) ? "toggle" : e.data();
                he._jQueryInterface.call(t, n)
            }))
        })), i.default.fn[$t] = he._jQueryInterface, i.default.fn[$t].Constructor = he, i.default.fn[$t].noConflict = function () {
            return i.default.fn[$t] = Zt, he._jQueryInterface
        };
        var pe = "dropdown", fe = "4.5.3", ge = "bs.dropdown", me = "." + ge, ve = ".data-api", be = i.default.fn[pe],
            ye = 27, xe = 32, _e = 9, we = 38, Se = 40, Ce = 3, ke = new RegExp(we + "|" + Se + "|" + ye),
            De = "hide" + me, Te = "hidden" + me, Ee = "show" + me, Ae = "shown" + me, Ie = "click" + me,
            Me = "click" + me + ve, Re = "keydown" + me + ve, Pe = "keyup" + me + ve, Oe = "disabled", je = "show",
            Ne = "dropup", Le = "dropright", Fe = "dropleft", He = "dropdown-menu-right", Be = "position-static",
            qe = '[data-toggle="dropdown"]', ze = ".dropdown form", We = ".dropdown-menu", Ve = ".navbar-nav",
            $e = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", Ye = "top-start", Ue = "top-end",
            Ge = "bottom-start", Xe = "bottom-end", Ze = "right-start", Ke = "left-start", Qe = {
                offset: 0,
                flip: !0,
                boundary: "scrollParent",
                reference: "toggle",
                display: "dynamic",
                popperConfig: null
            }, Je = {
                offset: "(number|string|function)",
                flip: "boolean",
                boundary: "(string|element)",
                reference: "(string|element)",
                display: "string",
                popperConfig: "(null|object)"
            }, tn = function () {
                function t(t, e) {
                    this._element = t, this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._addEventListeners()
                }

                var e = t.prototype;
                return e.toggle = function () {
                    if (!this._element.disabled && !i.default(this._element).hasClass(Oe)) {
                        var e = i.default(this._menu).hasClass(je);
                        t._clearMenus(), e || this.show(!0)
                    }
                }, e.show = function (e) {
                    if (void 0 === e && (e = !1), !(this._element.disabled || i.default(this._element).hasClass(Oe) || i.default(this._menu).hasClass(je))) {
                        var n = {relatedTarget: this._element}, a = i.default.Event(Ee, n),
                            o = t._getParentFromElement(this._element);
                        if (i.default(o).trigger(a), !a.isDefaultPrevented()) {
                            if (!this._inNavbar && e) {
                                if (void 0 === r.default) throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");
                                var s = this._element;
                                "parent" === this._config.reference ? s = o : v.isElement(this._config.reference) && (s = this._config.reference, void 0 !== this._config.reference.jquery && (s = this._config.reference[0])), "scrollParent" !== this._config.boundary && i.default(o).addClass(Be), this._popper = new r.default(s, this._menu, this._getPopperConfig())
                            }
                            "ontouchstart" in document.documentElement && 0 === i.default(o).closest(Ve).length && i.default(document.body).children().on("mouseover", null, i.default.noop), this._element.focus(), this._element.setAttribute("aria-expanded", !0), i.default(this._menu).toggleClass(je), i.default(o).toggleClass(je).trigger(i.default.Event(Ae, n))
                        }
                    }
                }, e.hide = function () {
                    if (!this._element.disabled && !i.default(this._element).hasClass(Oe) && i.default(this._menu).hasClass(je)) {
                        var e = {relatedTarget: this._element}, n = i.default.Event(De, e),
                            a = t._getParentFromElement(this._element);
                        i.default(a).trigger(n), n.isDefaultPrevented() || (this._popper && this._popper.destroy(), i.default(this._menu).toggleClass(je), i.default(a).toggleClass(je).trigger(i.default.Event(Te, e)))
                    }
                }, e.dispose = function () {
                    i.default.removeData(this._element, ge), i.default(this._element).off(me), this._element = null, this._menu = null, null !== this._popper && (this._popper.destroy(), this._popper = null)
                }, e.update = function () {
                    this._inNavbar = this._detectNavbar(), null !== this._popper && this._popper.scheduleUpdate()
                }, e._addEventListeners = function () {
                    var t = this;
                    i.default(this._element).on(Ie, (function (e) {
                        e.preventDefault(), e.stopPropagation(), t.toggle()
                    }))
                }, e._getConfig = function (t) {
                    return t = l({}, this.constructor.Default, i.default(this._element).data(), t), v.typeCheckConfig(pe, t, this.constructor.DefaultType), t
                }, e._getMenuElement = function () {
                    if (!this._menu) {
                        var e = t._getParentFromElement(this._element);
                        e && (this._menu = e.querySelector(We))
                    }
                    return this._menu
                }, e._getPlacement = function () {
                    var t = i.default(this._element.parentNode), e = Ge;
                    return t.hasClass(Ne) ? e = i.default(this._menu).hasClass(He) ? Ue : Ye : t.hasClass(Le) ? e = Ze : t.hasClass(Fe) ? e = Ke : i.default(this._menu).hasClass(He) && (e = Xe), e
                }, e._detectNavbar = function () {
                    return i.default(this._element).closest(".navbar").length > 0
                }, e._getOffset = function () {
                    var t = this, e = {};
                    return "function" == typeof this._config.offset ? e.fn = function (e) {
                        return e.offsets = l({}, e.offsets, t._config.offset(e.offsets, t._element) || {}), e
                    } : e.offset = this._config.offset, e
                }, e._getPopperConfig = function () {
                    var t = {
                        placement: this._getPlacement(),
                        modifiers: {
                            offset: this._getOffset(),
                            flip: {enabled: this._config.flip},
                            preventOverflow: {boundariesElement: this._config.boundary}
                        }
                    };
                    return "static" === this._config.display && (t.modifiers.applyStyle = {enabled: !1}), l({}, t, this._config.popperConfig)
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this).data(ge);
                        if (n || (n = new t(this, "object" == typeof e ? e : null), i.default(this).data(ge, n)), "string" == typeof e) {
                            if (void 0 === n[e]) throw new TypeError('No method named "' + e + '"');
                            n[e]()
                        }
                    }))
                }, t._clearMenus = function (e) {
                    if (!e || e.which !== Ce && ("keyup" !== e.type || e.which === _e)) for (var n = [].slice.call(document.querySelectorAll(qe)), a = 0, r = n.length; a < r; a++) {
                        var o = t._getParentFromElement(n[a]), s = i.default(n[a]).data(ge), l = {relatedTarget: n[a]};
                        if (e && "click" === e.type && (l.clickEvent = e), s) {
                            var c = s._menu;
                            if (i.default(o).hasClass(je) && !(e && ("click" === e.type && /input|textarea/i.test(e.target.tagName) || "keyup" === e.type && e.which === _e) && i.default.contains(o, e.target))) {
                                var d = i.default.Event(De, l);
                                i.default(o).trigger(d), d.isDefaultPrevented() || ("ontouchstart" in document.documentElement && i.default(document.body).children().off("mouseover", null, i.default.noop), n[a].setAttribute("aria-expanded", "false"), s._popper && s._popper.destroy(), i.default(c).removeClass(je), i.default(o).removeClass(je).trigger(i.default.Event(Te, l)))
                            }
                        }
                    }
                }, t._getParentFromElement = function (t) {
                    var e, n = v.getSelectorFromElement(t);
                    return n && (e = document.querySelector(n)), e || t.parentNode
                }, t._dataApiKeydownHandler = function (e) {
                    if (!(/input|textarea/i.test(e.target.tagName) ? e.which === xe || e.which !== ye && (e.which !== Se && e.which !== we || i.default(e.target).closest(We).length) : !ke.test(e.which)) && !this.disabled && !i.default(this).hasClass(Oe)) {
                        var n = t._getParentFromElement(this), a = i.default(n).hasClass(je);
                        if (a || e.which !== ye) {
                            if (e.preventDefault(), e.stopPropagation(), !a || e.which === ye || e.which === xe) return e.which === ye && i.default(n.querySelector(qe)).trigger("focus"), void i.default(this).trigger("click");
                            var r = [].slice.call(n.querySelectorAll($e)).filter((function (t) {
                                return i.default(t).is(":visible")
                            }));
                            if (0 !== r.length) {
                                var o = r.indexOf(e.target);
                                e.which === we && o > 0 && o--, e.which === Se && o < r.length - 1 && o++, o < 0 && (o = 0), r[o].focus()
                            }
                        }
                    }
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return fe
                    }
                }, {
                    key: "Default", get: function () {
                        return Qe
                    }
                }, {
                    key: "DefaultType", get: function () {
                        return Je
                    }
                }]), t
            }();
        i.default(document).on(Re, qe, tn._dataApiKeydownHandler).on(Re, We, tn._dataApiKeydownHandler).on(Me + " " + Pe, tn._clearMenus).on(Me, qe, (function (t) {
            t.preventDefault(), t.stopPropagation(), tn._jQueryInterface.call(i.default(this), "toggle")
        })).on(Me, ze, (function (t) {
            t.stopPropagation()
        })), i.default.fn[pe] = tn._jQueryInterface, i.default.fn[pe].Constructor = tn, i.default.fn[pe].noConflict = function () {
            return i.default.fn[pe] = be, tn._jQueryInterface
        };
        var en = "modal", nn = "4.5.3", an = "bs.modal", rn = "." + an, on = ".data-api", sn = i.default.fn[en],
            ln = 27, cn = {backdrop: !0, keyboard: !0, focus: !0, show: !0},
            dn = {backdrop: "(boolean|string)", keyboard: "boolean", focus: "boolean", show: "boolean"},
            un = "hide" + rn, hn = "hidePrevented" + rn, pn = "hidden" + rn, fn = "show" + rn, gn = "shown" + rn,
            mn = "focusin" + rn, vn = "resize" + rn, bn = "click.dismiss" + rn, yn = "keydown.dismiss" + rn,
            xn = "mouseup.dismiss" + rn, _n = "mousedown.dismiss" + rn, wn = "click" + rn + on,
            Sn = "modal-dialog-scrollable", Cn = "modal-scrollbar-measure", kn = "modal-backdrop", Dn = "modal-open",
            Tn = "fade", En = "show", An = "modal-static", In = ".modal-dialog", Mn = ".modal-body",
            Rn = '[data-toggle="modal"]', Pn = '[data-dismiss="modal"]',
            On = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", jn = ".sticky-top", Nn = function () {
                function t(t, e) {
                    this._config = this._getConfig(e), this._element = t, this._dialog = t.querySelector(In), this._backdrop = null, this._isShown = !1, this._isBodyOverflowing = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollbarWidth = 0
                }

                var e = t.prototype;
                return e.toggle = function (t) {
                    return this._isShown ? this.hide() : this.show(t)
                }, e.show = function (t) {
                    var e = this;
                    if (!this._isShown && !this._isTransitioning) {
                        i.default(this._element).hasClass(Tn) && (this._isTransitioning = !0);
                        var n = i.default.Event(fn, {relatedTarget: t});
                        i.default(this._element).trigger(n), this._isShown || n.isDefaultPrevented() || (this._isShown = !0, this._checkScrollbar(), this._setScrollbar(), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), i.default(this._element).on(bn, Pn, (function (t) {
                            return e.hide(t)
                        })), i.default(this._dialog).on(_n, (function () {
                            i.default(e._element).one(xn, (function (t) {
                                i.default(t.target).is(e._element) && (e._ignoreBackdropClick = !0)
                            }))
                        })), this._showBackdrop((function () {
                            return e._showElement(t)
                        })))
                    }
                }, e.hide = function (t) {
                    var e = this;
                    if (t && t.preventDefault(), this._isShown && !this._isTransitioning) {
                        var n = i.default.Event(un);
                        if (i.default(this._element).trigger(n), this._isShown && !n.isDefaultPrevented()) {
                            this._isShown = !1;
                            var a = i.default(this._element).hasClass(Tn);
                            if (a && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), i.default(document).off(mn), i.default(this._element).removeClass(En), i.default(this._element).off(bn), i.default(this._dialog).off(_n), a) {
                                var r = v.getTransitionDurationFromElement(this._element);
                                i.default(this._element).one(v.TRANSITION_END, (function (t) {
                                    return e._hideModal(t)
                                })).emulateTransitionEnd(r)
                            } else this._hideModal()
                        }
                    }
                }, e.dispose = function () {
                    [window, this._element, this._dialog].forEach((function (t) {
                        return i.default(t).off(rn)
                    })), i.default(document).off(mn), i.default.removeData(this._element, an), this._config = null, this._element = null, this._dialog = null, this._backdrop = null, this._isShown = null, this._isBodyOverflowing = null, this._ignoreBackdropClick = null, this._isTransitioning = null, this._scrollbarWidth = null
                }, e.handleUpdate = function () {
                    this._adjustDialog()
                }, e._getConfig = function (t) {
                    return t = l({}, cn, t), v.typeCheckConfig(en, t, dn), t
                }, e._triggerBackdropTransition = function () {
                    var t = this;
                    if ("static" === this._config.backdrop) {
                        var e = i.default.Event(hn);
                        if (i.default(this._element).trigger(e), e.isDefaultPrevented()) return;
                        var n = this._element.scrollHeight > document.documentElement.clientHeight;
                        n || (this._element.style.overflowY = "hidden"), this._element.classList.add(An);
                        var a = v.getTransitionDurationFromElement(this._dialog);
                        i.default(this._element).off(v.TRANSITION_END), i.default(this._element).one(v.TRANSITION_END, (function () {
                            t._element.classList.remove(An), n || i.default(t._element).one(v.TRANSITION_END, (function () {
                                t._element.style.overflowY = ""
                            })).emulateTransitionEnd(t._element, a)
                        })).emulateTransitionEnd(a), this._element.focus()
                    } else this.hide()
                }, e._showElement = function (t) {
                    var e = this, n = i.default(this._element).hasClass(Tn),
                        a = this._dialog ? this._dialog.querySelector(Mn) : null;
                    this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE || document.body.appendChild(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), i.default(this._dialog).hasClass(Sn) && a ? a.scrollTop = 0 : this._element.scrollTop = 0, n && v.reflow(this._element), i.default(this._element).addClass(En), this._config.focus && this._enforceFocus();
                    var r = i.default.Event(gn, {relatedTarget: t}), o = function () {
                        e._config.focus && e._element.focus(), e._isTransitioning = !1, i.default(e._element).trigger(r)
                    };
                    if (n) {
                        var s = v.getTransitionDurationFromElement(this._dialog);
                        i.default(this._dialog).one(v.TRANSITION_END, o).emulateTransitionEnd(s)
                    } else o()
                }, e._enforceFocus = function () {
                    var t = this;
                    i.default(document).off(mn).on(mn, (function (e) {
                        document !== e.target && t._element !== e.target && 0 === i.default(t._element).has(e.target).length && t._element.focus()
                    }))
                }, e._setEscapeEvent = function () {
                    var t = this;
                    this._isShown ? i.default(this._element).on(yn, (function (e) {
                        t._config.keyboard && e.which === ln ? (e.preventDefault(), t.hide()) : t._config.keyboard || e.which !== ln || t._triggerBackdropTransition()
                    })) : this._isShown || i.default(this._element).off(yn)
                }, e._setResizeEvent = function () {
                    var t = this;
                    this._isShown ? i.default(window).on(vn, (function (e) {
                        return t.handleUpdate(e)
                    })) : i.default(window).off(vn)
                }, e._hideModal = function () {
                    var t = this;
                    this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._showBackdrop((function () {
                        i.default(document.body).removeClass(Dn), t._resetAdjustments(), t._resetScrollbar(), i.default(t._element).trigger(pn)
                    }))
                }, e._removeBackdrop = function () {
                    this._backdrop && (i.default(this._backdrop).remove(), this._backdrop = null)
                }, e._showBackdrop = function (t) {
                    var e = this, n = i.default(this._element).hasClass(Tn) ? Tn : "";
                    if (this._isShown && this._config.backdrop) {
                        if (this._backdrop = document.createElement("div"), this._backdrop.className = kn, n && this._backdrop.classList.add(n), i.default(this._backdrop).appendTo(document.body), i.default(this._element).on(bn, (function (t) {
                            e._ignoreBackdropClick ? e._ignoreBackdropClick = !1 : t.target === t.currentTarget && e._triggerBackdropTransition()
                        })), n && v.reflow(this._backdrop), i.default(this._backdrop).addClass(En), !t) return;
                        if (!n) return void t();
                        var a = v.getTransitionDurationFromElement(this._backdrop);
                        i.default(this._backdrop).one(v.TRANSITION_END, t).emulateTransitionEnd(a)
                    } else if (!this._isShown && this._backdrop) {
                        i.default(this._backdrop).removeClass(En);
                        var r = function () {
                            e._removeBackdrop(), t && t()
                        };
                        if (i.default(this._element).hasClass(Tn)) {
                            var o = v.getTransitionDurationFromElement(this._backdrop);
                            i.default(this._backdrop).one(v.TRANSITION_END, r).emulateTransitionEnd(o)
                        } else r()
                    } else t && t()
                }, e._adjustDialog = function () {
                    var t = this._element.scrollHeight > document.documentElement.clientHeight;
                    !this._isBodyOverflowing && t && (this._element.style.paddingLeft = this._scrollbarWidth + "px"), this._isBodyOverflowing && !t && (this._element.style.paddingRight = this._scrollbarWidth + "px")
                }, e._resetAdjustments = function () {
                    this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
                }, e._checkScrollbar = function () {
                    var t = document.body.getBoundingClientRect();
                    this._isBodyOverflowing = Math.round(t.left + t.right) < window.innerWidth, this._scrollbarWidth = this._getScrollbarWidth()
                }, e._setScrollbar = function () {
                    var t = this;
                    if (this._isBodyOverflowing) {
                        var e = [].slice.call(document.querySelectorAll(On)),
                            n = [].slice.call(document.querySelectorAll(jn));
                        i.default(e).each((function (e, n) {
                            var a = n.style.paddingRight, r = i.default(n).css("padding-right");
                            i.default(n).data("padding-right", a).css("padding-right", parseFloat(r) + t._scrollbarWidth + "px")
                        })), i.default(n).each((function (e, n) {
                            var a = n.style.marginRight, r = i.default(n).css("margin-right");
                            i.default(n).data("margin-right", a).css("margin-right", parseFloat(r) - t._scrollbarWidth + "px")
                        }));
                        var a = document.body.style.paddingRight, r = i.default(document.body).css("padding-right");
                        i.default(document.body).data("padding-right", a).css("padding-right", parseFloat(r) + this._scrollbarWidth + "px")
                    }
                    i.default(document.body).addClass(Dn)
                }, e._resetScrollbar = function () {
                    var t = [].slice.call(document.querySelectorAll(On));
                    i.default(t).each((function (t, e) {
                        var n = i.default(e).data("padding-right");
                        i.default(e).removeData("padding-right"), e.style.paddingRight = n || ""
                    }));
                    var e = [].slice.call(document.querySelectorAll("" + jn));
                    i.default(e).each((function (t, e) {
                        var n = i.default(e).data("margin-right");
                        void 0 !== n && i.default(e).css("margin-right", n).removeData("margin-right")
                    }));
                    var n = i.default(document.body).data("padding-right");
                    i.default(document.body).removeData("padding-right"), document.body.style.paddingRight = n || ""
                }, e._getScrollbarWidth = function () {
                    var t = document.createElement("div");
                    t.className = Cn, document.body.appendChild(t);
                    var e = t.getBoundingClientRect().width - t.clientWidth;
                    return document.body.removeChild(t), e
                }, t._jQueryInterface = function (e, n) {
                    return this.each((function () {
                        var a = i.default(this).data(an),
                            r = l({}, cn, i.default(this).data(), "object" == typeof e && e ? e : {});
                        if (a || (a = new t(this, r), i.default(this).data(an, a)), "string" == typeof e) {
                            if (void 0 === a[e]) throw new TypeError('No method named "' + e + '"');
                            a[e](n)
                        } else r.show && a.show(n)
                    }))
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return nn
                    }
                }, {
                    key: "Default", get: function () {
                        return cn
                    }
                }]), t
            }();
        i.default(document).on(wn, Rn, (function (t) {
            var e, n = this, a = v.getSelectorFromElement(this);
            a && (e = document.querySelector(a));
            var r = i.default(e).data(an) ? "toggle" : l({}, i.default(e).data(), i.default(this).data());
            "A" !== this.tagName && "AREA" !== this.tagName || t.preventDefault();
            var o = i.default(e).one(fn, (function (t) {
                t.isDefaultPrevented() || o.one(pn, (function () {
                    i.default(n).is(":visible") && n.focus()
                }))
            }));
            Nn._jQueryInterface.call(i.default(e), r, this)
        })), i.default.fn[en] = Nn._jQueryInterface, i.default.fn[en].Constructor = Nn, i.default.fn[en].noConflict = function () {
            return i.default.fn[en] = sn, Nn._jQueryInterface
        };
        var Ln = ["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"], Fn = {
                "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
                a: ["target", "href", "title", "rel"],
                area: [],
                b: [],
                br: [],
                col: [],
                code: [],
                div: [],
                em: [],
                hr: [],
                h1: [],
                h2: [],
                h3: [],
                h4: [],
                h5: [],
                h6: [],
                i: [],
                img: ["src", "srcset", "alt", "title", "width", "height"],
                li: [],
                ol: [],
                p: [],
                pre: [],
                s: [],
                small: [],
                span: [],
                sub: [],
                sup: [],
                strong: [],
                u: [],
                ul: []
            }, Hn = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,
            Bn = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

        function qn(t, e) {
            var n = t.nodeName.toLowerCase();
            if (-1 !== e.indexOf(n)) return -1 === Ln.indexOf(n) || Boolean(t.nodeValue.match(Hn) || t.nodeValue.match(Bn));
            for (var a = e.filter((function (t) {
                return t instanceof RegExp
            })), i = 0, r = a.length; i < r; i++) if (n.match(a[i])) return !0;
            return !1
        }

        function zn(t, e, n) {
            if (0 === t.length) return t;
            if (n && "function" == typeof n) return n(t);
            for (var a = (new window.DOMParser).parseFromString(t, "text/html"), i = Object.keys(e), r = [].slice.call(a.body.querySelectorAll("*")), o = function (t, n) {
                var a = r[t], o = a.nodeName.toLowerCase();
                if (-1 === i.indexOf(a.nodeName.toLowerCase())) return a.parentNode.removeChild(a), "continue";
                var s = [].slice.call(a.attributes), l = [].concat(e["*"] || [], e[o] || []);
                s.forEach((function (t) {
                    qn(t, l) || a.removeAttribute(t.nodeName)
                }))
            }, s = 0, l = r.length; s < l; s++) o(s);
            return a.body.innerHTML
        }

        var Wn = "tooltip", Vn = "4.5.3", $n = "bs.tooltip", Yn = "." + $n, Un = i.default.fn[Wn], Gn = "bs-tooltip",
            Xn = new RegExp("(^|\\s)" + Gn + "\\S+", "g"), Zn = ["sanitize", "whiteList", "sanitizeFn"], Kn = {
                animation: "boolean",
                template: "string",
                title: "(string|element|function)",
                trigger: "string",
                delay: "(number|object)",
                html: "boolean",
                selector: "(string|boolean)",
                placement: "(string|function)",
                offset: "(number|string|function)",
                container: "(string|element|boolean)",
                fallbackPlacement: "(string|array)",
                boundary: "(string|element)",
                sanitize: "boolean",
                sanitizeFn: "(null|function)",
                whiteList: "object",
                popperConfig: "(null|object)"
            }, Qn = {AUTO: "auto", TOP: "top", RIGHT: "right", BOTTOM: "bottom", LEFT: "left"}, Jn = {
                animation: !0,
                template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
                trigger: "hover focus",
                title: "",
                delay: 0,
                html: !1,
                selector: !1,
                placement: "top",
                offset: 0,
                container: !1,
                fallbackPlacement: "flip",
                boundary: "scrollParent",
                sanitize: !0,
                sanitizeFn: null,
                whiteList: Fn,
                popperConfig: null
            }, ta = "show", ea = "out", na = {
                HIDE: "hide" + Yn,
                HIDDEN: "hidden" + Yn,
                SHOW: "show" + Yn,
                SHOWN: "shown" + Yn,
                INSERTED: "inserted" + Yn,
                CLICK: "click" + Yn,
                FOCUSIN: "focusin" + Yn,
                FOCUSOUT: "focusout" + Yn,
                MOUSEENTER: "mouseenter" + Yn,
                MOUSELEAVE: "mouseleave" + Yn
            }, aa = "fade", ia = "show", ra = ".tooltip-inner", oa = ".arrow", sa = "hover", la = "focus", ca = "click",
            da = "manual", ua = function () {
                function t(t, e) {
                    if (void 0 === r.default) throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");
                    this._isEnabled = !0, this._timeout = 0, this._hoverState = "", this._activeTrigger = {}, this._popper = null, this.element = t, this.config = this._getConfig(e), this.tip = null, this._setListeners()
                }

                var e = t.prototype;
                return e.enable = function () {
                    this._isEnabled = !0
                }, e.disable = function () {
                    this._isEnabled = !1
                }, e.toggleEnabled = function () {
                    this._isEnabled = !this._isEnabled
                }, e.toggle = function (t) {
                    if (this._isEnabled) if (t) {
                        var e = this.constructor.DATA_KEY, n = i.default(t.currentTarget).data(e);
                        n || (n = new this.constructor(t.currentTarget, this._getDelegateConfig()), i.default(t.currentTarget).data(e, n)), n._activeTrigger.click = !n._activeTrigger.click, n._isWithActiveTrigger() ? n._enter(null, n) : n._leave(null, n)
                    } else {
                        if (i.default(this.getTipElement()).hasClass(ia)) return void this._leave(null, this);
                        this._enter(null, this)
                    }
                }, e.dispose = function () {
                    clearTimeout(this._timeout), i.default.removeData(this.element, this.constructor.DATA_KEY), i.default(this.element).off(this.constructor.EVENT_KEY), i.default(this.element).closest(".modal").off("hide.bs.modal", this._hideModalHandler), this.tip && i.default(this.tip).remove(), this._isEnabled = null, this._timeout = null, this._hoverState = null, this._activeTrigger = null, this._popper && this._popper.destroy(), this._popper = null, this.element = null, this.config = null, this.tip = null
                }, e.show = function () {
                    var t = this;
                    if ("none" === i.default(this.element).css("display")) throw new Error("Please use show on visible elements");
                    var e = i.default.Event(this.constructor.Event.SHOW);
                    if (this.isWithContent() && this._isEnabled) {
                        i.default(this.element).trigger(e);
                        var n = v.findShadowRoot(this.element),
                            a = i.default.contains(null !== n ? n : this.element.ownerDocument.documentElement, this.element);
                        if (e.isDefaultPrevented() || !a) return;
                        var o = this.getTipElement(), s = v.getUID(this.constructor.NAME);
                        o.setAttribute("id", s), this.element.setAttribute("aria-describedby", s), this.setContent(), this.config.animation && i.default(o).addClass(aa);
                        var l = "function" == typeof this.config.placement ? this.config.placement.call(this, o, this.element) : this.config.placement,
                            c = this._getAttachment(l);
                        this.addAttachmentClass(c);
                        var d = this._getContainer();
                        i.default(o).data(this.constructor.DATA_KEY, this), i.default.contains(this.element.ownerDocument.documentElement, this.tip) || i.default(o).appendTo(d), i.default(this.element).trigger(this.constructor.Event.INSERTED), this._popper = new r.default(this.element, o, this._getPopperConfig(c)), i.default(o).addClass(ia), "ontouchstart" in document.documentElement && i.default(document.body).children().on("mouseover", null, i.default.noop);
                        var u = function () {
                            t.config.animation && t._fixTransition();
                            var e = t._hoverState;
                            t._hoverState = null, i.default(t.element).trigger(t.constructor.Event.SHOWN), e === ea && t._leave(null, t)
                        };
                        if (i.default(this.tip).hasClass(aa)) {
                            var h = v.getTransitionDurationFromElement(this.tip);
                            i.default(this.tip).one(v.TRANSITION_END, u).emulateTransitionEnd(h)
                        } else u()
                    }
                }, e.hide = function (t) {
                    var e = this, n = this.getTipElement(), a = i.default.Event(this.constructor.Event.HIDE),
                        r = function () {
                            e._hoverState !== ta && n.parentNode && n.parentNode.removeChild(n), e._cleanTipClass(), e.element.removeAttribute("aria-describedby"), i.default(e.element).trigger(e.constructor.Event.HIDDEN), null !== e._popper && e._popper.destroy(), t && t()
                        };
                    if (i.default(this.element).trigger(a), !a.isDefaultPrevented()) {
                        if (i.default(n).removeClass(ia), "ontouchstart" in document.documentElement && i.default(document.body).children().off("mouseover", null, i.default.noop), this._activeTrigger[ca] = !1, this._activeTrigger[la] = !1, this._activeTrigger[sa] = !1, i.default(this.tip).hasClass(aa)) {
                            var o = v.getTransitionDurationFromElement(n);
                            i.default(n).one(v.TRANSITION_END, r).emulateTransitionEnd(o)
                        } else r();
                        this._hoverState = ""
                    }
                }, e.update = function () {
                    null !== this._popper && this._popper.scheduleUpdate()
                }, e.isWithContent = function () {
                    return Boolean(this.getTitle())
                }, e.addAttachmentClass = function (t) {
                    i.default(this.getTipElement()).addClass(Gn + "-" + t)
                }, e.getTipElement = function () {
                    return this.tip = this.tip || i.default(this.config.template)[0], this.tip
                }, e.setContent = function () {
                    var t = this.getTipElement();
                    this.setElementContent(i.default(t.querySelectorAll(ra)), this.getTitle()), i.default(t).removeClass(aa + " " + ia)
                }, e.setElementContent = function (t, e) {
                    "object" != typeof e || !e.nodeType && !e.jquery ? this.config.html ? (this.config.sanitize && (e = zn(e, this.config.whiteList, this.config.sanitizeFn)), t.html(e)) : t.text(e) : this.config.html ? i.default(e).parent().is(t) || t.empty().append(e) : t.text(i.default(e).text())
                }, e.getTitle = function () {
                    var t = this.element.getAttribute("data-original-title");
                    return t || (t = "function" == typeof this.config.title ? this.config.title.call(this.element) : this.config.title), t
                }, e._getPopperConfig = function (t) {
                    var e = this;
                    return l({}, {
                        placement: t,
                        modifiers: {
                            offset: this._getOffset(),
                            flip: {behavior: this.config.fallbackPlacement},
                            arrow: {element: oa},
                            preventOverflow: {boundariesElement: this.config.boundary}
                        },
                        onCreate: function (t) {
                            t.originalPlacement !== t.placement && e._handlePopperPlacementChange(t)
                        },
                        onUpdate: function (t) {
                            return e._handlePopperPlacementChange(t)
                        }
                    }, this.config.popperConfig)
                }, e._getOffset = function () {
                    var t = this, e = {};
                    return "function" == typeof this.config.offset ? e.fn = function (e) {
                        return e.offsets = l({}, e.offsets, t.config.offset(e.offsets, t.element) || {}), e
                    } : e.offset = this.config.offset, e
                }, e._getContainer = function () {
                    return !1 === this.config.container ? document.body : v.isElement(this.config.container) ? i.default(this.config.container) : i.default(document).find(this.config.container)
                }, e._getAttachment = function (t) {
                    return Qn[t.toUpperCase()]
                }, e._setListeners = function () {
                    var t = this;
                    this.config.trigger.split(" ").forEach((function (e) {
                        if ("click" === e) i.default(t.element).on(t.constructor.Event.CLICK, t.config.selector, (function (e) {
                            return t.toggle(e)
                        })); else if (e !== da) {
                            var n = e === sa ? t.constructor.Event.MOUSEENTER : t.constructor.Event.FOCUSIN,
                                a = e === sa ? t.constructor.Event.MOUSELEAVE : t.constructor.Event.FOCUSOUT;
                            i.default(t.element).on(n, t.config.selector, (function (e) {
                                return t._enter(e)
                            })).on(a, t.config.selector, (function (e) {
                                return t._leave(e)
                            }))
                        }
                    })), this._hideModalHandler = function () {
                        t.element && t.hide()
                    }, i.default(this.element).closest(".modal").on("hide.bs.modal", this._hideModalHandler), this.config.selector ? this.config = l({}, this.config, {
                        trigger: "manual",
                        selector: ""
                    }) : this._fixTitle()
                }, e._fixTitle = function () {
                    var t = typeof this.element.getAttribute("data-original-title");
                    (this.element.getAttribute("title") || "string" !== t) && (this.element.setAttribute("data-original-title", this.element.getAttribute("title") || ""), this.element.setAttribute("title", ""))
                }, e._enter = function (t, e) {
                    var n = this.constructor.DATA_KEY;
                    (e = e || i.default(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), i.default(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusin" === t.type ? la : sa] = !0), i.default(e.getTipElement()).hasClass(ia) || e._hoverState === ta ? e._hoverState = ta : (clearTimeout(e._timeout), e._hoverState = ta, e.config.delay && e.config.delay.show ? e._timeout = setTimeout((function () {
                        e._hoverState === ta && e.show()
                    }), e.config.delay.show) : e.show())
                }, e._leave = function (t, e) {
                    var n = this.constructor.DATA_KEY;
                    (e = e || i.default(t.currentTarget).data(n)) || (e = new this.constructor(t.currentTarget, this._getDelegateConfig()), i.default(t.currentTarget).data(n, e)), t && (e._activeTrigger["focusout" === t.type ? la : sa] = !1), e._isWithActiveTrigger() || (clearTimeout(e._timeout), e._hoverState = ea, e.config.delay && e.config.delay.hide ? e._timeout = setTimeout((function () {
                        e._hoverState === ea && e.hide()
                    }), e.config.delay.hide) : e.hide())
                }, e._isWithActiveTrigger = function () {
                    for (var t in this._activeTrigger) if (this._activeTrigger[t]) return !0;
                    return !1
                }, e._getConfig = function (t) {
                    var e = i.default(this.element).data();
                    return Object.keys(e).forEach((function (t) {
                        -1 !== Zn.indexOf(t) && delete e[t]
                    })), "number" == typeof (t = l({}, this.constructor.Default, e, "object" == typeof t && t ? t : {})).delay && (t.delay = {
                        show: t.delay,
                        hide: t.delay
                    }), "number" == typeof t.title && (t.title = t.title.toString()), "number" == typeof t.content && (t.content = t.content.toString()), v.typeCheckConfig(Wn, t, this.constructor.DefaultType), t.sanitize && (t.template = zn(t.template, t.whiteList, t.sanitizeFn)), t
                }, e._getDelegateConfig = function () {
                    var t = {};
                    if (this.config) for (var e in this.config) this.constructor.Default[e] !== this.config[e] && (t[e] = this.config[e]);
                    return t
                }, e._cleanTipClass = function () {
                    var t = i.default(this.getTipElement()), e = t.attr("class").match(Xn);
                    null !== e && e.length && t.removeClass(e.join(""))
                }, e._handlePopperPlacementChange = function (t) {
                    this.tip = t.instance.popper, this._cleanTipClass(), this.addAttachmentClass(this._getAttachment(t.placement))
                }, e._fixTransition = function () {
                    var t = this.getTipElement(), e = this.config.animation;
                    null === t.getAttribute("x-placement") && (i.default(t).removeClass(aa), this.config.animation = !1, this.hide(), this.show(), this.config.animation = e)
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this), a = n.data($n), r = "object" == typeof e && e;
                        if ((a || !/dispose|hide/.test(e)) && (a || (a = new t(this, r), n.data($n, a)), "string" == typeof e)) {
                            if (void 0 === a[e]) throw new TypeError('No method named "' + e + '"');
                            a[e]()
                        }
                    }))
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return Vn
                    }
                }, {
                    key: "Default", get: function () {
                        return Jn
                    }
                }, {
                    key: "NAME", get: function () {
                        return Wn
                    }
                }, {
                    key: "DATA_KEY", get: function () {
                        return $n
                    }
                }, {
                    key: "Event", get: function () {
                        return na
                    }
                }, {
                    key: "EVENT_KEY", get: function () {
                        return Yn
                    }
                }, {
                    key: "DefaultType", get: function () {
                        return Kn
                    }
                }]), t
            }();
        i.default.fn[Wn] = ua._jQueryInterface, i.default.fn[Wn].Constructor = ua, i.default.fn[Wn].noConflict = function () {
            return i.default.fn[Wn] = Un, ua._jQueryInterface
        };
        var ha = "popover", pa = "4.5.3", fa = "bs.popover", ga = "." + fa, ma = i.default.fn[ha], va = "bs-popover",
            ba = new RegExp("(^|\\s)" + va + "\\S+", "g"), ya = l({}, ua.Default, {
                placement: "right",
                trigger: "click",
                content: "",
                template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
            }), xa = l({}, ua.DefaultType, {content: "(string|element|function)"}), _a = "fade", wa = "show",
            Sa = ".popover-header", Ca = ".popover-body", ka = {
                HIDE: "hide" + ga,
                HIDDEN: "hidden" + ga,
                SHOW: "show" + ga,
                SHOWN: "shown" + ga,
                INSERTED: "inserted" + ga,
                CLICK: "click" + ga,
                FOCUSIN: "focusin" + ga,
                FOCUSOUT: "focusout" + ga,
                MOUSEENTER: "mouseenter" + ga,
                MOUSELEAVE: "mouseleave" + ga
            }, Da = function (t) {
                function e() {
                    return t.apply(this, arguments) || this
                }

                c(e, t);
                var n = e.prototype;
                return n.isWithContent = function () {
                    return this.getTitle() || this._getContent()
                }, n.addAttachmentClass = function (t) {
                    i.default(this.getTipElement()).addClass(va + "-" + t)
                }, n.getTipElement = function () {
                    return this.tip = this.tip || i.default(this.config.template)[0], this.tip
                }, n.setContent = function () {
                    var t = i.default(this.getTipElement());
                    this.setElementContent(t.find(Sa), this.getTitle());
                    var e = this._getContent();
                    "function" == typeof e && (e = e.call(this.element)), this.setElementContent(t.find(Ca), e), t.removeClass(_a + " " + wa)
                }, n._getContent = function () {
                    return this.element.getAttribute("data-content") || this.config.content
                }, n._cleanTipClass = function () {
                    var t = i.default(this.getTipElement()), e = t.attr("class").match(ba);
                    null !== e && e.length > 0 && t.removeClass(e.join(""))
                }, e._jQueryInterface = function (t) {
                    return this.each((function () {
                        var n = i.default(this).data(fa), a = "object" == typeof t ? t : null;
                        if ((n || !/dispose|hide/.test(t)) && (n || (n = new e(this, a), i.default(this).data(fa, n)), "string" == typeof t)) {
                            if (void 0 === n[t]) throw new TypeError('No method named "' + t + '"');
                            n[t]()
                        }
                    }))
                }, s(e, null, [{
                    key: "VERSION", get: function () {
                        return pa
                    }
                }, {
                    key: "Default", get: function () {
                        return ya
                    }
                }, {
                    key: "NAME", get: function () {
                        return ha
                    }
                }, {
                    key: "DATA_KEY", get: function () {
                        return fa
                    }
                }, {
                    key: "Event", get: function () {
                        return ka
                    }
                }, {
                    key: "EVENT_KEY", get: function () {
                        return ga
                    }
                }, {
                    key: "DefaultType", get: function () {
                        return xa
                    }
                }]), e
            }(ua);
        i.default.fn[ha] = Da._jQueryInterface, i.default.fn[ha].Constructor = Da, i.default.fn[ha].noConflict = function () {
            return i.default.fn[ha] = ma, Da._jQueryInterface
        };
        var Ta = "scrollspy", Ea = "4.5.3", Aa = "bs.scrollspy", Ia = "." + Aa, Ma = ".data-api", Ra = i.default.fn[Ta],
            Pa = {offset: 10, method: "auto", target: ""},
            Oa = {offset: "number", method: "string", target: "(string|element)"}, ja = "activate" + Ia,
            Na = "scroll" + Ia, La = "load" + Ia + Ma, Fa = "dropdown-item", Ha = "active", Ba = '[data-spy="scroll"]',
            qa = ".nav, .list-group", za = ".nav-link", Wa = ".nav-item", Va = ".list-group-item", $a = ".dropdown",
            Ya = ".dropdown-item", Ua = ".dropdown-toggle", Ga = "offset", Xa = "position", Za = function () {
                function t(t, e) {
                    var n = this;
                    this._element = t, this._scrollElement = "BODY" === t.tagName ? window : t, this._config = this._getConfig(e), this._selector = this._config.target + " " + za + "," + this._config.target + " " + Va + "," + this._config.target + " " + Ya, this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, i.default(this._scrollElement).on(Na, (function (t) {
                        return n._process(t)
                    })), this.refresh(), this._process()
                }

                var e = t.prototype;
                return e.refresh = function () {
                    var t = this, e = this._scrollElement === this._scrollElement.window ? Ga : Xa,
                        n = "auto" === this._config.method ? e : this._config.method,
                        a = n === Xa ? this._getScrollTop() : 0;
                    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), [].slice.call(document.querySelectorAll(this._selector)).map((function (t) {
                        var e, r = v.getSelectorFromElement(t);
                        if (r && (e = document.querySelector(r)), e) {
                            var o = e.getBoundingClientRect();
                            if (o.width || o.height) return [i.default(e)[n]().top + a, r]
                        }
                        return null
                    })).filter((function (t) {
                        return t
                    })).sort((function (t, e) {
                        return t[0] - e[0]
                    })).forEach((function (e) {
                        t._offsets.push(e[0]), t._targets.push(e[1])
                    }))
                }, e.dispose = function () {
                    i.default.removeData(this._element, Aa), i.default(this._scrollElement).off(Ia), this._element = null, this._scrollElement = null, this._config = null, this._selector = null, this._offsets = null, this._targets = null, this._activeTarget = null, this._scrollHeight = null
                }, e._getConfig = function (t) {
                    if ("string" != typeof (t = l({}, Pa, "object" == typeof t && t ? t : {})).target && v.isElement(t.target)) {
                        var e = i.default(t.target).attr("id");
                        e || (e = v.getUID(Ta), i.default(t.target).attr("id", e)), t.target = "#" + e
                    }
                    return v.typeCheckConfig(Ta, t, Oa), t
                }, e._getScrollTop = function () {
                    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop
                }, e._getScrollHeight = function () {
                    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)
                }, e._getOffsetHeight = function () {
                    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height
                }, e._process = function () {
                    var t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(),
                        n = this._config.offset + e - this._getOffsetHeight();
                    if (this._scrollHeight !== e && this.refresh(), t >= n) {
                        var a = this._targets[this._targets.length - 1];
                        this._activeTarget !== a && this._activate(a)
                    } else {
                        if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) return this._activeTarget = null, void this._clear();
                        for (var i = this._offsets.length; i--;) this._activeTarget !== this._targets[i] && t >= this._offsets[i] && (void 0 === this._offsets[i + 1] || t < this._offsets[i + 1]) && this._activate(this._targets[i])
                    }
                }, e._activate = function (t) {
                    this._activeTarget = t, this._clear();
                    var e = this._selector.split(",").map((function (e) {
                        return e + '[data-target="' + t + '"],' + e + '[href="' + t + '"]'
                    })), n = i.default([].slice.call(document.querySelectorAll(e.join(","))));
                    n.hasClass(Fa) ? (n.closest($a).find(Ua).addClass(Ha), n.addClass(Ha)) : (n.addClass(Ha), n.parents(qa).prev(za + ", " + Va).addClass(Ha), n.parents(qa).prev(Wa).children(za).addClass(Ha)), i.default(this._scrollElement).trigger(ja, {relatedTarget: t})
                }, e._clear = function () {
                    [].slice.call(document.querySelectorAll(this._selector)).filter((function (t) {
                        return t.classList.contains(Ha)
                    })).forEach((function (t) {
                        return t.classList.remove(Ha)
                    }))
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this).data(Aa);
                        if (n || (n = new t(this, "object" == typeof e && e), i.default(this).data(Aa, n)), "string" == typeof e) {
                            if (void 0 === n[e]) throw new TypeError('No method named "' + e + '"');
                            n[e]()
                        }
                    }))
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return Ea
                    }
                }, {
                    key: "Default", get: function () {
                        return Pa
                    }
                }]), t
            }();
        i.default(window).on(La, (function () {
            for (var t = [].slice.call(document.querySelectorAll(Ba)), e = t.length; e--;) {
                var n = i.default(t[e]);
                Za._jQueryInterface.call(n, n.data())
            }
        })), i.default.fn[Ta] = Za._jQueryInterface, i.default.fn[Ta].Constructor = Za, i.default.fn[Ta].noConflict = function () {
            return i.default.fn[Ta] = Ra, Za._jQueryInterface
        };
        var Ka = "tab", Qa = "4.5.3", Ja = "bs.tab", ti = "." + Ja, ei = ".data-api", ni = i.default.fn[Ka],
            ai = "hide" + ti, ii = "hidden" + ti, ri = "show" + ti, oi = "shown" + ti, si = "click" + ti + ei,
            li = "dropdown-menu", ci = "active", di = "disabled", ui = "fade", hi = "show", pi = ".dropdown",
            fi = ".nav, .list-group", gi = ".active", mi = "> li > .active",
            vi = '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', bi = ".dropdown-toggle",
            yi = "> .dropdown-menu .active", xi = function () {
                function t(t) {
                    this._element = t
                }

                var e = t.prototype;
                return e.show = function () {
                    var t = this;
                    if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && i.default(this._element).hasClass(ci) || i.default(this._element).hasClass(di))) {
                        var e, n, a = i.default(this._element).closest(fi)[0], r = v.getSelectorFromElement(this._element);
                        if (a) {
                            var o = "UL" === a.nodeName || "OL" === a.nodeName ? mi : gi;
                            n = (n = i.default.makeArray(i.default(a).find(o)))[n.length - 1]
                        }
                        var s = i.default.Event(ai, {relatedTarget: this._element}),
                            l = i.default.Event(ri, {relatedTarget: n});
                        if (n && i.default(n).trigger(s), i.default(this._element).trigger(l), !l.isDefaultPrevented() && !s.isDefaultPrevented()) {
                            r && (e = document.querySelector(r)), this._activate(this._element, a);
                            var c = function () {
                                var e = i.default.Event(ii, {relatedTarget: t._element}),
                                    a = i.default.Event(oi, {relatedTarget: n});
                                i.default(n).trigger(e), i.default(t._element).trigger(a)
                            };
                            e ? this._activate(e, e.parentNode, c) : c()
                        }
                    }
                }, e.dispose = function () {
                    i.default.removeData(this._element, Ja), this._element = null
                }, e._activate = function (t, e, n) {
                    var a = this,
                        r = (!e || "UL" !== e.nodeName && "OL" !== e.nodeName ? i.default(e).children(gi) : i.default(e).find(mi))[0],
                        o = n && r && i.default(r).hasClass(ui), s = function () {
                            return a._transitionComplete(t, r, n)
                        };
                    if (r && o) {
                        var l = v.getTransitionDurationFromElement(r);
                        i.default(r).removeClass(hi).one(v.TRANSITION_END, s).emulateTransitionEnd(l)
                    } else s()
                }, e._transitionComplete = function (t, e, n) {
                    if (e) {
                        i.default(e).removeClass(ci);
                        var a = i.default(e.parentNode).find(yi)[0];
                        a && i.default(a).removeClass(ci), "tab" === e.getAttribute("role") && e.setAttribute("aria-selected", !1)
                    }
                    if (i.default(t).addClass(ci), "tab" === t.getAttribute("role") && t.setAttribute("aria-selected", !0), v.reflow(t), t.classList.contains(ui) && t.classList.add(hi), t.parentNode && i.default(t.parentNode).hasClass(li)) {
                        var r = i.default(t).closest(pi)[0];
                        if (r) {
                            var o = [].slice.call(r.querySelectorAll(bi));
                            i.default(o).addClass(ci)
                        }
                        t.setAttribute("aria-expanded", !0)
                    }
                    n && n()
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this), a = n.data(Ja);
                        if (a || (a = new t(this), n.data(Ja, a)), "string" == typeof e) {
                            if (void 0 === a[e]) throw new TypeError('No method named "' + e + '"');
                            a[e]()
                        }
                    }))
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return Qa
                    }
                }]), t
            }();
        i.default(document).on(si, vi, (function (t) {
            t.preventDefault(), xi._jQueryInterface.call(i.default(this), "show")
        })), i.default.fn[Ka] = xi._jQueryInterface, i.default.fn[Ka].Constructor = xi, i.default.fn[Ka].noConflict = function () {
            return i.default.fn[Ka] = ni, xi._jQueryInterface
        };
        var _i = "toast", wi = "4.5.3", Si = "bs.toast", Ci = "." + Si, ki = i.default.fn[_i],
            Di = "click.dismiss" + Ci, Ti = "hide" + Ci, Ei = "hidden" + Ci, Ai = "show" + Ci, Ii = "shown" + Ci,
            Mi = "fade", Ri = "hide", Pi = "show", Oi = "showing",
            ji = {animation: "boolean", autohide: "boolean", delay: "number"},
            Ni = {animation: !0, autohide: !0, delay: 500}, Li = '[data-dismiss="toast"]', Fi = function () {
                function t(t, e) {
                    this._element = t, this._config = this._getConfig(e), this._timeout = null, this._setListeners()
                }

                var e = t.prototype;
                return e.show = function () {
                    var t = this, e = i.default.Event(Ai);
                    if (i.default(this._element).trigger(e), !e.isDefaultPrevented()) {
                        this._clearTimeout(), this._config.animation && this._element.classList.add(Mi);
                        var n = function () {
                            t._element.classList.remove(Oi), t._element.classList.add(Pi), i.default(t._element).trigger(Ii), t._config.autohide && (t._timeout = setTimeout((function () {
                                t.hide()
                            }), t._config.delay))
                        };
                        if (this._element.classList.remove(Ri), v.reflow(this._element), this._element.classList.add(Oi), this._config.animation) {
                            var a = v.getTransitionDurationFromElement(this._element);
                            i.default(this._element).one(v.TRANSITION_END, n).emulateTransitionEnd(a)
                        } else n()
                    }
                }, e.hide = function () {
                    if (this._element.classList.contains(Pi)) {
                        var t = i.default.Event(Ti);
                        i.default(this._element).trigger(t), t.isDefaultPrevented() || this._close()
                    }
                }, e.dispose = function () {
                    this._clearTimeout(), this._element.classList.contains(Pi) && this._element.classList.remove(Pi), i.default(this._element).off(Di), i.default.removeData(this._element, Si), this._element = null, this._config = null
                }, e._getConfig = function (t) {
                    return t = l({}, Ni, i.default(this._element).data(), "object" == typeof t && t ? t : {}), v.typeCheckConfig(_i, t, this.constructor.DefaultType), t
                }, e._setListeners = function () {
                    var t = this;
                    i.default(this._element).on(Di, Li, (function () {
                        return t.hide()
                    }))
                }, e._close = function () {
                    var t = this, e = function () {
                        t._element.classList.add(Ri), i.default(t._element).trigger(Ei)
                    };
                    if (this._element.classList.remove(Pi), this._config.animation) {
                        var n = v.getTransitionDurationFromElement(this._element);
                        i.default(this._element).one(v.TRANSITION_END, e).emulateTransitionEnd(n)
                    } else e()
                }, e._clearTimeout = function () {
                    clearTimeout(this._timeout), this._timeout = null
                }, t._jQueryInterface = function (e) {
                    return this.each((function () {
                        var n = i.default(this), a = n.data(Si);
                        if (a || (a = new t(this, "object" == typeof e && e), n.data(Si, a)), "string" == typeof e) {
                            if (void 0 === a[e]) throw new TypeError('No method named "' + e + '"');
                            a[e](this)
                        }
                    }))
                }, s(t, null, [{
                    key: "VERSION", get: function () {
                        return wi
                    }
                }, {
                    key: "DefaultType", get: function () {
                        return ji
                    }
                }, {
                    key: "Default", get: function () {
                        return Ni
                    }
                }]), t
            }();
        i.default.fn[_i] = Fi._jQueryInterface, i.default.fn[_i].Constructor = Fi, i.default.fn[_i].noConflict = function () {
            return i.default.fn[_i] = ki, Fi._jQueryInterface
        }, t.Alert = M, t.Button = K, t.Carousel = Vt, t.Collapse = he, t.Dropdown = tn, t.Modal = Nn, t.Popover = Da, t.Scrollspy = Za, t.Tab = xi, t.Toast = Fi, t.Tooltip = ua, t.Util = v, Object.defineProperty(t, "__esModule", {value: !0})
    }(e, n(16), n(162))
}, function (t, e, n) {
    "use strict";
    n.r(e), function (t) {
        var n = "undefined" != typeof window && "undefined" != typeof document && "undefined" != typeof navigator,
            a = function () {
                for (var t = ["Edge", "Trident", "Firefox"], e = 0; e < t.length; e += 1) if (n && navigator.userAgent.indexOf(t[e]) >= 0) return 1;
                return 0
            }();
        var i = n && window.Promise ? function (t) {
            var e = !1;
            return function () {
                e || (e = !0, window.Promise.resolve().then((function () {
                    e = !1, t()
                })))
            }
        } : function (t) {
            var e = !1;
            return function () {
                e || (e = !0, setTimeout((function () {
                    e = !1, t()
                }), a))
            }
        };

        function r(t) {
            return t && "[object Function]" === {}.toString.call(t)
        }

        function o(t, e) {
            if (1 !== t.nodeType) return [];
            var n = t.ownerDocument.defaultView.getComputedStyle(t, null);
            return e ? n[e] : n
        }

        function s(t) {
            return "HTML" === t.nodeName ? t : t.parentNode || t.host
        }

        function l(t) {
            if (!t) return document.body;
            switch (t.nodeName) {
                case"HTML":
                case"BODY":
                    return t.ownerDocument.body;
                case"#document":
                    return t.body
            }
            var e = o(t), n = e.overflow, a = e.overflowX, i = e.overflowY;
            return /(auto|scroll|overlay)/.test(n + i + a) ? t : l(s(t))
        }

        function c(t) {
            return t && t.referenceNode ? t.referenceNode : t
        }

        var d = n && !(!window.MSInputMethodContext || !document.documentMode),
            u = n && /MSIE 10/.test(navigator.userAgent);

        function h(t) {
            return 11 === t ? d : 10 === t ? u : d || u
        }

        function p(t) {
            if (!t) return document.documentElement;
            for (var e = h(10) ? document.body : null, n = t.offsetParent || null; n === e && t.nextElementSibling;) n = (t = t.nextElementSibling).offsetParent;
            var a = n && n.nodeName;
            return a && "BODY" !== a && "HTML" !== a ? -1 !== ["TH", "TD", "TABLE"].indexOf(n.nodeName) && "static" === o(n, "position") ? p(n) : n : t ? t.ownerDocument.documentElement : document.documentElement
        }

        function f(t) {
            return null !== t.parentNode ? f(t.parentNode) : t
        }

        function g(t, e) {
            if (!(t && t.nodeType && e && e.nodeType)) return document.documentElement;
            var n = t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_FOLLOWING, a = n ? t : e, i = n ? e : t,
                r = document.createRange();
            r.setStart(a, 0), r.setEnd(i, 0);
            var o, s, l = r.commonAncestorContainer;
            if (t !== l && e !== l || a.contains(i)) return "BODY" === (s = (o = l).nodeName) || "HTML" !== s && p(o.firstElementChild) !== o ? p(l) : l;
            var c = f(t);
            return c.host ? g(c.host, e) : g(t, f(e).host)
        }

        function m(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "top",
                n = "top" === e ? "scrollTop" : "scrollLeft", a = t.nodeName;
            if ("BODY" === a || "HTML" === a) {
                var i = t.ownerDocument.documentElement, r = t.ownerDocument.scrollingElement || i;
                return r[n]
            }
            return t[n]
        }

        function v(t, e) {
            var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], a = m(e, "top"), i = m(e, "left"),
                r = n ? -1 : 1;
            return t.top += a * r, t.bottom += a * r, t.left += i * r, t.right += i * r, t
        }

        function b(t, e) {
            var n = "x" === e ? "Left" : "Top", a = "Left" === n ? "Right" : "Bottom";
            return parseFloat(t["border" + n + "Width"]) + parseFloat(t["border" + a + "Width"])
        }

        function y(t, e, n, a) {
            return Math.max(e["offset" + t], e["scroll" + t], n["client" + t], n["offset" + t], n["scroll" + t], h(10) ? parseInt(n["offset" + t]) + parseInt(a["margin" + ("Height" === t ? "Top" : "Left")]) + parseInt(a["margin" + ("Height" === t ? "Bottom" : "Right")]) : 0)
        }

        function x(t) {
            var e = t.body, n = t.documentElement, a = h(10) && getComputedStyle(n);
            return {height: y("Height", e, n, a), width: y("Width", e, n, a)}
        }

        var _ = function (t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
        }, w = function () {
            function t(t, e) {
                for (var n = 0; n < e.length; n++) {
                    var a = e[n];
                    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
                }
            }

            return function (e, n, a) {
                return n && t(e.prototype, n), a && t(e, a), e
            }
        }(), S = function (t, e, n) {
            return e in t ? Object.defineProperty(t, e, {
                value: n,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = n, t
        }, C = Object.assign || function (t) {
            for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a])
            }
            return t
        };

        function k(t) {
            return C({}, t, {right: t.left + t.width, bottom: t.top + t.height})
        }

        function D(t) {
            var e = {};
            try {
                if (h(10)) {
                    e = t.getBoundingClientRect();
                    var n = m(t, "top"), a = m(t, "left");
                    e.top += n, e.left += a, e.bottom += n, e.right += a
                } else e = t.getBoundingClientRect()
            } catch (t) {
            }
            var i = {left: e.left, top: e.top, width: e.right - e.left, height: e.bottom - e.top},
                r = "HTML" === t.nodeName ? x(t.ownerDocument) : {}, s = r.width || t.clientWidth || i.width,
                l = r.height || t.clientHeight || i.height, c = t.offsetWidth - s, d = t.offsetHeight - l;
            if (c || d) {
                var u = o(t);
                c -= b(u, "x"), d -= b(u, "y"), i.width -= c, i.height -= d
            }
            return k(i)
        }

        function T(t, e) {
            var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2], a = h(10),
                i = "HTML" === e.nodeName, r = D(t), s = D(e), c = l(t), d = o(e), u = parseFloat(d.borderTopWidth),
                p = parseFloat(d.borderLeftWidth);
            n && i && (s.top = Math.max(s.top, 0), s.left = Math.max(s.left, 0));
            var f = k({top: r.top - s.top - u, left: r.left - s.left - p, width: r.width, height: r.height});
            if (f.marginTop = 0, f.marginLeft = 0, !a && i) {
                var g = parseFloat(d.marginTop), m = parseFloat(d.marginLeft);
                f.top -= u - g, f.bottom -= u - g, f.left -= p - m, f.right -= p - m, f.marginTop = g, f.marginLeft = m
            }
            return (a && !n ? e.contains(c) : e === c && "BODY" !== c.nodeName) && (f = v(f, e)), f
        }

        function E(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                n = t.ownerDocument.documentElement, a = T(t, n), i = Math.max(n.clientWidth, window.innerWidth || 0),
                r = Math.max(n.clientHeight, window.innerHeight || 0), o = e ? 0 : m(n), s = e ? 0 : m(n, "left"),
                l = {top: o - a.top + a.marginTop, left: s - a.left + a.marginLeft, width: i, height: r};
            return k(l)
        }

        function A(t) {
            var e = t.nodeName;
            if ("BODY" === e || "HTML" === e) return !1;
            if ("fixed" === o(t, "position")) return !0;
            var n = s(t);
            return !!n && A(n)
        }

        function I(t) {
            if (!t || !t.parentElement || h()) return document.documentElement;
            for (var e = t.parentElement; e && "none" === o(e, "transform");) e = e.parentElement;
            return e || document.documentElement
        }

        function M(t, e, n, a) {
            var i = arguments.length > 4 && void 0 !== arguments[4] && arguments[4], r = {top: 0, left: 0},
                o = i ? I(t) : g(t, c(e));
            if ("viewport" === a) r = E(o, i); else {
                var d = void 0;
                "scrollParent" === a ? "BODY" === (d = l(s(e))).nodeName && (d = t.ownerDocument.documentElement) : d = "window" === a ? t.ownerDocument.documentElement : a;
                var u = T(d, o, i);
                if ("HTML" !== d.nodeName || A(o)) r = u; else {
                    var h = x(t.ownerDocument), p = h.height, f = h.width;
                    r.top += u.top - u.marginTop, r.bottom = p + u.top, r.left += u.left - u.marginLeft, r.right = f + u.left
                }
            }
            var m = "number" == typeof (n = n || 0);
            return r.left += m ? n : n.left || 0, r.top += m ? n : n.top || 0, r.right -= m ? n : n.right || 0, r.bottom -= m ? n : n.bottom || 0, r
        }

        function R(t) {
            return t.width * t.height
        }

        function P(t, e, n, a, i) {
            var r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0;
            if (-1 === t.indexOf("auto")) return t;
            var o = M(n, a, r, i), s = {
                top: {width: o.width, height: e.top - o.top},
                right: {width: o.right - e.right, height: o.height},
                bottom: {width: o.width, height: o.bottom - e.bottom},
                left: {width: e.left - o.left, height: o.height}
            }, l = Object.keys(s).map((function (t) {
                return C({key: t}, s[t], {area: R(s[t])})
            })).sort((function (t, e) {
                return e.area - t.area
            })), c = l.filter((function (t) {
                var e = t.width, a = t.height;
                return e >= n.clientWidth && a >= n.clientHeight
            })), d = c.length > 0 ? c[0].key : l[0].key, u = t.split("-")[1];
            return d + (u ? "-" + u : "")
        }

        function O(t, e, n) {
            var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, i = a ? I(e) : g(e, c(n));
            return T(n, i, a)
        }

        function j(t) {
            var e = t.ownerDocument.defaultView.getComputedStyle(t),
                n = parseFloat(e.marginTop || 0) + parseFloat(e.marginBottom || 0),
                a = parseFloat(e.marginLeft || 0) + parseFloat(e.marginRight || 0);
            return {width: t.offsetWidth + a, height: t.offsetHeight + n}
        }

        function N(t) {
            var e = {left: "right", right: "left", bottom: "top", top: "bottom"};
            return t.replace(/left|right|bottom|top/g, (function (t) {
                return e[t]
            }))
        }

        function L(t, e, n) {
            n = n.split("-")[0];
            var a = j(t), i = {width: a.width, height: a.height}, r = -1 !== ["right", "left"].indexOf(n),
                o = r ? "top" : "left", s = r ? "left" : "top", l = r ? "height" : "width", c = r ? "width" : "height";
            return i[o] = e[o] + e[l] / 2 - a[l] / 2, i[s] = n === s ? e[s] - a[c] : e[N(s)], i
        }

        function F(t, e) {
            return Array.prototype.find ? t.find(e) : t.filter(e)[0]
        }

        function H(t, e, n) {
            return (void 0 === n ? t : t.slice(0, function (t, e, n) {
                if (Array.prototype.findIndex) return t.findIndex((function (t) {
                    return t[e] === n
                }));
                var a = F(t, (function (t) {
                    return t[e] === n
                }));
                return t.indexOf(a)
            }(t, "name", n))).forEach((function (t) {
                t.function && console.warn("`modifier.function` is deprecated, use `modifier.fn`!");
                var n = t.function || t.fn;
                t.enabled && r(n) && (e.offsets.popper = k(e.offsets.popper), e.offsets.reference = k(e.offsets.reference), e = n(e, t))
            })), e
        }

        function B() {
            if (!this.state.isDestroyed) {
                var t = {instance: this, styles: {}, arrowStyles: {}, attributes: {}, flipped: !1, offsets: {}};
                t.offsets.reference = O(this.state, this.popper, this.reference, this.options.positionFixed), t.placement = P(this.options.placement, t.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), t.originalPlacement = t.placement, t.positionFixed = this.options.positionFixed, t.offsets.popper = L(this.popper, t.offsets.reference, t.placement), t.offsets.popper.position = this.options.positionFixed ? "fixed" : "absolute", t = H(this.modifiers, t), this.state.isCreated ? this.options.onUpdate(t) : (this.state.isCreated = !0, this.options.onCreate(t))
            }
        }

        function q(t, e) {
            return t.some((function (t) {
                var n = t.name;
                return t.enabled && n === e
            }))
        }

        function z(t) {
            for (var e = [!1, "ms", "Webkit", "Moz", "O"], n = t.charAt(0).toUpperCase() + t.slice(1), a = 0; a < e.length; a++) {
                var i = e[a], r = i ? "" + i + n : t;
                if (void 0 !== document.body.style[r]) return r
            }
            return null
        }

        function W() {
            return this.state.isDestroyed = !0, q(this.modifiers, "applyStyle") && (this.popper.removeAttribute("x-placement"), this.popper.style.position = "", this.popper.style.top = "", this.popper.style.left = "", this.popper.style.right = "", this.popper.style.bottom = "", this.popper.style.willChange = "", this.popper.style[z("transform")] = ""), this.disableEventListeners(), this.options.removeOnDestroy && this.popper.parentNode.removeChild(this.popper), this
        }

        function V(t) {
            var e = t.ownerDocument;
            return e ? e.defaultView : window
        }

        function $(t, e, n, a) {
            var i = "BODY" === t.nodeName, r = i ? t.ownerDocument.defaultView : t;
            r.addEventListener(e, n, {passive: !0}), i || $(l(r.parentNode), e, n, a), a.push(r)
        }

        function Y(t, e, n, a) {
            n.updateBound = a, V(t).addEventListener("resize", n.updateBound, {passive: !0});
            var i = l(t);
            return $(i, "scroll", n.updateBound, n.scrollParents), n.scrollElement = i, n.eventsEnabled = !0, n
        }

        function U() {
            this.state.eventsEnabled || (this.state = Y(this.reference, this.options, this.state, this.scheduleUpdate))
        }

        function G() {
            var t, e;
            this.state.eventsEnabled && (cancelAnimationFrame(this.scheduleUpdate), this.state = (t = this.reference, e = this.state, V(t).removeEventListener("resize", e.updateBound), e.scrollParents.forEach((function (t) {
                t.removeEventListener("scroll", e.updateBound)
            })), e.updateBound = null, e.scrollParents = [], e.scrollElement = null, e.eventsEnabled = !1, e))
        }

        function X(t) {
            return "" !== t && !isNaN(parseFloat(t)) && isFinite(t)
        }

        function Z(t, e) {
            Object.keys(e).forEach((function (n) {
                var a = "";
                -1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(n) && X(e[n]) && (a = "px"), t.style[n] = e[n] + a
            }))
        }

        var K = n && /Firefox/i.test(navigator.userAgent);

        function Q(t, e, n) {
            var a = F(t, (function (t) {
                return t.name === e
            })), i = !!a && t.some((function (t) {
                return t.name === n && t.enabled && t.order < a.order
            }));
            if (!i) {
                var r = "`" + e + "`", o = "`" + n + "`";
                console.warn(o + " modifier is required by " + r + " modifier in order to work, be sure to include it before " + r + "!")
            }
            return i
        }

        var J = ["auto-start", "auto", "auto-end", "top-start", "top", "top-end", "right-start", "right", "right-end", "bottom-end", "bottom", "bottom-start", "left-end", "left", "left-start"],
            tt = J.slice(3);

        function et(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n = tt.indexOf(t),
                a = tt.slice(n + 1).concat(tt.slice(0, n));
            return e ? a.reverse() : a
        }

        var nt = "flip", at = "clockwise", it = "counterclockwise";

        function rt(t, e, n, a) {
            var i = [0, 0], r = -1 !== ["right", "left"].indexOf(a), o = t.split(/(\+|\-)/).map((function (t) {
                return t.trim()
            })), s = o.indexOf(F(o, (function (t) {
                return -1 !== t.search(/,|\s/)
            })));
            o[s] && -1 === o[s].indexOf(",") && console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");
            var l = /\s*,\s*|\s+/,
                c = -1 !== s ? [o.slice(0, s).concat([o[s].split(l)[0]]), [o[s].split(l)[1]].concat(o.slice(s + 1))] : [o];
            return (c = c.map((function (t, a) {
                var i = (1 === a ? !r : r) ? "height" : "width", o = !1;
                return t.reduce((function (t, e) {
                    return "" === t[t.length - 1] && -1 !== ["+", "-"].indexOf(e) ? (t[t.length - 1] = e, o = !0, t) : o ? (t[t.length - 1] += e, o = !1, t) : t.concat(e)
                }), []).map((function (t) {
                    return function (t, e, n, a) {
                        var i = t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/), r = +i[1], o = i[2];
                        if (!r) return t;
                        if (0 === o.indexOf("%")) {
                            var s = void 0;
                            switch (o) {
                                case"%p":
                                    s = n;
                                    break;
                                case"%":
                                case"%r":
                                default:
                                    s = a
                            }
                            return k(s)[e] / 100 * r
                        }
                        if ("vh" === o || "vw" === o) return ("vh" === o ? Math.max(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0)) / 100 * r;
                        return r
                    }(t, i, e, n)
                }))
            }))).forEach((function (t, e) {
                t.forEach((function (n, a) {
                    X(n) && (i[e] += n * ("-" === t[a - 1] ? -1 : 1))
                }))
            })), i
        }

        var ot = {
            placement: "bottom", positionFixed: !1, eventsEnabled: !0, removeOnDestroy: !1, onCreate: function () {
            }, onUpdate: function () {
            }, modifiers: {
                shift: {
                    order: 100, enabled: !0, fn: function (t) {
                        var e = t.placement, n = e.split("-")[0], a = e.split("-")[1];
                        if (a) {
                            var i = t.offsets, r = i.reference, o = i.popper, s = -1 !== ["bottom", "top"].indexOf(n),
                                l = s ? "left" : "top", c = s ? "width" : "height",
                                d = {start: S({}, l, r[l]), end: S({}, l, r[l] + r[c] - o[c])};
                            t.offsets.popper = C({}, o, d[a])
                        }
                        return t
                    }
                }, offset: {
                    order: 200, enabled: !0, fn: function (t, e) {
                        var n = e.offset, a = t.placement, i = t.offsets, r = i.popper, o = i.reference,
                            s = a.split("-")[0], l = void 0;
                        return l = X(+n) ? [+n, 0] : rt(n, r, o, s), "left" === s ? (r.top += l[0], r.left -= l[1]) : "right" === s ? (r.top += l[0], r.left += l[1]) : "top" === s ? (r.left += l[0], r.top -= l[1]) : "bottom" === s && (r.left += l[0], r.top += l[1]), t.popper = r, t
                    }, offset: 0
                }, preventOverflow: {
                    order: 300, enabled: !0, fn: function (t, e) {
                        var n = e.boundariesElement || p(t.instance.popper);
                        t.instance.reference === n && (n = p(n));
                        var a = z("transform"), i = t.instance.popper.style, r = i.top, o = i.left, s = i[a];
                        i.top = "", i.left = "", i[a] = "";
                        var l = M(t.instance.popper, t.instance.reference, e.padding, n, t.positionFixed);
                        i.top = r, i.left = o, i[a] = s, e.boundaries = l;
                        var c = e.priority, d = t.offsets.popper, u = {
                            primary: function (t) {
                                var n = d[t];
                                return d[t] < l[t] && !e.escapeWithReference && (n = Math.max(d[t], l[t])), S({}, t, n)
                            }, secondary: function (t) {
                                var n = "right" === t ? "left" : "top", a = d[n];
                                return d[t] > l[t] && !e.escapeWithReference && (a = Math.min(d[n], l[t] - ("right" === t ? d.width : d.height))), S({}, n, a)
                            }
                        };
                        return c.forEach((function (t) {
                            var e = -1 !== ["left", "top"].indexOf(t) ? "primary" : "secondary";
                            d = C({}, d, u[e](t))
                        })), t.offsets.popper = d, t
                    }, priority: ["left", "right", "top", "bottom"], padding: 5, boundariesElement: "scrollParent"
                }, keepTogether: {
                    order: 400, enabled: !0, fn: function (t) {
                        var e = t.offsets, n = e.popper, a = e.reference, i = t.placement.split("-")[0], r = Math.floor,
                            o = -1 !== ["top", "bottom"].indexOf(i), s = o ? "right" : "bottom", l = o ? "left" : "top",
                            c = o ? "width" : "height";
                        return n[s] < r(a[l]) && (t.offsets.popper[l] = r(a[l]) - n[c]), n[l] > r(a[s]) && (t.offsets.popper[l] = r(a[s])), t
                    }
                }, arrow: {
                    order: 500, enabled: !0, fn: function (t, e) {
                        var n;
                        if (!Q(t.instance.modifiers, "arrow", "keepTogether")) return t;
                        var a = e.element;
                        if ("string" == typeof a) {
                            if (!(a = t.instance.popper.querySelector(a))) return t
                        } else if (!t.instance.popper.contains(a)) return console.warn("WARNING: `arrow.element` must be child of its popper element!"), t;
                        var i = t.placement.split("-")[0], r = t.offsets, s = r.popper, l = r.reference,
                            c = -1 !== ["left", "right"].indexOf(i), d = c ? "height" : "width", u = c ? "Top" : "Left",
                            h = u.toLowerCase(), p = c ? "left" : "top", f = c ? "bottom" : "right", g = j(a)[d];
                        l[f] - g < s[h] && (t.offsets.popper[h] -= s[h] - (l[f] - g)), l[h] + g > s[f] && (t.offsets.popper[h] += l[h] + g - s[f]), t.offsets.popper = k(t.offsets.popper);
                        var m = l[h] + l[d] / 2 - g / 2, v = o(t.instance.popper), b = parseFloat(v["margin" + u]),
                            y = parseFloat(v["border" + u + "Width"]), x = m - t.offsets.popper[h] - b - y;
                        return x = Math.max(Math.min(s[d] - g, x), 0), t.arrowElement = a, t.offsets.arrow = (S(n = {}, h, Math.round(x)), S(n, p, ""), n), t
                    }, element: "[x-arrow]"
                }, flip: {
                    order: 600,
                    enabled: !0,
                    fn: function (t, e) {
                        if (q(t.instance.modifiers, "inner")) return t;
                        if (t.flipped && t.placement === t.originalPlacement) return t;
                        var n = M(t.instance.popper, t.instance.reference, e.padding, e.boundariesElement, t.positionFixed),
                            a = t.placement.split("-")[0], i = N(a), r = t.placement.split("-")[1] || "", o = [];
                        switch (e.behavior) {
                            case nt:
                                o = [a, i];
                                break;
                            case at:
                                o = et(a);
                                break;
                            case it:
                                o = et(a, !0);
                                break;
                            default:
                                o = e.behavior
                        }
                        return o.forEach((function (s, l) {
                            if (a !== s || o.length === l + 1) return t;
                            a = t.placement.split("-")[0], i = N(a);
                            var c = t.offsets.popper, d = t.offsets.reference, u = Math.floor,
                                h = "left" === a && u(c.right) > u(d.left) || "right" === a && u(c.left) < u(d.right) || "top" === a && u(c.bottom) > u(d.top) || "bottom" === a && u(c.top) < u(d.bottom),
                                p = u(c.left) < u(n.left), f = u(c.right) > u(n.right), g = u(c.top) < u(n.top),
                                m = u(c.bottom) > u(n.bottom),
                                v = "left" === a && p || "right" === a && f || "top" === a && g || "bottom" === a && m,
                                b = -1 !== ["top", "bottom"].indexOf(a),
                                y = !!e.flipVariations && (b && "start" === r && p || b && "end" === r && f || !b && "start" === r && g || !b && "end" === r && m),
                                x = !!e.flipVariationsByContent && (b && "start" === r && f || b && "end" === r && p || !b && "start" === r && m || !b && "end" === r && g),
                                _ = y || x;
                            (h || v || _) && (t.flipped = !0, (h || v) && (a = o[l + 1]), _ && (r = function (t) {
                                return "end" === t ? "start" : "start" === t ? "end" : t
                            }(r)), t.placement = a + (r ? "-" + r : ""), t.offsets.popper = C({}, t.offsets.popper, L(t.instance.popper, t.offsets.reference, t.placement)), t = H(t.instance.modifiers, t, "flip"))
                        })), t
                    },
                    behavior: "flip",
                    padding: 5,
                    boundariesElement: "viewport",
                    flipVariations: !1,
                    flipVariationsByContent: !1
                }, inner: {
                    order: 700, enabled: !1, fn: function (t) {
                        var e = t.placement, n = e.split("-")[0], a = t.offsets, i = a.popper, r = a.reference,
                            o = -1 !== ["left", "right"].indexOf(n), s = -1 === ["top", "left"].indexOf(n);
                        return i[o ? "left" : "top"] = r[n] - (s ? i[o ? "width" : "height"] : 0), t.placement = N(e), t.offsets.popper = k(i), t
                    }
                }, hide: {
                    order: 800, enabled: !0, fn: function (t) {
                        if (!Q(t.instance.modifiers, "hide", "preventOverflow")) return t;
                        var e = t.offsets.reference, n = F(t.instance.modifiers, (function (t) {
                            return "preventOverflow" === t.name
                        })).boundaries;
                        if (e.bottom < n.top || e.left > n.right || e.top > n.bottom || e.right < n.left) {
                            if (!0 === t.hide) return t;
                            t.hide = !0, t.attributes["x-out-of-boundaries"] = ""
                        } else {
                            if (!1 === t.hide) return t;
                            t.hide = !1, t.attributes["x-out-of-boundaries"] = !1
                        }
                        return t
                    }
                }, computeStyle: {
                    order: 850, enabled: !0, fn: function (t, e) {
                        var n = e.x, a = e.y, i = t.offsets.popper, r = F(t.instance.modifiers, (function (t) {
                            return "applyStyle" === t.name
                        })).gpuAcceleration;
                        void 0 !== r && console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");
                        var o = void 0 !== r ? r : e.gpuAcceleration, s = p(t.instance.popper), l = D(s),
                            c = {position: i.position}, d = function (t, e) {
                                var n = t.offsets, a = n.popper, i = n.reference, r = Math.round, o = Math.floor,
                                    s = function (t) {
                                        return t
                                    }, l = r(i.width), c = r(a.width), d = -1 !== ["left", "right"].indexOf(t.placement),
                                    u = -1 !== t.placement.indexOf("-"), h = e ? d || u || l % 2 == c % 2 ? r : o : s,
                                    p = e ? r : s;
                                return {
                                    left: h(l % 2 == 1 && c % 2 == 1 && !u && e ? a.left - 1 : a.left),
                                    top: p(a.top),
                                    bottom: p(a.bottom),
                                    right: h(a.right)
                                }
                            }(t, window.devicePixelRatio < 2 || !K), u = "bottom" === n ? "top" : "bottom",
                            h = "right" === a ? "left" : "right", f = z("transform"), g = void 0, m = void 0;
                        if (m = "bottom" === u ? "HTML" === s.nodeName ? -s.clientHeight + d.bottom : -l.height + d.bottom : d.top, g = "right" === h ? "HTML" === s.nodeName ? -s.clientWidth + d.right : -l.width + d.right : d.left, o && f) c[f] = "translate3d(" + g + "px, " + m + "px, 0)", c[u] = 0, c[h] = 0, c.willChange = "transform"; else {
                            var v = "bottom" === u ? -1 : 1, b = "right" === h ? -1 : 1;
                            c[u] = m * v, c[h] = g * b, c.willChange = u + ", " + h
                        }
                        var y = {"x-placement": t.placement};
                        return t.attributes = C({}, y, t.attributes), t.styles = C({}, c, t.styles), t.arrowStyles = C({}, t.offsets.arrow, t.arrowStyles), t
                    }, gpuAcceleration: !0, x: "bottom", y: "right"
                }, applyStyle: {
                    order: 900, enabled: !0, fn: function (t) {
                        var e, n;
                        return Z(t.instance.popper, t.styles), e = t.instance.popper, n = t.attributes, Object.keys(n).forEach((function (t) {
                            !1 !== n[t] ? e.setAttribute(t, n[t]) : e.removeAttribute(t)
                        })), t.arrowElement && Object.keys(t.arrowStyles).length && Z(t.arrowElement, t.arrowStyles), t
                    }, onLoad: function (t, e, n, a, i) {
                        var r = O(i, e, t, n.positionFixed),
                            o = P(n.placement, r, e, t, n.modifiers.flip.boundariesElement, n.modifiers.flip.padding);
                        return e.setAttribute("x-placement", o), Z(e, {position: n.positionFixed ? "fixed" : "absolute"}), n
                    }, gpuAcceleration: void 0
                }
            }
        }, st = function () {
            function t(e, n) {
                var a = this, o = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                _(this, t), this.scheduleUpdate = function () {
                    return requestAnimationFrame(a.update)
                }, this.update = i(this.update.bind(this)), this.options = C({}, t.Defaults, o), this.state = {
                    isDestroyed: !1,
                    isCreated: !1,
                    scrollParents: []
                }, this.reference = e && e.jquery ? e[0] : e, this.popper = n && n.jquery ? n[0] : n, this.options.modifiers = {}, Object.keys(C({}, t.Defaults.modifiers, o.modifiers)).forEach((function (e) {
                    a.options.modifiers[e] = C({}, t.Defaults.modifiers[e] || {}, o.modifiers ? o.modifiers[e] : {})
                })), this.modifiers = Object.keys(this.options.modifiers).map((function (t) {
                    return C({name: t}, a.options.modifiers[t])
                })).sort((function (t, e) {
                    return t.order - e.order
                })), this.modifiers.forEach((function (t) {
                    t.enabled && r(t.onLoad) && t.onLoad(a.reference, a.popper, a.options, t, a.state)
                })), this.update();
                var s = this.options.eventsEnabled;
                s && this.enableEventListeners(), this.state.eventsEnabled = s
            }

            return w(t, [{
                key: "update", value: function () {
                    return B.call(this)
                }
            }, {
                key: "destroy", value: function () {
                    return W.call(this)
                }
            }, {
                key: "enableEventListeners", value: function () {
                    return U.call(this)
                }
            }, {
                key: "disableEventListeners", value: function () {
                    return G.call(this)
                }
            }]), t
        }();
        st.Utils = ("undefined" != typeof window ? window : t).PopperUtils, st.placements = J, st.Defaults = ot, e.default = st
    }.call(this, n(3))
}, function (t, e, n) {
    var a = n(8), i = n(164), r = n(11), o = n(65), s = n(81);
    a(a.S, "Object", {
        getOwnPropertyDescriptors: function (t) {
            for (var e, n, a = r(t), l = o.f, c = i(a), d = {}, u = 0; c.length > u;) void 0 !== (n = l(a, e = c[u++])) && s(d, e, n);
            return d
        }
    })
}, function (t, e, n) {
    var a = n(42), i = n(43), r = n(2), o = n(1).Reflect;
    t.exports = o && o.ownKeys || function (t) {
        var e = a.f(r(t)), n = i.f;
        return n ? e.concat(n(t)) : e
    }
}, function (t, e, n) {
    "use strict";
    var a = n(96), i = n(2), r = n(166), o = n(68), s = n(33), l = n(70), c = n(45), d = n(9), u = Math.min,
        h = [].push, p = 4294967295, f = !d((function () {
            RegExp(p, "y")
        }));
    n(71)("split", 2, (function (t, e, n, d) {
        var g;
        return g = "c" == "abbc".split(/(b)*/)[1] || 4 != "test".split(/(?:)/, -1).length || 2 != "ab".split(/(?:ab)*/).length || 4 != ".".split(/(.?)(.?)/).length || ".".split(/()()/).length > 1 || "".split(/.?/).length ? function (t, e) {
            var i = String(this);
            if (void 0 === t && 0 === e) return [];
            if (!a(t)) return n.call(i, t, e);
            for (var r, o, s, l = [], d = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), u = 0, f = void 0 === e ? p : e >>> 0, g = new RegExp(t.source, d + "g"); (r = c.call(g, i)) && !((o = g.lastIndex) > u && (l.push(i.slice(u, r.index)), r.length > 1 && r.index < i.length && h.apply(l, r.slice(1)), s = r[0].length, u = o, l.length >= f));) g.lastIndex === r.index && g.lastIndex++;
            return u === i.length ? !s && g.test("") || l.push("") : l.push(i.slice(u)), l.length > f ? l.slice(0, f) : l
        } : "0".split(void 0, 0).length ? function (t, e) {
            return void 0 === t && 0 === e ? [] : n.call(this, t, e)
        } : n, [function (n, a) {
            var i = t(this), r = null == n ? void 0 : n[e];
            return void 0 !== r ? r.call(n, i, a) : g.call(String(i), n, a)
        }, function (t, e) {
            var a = d(g, t, this, e, g !== n);
            if (a.done) return a.value;
            var c = i(t), h = String(this), m = r(c, RegExp), v = c.unicode,
                b = (c.ignoreCase ? "i" : "") + (c.multiline ? "m" : "") + (c.unicode ? "u" : "") + (f ? "y" : "g"),
                y = new m(f ? c : "^(?:" + c.source + ")", b), x = void 0 === e ? p : e >>> 0;
            if (0 === x) return [];
            if (0 === h.length) return null === l(y, h) ? [h] : [];
            for (var _ = 0, w = 0, S = []; w < h.length;) {
                y.lastIndex = f ? w : 0;
                var C, k = l(y, f ? h : h.slice(w));
                if (null === k || (C = u(s(y.lastIndex + (f ? 0 : w)), h.length)) === _) w = o(h, w, v); else {
                    if (S.push(h.slice(_, w)), S.length === x) return S;
                    for (var D = 1; D <= k.length - 1; D++) if (S.push(k[D]), S.length === x) return S;
                    w = _ = C
                }
            }
            return S.push(h.slice(_)), S
        }]
    }))
}, function (t, e, n) {
    var a = n(2), i = n(62), r = n(0)("species");
    t.exports = function (t, e) {
        var n, o = a(t).constructor;
        return void 0 === o || null == (n = a(o)[r]) ? e : i(n)
    }
}, function (t, e, n) {
    "use strict";
    var a = n(168), i = n(169);
    t.exports = function (t, e) {
        var n = e || {}, r = {};
        return void 0 === t && (t = {}), t.on = function (e, n) {
            return r[e] ? r[e].push(n) : r[e] = [n], t
        }, t.once = function (e, n) {
            return n._once = !0, t.on(e, n), t
        }, t.off = function (e, n) {
            var a = arguments.length;
            if (1 === a) delete r[e]; else if (0 === a) r = {}; else {
                var i = r[e];
                if (!i) return t;
                i.splice(i.indexOf(n), 1)
            }
            return t
        }, t.emit = function () {
            var e = a(arguments);
            return t.emitterSnapshot(e.shift()).apply(this, e)
        }, t.emitterSnapshot = function (e) {
            var o = (r[e] || []).slice(0);
            return function () {
                var r = a(arguments), s = this || t;
                if ("error" === e && !1 !== n.throws && !o.length) throw 1 === r.length ? r[0] : r;
                return o.forEach((function (a) {
                    n.async ? i(a, r, s) : a.apply(s, r), a._once && t.off(e, a)
                })), t
            }
        }, t
    }
}, function (t, e) {
    t.exports = function (t, e) {
        return Array.prototype.slice.call(t, e)
    }
}, function (t, e, n) {
    "use strict";
    var a = n(170);
    t.exports = function (t, e, n) {
        t && a((function () {
            t.apply(n || null, e || [])
        }))
    }
}, function (t, e, n) {
    (function (e) {
        var n;
        n = "function" == typeof e ? function (t) {
            e(t)
        } : function (t) {
            setTimeout(t, 0)
        }, t.exports = n
    }).call(this, n(171).setImmediate)
}, function (t, e, n) {
    (function (t) {
        var a = void 0 !== t && t || "undefined" != typeof self && self || window, i = Function.prototype.apply;

        function r(t, e) {
            this._id = t, this._clearFn = e
        }

        e.setTimeout = function () {
            return new r(i.call(setTimeout, a, arguments), clearTimeout)
        }, e.setInterval = function () {
            return new r(i.call(setInterval, a, arguments), clearInterval)
        }, e.clearTimeout = e.clearInterval = function (t) {
            t && t.close()
        }, r.prototype.unref = r.prototype.ref = function () {
        }, r.prototype.close = function () {
            this._clearFn.call(a, this._id)
        }, e.enroll = function (t, e) {
            clearTimeout(t._idleTimeoutId), t._idleTimeout = e
        }, e.unenroll = function (t) {
            clearTimeout(t._idleTimeoutId), t._idleTimeout = -1
        }, e._unrefActive = e.active = function (t) {
            clearTimeout(t._idleTimeoutId);
            var e = t._idleTimeout;
            e >= 0 && (t._idleTimeoutId = setTimeout((function () {
                t._onTimeout && t._onTimeout()
            }), e))
        }, n(172), e.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== t && t.setImmediate || this && this.setImmediate, e.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== t && t.clearImmediate || this && this.clearImmediate
    }).call(this, n(3))
}, function (t, e, n) {
    (function (t, e) {
        !function (t, n) {
            "use strict";
            if (!t.setImmediate) {
                var a, i, r, o, s, l = 1, c = {}, d = !1, u = t.document,
                    h = Object.getPrototypeOf && Object.getPrototypeOf(t);
                h = h && h.setTimeout ? h : t, "[object process]" === {}.toString.call(t.process) ? a = function (t) {
                    e.nextTick((function () {
                        f(t)
                    }))
                } : !function () {
                    if (t.postMessage && !t.importScripts) {
                        var e = !0, n = t.onmessage;
                        return t.onmessage = function () {
                            e = !1
                        }, t.postMessage("", "*"), t.onmessage = n, e
                    }
                }() ? t.MessageChannel ? ((r = new MessageChannel).port1.onmessage = function (t) {
                    f(t.data)
                }, a = function (t) {
                    r.port2.postMessage(t)
                }) : u && "onreadystatechange" in u.createElement("script") ? (i = u.documentElement, a = function (t) {
                    var e = u.createElement("script");
                    e.onreadystatechange = function () {
                        f(t), e.onreadystatechange = null, i.removeChild(e), e = null
                    }, i.appendChild(e)
                }) : a = function (t) {
                    setTimeout(f, 0, t)
                } : (o = "setImmediate$" + Math.random() + "$", s = function (e) {
                    e.source === t && "string" == typeof e.data && 0 === e.data.indexOf(o) && f(+e.data.slice(o.length))
                }, t.addEventListener ? t.addEventListener("message", s, !1) : t.attachEvent("onmessage", s), a = function (e) {
                    t.postMessage(o + e, "*")
                }), h.setImmediate = function (t) {
                    "function" != typeof t && (t = new Function("" + t));
                    for (var e = new Array(arguments.length - 1), n = 0; n < e.length; n++) e[n] = arguments[n + 1];
                    var i = {callback: t, args: e};
                    return c[l] = i, a(l), l++
                }, h.clearImmediate = p
            }

            function p(t) {
                delete c[t]
            }

            function f(t) {
                if (d) setTimeout(f, 0, t); else {
                    var e = c[t];
                    if (e) {
                        d = !0;
                        try {
                            !function (t) {
                                var e = t.callback, n = t.args;
                                switch (n.length) {
                                    case 0:
                                        e();
                                        break;
                                    case 1:
                                        e(n[0]);
                                        break;
                                    case 2:
                                        e(n[0], n[1]);
                                        break;
                                    case 3:
                                        e(n[0], n[1], n[2]);
                                        break;
                                    default:
                                        e.apply(void 0, n)
                                }
                            }(e)
                        } finally {
                            p(t), d = !1
                        }
                    }
                }
            }
        }("undefined" == typeof self ? void 0 === t ? this : t : self)
    }).call(this, n(3), n(98))
}, function (t, e, n) {
    "use strict";
    (function (e) {
        var a = n(174), i = n(175), r = e.document, o = function (t, e, n, a) {
            return t.addEventListener(e, n, a)
        }, s = function (t, e, n, a) {
            return t.removeEventListener(e, n, a)
        }, l = [];

        function c(t, e, n) {
            var a = function (t, e, n) {
                var a, i;
                for (a = 0; a < l.length; a++) if ((i = l[a]).element === t && i.type === e && i.fn === n) return a
            }(t, e, n);
            if (a) {
                var i = l[a].wrapper;
                return l.splice(a, 1), i
            }
        }

        e.addEventListener || (o = function (t, n, a) {
            return t.attachEvent("on" + n, function (t, n, a) {
                var i = c(t, n, a) || function (t, n, a) {
                    return function (n) {
                        var i = n || e.event;
                        i.target = i.target || i.srcElement, i.preventDefault = i.preventDefault || function () {
                            i.returnValue = !1
                        }, i.stopPropagation = i.stopPropagation || function () {
                            i.cancelBubble = !0
                        }, i.which = i.which || i.keyCode, a.call(t, i)
                    }
                }(t, 0, a);
                return l.push({wrapper: i, element: t, type: n, fn: a}), i
            }(t, n, a))
        }, s = function (t, e, n) {
            var a = c(t, e, n);
            if (a) return t.detachEvent("on" + e, a)
        }), t.exports = {
            add: o, remove: s, fabricate: function (t, e, n) {
                var o = -1 === i.indexOf(e) ? new a(e, {detail: n}) : function () {
                    var t;
                    r.createEvent ? (t = r.createEvent("Event")).initEvent(e, !0, !0) : r.createEventObject && (t = r.createEventObject());
                    return t
                }();
                t.dispatchEvent ? t.dispatchEvent(o) : t.fireEvent("on" + e, o)
            }
        }
    }).call(this, n(3))
}, function (t, e, n) {
    (function (e) {
        var n = e.CustomEvent;
        t.exports = function () {
            try {
                var t = new n("cat", {detail: {foo: "bar"}});
                return "cat" === t.type && "bar" === t.detail.foo
            } catch (t) {
            }
            return !1
        }() ? n : "undefined" != typeof document && "function" == typeof document.createEvent ? function (t, e) {
            var n = document.createEvent("CustomEvent");
            return e ? n.initCustomEvent(t, e.bubbles, e.cancelable, e.detail) : n.initCustomEvent(t, !1, !1, void 0), n
        } : function (t, e) {
            var n = document.createEventObject();
            return n.type = t, e ? (n.bubbles = Boolean(e.bubbles), n.cancelable = Boolean(e.cancelable), n.detail = e.detail) : (n.bubbles = !1, n.cancelable = !1, n.detail = void 0), n
        }
    }).call(this, n(3))
}, function (t, e, n) {
    "use strict";
    (function (e) {
        var n = [], a = "", i = /^on/;
        for (a in e) i.test(a) && n.push(a.slice(2));
        t.exports = n
    }).call(this, n(3))
}, function (t, e, n) {
    "use strict";
    var a = {};

    function i(t) {
        var e = a[t];
        return e ? e.lastIndex = 0 : a[t] = e = new RegExp("(?:^|\\s)" + t + "(?:\\s|$)", "g"), e
    }

    t.exports = {
        add: function (t, e) {
            var n = t.className;
            n.length ? i(e).test(n) || (t.className += " " + e) : t.className = e
        }, rm: function (t, e) {
            t.className = t.className.replace(i(e), " ").trim()
        }
    }
}, function (t, e, n) {
    "use strict";
    var a = n(35), i = n(129);
    a({target: "Array", proto: !0, forced: [].forEach != i}, {forEach: i})
}, function (t, e, n) {
    var a = n(19), i = n(179), r = n(117), o = n(41);
    t.exports = function (t, e) {
        for (var n = i(e), s = o.f, l = r.f, c = 0; c < n.length; c++) {
            var d = n[c];
            a(t, d) || s(t, d, l(e, d))
        }
    }
}, function (t, e, n) {
    var a = n(106), i = n(181), r = n(127), o = n(23);
    t.exports = a("Reflect", "ownKeys") || function (t) {
        var e = i.f(o(t)), n = r.f;
        return n ? e.concat(n(t)) : e
    }
}, function (t, e, n) {
    var a = n(7);
    t.exports = a
}, function (t, e, n) {
    var a = n(126), i = n(107).concat("length", "prototype");
    e.f = Object.getOwnPropertyNames || function (t) {
        return a(t, i)
    }
}, function (t, e, n) {
    var a = n(72), i = n(48), r = n(183), o = function (t) {
        return function (e, n, o) {
            var s, l = a(e), c = i(l.length), d = r(o, c);
            if (t && n != n) {
                for (; c > d;) if ((s = l[d++]) != s) return !0
            } else for (; c > d; d++) if ((t || d in l) && l[d] === n) return t || d || 0;
            return !t && -1
        }
    };
    t.exports = {includes: o(!0), indexOf: o(!1)}
}, function (t, e, n) {
    var a = n(76), i = Math.max, r = Math.min;
    t.exports = function (t, e) {
        var n = a(t);
        return n < 0 ? i(n + e, 0) : r(n, e)
    }
}, function (t, e, n) {
    var a = n(22), i = n(185), r = n(15)("species");
    t.exports = function (t, e) {
        var n;
        return i(t) && ("function" != typeof (n = t.constructor) || n !== Array && !i(n.prototype) ? a(n) && null === (n = n[r]) && (n = void 0) : n = void 0), new (void 0 === n ? Array : n)(0 === e ? 0 : e)
    }
}, function (t, e, n) {
    var a = n(74);
    t.exports = Array.isArray || function (t) {
        return "Array" == a(t)
    }
}, function (t, e, n) {
    var a = n(132);
    t.exports = a && !Symbol.sham && "symbol" == typeof Symbol.iterator
}, function (t, e, n) {
    var a = n(7), i = n(134), r = n(129), o = n(32);
    for (var s in i) {
        var l = a[s], c = l && l.prototype;
        if (c && c.forEach !== r) try {
            o(c, "forEach", r)
        } catch (t) {
            c.forEach = r
        }
    }
}, function (t, e, n) {
    "use strict";
    var a = n(35), i = n(108).filter, r = n(189), o = n(109), s = r("filter"), l = o("filter");
    a({target: "Array", proto: !0, forced: !s || !l}, {
        filter: function (t) {
            return i(this, t, arguments.length > 1 ? arguments[1] : void 0)
        }
    })
}, function (t, e, n) {
    var a = n(13), i = n(15), r = n(190), o = i("species");
    t.exports = function (t) {
        return r >= 51 || !a((function () {
            var e = [];
            return (e.constructor = {})[o] = function () {
                return {foo: 1}
            }, 1 !== e[t](Boolean).foo
        }))
    }
}, function (t, e, n) {
    var a, i, r = n(7), o = n(191), s = r.process, l = s && s.versions, c = l && l.v8;
    c ? i = (a = c.split("."))[0] + a[1] : o && (!(a = o.match(/Edge\/(\d+)/)) || a[1] >= 74) && (a = o.match(/Chrome\/(\d+)/)) && (i = a[1]), t.exports = i && +i
}, function (t, e, n) {
    var a = n(106);
    t.exports = a("navigator", "userAgent") || ""
}, function (t, e, n) {
    var a = n(15), i = n(136), r = n(41), o = a("unscopables"), s = Array.prototype;
    null == s[o] && r.f(s, o, {configurable: !0, value: i(null)}), t.exports = function (t) {
        s[o][t] = !0
    }
}, function (t, e, n) {
    var a = n(36), i = n(41), r = n(23), o = n(137);
    t.exports = a ? Object.defineProperties : function (t, e) {
        r(t);
        for (var n, a = o(e), s = a.length, l = 0; s > l;) i.f(t, n = a[l++], e[n]);
        return t
    }
}, function (t, e, n) {
    var a = n(106);
    t.exports = a("document", "documentElement")
}, function (t, e, n) {
    "use strict";
    var a = n(139).IteratorPrototype, i = n(136), r = n(101), o = n(110), s = n(59), l = function () {
        return this
    };
    t.exports = function (t, e, n) {
        var c = e + " Iterator";
        return t.prototype = i(a, {next: r(1, n)}), o(t, c, !1, !0), s[c] = l, t
    }
}, function (t, e, n) {
    var a = n(13);
    t.exports = !a((function () {
        function t() {
        }

        return t.prototype.constructor = null, Object.getPrototypeOf(new t) !== t.prototype
    }))
}, function (t, e, n) {
    var a = n(22);
    t.exports = function (t) {
        if (!a(t) && null !== t) throw TypeError("Can't set " + String(t) + " as a prototype");
        return t
    }
}, function (t, e, n) {
    var a = n(35), i = n(199);
    a({target: "Object", stat: !0, forced: Object.assign !== i}, {assign: i})
}, function (t, e, n) {
    "use strict";
    var a = n(36), i = n(13), r = n(137), o = n(127), s = n(118), l = n(58), c = n(73), d = Object.assign,
        u = Object.defineProperty;
    t.exports = !d || i((function () {
        if (a && 1 !== d({b: 1}, d(u({}, "a", {
            enumerable: !0, get: function () {
                u(this, "b", {value: 3, enumerable: !1})
            }
        }), {b: 2})).b) return !0;
        var t = {}, e = {}, n = Symbol(), i = "abcdefghijklmnopqrst";
        return t[n] = 7, i.split("").forEach((function (t) {
            e[t] = t
        })), 7 != d({}, t)[n] || r(d({}, e)).join("") != i
    })) ? function (t, e) {
        for (var n = l(t), i = arguments.length, d = 1, u = o.f, h = s.f; i > d;) for (var p, f = c(arguments[d++]), g = u ? r(f).concat(u(f)) : r(f), m = g.length, v = 0; m > v;) p = g[v++], a && !h.call(f, p) || (n[p] = f[p]);
        return n
    } : d
}, function (t, e, n) {
    var a = n(111), i = n(47), r = n(201);
    a || i(Object.prototype, "toString", r, {unsafe: !0})
}, function (t, e, n) {
    "use strict";
    var a = n(111), i = n(142);
    t.exports = a ? {}.toString : function () {
        return "[object " + i(this) + "]"
    }
}, function (t, e, n) {
    var a = n(35), i = n(203);
    a({global: !0, forced: parseInt != i}, {parseInt: i})
}, function (t, e, n) {
    var a = n(7), i = n(204).trim, r = n(143), o = a.parseInt, s = /^[+-]?0[Xx]/,
        l = 8 !== o(r + "08") || 22 !== o(r + "0x16");
    t.exports = l ? function (t, e) {
        var n = i(String(t));
        return o(n, e >>> 0 || (s.test(n) ? 16 : 10))
    } : o
}, function (t, e, n) {
    var a = n(46), i = "[" + n(143) + "]", r = RegExp("^" + i + i + "*"), o = RegExp(i + i + "*$"), s = function (t) {
        return function (e) {
            var n = String(a(e));
            return 1 & t && (n = n.replace(r, "")), 2 & t && (n = n.replace(o, "")), n
        }
    };
    t.exports = {start: s(1), end: s(2), trim: s(3)}
}, function (t, e, n) {
    "use strict";
    var a = n(144).charAt, i = n(57), r = n(138), o = "String Iterator", s = i.set, l = i.getterFor(o);
    r(String, "String", (function (t) {
        s(this, {type: o, string: String(t), index: 0})
    }), (function () {
        var t, e = l(this), n = e.string, i = e.index;
        return i >= n.length ? {value: void 0, done: !0} : (t = a(n, i), e.index += t.length, {value: t, done: !1})
    }))
}, function (t, e, n) {
    "use strict";
    var a, i = n(7), r = n(145), o = n(112), s = n(208), l = n(214), c = n(22), d = n(57).enforce, u = n(124),
        h = !i.ActiveXObject && "ActiveXObject" in i, p = Object.isExtensible, f = function (t) {
            return function () {
                return t(this, arguments.length ? arguments[0] : void 0)
            }
        }, g = t.exports = s("WeakMap", f, l);
    if (u && h) {
        a = l.getConstructor(f, "WeakMap", !0), o.REQUIRED = !0;
        var m = g.prototype, v = m.delete, b = m.has, y = m.get, x = m.set;
        r(m, {
            delete: function (t) {
                if (c(t) && !p(t)) {
                    var e = d(this);
                    return e.frozen || (e.frozen = new a), v.call(this, t) || e.frozen.delete(t)
                }
                return v.call(this, t)
            }, has: function (t) {
                if (c(t) && !p(t)) {
                    var e = d(this);
                    return e.frozen || (e.frozen = new a), b.call(this, t) || e.frozen.has(t)
                }
                return b.call(this, t)
            }, get: function (t) {
                if (c(t) && !p(t)) {
                    var e = d(this);
                    return e.frozen || (e.frozen = new a), b.call(this, t) ? y.call(this, t) : e.frozen.get(t)
                }
                return y.call(this, t)
            }, set: function (t, e) {
                if (c(t) && !p(t)) {
                    var n = d(this);
                    n.frozen || (n.frozen = new a), b.call(this, t) ? x.call(this, t, e) : n.frozen.set(t, e)
                } else x.call(this, t, e);
                return this
            }
        })
    }
}, function (t, e, n) {
    var a = n(13);
    t.exports = !a((function () {
        return Object.isExtensible(Object.preventExtensions({}))
    }))
}, function (t, e, n) {
    "use strict";
    var a = n(35), i = n(7), r = n(128), o = n(47), s = n(112), l = n(146), c = n(147), d = n(22), u = n(13),
        h = n(212), p = n(110), f = n(213);
    t.exports = function (t, e, n) {
        var g = -1 !== t.indexOf("Map"), m = -1 !== t.indexOf("Weak"), v = g ? "set" : "add", b = i[t],
            y = b && b.prototype, x = b, _ = {}, w = function (t) {
                var e = y[t];
                o(y, t, "add" == t ? function (t) {
                    return e.call(this, 0 === t ? 0 : t), this
                } : "delete" == t ? function (t) {
                    return !(m && !d(t)) && e.call(this, 0 === t ? 0 : t)
                } : "get" == t ? function (t) {
                    return m && !d(t) ? void 0 : e.call(this, 0 === t ? 0 : t)
                } : "has" == t ? function (t) {
                    return !(m && !d(t)) && e.call(this, 0 === t ? 0 : t)
                } : function (t, n) {
                    return e.call(this, 0 === t ? 0 : t, n), this
                })
            };
        if (r(t, "function" != typeof b || !(m || y.forEach && !u((function () {
            (new b).entries().next()
        }))))) x = n.getConstructor(e, t, g, v), s.REQUIRED = !0; else if (r(t, !0)) {
            var S = new x, C = S[v](m ? {} : -0, 1) != S, k = u((function () {
                S.has(1)
            })), D = h((function (t) {
                new b(t)
            })), T = !m && u((function () {
                for (var t = new b, e = 5; e--;) t[v](e, e);
                return !t.has(-0)
            }));
            D || ((x = e((function (e, n) {
                c(e, x, t);
                var a = f(new b, e, x);
                return null != n && l(n, a[v], a, g), a
            }))).prototype = y, y.constructor = x), (k || T) && (w("delete"), w("has"), g && w("get")), (T || C) && w(v), m && y.clear && delete y.clear
        }
        return _[t] = x, a({global: !0, forced: x != b}, _), p(x, t), m || n.setStrong(x, t, g), x
    }
}, function (t, e, n) {
    var a = n(15), i = n(59), r = a("iterator"), o = Array.prototype;
    t.exports = function (t) {
        return void 0 !== t && (i.Array === t || o[r] === t)
    }
}, function (t, e, n) {
    var a = n(142), i = n(59), r = n(15)("iterator");
    t.exports = function (t) {
        if (null != t) return t[r] || t["@@iterator"] || i[a(t)]
    }
}, function (t, e, n) {
    var a = n(23);
    t.exports = function (t, e, n, i) {
        try {
            return i ? e(a(n)[0], n[1]) : e(n)
        } catch (e) {
            var r = t.return;
            throw void 0 !== r && a(r.call(t)), e
        }
    }
}, function (t, e, n) {
    var a = n(15)("iterator"), i = !1;
    try {
        var r = 0, o = {
            next: function () {
                return {done: !!r++}
            }, return: function () {
                i = !0
            }
        };
        o[a] = function () {
            return this
        }, Array.from(o, (function () {
            throw 2
        }))
    } catch (t) {
    }
    t.exports = function (t, e) {
        if (!e && !i) return !1;
        var n = !1;
        try {
            var r = {};
            r[a] = function () {
                return {
                    next: function () {
                        return {done: n = !0}
                    }
                }
            }, t(r)
        } catch (t) {
        }
        return n
    }
}, function (t, e, n) {
    var a = n(22), i = n(141);
    t.exports = function (t, e, n) {
        var r, o;
        return i && "function" == typeof (r = e.constructor) && r !== n && a(o = r.prototype) && o !== n.prototype && i(t, o), t
    }
}, function (t, e, n) {
    "use strict";
    var a = n(145), i = n(112).getWeakData, r = n(23), o = n(22), s = n(147), l = n(146), c = n(108), d = n(19),
        u = n(57), h = u.set, p = u.getterFor, f = c.find, g = c.findIndex, m = 0, v = function (t) {
            return t.frozen || (t.frozen = new b)
        }, b = function () {
            this.entries = []
        }, y = function (t, e) {
            return f(t.entries, (function (t) {
                return t[0] === e
            }))
        };
    b.prototype = {
        get: function (t) {
            var e = y(this, t);
            if (e) return e[1]
        }, has: function (t) {
            return !!y(this, t)
        }, set: function (t, e) {
            var n = y(this, t);
            n ? n[1] = e : this.entries.push([t, e])
        }, delete: function (t) {
            var e = g(this.entries, (function (e) {
                return e[0] === t
            }));
            return ~e && this.entries.splice(e, 1), !!~e
        }
    }, t.exports = {
        getConstructor: function (t, e, n, c) {
            var u = t((function (t, a) {
                s(t, u, e), h(t, {type: e, id: m++, frozen: void 0}), null != a && l(a, t[c], t, n)
            })), f = p(e), g = function (t, e, n) {
                var a = f(t), o = i(r(e), !0);
                return !0 === o ? v(a).set(e, n) : o[a.id] = n, t
            };
            return a(u.prototype, {
                delete: function (t) {
                    var e = f(this);
                    if (!o(t)) return !1;
                    var n = i(t);
                    return !0 === n ? v(e).delete(t) : n && d(n, e.id) && delete n[e.id]
                }, has: function (t) {
                    var e = f(this);
                    if (!o(t)) return !1;
                    var n = i(t);
                    return !0 === n ? v(e).has(t) : n && d(n, e.id)
                }
            }), a(u.prototype, n ? {
                get: function (t) {
                    var e = f(this);
                    if (o(t)) {
                        var n = i(t);
                        return !0 === n ? v(e).get(t) : n ? n[e.id] : void 0
                    }
                }, set: function (t, e) {
                    return g(this, t, e)
                }
            } : {
                add: function (t) {
                    return g(this, t, !0)
                }
            }), u
        }
    }
}, function (t, e, n) {
    var a = n(7), i = n(134), r = n(135), o = n(32), s = n(15), l = s("iterator"), c = s("toStringTag"), d = r.values;
    for (var u in i) {
        var h = a[u], p = h && h.prototype;
        if (p) {
            if (p[l] !== d) try {
                o(p, l, d)
            } catch (t) {
                p[l] = d
            }
            if (p[c] || o(p, c, u), i[u]) for (var f in r) if (p[f] !== r[f]) try {
                o(p, f, r[f])
            } catch (t) {
                p[f] = r[f]
            }
        }
    }
}, function (t, e, n) {
    "use strict";
    var a = n(35), i = n(217).left, r = n(133), o = n(109), s = r("reduce"), l = o("reduce", {1: 0});
    a({target: "Array", proto: !0, forced: !s || !l}, {
        reduce: function (t) {
            return i(this, t, arguments.length, arguments.length > 1 ? arguments[1] : void 0)
        }
    })
}, function (t, e, n) {
    var a = n(131), i = n(58), r = n(73), o = n(48), s = function (t) {
        return function (e, n, s, l) {
            a(n);
            var c = i(e), d = r(c), u = o(c.length), h = t ? u - 1 : 0, p = t ? -1 : 1;
            if (s < 2) for (; ;) {
                if (h in d) {
                    l = d[h], h += p;
                    break
                }
                if (h += p, t ? h < 0 : u <= h) throw TypeError("Reduce of empty array with no initial value")
            }
            for (; t ? h >= 0 : u > h; h += p) h in d && (l = n(l, d[h], h, c));
            return l
        }
    };
    t.exports = {left: s(!1), right: s(!0)}
}, function (t, e, n) {
    var a = n(36), i = n(41).f, r = Function.prototype, o = r.toString, s = /^\s*function ([^ (]*)/, l = "name";
    a && !(l in r) && i(r, l, {
        configurable: !0, get: function () {
            try {
                return o.call(this).match(s)[1]
            } catch (t) {
                return ""
            }
        }
    })
}, function (t, e, n) {
    "use strict";
    var a = n(23);
    t.exports = function () {
        var t = a(this), e = "";
        return t.global && (e += "g"), t.ignoreCase && (e += "i"), t.multiline && (e += "m"), t.dotAll && (e += "s"), t.unicode && (e += "u"), t.sticky && (e += "y"), e
    }
}, function (t, e, n) {
    "use strict";
    var a = n(13);

    function i(t, e) {
        return RegExp(t, e)
    }

    e.UNSUPPORTED_Y = a((function () {
        var t = i("a", "y");
        return t.lastIndex = 2, null != t.exec("abcd")
    })), e.BROKEN_CARET = a((function () {
        var t = i("^r", "gy");
        return t.lastIndex = 2, null != t.exec("str")
    }))
}, function (t, e, n) {
    "use strict";
    var a = n(149), i = n(23), r = n(48), o = n(46), s = n(150), l = n(151);
    a("match", 1, (function (t, e, n) {
        return [function (e) {
            var n = o(this), a = null == e ? void 0 : e[t];
            return void 0 !== a ? a.call(e, n) : new RegExp(e)[t](String(n))
        }, function (t) {
            var a = n(e, t, this);
            if (a.done) return a.value;
            var o = i(t), c = String(this);
            if (!o.global) return l(o, c);
            var d = o.unicode;
            o.lastIndex = 0;
            for (var u, h = [], p = 0; null !== (u = l(o, c));) {
                var f = String(u[0]);
                h[p] = f, "" === f && (o.lastIndex = s(c, r(o.lastIndex), d)), p++
            }
            return 0 === p ? null : h
        }]
    }))
}, function (t, e, n) {
    "use strict";
    var a = n(149), i = n(23), r = n(58), o = n(48), s = n(76), l = n(46), c = n(150), d = n(151), u = Math.max,
        h = Math.min, p = Math.floor, f = /\$([$&'`]|\d\d?|<[^>]*>)/g, g = /\$([$&'`]|\d\d?)/g;
    a("replace", 2, (function (t, e, n, a) {
        var m = a.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, v = a.REPLACE_KEEPS_$0, b = m ? "$" : "$0";
        return [function (n, a) {
            var i = l(this), r = null == n ? void 0 : n[t];
            return void 0 !== r ? r.call(n, i, a) : e.call(String(i), n, a)
        }, function (t, a) {
            if (!m && v || "string" == typeof a && -1 === a.indexOf(b)) {
                var r = n(e, t, this, a);
                if (r.done) return r.value
            }
            var l = i(t), p = String(this), f = "function" == typeof a;
            f || (a = String(a));
            var g = l.global;
            if (g) {
                var x = l.unicode;
                l.lastIndex = 0
            }
            for (var _ = []; ;) {
                var w = d(l, p);
                if (null === w) break;
                if (_.push(w), !g) break;
                "" === String(w[0]) && (l.lastIndex = c(p, o(l.lastIndex), x))
            }
            for (var S, C = "", k = 0, D = 0; D < _.length; D++) {
                w = _[D];
                for (var T = String(w[0]), E = u(h(s(w.index), p.length), 0), A = [], I = 1; I < w.length; I++) A.push(void 0 === (S = w[I]) ? S : String(S));
                var M = w.groups;
                if (f) {
                    var R = [T].concat(A, E, p);
                    void 0 !== M && R.push(M);
                    var P = String(a.apply(void 0, R))
                } else P = y(T, p, E, A, M, a);
                E >= k && (C += p.slice(k, E) + P, k = E + T.length)
            }
            return C + p.slice(k)
        }];

        function y(t, n, a, i, o, s) {
            var l = a + t.length, c = i.length, d = g;
            return void 0 !== o && (o = r(o), d = f), e.call(s, d, (function (e, r) {
                var s;
                switch (r.charAt(0)) {
                    case"$":
                        return "$";
                    case"&":
                        return t;
                    case"`":
                        return n.slice(0, a);
                    case"'":
                        return n.slice(l);
                    case"<":
                        s = o[r.slice(1, -1)];
                        break;
                    default:
                        var d = +r;
                        if (0 === d) return e;
                        if (d > c) {
                            var u = p(d / 10);
                            return 0 === u ? e : u <= c ? void 0 === i[u - 1] ? r.charAt(1) : i[u - 1] + r.charAt(1) : e
                        }
                        s = i[d - 1]
                }
                return void 0 === s ? "" : s
            }))
        }
    }))
}, function (t, e, n) {
    var a = n(8);
    a(a.P, "Array", {fill: n(224)}), n(55)("fill")
}, function (t, e, n) {
    "use strict";
    var a = n(31), i = n(64), r = n(33);
    t.exports = function (t) {
        for (var e = a(this), n = r(e.length), o = arguments.length, s = i(o > 1 ? arguments[1] : void 0, n), l = o > 2 ? arguments[2] : void 0, c = void 0 === l ? n : i(l, n); c > s;) e[s++] = t;
        return e
    }
}, function (t, e, n) {
    var a, i;
    a = [n(77), n(16)], void 0 === (i = function (t, e) {
        return e.fn || (e.fn = {}), "function" != typeof t && t.hasOwnProperty("default") && (t = t.default), function (t, e) {
            var n = function (n, a, i) {
                if (this.parentEl = "body", this.element = e(n), this.startDate = t().startOf("day"), this.endDate = t().endOf("day"), this.minDate = !1, this.maxDate = !1, this.maxSpan = !1, this.autoApply = !1, this.singleDatePicker = !1, this.showDropdowns = !1, this.minYear = t().subtract(100, "year").format("YYYY"), this.maxYear = t().add(100, "year").format("YYYY"), this.showWeekNumbers = !1, this.showISOWeekNumbers = !1, this.showCustomRangeLabel = !0, this.timePicker = !1, this.timePicker24Hour = !1, this.timePickerIncrement = 1, this.timePickerSeconds = !1, this.linkedCalendars = !0, this.autoUpdateInput = !0, this.alwaysShowCalendars = !1, this.ranges = {}, this.opens = "right", this.element.hasClass("pull-right") && (this.opens = "left"), this.drops = "down", this.element.hasClass("dropup") && (this.drops = "up"), this.buttonClasses = "btn btn-sm", this.applyButtonClasses = "btn-primary", this.cancelButtonClasses = "btn-default", this.locale = {
                    direction: "ltr",
                    format: t.localeData().longDateFormat("L"),
                    separator: " - ",
                    applyLabel: "Apply",
                    cancelLabel: "Cancel",
                    weekLabel: "W",
                    customRangeLabel: "Custom Range",
                    daysOfWeek: t.weekdaysMin(),
                    monthNames: t.monthsShort(),
                    firstDay: t.localeData().firstDayOfWeek()
                }, this.callback = function () {
                }, this.isShowing = !1, this.leftCalendar = {}, this.rightCalendar = {}, "object" == typeof a && null !== a || (a = {}), "string" == typeof (a = e.extend(this.element.data(), a)).template || a.template instanceof e || (a.template = '<div class="daterangepicker"><div class="ranges"></div><div class="drp-calendar left"><div class="calendar-table"></div><div class="calendar-time"></div></div><div class="drp-calendar right"><div class="calendar-table"></div><div class="calendar-time"></div></div><div class="drp-buttons"><span class="drp-selected"></span><button class="cancelBtn" type="button"></button><button class="applyBtn" disabled="disabled" type="button"></button> </div></div>'), this.parentEl = a.parentEl && e(a.parentEl).length ? e(a.parentEl) : e(this.parentEl), this.container = e(a.template).appendTo(this.parentEl), "object" == typeof a.locale && ("string" == typeof a.locale.direction && (this.locale.direction = a.locale.direction), "string" == typeof a.locale.format && (this.locale.format = a.locale.format), "string" == typeof a.locale.separator && (this.locale.separator = a.locale.separator), "object" == typeof a.locale.daysOfWeek && (this.locale.daysOfWeek = a.locale.daysOfWeek.slice()), "object" == typeof a.locale.monthNames && (this.locale.monthNames = a.locale.monthNames.slice()), "number" == typeof a.locale.firstDay && (this.locale.firstDay = a.locale.firstDay), "string" == typeof a.locale.applyLabel && (this.locale.applyLabel = a.locale.applyLabel), "string" == typeof a.locale.cancelLabel && (this.locale.cancelLabel = a.locale.cancelLabel), "string" == typeof a.locale.weekLabel && (this.locale.weekLabel = a.locale.weekLabel), "string" == typeof a.locale.customRangeLabel)) {
                    (h = document.createElement("textarea")).innerHTML = a.locale.customRangeLabel;
                    var r = h.value;
                    this.locale.customRangeLabel = r
                }
                if (this.container.addClass(this.locale.direction), "string" == typeof a.startDate && (this.startDate = t(a.startDate, this.locale.format)), "string" == typeof a.endDate && (this.endDate = t(a.endDate, this.locale.format)), "string" == typeof a.minDate && (this.minDate = t(a.minDate, this.locale.format)), "string" == typeof a.maxDate && (this.maxDate = t(a.maxDate, this.locale.format)), "object" == typeof a.startDate && (this.startDate = t(a.startDate)), "object" == typeof a.endDate && (this.endDate = t(a.endDate)), "object" == typeof a.minDate && (this.minDate = t(a.minDate)), "object" == typeof a.maxDate && (this.maxDate = t(a.maxDate)), this.minDate && this.startDate.isBefore(this.minDate) && (this.startDate = this.minDate.clone()), this.maxDate && this.endDate.isAfter(this.maxDate) && (this.endDate = this.maxDate.clone()), "string" == typeof a.applyButtonClasses && (this.applyButtonClasses = a.applyButtonClasses), "string" == typeof a.applyClass && (this.applyButtonClasses = a.applyClass), "string" == typeof a.cancelButtonClasses && (this.cancelButtonClasses = a.cancelButtonClasses), "string" == typeof a.cancelClass && (this.cancelButtonClasses = a.cancelClass), "object" == typeof a.maxSpan && (this.maxSpan = a.maxSpan), "object" == typeof a.dateLimit && (this.maxSpan = a.dateLimit), "string" == typeof a.opens && (this.opens = a.opens), "string" == typeof a.drops && (this.drops = a.drops), "boolean" == typeof a.showWeekNumbers && (this.showWeekNumbers = a.showWeekNumbers), "boolean" == typeof a.showISOWeekNumbers && (this.showISOWeekNumbers = a.showISOWeekNumbers), "string" == typeof a.buttonClasses && (this.buttonClasses = a.buttonClasses), "object" == typeof a.buttonClasses && (this.buttonClasses = a.buttonClasses.join(" ")), "boolean" == typeof a.showDropdowns && (this.showDropdowns = a.showDropdowns), "number" == typeof a.minYear && (this.minYear = a.minYear), "number" == typeof a.maxYear && (this.maxYear = a.maxYear), "boolean" == typeof a.showCustomRangeLabel && (this.showCustomRangeLabel = a.showCustomRangeLabel), "boolean" == typeof a.singleDatePicker && (this.singleDatePicker = a.singleDatePicker, this.singleDatePicker && (this.endDate = this.startDate.clone())), "boolean" == typeof a.timePicker && (this.timePicker = a.timePicker), "boolean" == typeof a.timePickerSeconds && (this.timePickerSeconds = a.timePickerSeconds), "number" == typeof a.timePickerIncrement && (this.timePickerIncrement = a.timePickerIncrement), "boolean" == typeof a.timePicker24Hour && (this.timePicker24Hour = a.timePicker24Hour), "boolean" == typeof a.autoApply && (this.autoApply = a.autoApply), "boolean" == typeof a.autoUpdateInput && (this.autoUpdateInput = a.autoUpdateInput), "boolean" == typeof a.linkedCalendars && (this.linkedCalendars = a.linkedCalendars), "function" == typeof a.isInvalidDate && (this.isInvalidDate = a.isInvalidDate), "function" == typeof a.isCustomDate && (this.isCustomDate = a.isCustomDate), "boolean" == typeof a.alwaysShowCalendars && (this.alwaysShowCalendars = a.alwaysShowCalendars), 0 != this.locale.firstDay) for (var o = this.locale.firstDay; o > 0;) this.locale.daysOfWeek.push(this.locale.daysOfWeek.shift()), o--;
                var s, l, c;
                if (void 0 === a.startDate && void 0 === a.endDate && e(this.element).is(":text")) {
                    var d = e(this.element).val(), u = d.split(this.locale.separator);
                    s = l = null, 2 == u.length ? (s = t(u[0], this.locale.format), l = t(u[1], this.locale.format)) : this.singleDatePicker && "" !== d && (s = t(d, this.locale.format), l = t(d, this.locale.format)), null !== s && null !== l && (this.setStartDate(s), this.setEndDate(l))
                }
                if ("object" == typeof a.ranges) {
                    for (c in a.ranges) {
                        s = "string" == typeof a.ranges[c][0] ? t(a.ranges[c][0], this.locale.format) : t(a.ranges[c][0]), l = "string" == typeof a.ranges[c][1] ? t(a.ranges[c][1], this.locale.format) : t(a.ranges[c][1]), this.minDate && s.isBefore(this.minDate) && (s = this.minDate.clone());
                        var h, p = this.maxDate;
                        if (this.maxSpan && p && s.clone().add(this.maxSpan).isAfter(p) && (p = s.clone().add(this.maxSpan)), p && l.isAfter(p) && (l = p.clone()), !(this.minDate && l.isBefore(this.minDate, this.timepicker ? "minute" : "day") || p && s.isAfter(p, this.timepicker ? "minute" : "day"))) (h = document.createElement("textarea")).innerHTML = c, r = h.value, this.ranges[r] = [s, l]
                    }
                    var f = "<ul>";
                    for (c in this.ranges) f += '<li data-range-key="' + c + '">' + c + "</li>";
                    this.showCustomRangeLabel && (f += '<li data-range-key="' + this.locale.customRangeLabel + '">' + this.locale.customRangeLabel + "</li>"), f += "</ul>", this.container.find(".ranges").prepend(f)
                }
                "function" == typeof i && (this.callback = i), this.timePicker || (this.startDate = this.startDate.startOf("day"), this.endDate = this.endDate.endOf("day"), this.container.find(".calendar-time").hide()), this.timePicker && this.autoApply && (this.autoApply = !1), this.autoApply && this.container.addClass("auto-apply"), "object" == typeof a.ranges && this.container.addClass("show-ranges"), this.singleDatePicker && (this.container.addClass("single"), this.container.find(".drp-calendar.left").addClass("single"), this.container.find(".drp-calendar.left").show(), this.container.find(".drp-calendar.right").hide(), !this.timePicker && this.autoApply && this.container.addClass("auto-apply")), (void 0 === a.ranges && !this.singleDatePicker || this.alwaysShowCalendars) && this.container.addClass("show-calendar"), this.container.addClass("opens" + this.opens), this.container.find(".applyBtn, .cancelBtn").addClass(this.buttonClasses), this.applyButtonClasses.length && this.container.find(".applyBtn").addClass(this.applyButtonClasses), this.cancelButtonClasses.length && this.container.find(".cancelBtn").addClass(this.cancelButtonClasses), this.container.find(".applyBtn").html(this.locale.applyLabel), this.container.find(".cancelBtn").html(this.locale.cancelLabel), this.container.find(".drp-calendar").on("click.daterangepicker", ".prev", e.proxy(this.clickPrev, this)).on("click.daterangepicker", ".next", e.proxy(this.clickNext, this)).on("mousedown.daterangepicker", "td.available", e.proxy(this.clickDate, this)).on("mouseenter.daterangepicker", "td.available", e.proxy(this.hoverDate, this)).on("change.daterangepicker", "select.yearselect", e.proxy(this.monthOrYearChanged, this)).on("change.daterangepicker", "select.monthselect", e.proxy(this.monthOrYearChanged, this)).on("change.daterangepicker", "select.hourselect,select.minuteselect,select.secondselect,select.ampmselect", e.proxy(this.timeChanged, this)), this.container.find(".ranges").on("click.daterangepicker", "li", e.proxy(this.clickRange, this)), this.container.find(".drp-buttons").on("click.daterangepicker", "button.applyBtn", e.proxy(this.clickApply, this)).on("click.daterangepicker", "button.cancelBtn", e.proxy(this.clickCancel, this)), this.element.is("input") || this.element.is("button") ? this.element.on({
                    "click.daterangepicker": e.proxy(this.show, this),
                    "focus.daterangepicker": e.proxy(this.show, this),
                    "keyup.daterangepicker": e.proxy(this.elementChanged, this),
                    "keydown.daterangepicker": e.proxy(this.keydown, this)
                }) : (this.element.on("click.daterangepicker", e.proxy(this.toggle, this)), this.element.on("keydown.daterangepicker", e.proxy(this.toggle, this))), this.updateElement()
            };
            return n.prototype = {
                constructor: n, setStartDate: function (e) {
                    "string" == typeof e && (this.startDate = t(e, this.locale.format)), "object" == typeof e && (this.startDate = t(e)), this.timePicker || (this.startDate = this.startDate.startOf("day")), this.timePicker && this.timePickerIncrement && this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement), this.minDate && this.startDate.isBefore(this.minDate) && (this.startDate = this.minDate.clone(), this.timePicker && this.timePickerIncrement && this.startDate.minute(Math.round(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement)), this.maxDate && this.startDate.isAfter(this.maxDate) && (this.startDate = this.maxDate.clone(), this.timePicker && this.timePickerIncrement && this.startDate.minute(Math.floor(this.startDate.minute() / this.timePickerIncrement) * this.timePickerIncrement)), this.isShowing || this.updateElement(), this.updateMonthsInView()
                }, setEndDate: function (e) {
                    "string" == typeof e && (this.endDate = t(e, this.locale.format)), "object" == typeof e && (this.endDate = t(e)), this.timePicker || (this.endDate = this.endDate.endOf("day")), this.timePicker && this.timePickerIncrement && this.endDate.minute(Math.round(this.endDate.minute() / this.timePickerIncrement) * this.timePickerIncrement), this.endDate.isBefore(this.startDate) && (this.endDate = this.startDate.clone()), this.maxDate && this.endDate.isAfter(this.maxDate) && (this.endDate = this.maxDate.clone()), this.maxSpan && this.startDate.clone().add(this.maxSpan).isBefore(this.endDate) && (this.endDate = this.startDate.clone().add(this.maxSpan)), this.previousRightTime = this.endDate.clone(), this.container.find(".drp-selected").html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format)), this.isShowing || this.updateElement(), this.updateMonthsInView()
                }, isInvalidDate: function () {
                    return !1
                }, isCustomDate: function () {
                    return !1
                }, updateView: function () {
                    this.timePicker && (this.renderTimePicker("left"), this.renderTimePicker("right"), this.endDate ? this.container.find(".right .calendar-time select").prop("disabled", !1).removeClass("disabled") : this.container.find(".right .calendar-time select").prop("disabled", !0).addClass("disabled")), this.endDate && this.container.find(".drp-selected").html(this.startDate.format(this.locale.format) + this.locale.separator + this.endDate.format(this.locale.format)), this.updateMonthsInView(), this.updateCalendars(), this.updateFormInputs()
                }, updateMonthsInView: function () {
                    if (this.endDate) {
                        if (!this.singleDatePicker && this.leftCalendar.month && this.rightCalendar.month && (this.startDate.format("YYYY-MM") == this.leftCalendar.month.format("YYYY-MM") || this.startDate.format("YYYY-MM") == this.rightCalendar.month.format("YYYY-MM")) && (this.endDate.format("YYYY-MM") == this.leftCalendar.month.format("YYYY-MM") || this.endDate.format("YYYY-MM") == this.rightCalendar.month.format("YYYY-MM"))) return;
                        this.leftCalendar.month = this.startDate.clone().date(2), this.linkedCalendars || this.endDate.month() == this.startDate.month() && this.endDate.year() == this.startDate.year() ? this.rightCalendar.month = this.startDate.clone().date(2).add(1, "month") : this.rightCalendar.month = this.endDate.clone().date(2)
                    } else this.leftCalendar.month.format("YYYY-MM") != this.startDate.format("YYYY-MM") && this.rightCalendar.month.format("YYYY-MM") != this.startDate.format("YYYY-MM") && (this.leftCalendar.month = this.startDate.clone().date(2), this.rightCalendar.month = this.startDate.clone().date(2).add(1, "month"));
                    this.maxDate && this.linkedCalendars && !this.singleDatePicker && this.rightCalendar.month > this.maxDate && (this.rightCalendar.month = this.maxDate.clone().date(2), this.leftCalendar.month = this.maxDate.clone().date(2).subtract(1, "month"))
                }, updateCalendars: function () {
                    var t, e, n, a;
                    this.timePicker && (this.endDate ? (t = parseInt(this.container.find(".left .hourselect").val(), 10), e = parseInt(this.container.find(".left .minuteselect").val(), 10), isNaN(e) && (e = parseInt(this.container.find(".left .minuteselect option:last").val(), 10)), n = this.timePickerSeconds ? parseInt(this.container.find(".left .secondselect").val(), 10) : 0, this.timePicker24Hour || ("PM" === (a = this.container.find(".left .ampmselect").val()) && t < 12 && (t += 12), "AM" === a && 12 === t && (t = 0))) : (t = parseInt(this.container.find(".right .hourselect").val(), 10), e = parseInt(this.container.find(".right .minuteselect").val(), 10), isNaN(e) && (e = parseInt(this.container.find(".right .minuteselect option:last").val(), 10)), n = this.timePickerSeconds ? parseInt(this.container.find(".right .secondselect").val(), 10) : 0, this.timePicker24Hour || ("PM" === (a = this.container.find(".right .ampmselect").val()) && t < 12 && (t += 12), "AM" === a && 12 === t && (t = 0))), this.leftCalendar.month.hour(t).minute(e).second(n), this.rightCalendar.month.hour(t).minute(e).second(n));
                    this.renderCalendar("left"), this.renderCalendar("right"), this.container.find(".ranges li").removeClass("active"), null != this.endDate && this.calculateChosenLabel()
                }, renderCalendar: function (n) {
                    var a, i = (a = "left" == n ? this.leftCalendar : this.rightCalendar).month.month(),
                        r = a.month.year(), o = a.month.hour(), s = a.month.minute(), l = a.month.second(),
                        c = t([r, i]).daysInMonth(), d = t([r, i, 1]), u = t([r, i, c]),
                        h = t(d).subtract(1, "month").month(), p = t(d).subtract(1, "month").year(),
                        f = t([p, h]).daysInMonth(), g = d.day();
                    (a = []).firstDay = d, a.lastDay = u;
                    for (var m = 0; m < 6; m++) a[m] = [];
                    var v = f - g + this.locale.firstDay + 1;
                    v > f && (v -= 7), g == this.locale.firstDay && (v = f - 6);
                    for (var b = t([p, h, v, 12, s, l]), y = (m = 0, 0), x = 0; m < 42; m++, y++, b = t(b).add(24, "hour")) m > 0 && y % 7 == 0 && (y = 0, x++), a[x][y] = b.clone().hour(o).minute(s).second(l), b.hour(12), this.minDate && a[x][y].format("YYYY-MM-DD") == this.minDate.format("YYYY-MM-DD") && a[x][y].isBefore(this.minDate) && "left" == n && (a[x][y] = this.minDate.clone()), this.maxDate && a[x][y].format("YYYY-MM-DD") == this.maxDate.format("YYYY-MM-DD") && a[x][y].isAfter(this.maxDate) && "right" == n && (a[x][y] = this.maxDate.clone());
                    "left" == n ? this.leftCalendar.calendar = a : this.rightCalendar.calendar = a;
                    var _ = "left" == n ? this.minDate : this.startDate, w = this.maxDate,
                        S = ("left" == n ? this.startDate : this.endDate, this.locale.direction, '<table class="table-condensed">');
                    S += "<thead>", S += "<tr>", (this.showWeekNumbers || this.showISOWeekNumbers) && (S += "<th></th>"), _ && !_.isBefore(a.firstDay) || this.linkedCalendars && "left" != n ? S += "<th></th>" : S += '<th class="prev available"><span></span></th>';
                    var C = this.locale.monthNames[a[1][1].month()] + a[1][1].format(" YYYY");
                    if (this.showDropdowns) {
                        for (var k = a[1][1].month(), D = a[1][1].year(), T = w && w.year() || this.maxYear, E = _ && _.year() || this.minYear, A = D == E, I = D == T, M = '<select class="monthselect">', R = 0; R < 12; R++) (!A || _ && R >= _.month()) && (!I || w && R <= w.month()) ? M += "<option value='" + R + "'" + (R === k ? " selected='selected'" : "") + ">" + this.locale.monthNames[R] + "</option>" : M += "<option value='" + R + "'" + (R === k ? " selected='selected'" : "") + " disabled='disabled'>" + this.locale.monthNames[R] + "</option>";
                        M += "</select>";
                        for (var P = '<select class="yearselect">', O = E; O <= T; O++) P += '<option value="' + O + '"' + (O === D ? ' selected="selected"' : "") + ">" + O + "</option>";
                        C = M + (P += "</select>")
                    }
                    if (S += '<th colspan="5" class="month">' + C + "</th>", w && !w.isAfter(a.lastDay) || this.linkedCalendars && "right" != n && !this.singleDatePicker ? S += "<th></th>" : S += '<th class="next available"><span></span></th>', S += "</tr>", S += "<tr>", (this.showWeekNumbers || this.showISOWeekNumbers) && (S += '<th class="week">' + this.locale.weekLabel + "</th>"), e.each(this.locale.daysOfWeek, (function (t, e) {
                        S += "<th>" + e + "</th>"
                    })), S += "</tr>", S += "</thead>", S += "<tbody>", null == this.endDate && this.maxSpan) {
                        var j = this.startDate.clone().add(this.maxSpan).endOf("day");
                        w && !j.isBefore(w) || (w = j)
                    }
                    for (x = 0; x < 6; x++) {
                        for (S += "<tr>", this.showWeekNumbers ? S += '<td class="week">' + a[x][0].week() + "</td>" : this.showISOWeekNumbers && (S += '<td class="week">' + a[x][0].isoWeek() + "</td>"), y = 0; y < 7; y++) {
                            var N = [];
                            a[x][y].isSame(new Date, "day") && N.push("today"), a[x][y].isoWeekday() > 5 && N.push("weekend"), a[x][y].month() != a[1][1].month() && N.push("off", "ends"), this.minDate && a[x][y].isBefore(this.minDate, "day") && N.push("off", "disabled"), w && a[x][y].isAfter(w, "day") && N.push("off", "disabled"), this.isInvalidDate(a[x][y]) && N.push("off", "disabled"), a[x][y].format("YYYY-MM-DD") == this.startDate.format("YYYY-MM-DD") && N.push("active", "start-date"), null != this.endDate && a[x][y].format("YYYY-MM-DD") == this.endDate.format("YYYY-MM-DD") && N.push("active", "end-date"), null != this.endDate && a[x][y] > this.startDate && a[x][y] < this.endDate && N.push("in-range");
                            var L = this.isCustomDate(a[x][y]);
                            !1 !== L && ("string" == typeof L ? N.push(L) : Array.prototype.push.apply(N, L));
                            var F = "", H = !1;
                            for (m = 0; m < N.length; m++) F += N[m] + " ", "disabled" == N[m] && (H = !0);
                            H || (F += "available"), S += '<td class="' + F.replace(/^\s+|\s+$/g, "") + '" data-title="r' + x + "c" + y + '">' + a[x][y].date() + "</td>"
                        }
                        S += "</tr>"
                    }
                    S += "</tbody>", S += "</table>", this.container.find(".drp-calendar." + n + " .calendar-table").html(S)
                }, renderTimePicker: function (t) {
                    if ("right" != t || this.endDate) {
                        var e, n, a, i = this.maxDate;
                        if (!this.maxSpan || this.maxDate && !this.startDate.clone().add(this.maxSpan).isBefore(this.maxDate) || (i = this.startDate.clone().add(this.maxSpan)), "left" == t) n = this.startDate.clone(), a = this.minDate; else if ("right" == t) {
                            n = this.endDate.clone(), a = this.startDate;
                            var r = this.container.find(".drp-calendar.right .calendar-time");
                            if ("" != r.html() && (n.hour(isNaN(n.hour()) ? r.find(".hourselect option:selected").val() : n.hour()), n.minute(isNaN(n.minute()) ? r.find(".minuteselect option:selected").val() : n.minute()), n.second(isNaN(n.second()) ? r.find(".secondselect option:selected").val() : n.second()), !this.timePicker24Hour)) {
                                var o = r.find(".ampmselect option:selected").val();
                                "PM" === o && n.hour() < 12 && n.hour(n.hour() + 12), "AM" === o && 12 === n.hour() && n.hour(0)
                            }
                            n.isBefore(this.startDate) && (n = this.startDate.clone()), i && n.isAfter(i) && (n = i.clone())
                        }
                        e = '<select class="hourselect">';
                        for (var s = this.timePicker24Hour ? 0 : 1, l = this.timePicker24Hour ? 23 : 12, c = s; c <= l; c++) {
                            var d = c;
                            this.timePicker24Hour || (d = n.hour() >= 12 ? 12 == c ? 12 : c + 12 : 12 == c ? 0 : c);
                            var u = n.clone().hour(d), h = !1;
                            a && u.minute(59).isBefore(a) && (h = !0), i && u.minute(0).isAfter(i) && (h = !0), d != n.hour() || h ? e += h ? '<option value="' + c + '" disabled="disabled" class="disabled">' + c + "</option>" : '<option value="' + c + '">' + c + "</option>" : e += '<option value="' + c + '" selected="selected">' + c + "</option>"
                        }
                        for (e += "</select> ", e += ': <select class="minuteselect">', c = 0; c < 60; c += this.timePickerIncrement) {
                            var p = c < 10 ? "0" + c : c;
                            u = n.clone().minute(c), h = !1, a && u.second(59).isBefore(a) && (h = !0), i && u.second(0).isAfter(i) && (h = !0), n.minute() != c || h ? e += h ? '<option value="' + c + '" disabled="disabled" class="disabled">' + p + "</option>" : '<option value="' + c + '">' + p + "</option>" : e += '<option value="' + c + '" selected="selected">' + p + "</option>"
                        }
                        if (e += "</select> ", this.timePickerSeconds) {
                            for (e += ': <select class="secondselect">', c = 0; c < 60; c++) p = c < 10 ? "0" + c : c, u = n.clone().second(c), h = !1, a && u.isBefore(a) && (h = !0), i && u.isAfter(i) && (h = !0), n.second() != c || h ? e += h ? '<option value="' + c + '" disabled="disabled" class="disabled">' + p + "</option>" : '<option value="' + c + '">' + p + "</option>" : e += '<option value="' + c + '" selected="selected">' + p + "</option>";
                            e += "</select> "
                        }
                        if (!this.timePicker24Hour) {
                            e += '<select class="ampmselect">';
                            var f = "", g = "";
                            a && n.clone().hour(12).minute(0).second(0).isBefore(a) && (f = ' disabled="disabled" class="disabled"'), i && n.clone().hour(0).minute(0).second(0).isAfter(i) && (g = ' disabled="disabled" class="disabled"'), n.hour() >= 12 ? e += '<option value="AM"' + f + '>AM</option><option value="PM" selected="selected"' + g + ">PM</option>" : e += '<option value="AM" selected="selected"' + f + '>AM</option><option value="PM"' + g + ">PM</option>", e += "</select>"
                        }
                        this.container.find(".drp-calendar." + t + " .calendar-time").html(e)
                    }
                }, updateFormInputs: function () {
                    this.singleDatePicker || this.endDate && (this.startDate.isBefore(this.endDate) || this.startDate.isSame(this.endDate)) ? this.container.find("button.applyBtn").prop("disabled", !1) : this.container.find("button.applyBtn").prop("disabled", !0)
                }, move: function () {
                    var t, n = {top: 0, left: 0}, a = this.drops, i = e(window).width();
                    switch (this.parentEl.is("body") || (n = {
                        top: this.parentEl.offset().top - this.parentEl.scrollTop(),
                        left: this.parentEl.offset().left - this.parentEl.scrollLeft()
                    }, i = this.parentEl[0].clientWidth + this.parentEl.offset().left), a) {
                        case"auto":
                            (t = this.element.offset().top + this.element.outerHeight() - n.top) + this.container.outerHeight() >= this.parentEl[0].scrollHeight && (t = this.element.offset().top - this.container.outerHeight() - n.top, a = "up");
                            break;
                        case"up":
                            t = this.element.offset().top - this.container.outerHeight() - n.top;
                            break;
                        default:
                            t = this.element.offset().top + this.element.outerHeight() - n.top
                    }
                    this.container.css({top: 0, left: 0, right: "auto"});
                    var r = this.container.outerWidth();
                    if (this.container.toggleClass("drop-up", "up" == a), "left" == this.opens) {
                        var o = i - this.element.offset().left - this.element.outerWidth();
                        r + o > e(window).width() ? this.container.css({
                            top: t,
                            right: "auto",
                            left: 9
                        }) : this.container.css({top: t, right: o, left: "auto"})
                    } else if ("center" == this.opens) (s = this.element.offset().left - n.left + this.element.outerWidth() / 2 - r / 2) < 0 ? this.container.css({
                        top: t,
                        right: "auto",
                        left: 9
                    }) : s + r > e(window).width() ? this.container.css({
                        top: t,
                        left: "auto",
                        right: 0
                    }) : this.container.css({top: t, left: s, right: "auto"}); else {
                        var s;
                        (s = this.element.offset().left - n.left) + r > e(window).width() ? this.container.css({
                            top: t,
                            left: "auto",
                            right: 0
                        }) : this.container.css({top: t, left: s, right: "auto"})
                    }
                }, show: function (t) {
                    this.isShowing || (this._outsideClickProxy = e.proxy((function (t) {
                        this.outsideClick(t)
                    }), this), e(document).on("mousedown.daterangepicker", this._outsideClickProxy).on("touchend.daterangepicker", this._outsideClickProxy).on("click.daterangepicker", "[data-toggle=dropdown]", this._outsideClickProxy).on("focusin.daterangepicker", this._outsideClickProxy), e(window).on("resize.daterangepicker", e.proxy((function (t) {
                        this.move(t)
                    }), this)), this.oldStartDate = this.startDate.clone(), this.oldEndDate = this.endDate.clone(), this.previousRightTime = this.endDate.clone(), this.updateView(), this.container.show(), this.move(), this.element.trigger("show.daterangepicker", this), this.isShowing = !0)
                }, hide: function (t) {
                    this.isShowing && (this.endDate || (this.startDate = this.oldStartDate.clone(), this.endDate = this.oldEndDate.clone()), this.startDate.isSame(this.oldStartDate) && this.endDate.isSame(this.oldEndDate) || this.callback(this.startDate.clone(), this.endDate.clone(), this.chosenLabel), this.updateElement(), e(document).off(".daterangepicker"), e(window).off(".daterangepicker"), this.container.hide(), this.element.trigger("hide.daterangepicker", this), this.isShowing = !1)
                }, toggle: function (t) {
                    this.isShowing ? this.hide() : this.show()
                }, outsideClick: function (t) {
                    var n = e(t.target);
                    "focusin" == t.type || n.closest(this.element).length || n.closest(this.container).length || n.closest(".calendar-table").length || (this.hide(), this.element.trigger("outsideClick.daterangepicker", this))
                }, showCalendars: function () {
                    this.container.addClass("show-calendar"), this.move(), this.element.trigger("showCalendar.daterangepicker", this)
                }, hideCalendars: function () {
                    this.container.removeClass("show-calendar"), this.element.trigger("hideCalendar.daterangepicker", this)
                }, clickRange: function (t) {
                    var e = t.target.getAttribute("data-range-key");
                    if (this.chosenLabel = e, e == this.locale.customRangeLabel) this.showCalendars(); else {
                        var n = this.ranges[e];
                        this.startDate = n[0], this.endDate = n[1], this.timePicker || (this.startDate.startOf("day"), this.endDate.endOf("day")), this.alwaysShowCalendars || this.hideCalendars(), this.clickApply()
                    }
                }, clickPrev: function (t) {
                    e(t.target).parents(".drp-calendar").hasClass("left") ? (this.leftCalendar.month.subtract(1, "month"), this.linkedCalendars && this.rightCalendar.month.subtract(1, "month")) : this.rightCalendar.month.subtract(1, "month"), this.updateCalendars()
                }, clickNext: function (t) {
                    e(t.target).parents(".drp-calendar").hasClass("left") ? this.leftCalendar.month.add(1, "month") : (this.rightCalendar.month.add(1, "month"), this.linkedCalendars && this.leftCalendar.month.add(1, "month")), this.updateCalendars()
                }, hoverDate: function (t) {
                    if (e(t.target).hasClass("available")) {
                        var n = e(t.target).attr("data-title"), a = n.substr(1, 1), i = n.substr(3, 1),
                            r = e(t.target).parents(".drp-calendar").hasClass("left") ? this.leftCalendar.calendar[a][i] : this.rightCalendar.calendar[a][i],
                            o = this.leftCalendar, s = this.rightCalendar, l = this.startDate;
                        this.endDate || this.container.find(".drp-calendar tbody td").each((function (t, n) {
                            if (!e(n).hasClass("week")) {
                                var a = e(n).attr("data-title"), i = a.substr(1, 1), c = a.substr(3, 1),
                                    d = e(n).parents(".drp-calendar").hasClass("left") ? o.calendar[i][c] : s.calendar[i][c];
                                d.isAfter(l) && d.isBefore(r) || d.isSame(r, "day") ? e(n).addClass("in-range") : e(n).removeClass("in-range")
                            }
                        }))
                    }
                }, clickDate: function (t) {
                    if (e(t.target).hasClass("available")) {
                        var n = e(t.target).attr("data-title"), a = n.substr(1, 1), i = n.substr(3, 1),
                            r = e(t.target).parents(".drp-calendar").hasClass("left") ? this.leftCalendar.calendar[a][i] : this.rightCalendar.calendar[a][i];
                        if (this.endDate || r.isBefore(this.startDate, "day")) {
                            if (this.timePicker) {
                                var o = parseInt(this.container.find(".left .hourselect").val(), 10);
                                this.timePicker24Hour || ("PM" === (c = this.container.find(".left .ampmselect").val()) && o < 12 && (o += 12), "AM" === c && 12 === o && (o = 0));
                                var s = parseInt(this.container.find(".left .minuteselect").val(), 10);
                                isNaN(s) && (s = parseInt(this.container.find(".left .minuteselect option:last").val(), 10));
                                var l = this.timePickerSeconds ? parseInt(this.container.find(".left .secondselect").val(), 10) : 0;
                                r = r.clone().hour(o).minute(s).second(l)
                            }
                            this.endDate = null, this.setStartDate(r.clone())
                        } else if (!this.endDate && r.isBefore(this.startDate)) this.setEndDate(this.startDate.clone()); else {
                            var c;
                            if (this.timePicker) o = parseInt(this.container.find(".right .hourselect").val(), 10), this.timePicker24Hour || ("PM" === (c = this.container.find(".right .ampmselect").val()) && o < 12 && (o += 12), "AM" === c && 12 === o && (o = 0)), s = parseInt(this.container.find(".right .minuteselect").val(), 10), isNaN(s) && (s = parseInt(this.container.find(".right .minuteselect option:last").val(), 10)), l = this.timePickerSeconds ? parseInt(this.container.find(".right .secondselect").val(), 10) : 0, r = r.clone().hour(o).minute(s).second(l);
                            this.setEndDate(r.clone()), this.autoApply && (this.calculateChosenLabel(), this.clickApply())
                        }
                        this.singleDatePicker && (this.setEndDate(this.startDate), !this.timePicker && this.autoApply && this.clickApply()), this.updateView(), t.stopPropagation()
                    }
                }, calculateChosenLabel: function () {
                    var t = !0, e = 0;
                    for (var n in this.ranges) {
                        if (this.timePicker) {
                            var a = this.timePickerSeconds ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD HH:mm";
                            if (this.startDate.format(a) == this.ranges[n][0].format(a) && this.endDate.format(a) == this.ranges[n][1].format(a)) {
                                t = !1, this.chosenLabel = this.container.find(".ranges li:eq(" + e + ")").addClass("active").attr("data-range-key");
                                break
                            }
                        } else if (this.startDate.format("YYYY-MM-DD") == this.ranges[n][0].format("YYYY-MM-DD") && this.endDate.format("YYYY-MM-DD") == this.ranges[n][1].format("YYYY-MM-DD")) {
                            t = !1, this.chosenLabel = this.container.find(".ranges li:eq(" + e + ")").addClass("active").attr("data-range-key");
                            break
                        }
                        e++
                    }
                    t && (this.showCustomRangeLabel ? this.chosenLabel = this.container.find(".ranges li:last").addClass("active").attr("data-range-key") : this.chosenLabel = null, this.showCalendars())
                }, clickApply: function (t) {
                    this.hide(), this.element.trigger("apply.daterangepicker", this)
                }, clickCancel: function (t) {
                    this.startDate = this.oldStartDate, this.endDate = this.oldEndDate, this.hide(), this.element.trigger("cancel.daterangepicker", this)
                }, monthOrYearChanged: function (t) {
                    var n = e(t.target).closest(".drp-calendar").hasClass("left"), a = n ? "left" : "right",
                        i = this.container.find(".drp-calendar." + a), r = parseInt(i.find(".monthselect").val(), 10),
                        o = i.find(".yearselect").val();
                    n || (o < this.startDate.year() || o == this.startDate.year() && r < this.startDate.month()) && (r = this.startDate.month(), o = this.startDate.year()), this.minDate && (o < this.minDate.year() || o == this.minDate.year() && r < this.minDate.month()) && (r = this.minDate.month(), o = this.minDate.year()), this.maxDate && (o > this.maxDate.year() || o == this.maxDate.year() && r > this.maxDate.month()) && (r = this.maxDate.month(), o = this.maxDate.year()), n ? (this.leftCalendar.month.month(r).year(o), this.linkedCalendars && (this.rightCalendar.month = this.leftCalendar.month.clone().add(1, "month"))) : (this.rightCalendar.month.month(r).year(o), this.linkedCalendars && (this.leftCalendar.month = this.rightCalendar.month.clone().subtract(1, "month"))), this.updateCalendars()
                }, timeChanged: function (t) {
                    var n = e(t.target).closest(".drp-calendar"), a = n.hasClass("left"),
                        i = parseInt(n.find(".hourselect").val(), 10), r = parseInt(n.find(".minuteselect").val(), 10);
                    isNaN(r) && (r = parseInt(n.find(".minuteselect option:last").val(), 10));
                    var o = this.timePickerSeconds ? parseInt(n.find(".secondselect").val(), 10) : 0;
                    if (!this.timePicker24Hour) {
                        var s = n.find(".ampmselect").val();
                        "PM" === s && i < 12 && (i += 12), "AM" === s && 12 === i && (i = 0)
                    }
                    if (a) {
                        var l = this.startDate.clone();
                        l.hour(i), l.minute(r), l.second(o), this.setStartDate(l), this.singleDatePicker ? this.endDate = this.startDate.clone() : this.endDate && this.endDate.format("YYYY-MM-DD") == l.format("YYYY-MM-DD") && this.endDate.isBefore(l) && this.setEndDate(l.clone())
                    } else if (this.endDate) {
                        var c = this.endDate.clone();
                        c.hour(i), c.minute(r), c.second(o), this.setEndDate(c)
                    }
                    this.updateCalendars(), this.updateFormInputs(), this.renderTimePicker("left"), this.renderTimePicker("right")
                }, elementChanged: function () {
                    if (this.element.is("input") && this.element.val().length) {
                        var e = this.element.val().split(this.locale.separator), n = null, a = null;
                        2 === e.length && (n = t(e[0], this.locale.format), a = t(e[1], this.locale.format)), (this.singleDatePicker || null === n || null === a) && (a = n = t(this.element.val(), this.locale.format)), n.isValid() && a.isValid() && (this.setStartDate(n), this.setEndDate(a), this.updateView())
                    }
                }, keydown: function (t) {
                    9 !== t.keyCode && 13 !== t.keyCode || this.hide(), 27 === t.keyCode && (t.preventDefault(), t.stopPropagation(), this.hide())
                }, updateElement: function () {
                    if (this.element.is("input") && this.autoUpdateInput) {
                        var t = this.startDate.format(this.locale.format);
                        this.singleDatePicker || (t += this.locale.separator + this.endDate.format(this.locale.format)), t !== this.element.val() && this.element.val(t).trigger("change")
                    }
                }, remove: function () {
                    this.container.remove(), this.element.off(".daterangepicker"), this.element.removeData()
                }
            }, e.fn.daterangepicker = function (t, a) {
                var i = e.extend(!0, {}, e.fn.daterangepicker.defaultOptions, t);
                return this.each((function () {
                    var t = e(this);
                    t.data("daterangepicker") && t.data("daterangepicker").remove(), t.data("daterangepicker", new n(t, i, a))
                })), this
            }, n
        }(t, e)
    }.apply(e, a)) || (t.exports = i)
}, function (t, e, n) {
    "use strict";
    (function (t) {
        n(227);
        t.fn.datetimepicker.Constructor.Default = t.extend({}, t.fn.datetimepicker.Constructor.Default, {
            icons: {
                time: "far fa-clock",
                date: "far fa-calendar",
                up: "fas fa-arrow-up",
                down: "fas fa-arrow-down",
                previous: "fas fa-chevron-left",
                next: "fas fa-chevron-right",
                today: "far fa-calendar-check-o",
                clear: "fas fa-trash",
                close: "fas fa-times"
            }
        })
    }).call(this, n(16))
}, function (t, e, n) {
    (function (t) {
        if (void 0 === t) throw new Error("Tempus Dominus Bootstrap4's requires jQuery. jQuery must be included before Tempus Dominus Bootstrap4's JavaScript.");
        if (function (t) {
            var e = t.fn.jquery.split(" ")[0].split(".");
            if (e[0] < 2 && e[1] < 9 || 1 === e[0] && 9 === e[1] && e[2] < 1 || e[0] >= 4) throw new Error("Tempus Dominus Bootstrap4's requires at least jQuery v3.0.0 but less than v4.0.0")
        }(t), "undefined" == typeof moment) throw new Error("Tempus Dominus Bootstrap4's requires moment.js. Moment.js must be included before Tempus Dominus Bootstrap4's JavaScript.");
        var e = moment.version.split(".");
        if (e[0] <= 2 && e[1] < 17 || e[0] >= 3) throw new Error("Tempus Dominus Bootstrap4's requires at least moment.js v2.17.0 but less than v3.0.0");
        !function () {
            var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) {
                return typeof t
            } : function (t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, n = function () {
                function t(t, e) {
                    for (var n = 0; n < e.length; n++) {
                        var a = e[n];
                        a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
                    }
                }

                return function (e, n, a) {
                    return n && t(e.prototype, n), a && t(e, a), e
                }
            }();

            function a(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            }

            var i = function (t, e) {
                var i = "datetimepicker", r = "" + i, o = "." + r, s = ".data-api",
                    l = {DATA_TOGGLE: '[data-toggle="' + r + '"]'}, c = {INPUT: i + "-input"}, d = {
                        CHANGE: "change" + o,
                        BLUR: "blur" + o,
                        KEYUP: "keyup" + o,
                        KEYDOWN: "keydown" + o,
                        FOCUS: "focus" + o,
                        CLICK_DATA_API: "click" + o + s,
                        UPDATE: "update" + o,
                        ERROR: "error" + o,
                        HIDE: "hide" + o,
                        SHOW: "show" + o
                    }, u = [{CLASS_NAME: "days", NAV_FUNCTION: "M", NAV_STEP: 1}, {
                        CLASS_NAME: "months",
                        NAV_FUNCTION: "y",
                        NAV_STEP: 1
                    }, {CLASS_NAME: "years", NAV_FUNCTION: "y", NAV_STEP: 10}, {
                        CLASS_NAME: "decades",
                        NAV_FUNCTION: "y",
                        NAV_STEP: 100
                    }], h = {
                        up: 38,
                        38: "up",
                        down: 40,
                        40: "down",
                        left: 37,
                        37: "left",
                        right: 39,
                        39: "right",
                        tab: 9,
                        9: "tab",
                        escape: 27,
                        27: "escape",
                        enter: 13,
                        13: "enter",
                        pageUp: 33,
                        33: "pageUp",
                        pageDown: 34,
                        34: "pageDown",
                        shift: 16,
                        16: "shift",
                        control: 17,
                        17: "control",
                        space: 32,
                        32: "space",
                        t: 84,
                        84: "t",
                        delete: 46,
                        46: "delete"
                    }, p = ["times", "days", "months", "years", "decades"], f = {}, g = {}, m = {
                        timeZone: "",
                        format: !1,
                        dayViewHeaderFormat: "MMMM YYYY",
                        extraFormats: !1,
                        stepping: 1,
                        minDate: !1,
                        maxDate: !1,
                        useCurrent: !0,
                        collapse: !0,
                        locale: e.locale(),
                        defaultDate: !1,
                        disabledDates: !1,
                        enabledDates: !1,
                        icons: {
                            time: "fa fa-clock-o",
                            date: "fa fa-calendar",
                            up: "fa fa-arrow-up",
                            down: "fa fa-arrow-down",
                            previous: "fa fa-chevron-left",
                            next: "fa fa-chevron-right",
                            today: "fa fa-calendar-check-o",
                            clear: "fa fa-delete",
                            close: "fa fa-times"
                        },
                        tooltips: {
                            today: "Go to today",
                            clear: "Clear selection",
                            close: "Close the picker",
                            selectMonth: "Select Month",
                            prevMonth: "Previous Month",
                            nextMonth: "Next Month",
                            selectYear: "Select Year",
                            prevYear: "Previous Year",
                            nextYear: "Next Year",
                            selectDecade: "Select Decade",
                            prevDecade: "Previous Decade",
                            nextDecade: "Next Decade",
                            prevCentury: "Previous Century",
                            nextCentury: "Next Century",
                            pickHour: "Pick Hour",
                            incrementHour: "Increment Hour",
                            decrementHour: "Decrement Hour",
                            pickMinute: "Pick Minute",
                            incrementMinute: "Increment Minute",
                            decrementMinute: "Decrement Minute",
                            pickSecond: "Pick Second",
                            incrementSecond: "Increment Second",
                            decrementSecond: "Decrement Second",
                            togglePeriod: "Toggle Period",
                            selectTime: "Select Time",
                            selectDate: "Select Date"
                        },
                        useStrict: !1,
                        sideBySide: !1,
                        daysOfWeekDisabled: !1,
                        calendarWeeks: !1,
                        viewMode: "days",
                        toolbarPlacement: "default",
                        buttons: {showToday: !1, showClear: !1, showClose: !1},
                        widgetPositioning: {horizontal: "auto", vertical: "auto"},
                        widgetParent: null,
                        ignoreReadonly: !1,
                        keepOpen: !1,
                        focusOnShow: !0,
                        inline: !1,
                        keepInvalid: !1,
                        keyBinds: {
                            up: function () {
                                if (!this.widget) return !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") ? this.date(t.clone().subtract(7, "d")) : this.date(t.clone().add(this.stepping(), "m")), !0
                            }, down: function () {
                                if (!this.widget) return this.show(), !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") ? this.date(t.clone().add(7, "d")) : this.date(t.clone().subtract(this.stepping(), "m")), !0
                            }, "control up": function () {
                                if (!this.widget) return !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") ? this.date(t.clone().subtract(1, "y")) : this.date(t.clone().add(1, "h")), !0
                            }, "control down": function () {
                                if (!this.widget) return !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") ? this.date(t.clone().add(1, "y")) : this.date(t.clone().subtract(1, "h")), !0
                            }, left: function () {
                                if (!this.widget) return !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") && this.date(t.clone().subtract(1, "d")), !0
                            }, right: function () {
                                if (!this.widget) return !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") && this.date(t.clone().add(1, "d")), !0
                            }, pageUp: function () {
                                if (!this.widget) return !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") && this.date(t.clone().subtract(1, "M")), !0
                            }, pageDown: function () {
                                if (!this.widget) return !1;
                                var t = this._dates[0] || this.getMoment();
                                return this.widget.find(".datepicker").is(":visible") && this.date(t.clone().add(1, "M")), !0
                            }, enter: function () {
                                return !!this.widget && (this.hide(), !0)
                            }, escape: function () {
                                return !!this.widget && (this.hide(), !0)
                            }, "control space": function () {
                                return !!this.widget && (this.widget.find(".timepicker").is(":visible") && this.widget.find('.btn[data-action="togglePeriod"]').click(), !0)
                            }, t: function () {
                                return !!this.widget && (this.date(this.getMoment()), !0)
                            }, delete: function () {
                                return !!this.widget && (this.clear(), !0)
                            }
                        },
                        debug: !1,
                        allowInputToggle: !1,
                        disabledTimeIntervals: !1,
                        disabledHours: !1,
                        enabledHours: !1,
                        viewDate: !1,
                        allowMultidate: !1,
                        multidateSeparator: ","
                    };
                return function () {
                    function v(t, e) {
                        a(this, v), this._options = this._getOptions(e), this._element = t, this._dates = [], this._datesFormatted = [], this._viewDate = null, this.unset = !0, this.component = !1, this.widget = !1, this.use24Hours = null, this.actualFormat = null, this.parseFormats = null, this.currentViewMode = null, this.MinViewModeNumber = 0, this._int()
                    }

                    return v.prototype._int = function () {
                        var e = this._element.data("target-input");
                        this._element.is("input") ? this.input = this._element : void 0 !== e && (this.input = "nearest" === e ? this._element.find("input") : t(e)), this._dates = [], this._dates[0] = this.getMoment(), this._viewDate = this.getMoment().clone(), t.extend(!0, this._options, this._dataToOptions()), this.options(this._options), this._initFormatting(), void 0 !== this.input && this.input.is("input") && 0 !== this.input.val().trim().length ? this._setValue(this._parseInputDate(this.input.val().trim()), 0) : this._options.defaultDate && void 0 !== this.input && void 0 === this.input.attr("placeholder") && this._setValue(this._options.defaultDate, 0), this._options.inline && this.show()
                    }, v.prototype._update = function () {
                        this.widget && (this._fillDate(), this._fillTime())
                    }, v.prototype._setValue = function (t, e) {
                        var n = this.unset ? null : this._dates[e], a = "";
                        if (!t) return this._options.allowMultidate && 1 !== this._dates.length ? (a = (a = this._element.data("date") + ",").replace(n.format(this.actualFormat) + ",", "").replace(",,", "").replace(/,\s*$/, ""), this._dates.splice(e, 1), this._datesFormatted.splice(e, 1)) : (this.unset = !0, this._dates = [], this._datesFormatted = []), void 0 !== this.input && (this.input.val(a), this.input.trigger("input")), this._element.data("date", a), this._notifyEvent({
                            type: v.Event.CHANGE,
                            date: !1,
                            oldDate: n
                        }), void this._update();
                        if (t = t.clone().locale(this._options.locale), this._hasTimeZone() && t.tz(this._options.timeZone), 1 !== this._options.stepping && t.minutes(Math.round(t.minutes() / this._options.stepping) * this._options.stepping).seconds(0), this._isValid(t)) {
                            if (this._dates[e] = t, this._datesFormatted[e] = t.format("YYYY-MM-DD"), this._viewDate = t.clone(), this._options.allowMultidate && this._dates.length > 1) {
                                for (var i = 0; i < this._dates.length; i++) a += "" + this._dates[i].format(this.actualFormat) + this._options.multidateSeparator;
                                a = a.replace(/,\s*$/, "")
                            } else a = this._dates[e].format(this.actualFormat);
                            void 0 !== this.input && (this.input.val(a), this.input.trigger("input")), this._element.data("date", a), this.unset = !1, this._update(), this._notifyEvent({
                                type: v.Event.CHANGE,
                                date: this._dates[e].clone(),
                                oldDate: n
                            })
                        } else this._options.keepInvalid ? this._notifyEvent({
                            type: v.Event.CHANGE,
                            date: t,
                            oldDate: n
                        }) : void 0 !== this.input && (this.input.val("" + (this.unset ? "" : this._dates[e].format(this.actualFormat))), this.input.trigger("input")), this._notifyEvent({
                            type: v.Event.ERROR,
                            date: t,
                            oldDate: n
                        })
                    }, v.prototype._change = function (e) {
                        var n = t(e.target).val().trim(), a = n ? this._parseInputDate(n) : null;
                        return this._setValue(a), e.stopImmediatePropagation(), !1
                    }, v.prototype._getOptions = function (e) {
                        return e = t.extend(!0, {}, m, e)
                    }, v.prototype._hasTimeZone = function () {
                        return void 0 !== e.tz && void 0 !== this._options.timeZone && null !== this._options.timeZone && "" !== this._options.timeZone
                    }, v.prototype._isEnabled = function (t) {
                        if ("string" != typeof t || t.length > 1) throw new TypeError("isEnabled expects a single character string parameter");
                        switch (t) {
                            case"y":
                                return -1 !== this.actualFormat.indexOf("Y");
                            case"M":
                                return -1 !== this.actualFormat.indexOf("M");
                            case"d":
                                return -1 !== this.actualFormat.toLowerCase().indexOf("d");
                            case"h":
                            case"H":
                                return -1 !== this.actualFormat.toLowerCase().indexOf("h");
                            case"m":
                                return -1 !== this.actualFormat.indexOf("m");
                            case"s":
                                return -1 !== this.actualFormat.indexOf("s");
                            case"a":
                            case"A":
                                return -1 !== this.actualFormat.toLowerCase().indexOf("a");
                            default:
                                return !1
                        }
                    }, v.prototype._hasTime = function () {
                        return this._isEnabled("h") || this._isEnabled("m") || this._isEnabled("s")
                    }, v.prototype._hasDate = function () {
                        return this._isEnabled("y") || this._isEnabled("M") || this._isEnabled("d")
                    }, v.prototype._dataToOptions = function () {
                        var e = this._element.data(), n = {};
                        return e.dateOptions && e.dateOptions instanceof Object && (n = t.extend(!0, n, e.dateOptions)), t.each(this._options, (function (t) {
                            var a = "date" + t.charAt(0).toUpperCase() + t.slice(1);
                            void 0 !== e[a] ? n[t] = e[a] : delete n[t]
                        })), n
                    }, v.prototype._notifyEvent = function (t) {
                        t.type === v.Event.CHANGE && t.date && t.date.isSame(t.oldDate) || !t.date && !t.oldDate || this._element.trigger(t)
                    }, v.prototype._viewUpdate = function (t) {
                        "y" === t && (t = "YYYY"), this._notifyEvent({
                            type: v.Event.UPDATE,
                            change: t,
                            viewDate: this._viewDate.clone()
                        })
                    }, v.prototype._showMode = function (t) {
                        this.widget && (t && (this.currentViewMode = Math.max(this.MinViewModeNumber, Math.min(3, this.currentViewMode + t))), this.widget.find(".datepicker > div").hide().filter(".datepicker-" + u[this.currentViewMode].CLASS_NAME).show())
                    }, v.prototype._isInDisabledDates = function (t) {
                        return !0 === this._options.disabledDates[t.format("YYYY-MM-DD")]
                    }, v.prototype._isInEnabledDates = function (t) {
                        return !0 === this._options.enabledDates[t.format("YYYY-MM-DD")]
                    }, v.prototype._isInDisabledHours = function (t) {
                        return !0 === this._options.disabledHours[t.format("H")]
                    }, v.prototype._isInEnabledHours = function (t) {
                        return !0 === this._options.enabledHours[t.format("H")]
                    }, v.prototype._isValid = function (e, n) {
                        if (!e.isValid()) return !1;
                        if (this._options.disabledDates && "d" === n && this._isInDisabledDates(e)) return !1;
                        if (this._options.enabledDates && "d" === n && !this._isInEnabledDates(e)) return !1;
                        if (this._options.minDate && e.isBefore(this._options.minDate, n)) return !1;
                        if (this._options.maxDate && e.isAfter(this._options.maxDate, n)) return !1;
                        if (this._options.daysOfWeekDisabled && "d" === n && -1 !== this._options.daysOfWeekDisabled.indexOf(e.day())) return !1;
                        if (this._options.disabledHours && ("h" === n || "m" === n || "s" === n) && this._isInDisabledHours(e)) return !1;
                        if (this._options.enabledHours && ("h" === n || "m" === n || "s" === n) && !this._isInEnabledHours(e)) return !1;
                        if (this._options.disabledTimeIntervals && ("h" === n || "m" === n || "s" === n)) {
                            var a = !1;
                            if (t.each(this._options.disabledTimeIntervals, (function () {
                                if (e.isBetween(this[0], this[1])) return a = !0, !1
                            })), a) return !1
                        }
                        return !0
                    }, v.prototype._parseInputDate = function (t) {
                        return void 0 === this._options.parseInputDate ? e.isMoment(t) || (t = this.getMoment(t)) : t = this._options.parseInputDate(t), t
                    }, v.prototype._keydown = function (t) {
                        var e = null, n = void 0, a = void 0, i = void 0, r = void 0, o = [], s = {}, l = t.which;
                        for (n in f[l] = "p", f) f.hasOwnProperty(n) && "p" === f[n] && (o.push(n), parseInt(n, 10) !== l && (s[n] = !0));
                        for (n in this._options.keyBinds) if (this._options.keyBinds.hasOwnProperty(n) && "function" == typeof this._options.keyBinds[n] && (i = n.split(" ")).length === o.length && h[l] === i[i.length - 1]) {
                            for (r = !0, a = i.length - 2; a >= 0; a--) if (!(h[i[a]] in s)) {
                                r = !1;
                                break
                            }
                            if (r) {
                                e = this._options.keyBinds[n];
                                break
                            }
                        }
                        e && e.call(this) && (t.stopPropagation(), t.preventDefault())
                    }, v.prototype._keyup = function (t) {
                        f[t.which] = "r", g[t.which] && (g[t.which] = !1, t.stopPropagation(), t.preventDefault())
                    }, v.prototype._indexGivenDates = function (e) {
                        var n = {}, a = this;
                        return t.each(e, (function () {
                            var t = a._parseInputDate(this);
                            t.isValid() && (n[t.format("YYYY-MM-DD")] = !0)
                        })), !!Object.keys(n).length && n
                    }, v.prototype._indexGivenHours = function (e) {
                        var n = {};
                        return t.each(e, (function () {
                            n[this] = !0
                        })), !!Object.keys(n).length && n
                    }, v.prototype._initFormatting = function () {
                        var t = this._options.format || "L LT", e = this;
                        this.actualFormat = t.replace(/(\[[^\[]*])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, (function (t) {
                            return e._dates[0].localeData().longDateFormat(t) || t
                        })), this.parseFormats = this._options.extraFormats ? this._options.extraFormats.slice() : [], this.parseFormats.indexOf(t) < 0 && this.parseFormats.indexOf(this.actualFormat) < 0 && this.parseFormats.push(this.actualFormat), this.use24Hours = this.actualFormat.toLowerCase().indexOf("a") < 1 && this.actualFormat.replace(/\[.*?]/g, "").indexOf("h") < 1, this._isEnabled("y") && (this.MinViewModeNumber = 2), this._isEnabled("M") && (this.MinViewModeNumber = 1), this._isEnabled("d") && (this.MinViewModeNumber = 0), this.currentViewMode = Math.max(this.MinViewModeNumber, this.currentViewMode), this.unset || this._setValue(this._dates[0], 0)
                    }, v.prototype._getLastPickedDate = function () {
                        return this._dates[this._getLastPickedDateIndex()]
                    }, v.prototype._getLastPickedDateIndex = function () {
                        return this._dates.length - 1
                    }, v.prototype.getMoment = function (t) {
                        var n = void 0;
                        return n = null == t ? e() : this._hasTimeZone() ? e.tz(t, this.parseFormats, this._options.locale, this._options.useStrict, this._options.timeZone) : e(t, this.parseFormats, this._options.locale, this._options.useStrict), this._hasTimeZone() && n.tz(this._options.timeZone), n
                    }, v.prototype.toggle = function () {
                        return this.widget ? this.hide() : this.show()
                    }, v.prototype.ignoreReadonly = function (t) {
                        if (0 === arguments.length) return this._options.ignoreReadonly;
                        if ("boolean" != typeof t) throw new TypeError("ignoreReadonly () expects a boolean parameter");
                        this._options.ignoreReadonly = t
                    }, v.prototype.options = function (e) {
                        if (0 === arguments.length) return t.extend(!0, {}, this._options);
                        if (!(e instanceof Object)) throw new TypeError("options() this.options parameter should be an object");
                        t.extend(!0, this._options, e);
                        var n = this;
                        t.each(this._options, (function (t, e) {
                            void 0 !== n[t] && n[t](e)
                        }))
                    }, v.prototype.date = function (t, n) {
                        if (n = n || 0, 0 === arguments.length) return this.unset ? null : this._options.allowMultidate ? this._dates.join(this._options.multidateSeparator) : this._dates[n].clone();
                        if (!(null === t || "string" == typeof t || e.isMoment(t) || t instanceof Date)) throw new TypeError("date() parameter must be one of [null, string, moment or Date]");
                        this._setValue(null === t ? null : this._parseInputDate(t), n)
                    }, v.prototype.format = function (t) {
                        if (0 === arguments.length) return this._options.format;
                        if ("string" != typeof t && ("boolean" != typeof t || !1 !== t)) throw new TypeError("format() expects a string or boolean:false parameter " + t);
                        this._options.format = t, this.actualFormat && this._initFormatting()
                    }, v.prototype.timeZone = function (t) {
                        if (0 === arguments.length) return this._options.timeZone;
                        if ("string" != typeof t) throw new TypeError("newZone() expects a string parameter");
                        this._options.timeZone = t
                    }, v.prototype.dayViewHeaderFormat = function (t) {
                        if (0 === arguments.length) return this._options.dayViewHeaderFormat;
                        if ("string" != typeof t) throw new TypeError("dayViewHeaderFormat() expects a string parameter");
                        this._options.dayViewHeaderFormat = t
                    }, v.prototype.extraFormats = function (t) {
                        if (0 === arguments.length) return this._options.extraFormats;
                        if (!1 !== t && !(t instanceof Array)) throw new TypeError("extraFormats() expects an array or false parameter");
                        this._options.extraFormats = t, this.parseFormats && this._initFormatting()
                    }, v.prototype.disabledDates = function (e) {
                        if (0 === arguments.length) return this._options.disabledDates ? t.extend({}, this._options.disabledDates) : this._options.disabledDates;
                        if (!e) return this._options.disabledDates = !1, this._update(), !0;
                        if (!(e instanceof Array)) throw new TypeError("disabledDates() expects an array parameter");
                        this._options.disabledDates = this._indexGivenDates(e), this._options.enabledDates = !1, this._update()
                    }, v.prototype.enabledDates = function (e) {
                        if (0 === arguments.length) return this._options.enabledDates ? t.extend({}, this._options.enabledDates) : this._options.enabledDates;
                        if (!e) return this._options.enabledDates = !1, this._update(), !0;
                        if (!(e instanceof Array)) throw new TypeError("enabledDates() expects an array parameter");
                        this._options.enabledDates = this._indexGivenDates(e), this._options.disabledDates = !1, this._update()
                    }, v.prototype.daysOfWeekDisabled = function (t) {
                        if (0 === arguments.length) return this._options.daysOfWeekDisabled.splice(0);
                        if ("boolean" == typeof t && !t) return this._options.daysOfWeekDisabled = !1, this._update(), !0;
                        if (!(t instanceof Array)) throw new TypeError("daysOfWeekDisabled() expects an array parameter");
                        if (this._options.daysOfWeekDisabled = t.reduce((function (t, e) {
                            return (e = parseInt(e, 10)) > 6 || e < 0 || isNaN(e) || -1 === t.indexOf(e) && t.push(e), t
                        }), []).sort(), this._options.useCurrent && !this._options.keepInvalid) for (var e = 0; e < this._dates.length; e++) {
                            for (var n = 0; !this._isValid(this._dates[e], "d");) {
                                if (this._dates[e].add(1, "d"), 31 === n) throw"Tried 31 times to find a valid date";
                                n++
                            }
                            this._setValue(this._dates[e], e)
                        }
                        this._update()
                    }, v.prototype.maxDate = function (t) {
                        if (0 === arguments.length) return this._options.maxDate ? this._options.maxDate.clone() : this._options.maxDate;
                        if ("boolean" == typeof t && !1 === t) return this._options.maxDate = !1, this._update(), !0;
                        "string" == typeof t && ("now" !== t && "moment" !== t || (t = this.getMoment()));
                        var e = this._parseInputDate(t);
                        if (!e.isValid()) throw new TypeError("maxDate() Could not parse date parameter: " + t);
                        if (this._options.minDate && e.isBefore(this._options.minDate)) throw new TypeError("maxDate() date parameter is before this.options.minDate: " + e.format(this.actualFormat));
                        this._options.maxDate = e;
                        for (var n = 0; n < this._dates.length; n++) this._options.useCurrent && !this._options.keepInvalid && this._dates[n].isAfter(t) && this._setValue(this._options.maxDate, n);
                        this._viewDate.isAfter(e) && (this._viewDate = e.clone().subtract(this._options.stepping, "m")), this._update()
                    }, v.prototype.minDate = function (t) {
                        if (0 === arguments.length) return this._options.minDate ? this._options.minDate.clone() : this._options.minDate;
                        if ("boolean" == typeof t && !1 === t) return this._options.minDate = !1, this._update(), !0;
                        "string" == typeof t && ("now" !== t && "moment" !== t || (t = this.getMoment()));
                        var e = this._parseInputDate(t);
                        if (!e.isValid()) throw new TypeError("minDate() Could not parse date parameter: " + t);
                        if (this._options.maxDate && e.isAfter(this._options.maxDate)) throw new TypeError("minDate() date parameter is after this.options.maxDate: " + e.format(this.actualFormat));
                        this._options.minDate = e;
                        for (var n = 0; n < this._dates.length; n++) this._options.useCurrent && !this._options.keepInvalid && this._dates[n].isBefore(t) && this._setValue(this._options.minDate, n);
                        this._viewDate.isBefore(e) && (this._viewDate = e.clone().add(this._options.stepping, "m")), this._update()
                    }, v.prototype.defaultDate = function (t) {
                        if (0 === arguments.length) return this._options.defaultDate ? this._options.defaultDate.clone() : this._options.defaultDate;
                        if (!t) return this._options.defaultDate = !1, !0;
                        "string" == typeof t && (t = "now" === t || "moment" === t ? this.getMoment() : this.getMoment(t));
                        var e = this._parseInputDate(t);
                        if (!e.isValid()) throw new TypeError("defaultDate() Could not parse date parameter: " + t);
                        if (!this._isValid(e)) throw new TypeError("defaultDate() date passed is invalid according to component setup validations");
                        this._options.defaultDate = e, (this._options.defaultDate && this._options.inline || void 0 !== this.input && "" === this.input.val().trim()) && this._setValue(this._options.defaultDate, 0)
                    }, v.prototype.locale = function (t) {
                        if (0 === arguments.length) return this._options.locale;
                        if (!e.localeData(t)) throw new TypeError("locale() locale " + t + " is not loaded from moment locales!");
                        this._options.locale = t;
                        for (var n = 0; n < this._dates.length; n++) this._dates[n].locale(this._options.locale);
                        this._viewDate.locale(this._options.locale), this.actualFormat && this._initFormatting(), this.widget && (this.hide(), this.show())
                    }, v.prototype.stepping = function (t) {
                        if (0 === arguments.length) return this._options.stepping;
                        t = parseInt(t, 10), (isNaN(t) || t < 1) && (t = 1), this._options.stepping = t
                    }, v.prototype.useCurrent = function (t) {
                        var e = ["year", "month", "day", "hour", "minute"];
                        if (0 === arguments.length) return this._options.useCurrent;
                        if ("boolean" != typeof t && "string" != typeof t) throw new TypeError("useCurrent() expects a boolean or string parameter");
                        if ("string" == typeof t && -1 === e.indexOf(t.toLowerCase())) throw new TypeError("useCurrent() expects a string parameter of " + e.join(", "));
                        this._options.useCurrent = t
                    }, v.prototype.collapse = function (t) {
                        if (0 === arguments.length) return this._options.collapse;
                        if ("boolean" != typeof t) throw new TypeError("collapse() expects a boolean parameter");
                        if (this._options.collapse === t) return !0;
                        this._options.collapse = t, this.widget && (this.hide(), this.show())
                    }, v.prototype.icons = function (e) {
                        if (0 === arguments.length) return t.extend({}, this._options.icons);
                        if (!(e instanceof Object)) throw new TypeError("icons() expects parameter to be an Object");
                        t.extend(this._options.icons, e), this.widget && (this.hide(), this.show())
                    }, v.prototype.tooltips = function (e) {
                        if (0 === arguments.length) return t.extend({}, this._options.tooltips);
                        if (!(e instanceof Object)) throw new TypeError("tooltips() expects parameter to be an Object");
                        t.extend(this._options.tooltips, e), this.widget && (this.hide(), this.show())
                    }, v.prototype.useStrict = function (t) {
                        if (0 === arguments.length) return this._options.useStrict;
                        if ("boolean" != typeof t) throw new TypeError("useStrict() expects a boolean parameter");
                        this._options.useStrict = t
                    }, v.prototype.sideBySide = function (t) {
                        if (0 === arguments.length) return this._options.sideBySide;
                        if ("boolean" != typeof t) throw new TypeError("sideBySide() expects a boolean parameter");
                        this._options.sideBySide = t, this.widget && (this.hide(), this.show())
                    }, v.prototype.viewMode = function (t) {
                        if (0 === arguments.length) return this._options.viewMode;
                        if ("string" != typeof t) throw new TypeError("viewMode() expects a string parameter");
                        if (-1 === v.ViewModes.indexOf(t)) throw new TypeError("viewMode() parameter must be one of (" + v.ViewModes.join(", ") + ") value");
                        this._options.viewMode = t, this.currentViewMode = Math.max(v.ViewModes.indexOf(t) - 1, this.MinViewModeNumber), this._showMode()
                    }, v.prototype.calendarWeeks = function (t) {
                        if (0 === arguments.length) return this._options.calendarWeeks;
                        if ("boolean" != typeof t) throw new TypeError("calendarWeeks() expects parameter to be a boolean value");
                        this._options.calendarWeeks = t, this._update()
                    }, v.prototype.buttons = function (e) {
                        if (0 === arguments.length) return t.extend({}, this._options.buttons);
                        if (!(e instanceof Object)) throw new TypeError("buttons() expects parameter to be an Object");
                        if (t.extend(this._options.buttons, e), "boolean" != typeof this._options.buttons.showToday) throw new TypeError("buttons.showToday expects a boolean parameter");
                        if ("boolean" != typeof this._options.buttons.showClear) throw new TypeError("buttons.showClear expects a boolean parameter");
                        if ("boolean" != typeof this._options.buttons.showClose) throw new TypeError("buttons.showClose expects a boolean parameter");
                        this.widget && (this.hide(), this.show())
                    }, v.prototype.keepOpen = function (t) {
                        if (0 === arguments.length) return this._options.keepOpen;
                        if ("boolean" != typeof t) throw new TypeError("keepOpen() expects a boolean parameter");
                        this._options.keepOpen = t
                    }, v.prototype.focusOnShow = function (t) {
                        if (0 === arguments.length) return this._options.focusOnShow;
                        if ("boolean" != typeof t) throw new TypeError("focusOnShow() expects a boolean parameter");
                        this._options.focusOnShow = t
                    }, v.prototype.inline = function (t) {
                        if (0 === arguments.length) return this._options.inline;
                        if ("boolean" != typeof t) throw new TypeError("inline() expects a boolean parameter");
                        this._options.inline = t
                    }, v.prototype.clear = function () {
                        this._setValue(null)
                    }, v.prototype.keyBinds = function (t) {
                        if (0 === arguments.length) return this._options.keyBinds;
                        this._options.keyBinds = t
                    }, v.prototype.debug = function (t) {
                        if ("boolean" != typeof t) throw new TypeError("debug() expects a boolean parameter");
                        this._options.debug = t
                    }, v.prototype.allowInputToggle = function (t) {
                        if (0 === arguments.length) return this._options.allowInputToggle;
                        if ("boolean" != typeof t) throw new TypeError("allowInputToggle() expects a boolean parameter");
                        this._options.allowInputToggle = t
                    }, v.prototype.keepInvalid = function (t) {
                        if (0 === arguments.length) return this._options.keepInvalid;
                        if ("boolean" != typeof t) throw new TypeError("keepInvalid() expects a boolean parameter");
                        this._options.keepInvalid = t
                    }, v.prototype.datepickerInput = function (t) {
                        if (0 === arguments.length) return this._options.datepickerInput;
                        if ("string" != typeof t) throw new TypeError("datepickerInput() expects a string parameter");
                        this._options.datepickerInput = t
                    }, v.prototype.parseInputDate = function (t) {
                        if (0 === arguments.length) return this._options.parseInputDate;
                        if ("function" != typeof t) throw new TypeError("parseInputDate() should be as function");
                        this._options.parseInputDate = t
                    }, v.prototype.disabledTimeIntervals = function (e) {
                        if (0 === arguments.length) return this._options.disabledTimeIntervals ? t.extend({}, this._options.disabledTimeIntervals) : this._options.disabledTimeIntervals;
                        if (!e) return this._options.disabledTimeIntervals = !1, this._update(), !0;
                        if (!(e instanceof Array)) throw new TypeError("disabledTimeIntervals() expects an array parameter");
                        this._options.disabledTimeIntervals = e, this._update()
                    }, v.prototype.disabledHours = function (e) {
                        if (0 === arguments.length) return this._options.disabledHours ? t.extend({}, this._options.disabledHours) : this._options.disabledHours;
                        if (!e) return this._options.disabledHours = !1, this._update(), !0;
                        if (!(e instanceof Array)) throw new TypeError("disabledHours() expects an array parameter");
                        if (this._options.disabledHours = this._indexGivenHours(e), this._options.enabledHours = !1, this._options.useCurrent && !this._options.keepInvalid) for (var n = 0; n < this._dates.length; n++) {
                            for (var a = 0; !this._isValid(this._dates[n], "h");) {
                                if (this._dates[n].add(1, "h"), 24 === a) throw"Tried 24 times to find a valid date";
                                a++
                            }
                            this._setValue(this._dates[n], n)
                        }
                        this._update()
                    }, v.prototype.enabledHours = function (e) {
                        if (0 === arguments.length) return this._options.enabledHours ? t.extend({}, this._options.enabledHours) : this._options.enabledHours;
                        if (!e) return this._options.enabledHours = !1, this._update(), !0;
                        if (!(e instanceof Array)) throw new TypeError("enabledHours() expects an array parameter");
                        if (this._options.enabledHours = this._indexGivenHours(e), this._options.disabledHours = !1, this._options.useCurrent && !this._options.keepInvalid) for (var n = 0; n < this._dates.length; n++) {
                            for (var a = 0; !this._isValid(this._dates[n], "h");) {
                                if (this._dates[n].add(1, "h"), 24 === a) throw"Tried 24 times to find a valid date";
                                a++
                            }
                            this._setValue(this._dates[n], n)
                        }
                        this._update()
                    }, v.prototype.viewDate = function (t) {
                        if (0 === arguments.length) return this._viewDate.clone();
                        if (!t) return this._viewDate = (this._dates[0] || this.getMoment()).clone(), !0;
                        if (!("string" == typeof t || e.isMoment(t) || t instanceof Date)) throw new TypeError("viewDate() parameter must be one of [string, moment or Date]");
                        this._viewDate = this._parseInputDate(t), this._viewUpdate()
                    }, v.prototype.allowMultidate = function (t) {
                        if ("boolean" != typeof t) throw new TypeError("allowMultidate() expects a boolean parameter");
                        this._options.allowMultidate = t
                    }, v.prototype.multidateSeparator = function (t) {
                        if (0 === arguments.length) return this._options.multidateSeparator;
                        if ("string" != typeof t || t.length > 1) throw new TypeError("multidateSeparator expects a single character string parameter");
                        this._options.multidateSeparator = t
                    }, n(v, null, [{
                        key: "NAME", get: function () {
                            return i
                        }
                    }, {
                        key: "DATA_KEY", get: function () {
                            return r
                        }
                    }, {
                        key: "EVENT_KEY", get: function () {
                            return o
                        }
                    }, {
                        key: "DATA_API_KEY", get: function () {
                            return s
                        }
                    }, {
                        key: "DatePickerModes", get: function () {
                            return u
                        }
                    }, {
                        key: "ViewModes", get: function () {
                            return p
                        }
                    }, {
                        key: "Event", get: function () {
                            return d
                        }
                    }, {
                        key: "Selector", get: function () {
                            return l
                        }
                    }, {
                        key: "Default", get: function () {
                            return m
                        }, set: function (t) {
                            m = t
                        }
                    }, {
                        key: "ClassName", get: function () {
                            return c
                        }
                    }]), v
                }()
            }(t, moment);
            !function (t) {
                var n = t.fn[i.NAME], r = ["top", "bottom", "auto"], o = ["left", "right", "auto"],
                    s = ["default", "top", "bottom"], l = function (e) {
                        var n = e.data("target"), a = void 0;
                        return n || (n = e.attr("href") || "", n = /^#[a-z]/i.test(n) ? n : null), 0 === (a = t(n)).length || a.data(i.DATA_KEY) || t.extend({}, a.data(), t(this).data()), a
                    }, c = function (n) {
                        function l(t, e) {
                            a(this, l);
                            var i = function (t, e) {
                                if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                                return !e || "object" != typeof e && "function" != typeof e ? t : e
                            }(this, n.call(this, t, e));
                            return i._init(), i
                        }

                        return function (t, e) {
                            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + typeof e);
                            t.prototype = Object.create(e && e.prototype, {
                                constructor: {
                                    value: t,
                                    enumerable: !1,
                                    writable: !0,
                                    configurable: !0
                                }
                            }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                        }(l, n), l.prototype._init = function () {
                            if (this._element.hasClass("input-group")) {
                                var t = this._element.find(".datepickerbutton");
                                0 === t.length ? this.component = this._element.find('[data-toggle="datetimepicker"]') : this.component = t
                            }
                        }, l.prototype._getDatePickerTemplate = function () {
                            var e = t("<thead>").append(t("<tr>").append(t("<th>").addClass("prev").attr("data-action", "previous").append(t("<span>").addClass(this._options.icons.previous))).append(t("<th>").addClass("picker-switch").attr("data-action", "pickerSwitch").attr("colspan", this._options.calendarWeeks ? "6" : "5")).append(t("<th>").addClass("next").attr("data-action", "next").append(t("<span>").addClass(this._options.icons.next)))),
                                n = t("<tbody>").append(t("<tr>").append(t("<td>").attr("colspan", this._options.calendarWeeks ? "8" : "7")));
                            return [t("<div>").addClass("datepicker-days").append(t("<table>").addClass("table table-sm").append(e).append(t("<tbody>"))), t("<div>").addClass("datepicker-months").append(t("<table>").addClass("table-condensed").append(e.clone()).append(n.clone())), t("<div>").addClass("datepicker-years").append(t("<table>").addClass("table-condensed").append(e.clone()).append(n.clone())), t("<div>").addClass("datepicker-decades").append(t("<table>").addClass("table-condensed").append(e.clone()).append(n.clone()))]
                        }, l.prototype._getTimePickerMainTemplate = function () {
                            var e = t("<tr>"), n = t("<tr>"), a = t("<tr>");
                            return this._isEnabled("h") && (e.append(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                title: this._options.tooltips.incrementHour
                            }).addClass("btn").attr("data-action", "incrementHours").append(t("<span>").addClass(this._options.icons.up)))), n.append(t("<td>").append(t("<span>").addClass("timepicker-hour").attr({
                                "data-time-component": "hours",
                                title: this._options.tooltips.pickHour
                            }).attr("data-action", "showHours"))), a.append(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                title: this._options.tooltips.decrementHour
                            }).addClass("btn").attr("data-action", "decrementHours").append(t("<span>").addClass(this._options.icons.down))))), this._isEnabled("m") && (this._isEnabled("h") && (e.append(t("<td>").addClass("separator")), n.append(t("<td>").addClass("separator").html(":")), a.append(t("<td>").addClass("separator"))), e.append(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                title: this._options.tooltips.incrementMinute
                            }).addClass("btn").attr("data-action", "incrementMinutes").append(t("<span>").addClass(this._options.icons.up)))), n.append(t("<td>").append(t("<span>").addClass("timepicker-minute").attr({
                                "data-time-component": "minutes",
                                title: this._options.tooltips.pickMinute
                            }).attr("data-action", "showMinutes"))), a.append(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                title: this._options.tooltips.decrementMinute
                            }).addClass("btn").attr("data-action", "decrementMinutes").append(t("<span>").addClass(this._options.icons.down))))), this._isEnabled("s") && (this._isEnabled("m") && (e.append(t("<td>").addClass("separator")), n.append(t("<td>").addClass("separator").html(":")), a.append(t("<td>").addClass("separator"))), e.append(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                title: this._options.tooltips.incrementSecond
                            }).addClass("btn").attr("data-action", "incrementSeconds").append(t("<span>").addClass(this._options.icons.up)))), n.append(t("<td>").append(t("<span>").addClass("timepicker-second").attr({
                                "data-time-component": "seconds",
                                title: this._options.tooltips.pickSecond
                            }).attr("data-action", "showSeconds"))), a.append(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                title: this._options.tooltips.decrementSecond
                            }).addClass("btn").attr("data-action", "decrementSeconds").append(t("<span>").addClass(this._options.icons.down))))), this.use24Hours || (e.append(t("<td>").addClass("separator")), n.append(t("<td>").append(t("<button>").addClass("btn btn-primary").attr({
                                "data-action": "togglePeriod",
                                tabindex: "-1",
                                title: this._options.tooltips.togglePeriod
                            }))), a.append(t("<td>").addClass("separator"))), t("<div>").addClass("timepicker-picker").append(t("<table>").addClass("table-condensed").append([e, n, a]))
                        }, l.prototype._getTimePickerTemplate = function () {
                            var e = t("<div>").addClass("timepicker-hours").append(t("<table>").addClass("table-condensed")),
                                n = t("<div>").addClass("timepicker-minutes").append(t("<table>").addClass("table-condensed")),
                                a = t("<div>").addClass("timepicker-seconds").append(t("<table>").addClass("table-condensed")),
                                i = [this._getTimePickerMainTemplate()];
                            return this._isEnabled("h") && i.push(e), this._isEnabled("m") && i.push(n), this._isEnabled("s") && i.push(a), i
                        }, l.prototype._getToolbar = function () {
                            var e = [];
                            if (this._options.buttons.showToday && e.push(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                "data-action": "today",
                                title: this._options.tooltips.today
                            }).append(t("<span>").addClass(this._options.icons.today)))), !this._options.sideBySide && this._hasDate() && this._hasTime()) {
                                var n = void 0, a = void 0;
                                "times" === this._options.viewMode ? (n = this._options.tooltips.selectDate, a = this._options.icons.date) : (n = this._options.tooltips.selectTime, a = this._options.icons.time), e.push(t("<td>").append(t("<a>").attr({
                                    href: "#",
                                    tabindex: "-1",
                                    "data-action": "togglePicker",
                                    title: n
                                }).append(t("<span>").addClass(a))))
                            }
                            return this._options.buttons.showClear && e.push(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                "data-action": "clear",
                                title: this._options.tooltips.clear
                            }).append(t("<span>").addClass(this._options.icons.clear)))), this._options.buttons.showClose && e.push(t("<td>").append(t("<a>").attr({
                                href: "#",
                                tabindex: "-1",
                                "data-action": "close",
                                title: this._options.tooltips.close
                            }).append(t("<span>").addClass(this._options.icons.close)))), 0 === e.length ? "" : t("<table>").addClass("table-condensed").append(t("<tbody>").append(t("<tr>").append(e)))
                        }, l.prototype._getTemplate = function () {
                            var e = t("<div>").addClass("bootstrap-datetimepicker-widget dropdown-menu"),
                                n = t("<div>").addClass("datepicker").append(this._getDatePickerTemplate()),
                                a = t("<div>").addClass("timepicker").append(this._getTimePickerTemplate()),
                                i = t("<ul>").addClass("list-unstyled"),
                                r = t("<li>").addClass("picker-switch" + (this._options.collapse ? " accordion-toggle" : "")).append(this._getToolbar());
                            return this._options.inline && e.removeClass("dropdown-menu"), this.use24Hours && e.addClass("usetwentyfour"), this._isEnabled("s") && !this.use24Hours && e.addClass("wider"), this._options.sideBySide && this._hasDate() && this._hasTime() ? (e.addClass("timepicker-sbs"), "top" === this._options.toolbarPlacement && e.append(r), e.append(t("<div>").addClass("row").append(n.addClass("col-md-6")).append(a.addClass("col-md-6"))), "bottom" !== this._options.toolbarPlacement && "default" !== this._options.toolbarPlacement || e.append(r), e) : ("top" === this._options.toolbarPlacement && i.append(r), this._hasDate() && i.append(t("<li>").addClass(this._options.collapse && this._hasTime() ? "collapse" : "").addClass(this._options.collapse && this._hasTime() && "times" === this._options.viewMode ? "" : "show").append(n)), "default" === this._options.toolbarPlacement && i.append(r), this._hasTime() && i.append(t("<li>").addClass(this._options.collapse && this._hasDate() ? "collapse" : "").addClass(this._options.collapse && this._hasDate() && "times" === this._options.viewMode ? "show" : "").append(a)), "bottom" === this._options.toolbarPlacement && i.append(r), e.append(i))
                        }, l.prototype._place = function (e) {
                            var n = e && e.data && e.data.picker || this, a = n._options.widgetPositioning.vertical,
                                i = n._options.widgetPositioning.horizontal, r = void 0,
                                o = (n.component && n.component.length ? n.component : n._element).position(),
                                s = (n.component && n.component.length ? n.component : n._element).offset();
                            if (n._options.widgetParent) r = n._options.widgetParent.append(n.widget); else if (n._element.is("input")) r = n._element.after(n.widget).parent(); else {
                                if (n._options.inline) return void (r = n._element.append(n.widget));
                                r = n._element, n._element.children().first().after(n.widget)
                            }
                            if ("auto" === a && (a = s.top + 1.5 * n.widget.height() >= t(window).height() + t(window).scrollTop() && n.widget.height() + n._element.outerHeight() < s.top ? "top" : "bottom"), "auto" === i && (i = r.width() < s.left + n.widget.outerWidth() / 2 && s.left + n.widget.outerWidth() > t(window).width() ? "right" : "left"), "top" === a ? n.widget.addClass("top").removeClass("bottom") : n.widget.addClass("bottom").removeClass("top"), "right" === i ? n.widget.addClass("float-right") : n.widget.removeClass("float-right"), "relative" !== r.css("position") && (r = r.parents().filter((function () {
                                return "relative" === t(this).css("position")
                            })).first()), 0 === r.length) throw new Error("datetimepicker component should be placed within a relative positioned container");
                            n.widget.css({
                                top: "top" === a ? "auto" : o.top + n._element.outerHeight() + "px",
                                bottom: "top" === a ? r.outerHeight() - (r === n._element ? 0 : o.top) + "px" : "auto",
                                left: "left" === i ? (r === n._element ? 0 : o.left) + "px" : "auto",
                                right: "left" === i ? "auto" : r.outerWidth() - n._element.outerWidth() - (r === n._element ? 0 : o.left) + "px"
                            })
                        }, l.prototype._fillDow = function () {
                            var e = t("<tr>"), n = this._viewDate.clone().startOf("w").startOf("d");
                            for (!0 === this._options.calendarWeeks && e.append(t("<th>").addClass("cw").text("#")); n.isBefore(this._viewDate.clone().endOf("w"));) e.append(t("<th>").addClass("dow").text(n.format("dd"))), n.add(1, "d");
                            this.widget.find(".datepicker-days thead").append(e)
                        }, l.prototype._fillMonths = function () {
                            for (var e = [], n = this._viewDate.clone().startOf("y").startOf("d"); n.isSame(this._viewDate, "y");) e.push(t("<span>").attr("data-action", "selectMonth").addClass("month").text(n.format("MMM"))), n.add(1, "M");
                            this.widget.find(".datepicker-months td").empty().append(e)
                        }, l.prototype._updateMonths = function () {
                            var e = this.widget.find(".datepicker-months"), n = e.find("th"),
                                a = e.find("tbody").find("span"), i = this;
                            n.eq(0).find("span").attr("title", this._options.tooltips.prevYear), n.eq(1).attr("title", this._options.tooltips.selectYear), n.eq(2).find("span").attr("title", this._options.tooltips.nextYear), e.find(".disabled").removeClass("disabled"), this._isValid(this._viewDate.clone().subtract(1, "y"), "y") || n.eq(0).addClass("disabled"), n.eq(1).text(this._viewDate.year()), this._isValid(this._viewDate.clone().add(1, "y"), "y") || n.eq(2).addClass("disabled"), a.removeClass("active"), this._getLastPickedDate().isSame(this._viewDate, "y") && !this.unset && a.eq(this._getLastPickedDate().month()).addClass("active"), a.each((function (e) {
                                i._isValid(i._viewDate.clone().month(e), "M") || t(this).addClass("disabled")
                            }))
                        }, l.prototype._getStartEndYear = function (t, e) {
                            var n = t / 10, a = Math.floor(e / t) * t;
                            return [a, a + 9 * n, Math.floor(e / n) * n]
                        }, l.prototype._updateYears = function () {
                            var t = this.widget.find(".datepicker-years"), e = t.find("th"),
                                n = this._getStartEndYear(10, this._viewDate.year()), a = this._viewDate.clone().year(n[0]),
                                i = this._viewDate.clone().year(n[1]), r = "";
                            for (e.eq(0).find("span").attr("title", this._options.tooltips.prevDecade), e.eq(1).attr("title", this._options.tooltips.selectDecade), e.eq(2).find("span").attr("title", this._options.tooltips.nextDecade), t.find(".disabled").removeClass("disabled"), this._options.minDate && this._options.minDate.isAfter(a, "y") && e.eq(0).addClass("disabled"), e.eq(1).text(a.year() + "-" + i.year()), this._options.maxDate && this._options.maxDate.isBefore(i, "y") && e.eq(2).addClass("disabled"), r += '<span data-action="selectYear" class="year old' + (this._isValid(a, "y") ? "" : " disabled") + '">' + (a.year() - 1) + "</span>"; !a.isAfter(i, "y");) r += '<span data-action="selectYear" class="year' + (a.isSame(this._getLastPickedDate(), "y") && !this.unset ? " active" : "") + (this._isValid(a, "y") ? "" : " disabled") + '">' + a.year() + "</span>", a.add(1, "y");
                            r += '<span data-action="selectYear" class="year old' + (this._isValid(a, "y") ? "" : " disabled") + '">' + a.year() + "</span>", t.find("td").html(r)
                        }, l.prototype._updateDecades = function () {
                            var t = this.widget.find(".datepicker-decades"), e = t.find("th"),
                                n = this._getStartEndYear(100, this._viewDate.year()),
                                a = this._viewDate.clone().year(n[0]), i = this._viewDate.clone().year(n[1]), r = !1,
                                o = !1, s = void 0, l = "";
                            for (e.eq(0).find("span").attr("title", this._options.tooltips.prevCentury), e.eq(2).find("span").attr("title", this._options.tooltips.nextCentury), t.find(".disabled").removeClass("disabled"), (0 === a.year() || this._options.minDate && this._options.minDate.isAfter(a, "y")) && e.eq(0).addClass("disabled"), e.eq(1).text(a.year() + "-" + i.year()), this._options.maxDate && this._options.maxDate.isBefore(i, "y") && e.eq(2).addClass("disabled"), a.year() - 10 < 0 ? l += "<span>&nbsp;</span>" : l += '<span data-action="selectDecade" class="decade old" data-selection="' + (a.year() + 6) + '">' + (a.year() - 10) + "</span>"; !a.isAfter(i, "y");) s = a.year() + 11, r = this._options.minDate && this._options.minDate.isAfter(a, "y") && this._options.minDate.year() <= s, o = this._options.maxDate && this._options.maxDate.isAfter(a, "y") && this._options.maxDate.year() <= s, l += '<span data-action="selectDecade" class="decade' + (this._getLastPickedDate().isAfter(a) && this._getLastPickedDate().year() <= s ? " active" : "") + (this._isValid(a, "y") || r || o ? "" : " disabled") + '" data-selection="' + (a.year() + 6) + '">' + a.year() + "</span>", a.add(10, "y");
                            l += '<span data-action="selectDecade" class="decade old" data-selection="' + (a.year() + 6) + '">' + a.year() + "</span>", t.find("td").html(l)
                        }, l.prototype._fillDate = function () {
                            var e = this.widget.find(".datepicker-days"), n = e.find("th"), a = [], i = void 0, r = void 0,
                                o = void 0, s = void 0;
                            if (this._hasDate()) {
                                for (n.eq(0).find("span").attr("title", this._options.tooltips.prevMonth), n.eq(1).attr("title", this._options.tooltips.selectMonth), n.eq(2).find("span").attr("title", this._options.tooltips.nextMonth), e.find(".disabled").removeClass("disabled"), n.eq(1).text(this._viewDate.format(this._options.dayViewHeaderFormat)), this._isValid(this._viewDate.clone().subtract(1, "M"), "M") || n.eq(0).addClass("disabled"), this._isValid(this._viewDate.clone().add(1, "M"), "M") || n.eq(2).addClass("disabled"), i = this._viewDate.clone().startOf("M").startOf("w").startOf("d"), s = 0; s < 42; s++) {
                                    if (0 === i.weekday() && (r = t("<tr>"), this._options.calendarWeeks && r.append('<td class="cw">' + i.week() + "</td>"), a.push(r)), o = "", i.isBefore(this._viewDate, "M") && (o += " old"), i.isAfter(this._viewDate, "M") && (o += " new"), this._options.allowMultidate) {
                                        var l = this._datesFormatted.indexOf(i.format("YYYY-MM-DD"));
                                        -1 !== l && i.isSame(this._datesFormatted[l], "d") && !this.unset && (o += " active")
                                    } else i.isSame(this._getLastPickedDate(), "d") && !this.unset && (o += " active");
                                    this._isValid(i, "d") || (o += " disabled"), i.isSame(this.getMoment(), "d") && (o += " today"), 0 !== i.day() && 6 !== i.day() || (o += " weekend"), r.append('<td data-action="selectDay" data-day="' + i.format("L") + '" class="day' + o + '">' + i.date() + "</td>"), i.add(1, "d")
                                }
                                e.find("tbody").empty().append(a), this._updateMonths(), this._updateYears(), this._updateDecades()
                            }
                        }, l.prototype._fillHours = function () {
                            var e = this.widget.find(".timepicker-hours table"), n = this._viewDate.clone().startOf("d"),
                                a = [], i = t("<tr>");
                            for (this._viewDate.hour() > 11 && !this.use24Hours && n.hour(12); n.isSame(this._viewDate, "d") && (this.use24Hours || this._viewDate.hour() < 12 && n.hour() < 12 || this._viewDate.hour() > 11);) n.hour() % 4 == 0 && (i = t("<tr>"), a.push(i)), i.append('<td data-action="selectHour" class="hour' + (this._isValid(n, "h") ? "" : " disabled") + '">' + n.format(this.use24Hours ? "HH" : "hh") + "</td>"), n.add(1, "h");
                            e.empty().append(a)
                        }, l.prototype._fillMinutes = function () {
                            for (var e = this.widget.find(".timepicker-minutes table"), n = this._viewDate.clone().startOf("h"), a = [], i = 1 === this._options.stepping ? 5 : this._options.stepping, r = t("<tr>"); this._viewDate.isSame(n, "h");) n.minute() % (4 * i) == 0 && (r = t("<tr>"), a.push(r)), r.append('<td data-action="selectMinute" class="minute' + (this._isValid(n, "m") ? "" : " disabled") + '">' + n.format("mm") + "</td>"), n.add(i, "m");
                            e.empty().append(a)
                        }, l.prototype._fillSeconds = function () {
                            for (var e = this.widget.find(".timepicker-seconds table"), n = this._viewDate.clone().startOf("m"), a = [], i = t("<tr>"); this._viewDate.isSame(n, "m");) n.second() % 20 == 0 && (i = t("<tr>"), a.push(i)), i.append('<td data-action="selectSecond" class="second' + (this._isValid(n, "s") ? "" : " disabled") + '">' + n.format("ss") + "</td>"), n.add(5, "s");
                            e.empty().append(a)
                        }, l.prototype._fillTime = function () {
                            var t = void 0, e = void 0, n = this.widget.find(".timepicker span[data-time-component]");
                            this.use24Hours || (t = this.widget.find(".timepicker [data-action=togglePeriod]"), e = this._getLastPickedDate().clone().add(this._getLastPickedDate().hours() >= 12 ? -12 : 12, "h"), t.text(this._getLastPickedDate().format("A")), this._isValid(e, "h") ? t.removeClass("disabled") : t.addClass("disabled")), n.filter("[data-time-component=hours]").text(this._getLastPickedDate().format(this.use24Hours ? "HH" : "hh")), n.filter("[data-time-component=minutes]").text(this._getLastPickedDate().format("mm")), n.filter("[data-time-component=seconds]").text(this._getLastPickedDate().format("ss")), this._fillHours(), this._fillMinutes(), this._fillSeconds()
                        }, l.prototype._doAction = function (e, n) {
                            var a = this._getLastPickedDate();
                            if (t(e.currentTarget).is(".disabled")) return !1;
                            switch (n = n || t(e.currentTarget).data("action")) {
                                case"next":
                                    var r = i.DatePickerModes[this.currentViewMode].NAV_FUNCTION;
                                    this._viewDate.add(i.DatePickerModes[this.currentViewMode].NAV_STEP, r), this._fillDate(), this._viewUpdate(r);
                                    break;
                                case"previous":
                                    var o = i.DatePickerModes[this.currentViewMode].NAV_FUNCTION;
                                    this._viewDate.subtract(i.DatePickerModes[this.currentViewMode].NAV_STEP, o), this._fillDate(), this._viewUpdate(o);
                                    break;
                                case"pickerSwitch":
                                    this._showMode(1);
                                    break;
                                case"selectMonth":
                                    var s = t(e.target).closest("tbody").find("span").index(t(e.target));
                                    this._viewDate.month(s), this.currentViewMode === this.MinViewModeNumber ? (this._setValue(a.clone().year(this._viewDate.year()).month(this._viewDate.month()), this._getLastPickedDateIndex()), this._options.inline || this.hide()) : (this._showMode(-1), this._fillDate()), this._viewUpdate("M");
                                    break;
                                case"selectYear":
                                    var l = parseInt(t(e.target).text(), 10) || 0;
                                    this._viewDate.year(l), this.currentViewMode === this.MinViewModeNumber ? (this._setValue(a.clone().year(this._viewDate.year()), this._getLastPickedDateIndex()), this._options.inline || this.hide()) : (this._showMode(-1), this._fillDate()), this._viewUpdate("YYYY");
                                    break;
                                case"selectDecade":
                                    var c = parseInt(t(e.target).data("selection"), 10) || 0;
                                    this._viewDate.year(c), this.currentViewMode === this.MinViewModeNumber ? (this._setValue(a.clone().year(this._viewDate.year()), this._getLastPickedDateIndex()), this._options.inline || this.hide()) : (this._showMode(-1), this._fillDate()), this._viewUpdate("YYYY");
                                    break;
                                case"selectDay":
                                    var d = this._viewDate.clone();
                                    t(e.target).is(".old") && d.subtract(1, "M"), t(e.target).is(".new") && d.add(1, "M");
                                    var u = d.date(parseInt(t(e.target).text(), 10)), h = 0;
                                    this._options.allowMultidate ? -1 !== (h = this._datesFormatted.indexOf(u.format("YYYY-MM-DD"))) ? this._setValue(null, h) : this._setValue(u, this._getLastPickedDateIndex() + 1) : this._setValue(u, this._getLastPickedDateIndex()), this._hasTime() || this._options.keepOpen || this._options.inline || this._options.allowMultidate || this.hide();
                                    break;
                                case"incrementHours":
                                    var p = a.clone().add(1, "h");
                                    this._isValid(p, "h") && this._setValue(p, this._getLastPickedDateIndex());
                                    break;
                                case"incrementMinutes":
                                    var f = a.clone().add(this._options.stepping, "m");
                                    this._isValid(f, "m") && this._setValue(f, this._getLastPickedDateIndex());
                                    break;
                                case"incrementSeconds":
                                    var g = a.clone().add(1, "s");
                                    this._isValid(g, "s") && this._setValue(g, this._getLastPickedDateIndex());
                                    break;
                                case"decrementHours":
                                    var m = a.clone().subtract(1, "h");
                                    this._isValid(m, "h") && this._setValue(m, this._getLastPickedDateIndex());
                                    break;
                                case"decrementMinutes":
                                    var v = a.clone().subtract(this._options.stepping, "m");
                                    this._isValid(v, "m") && this._setValue(v, this._getLastPickedDateIndex());
                                    break;
                                case"decrementSeconds":
                                    var b = a.clone().subtract(1, "s");
                                    this._isValid(b, "s") && this._setValue(b, this._getLastPickedDateIndex());
                                    break;
                                case"togglePeriod":
                                    this._setValue(a.clone().add(a.hours() >= 12 ? -12 : 12, "h"), this._getLastPickedDateIndex());
                                    break;
                                case"togglePicker":
                                    var y = t(e.target), x = y.closest("a"), _ = y.closest("ul"), w = _.find(".show"),
                                        S = _.find(".collapse:not(.show)"), C = y.is("span") ? y : y.find("span"),
                                        k = void 0;
                                    if (w && w.length) {
                                        if ((k = w.data("collapse")) && k.transitioning) return !0;
                                        w.collapse ? (w.collapse("hide"), S.collapse("show")) : (w.removeClass("show"), S.addClass("show")), C.toggleClass(this._options.icons.time + " " + this._options.icons.date), C.hasClass(this._options.icons.date) ? x.attr("title", this._options.tooltips.selectDate) : x.attr("title", this._options.tooltips.selectTime)
                                    }
                                    break;
                                case"showPicker":
                                    this.widget.find(".timepicker > div:not(.timepicker-picker)").hide(), this.widget.find(".timepicker .timepicker-picker").show();
                                    break;
                                case"showHours":
                                    this.widget.find(".timepicker .timepicker-picker").hide(), this.widget.find(".timepicker .timepicker-hours").show();
                                    break;
                                case"showMinutes":
                                    this.widget.find(".timepicker .timepicker-picker").hide(), this.widget.find(".timepicker .timepicker-minutes").show();
                                    break;
                                case"showSeconds":
                                    this.widget.find(".timepicker .timepicker-picker").hide(), this.widget.find(".timepicker .timepicker-seconds").show();
                                    break;
                                case"selectHour":
                                    var D = parseInt(t(e.target).text(), 10);
                                    this.use24Hours || (a.hours() >= 12 ? 12 !== D && (D += 12) : 12 === D && (D = 0)), this._setValue(a.clone().hours(D), this._getLastPickedDateIndex()), this._isEnabled("a") || this._isEnabled("m") || this._options.keepOpen || this._options.inline ? this._doAction(e, "showPicker") : this.hide();
                                    break;
                                case"selectMinute":
                                    this._setValue(a.clone().minutes(parseInt(t(e.target).text(), 10)), this._getLastPickedDateIndex()), this._isEnabled("a") || this._isEnabled("s") || this._options.keepOpen || this._options.inline ? this._doAction(e, "showPicker") : this.hide();
                                    break;
                                case"selectSecond":
                                    this._setValue(a.clone().seconds(parseInt(t(e.target).text(), 10)), this._getLastPickedDateIndex()), this._isEnabled("a") || this._options.keepOpen || this._options.inline ? this._doAction(e, "showPicker") : this.hide();
                                    break;
                                case"clear":
                                    this.clear();
                                    break;
                                case"close":
                                    this.hide();
                                    break;
                                case"today":
                                    var T = this.getMoment();
                                    this._isValid(T, "d") && this._setValue(T, this._getLastPickedDateIndex())
                            }
                            return !1
                        }, l.prototype.hide = function () {
                            var e = !1;
                            this.widget && (this.widget.find(".collapse").each((function () {
                                var n = t(this).data("collapse");
                                return !n || !n.transitioning || (e = !0, !1)
                            })), e || (this.component && this.component.hasClass("btn") && this.component.toggleClass("active"), this.widget.hide(), t(window).off("resize", this._place()), this.widget.off("click", "[data-action]"), this.widget.off("mousedown", !1), this.widget.remove(), this.widget = !1, this._notifyEvent({
                                type: i.Event.HIDE,
                                date: this._getLastPickedDate().clone()
                            }), void 0 !== this.input && this.input.blur(), this._viewDate = this._getLastPickedDate().clone()))
                        }, l.prototype.show = function () {
                            var e = void 0, n = {
                                year: function (t) {
                                    return t.month(0).date(1).hours(0).seconds(0).minutes(0)
                                }, month: function (t) {
                                    return t.date(1).hours(0).seconds(0).minutes(0)
                                }, day: function (t) {
                                    return t.hours(0).seconds(0).minutes(0)
                                }, hour: function (t) {
                                    return t.seconds(0).minutes(0)
                                }, minute: function (t) {
                                    return t.seconds(0)
                                }
                            };
                            if (void 0 !== this.input) {
                                if (this.input.prop("disabled") || !this._options.ignoreReadonly && this.input.prop("readonly") || this.widget) return;
                                void 0 !== this.input.val() && 0 !== this.input.val().trim().length ? this._setValue(this._parseInputDate(this.input.val().trim()), 0) : this.unset && this._options.useCurrent && (e = this.getMoment(), "string" == typeof this._options.useCurrent && (e = n[this._options.useCurrent](e)), this._setValue(e, 0))
                            } else this.unset && this._options.useCurrent && (e = this.getMoment(), "string" == typeof this._options.useCurrent && (e = n[this._options.useCurrent](e)), this._setValue(e, 0));
                            this.widget = this._getTemplate(), this._fillDow(), this._fillMonths(), this.widget.find(".timepicker-hours").hide(), this.widget.find(".timepicker-minutes").hide(), this.widget.find(".timepicker-seconds").hide(), this._update(), this._showMode(), t(window).on("resize", {picker: this}, this._place), this.widget.on("click", "[data-action]", t.proxy(this._doAction, this)), this.widget.on("mousedown", !1), this.component && this.component.hasClass("btn") && this.component.toggleClass("active"), this._place(), this.widget.show(), void 0 !== this.input && this._options.focusOnShow && !this.input.is(":focus") && this.input.focus(), this._notifyEvent({type: i.Event.SHOW})
                        }, l.prototype.destroy = function () {
                            this.hide(), this._element.removeData(i.DATA_KEY), this._element.removeData("date")
                        }, l.prototype.disable = function () {
                            this.hide(), this.component && this.component.hasClass("btn") && this.component.addClass("disabled"), void 0 !== this.input && this.input.prop("disabled", !0)
                        }, l.prototype.enable = function () {
                            this.component && this.component.hasClass("btn") && this.component.removeClass("disabled"), void 0 !== this.input && this.input.prop("disabled", !1)
                        }, l.prototype.toolbarPlacement = function (t) {
                            if (0 === arguments.length) return this._options.toolbarPlacement;
                            if ("string" != typeof t) throw new TypeError("toolbarPlacement() expects a string parameter");
                            if (-1 === s.indexOf(t)) throw new TypeError("toolbarPlacement() parameter must be one of (" + s.join(", ") + ") value");
                            this._options.toolbarPlacement = t, this.widget && (this.hide(), this.show())
                        }, l.prototype.widgetPositioning = function (e) {
                            if (0 === arguments.length) return t.extend({}, this._options.widgetPositioning);
                            if ("[object Object]" !== {}.toString.call(e)) throw new TypeError("widgetPositioning() expects an object variable");
                            if (e.horizontal) {
                                if ("string" != typeof e.horizontal) throw new TypeError("widgetPositioning() horizontal variable must be a string");
                                if (e.horizontal = e.horizontal.toLowerCase(), -1 === o.indexOf(e.horizontal)) throw new TypeError("widgetPositioning() expects horizontal parameter to be one of (" + o.join(", ") + ")");
                                this._options.widgetPositioning.horizontal = e.horizontal
                            }
                            if (e.vertical) {
                                if ("string" != typeof e.vertical) throw new TypeError("widgetPositioning() vertical variable must be a string");
                                if (e.vertical = e.vertical.toLowerCase(), -1 === r.indexOf(e.vertical)) throw new TypeError("widgetPositioning() expects vertical parameter to be one of (" + r.join(", ") + ")");
                                this._options.widgetPositioning.vertical = e.vertical
                            }
                            this._update()
                        }, l.prototype.widgetParent = function (e) {
                            if (0 === arguments.length) return this._options.widgetParent;
                            if ("string" == typeof e && (e = t(e)), null !== e && "string" != typeof e && !(e instanceof t)) throw new TypeError("widgetParent() expects a string or a jQuery object parameter");
                            this._options.widgetParent = e, this.widget && (this.hide(), this.show())
                        }, l._jQueryHandleThis = function (n, a, r) {
                            var o = t(n).data(i.DATA_KEY);
                            if ("object" === (void 0 === a ? "undefined" : e(a)) && t.extend({}, i.Default, a), o || (o = new l(t(n), a), t(n).data(i.DATA_KEY, o)), "string" == typeof a) {
                                if (void 0 === o[a]) throw new Error('No method named "' + a + '"');
                                return void 0 === r ? o[a]() : o[a](r)
                            }
                        }, l._jQueryInterface = function (t, e) {
                            return 1 === this.length ? l._jQueryHandleThis(this[0], t, e) : this.each((function () {
                                l._jQueryHandleThis(this, t, e)
                            }))
                        }, l
                    }(i);
                t(document).on(i.Event.CLICK_DATA_API, i.Selector.DATA_TOGGLE, (function () {
                    var e = l(t(this));
                    0 !== e.length && c._jQueryInterface.call(e, "toggle")
                })).on(i.Event.CHANGE, "." + i.ClassName.INPUT, (function (e) {
                    var n = l(t(this));
                    0 !== n.length && c._jQueryInterface.call(n, "_change", e)
                })).on(i.Event.BLUR, "." + i.ClassName.INPUT, (function (e) {
                    var n = l(t(this)), a = n.data(i.DATA_KEY);
                    0 !== n.length && (a._options.debug || window.debug || c._jQueryInterface.call(n, "hide", e))
                })).on(i.Event.KEYDOWN, "." + i.ClassName.INPUT, (function (e) {
                    var n = l(t(this));
                    0 !== n.length && c._jQueryInterface.call(n, "_keydown", e)
                })).on(i.Event.KEYUP, "." + i.ClassName.INPUT, (function (e) {
                    var n = l(t(this));
                    0 !== n.length && c._jQueryInterface.call(n, "_keyup", e)
                })).on(i.Event.FOCUS, "." + i.ClassName.INPUT, (function (e) {
                    var n = l(t(this)), a = n.data(i.DATA_KEY);
                    0 !== n.length && a._options.allowInputToggle && c._jQueryInterface.call(n, "show", e)
                })), t.fn[i.NAME] = c._jQueryInterface, t.fn[i.NAME].Constructor = c, t.fn[i.NAME].noConflict = function () {
                    return t.fn[i.NAME] = n, c._jQueryInterface
                }
            }(t)
        }()
    }).call(this, n(16))
}, function (t, e, n) {
    n(24)(n(229))
}, function (t, e) {
    t.exports = "/*!\nFullCalendar v5.3.2\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\nvar FullCalendar = (function (exports) {\n    'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\r\n\r\n    var __assign = function() {\r\n        __assign = Object.assign || function __assign(t) {\r\n            for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n                s = arguments[i];\r\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n            }\r\n            return t;\r\n        };\r\n        return __assign.apply(this, arguments);\r\n    };\r\n\r\n    function __spreadArrays() {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    }\n\n    var n,u,i,t,o,r,f={},e=[],c=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s(n,l){for(var u in l)n[u]=l[u];return n}function a(n){var l=n.parentNode;l&&l.removeChild(n);}function h(n,l,u){var i,t,o,r=arguments,f={};for(o in l)\"key\"==o?i=l[o]:\"ref\"==o?t=l[o]:f[o]=l[o];if(arguments.length>3)for(u=[u],o=3;o<arguments.length;o++)u.push(r[o]);if(null!=u&&(f.children=u),\"function\"==typeof n&&null!=n.defaultProps)for(o in n.defaultProps)void 0===f[o]&&(f[o]=n.defaultProps[o]);return v(n,f,i,t,null)}function v(l,u,i,t,o){var r={type:l,props:u,key:i,ref:t,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:o};return null==o&&(r.__v=r),null!=n.vnode&&n.vnode(r),r}function y(){return {current:null}}function p(n){return n.children}function d(n,l){this.props=n,this.context=l;}function _(n,l){if(null==l)return n.__?_(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return \"function\"==typeof n.type?_(n):null}function w(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return w(n)}}function k(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!g.__r++||t!==n.debounceRendering)&&((t=n.debounceRendering)||i)(g);}function g(){for(var n;g.__r=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,i,t,o,r,f;n.__d&&(r=(o=(l=n).__v).__e,(f=l.__P)&&(u=[],(i=s({},o)).__v=i,t=$(f,o,i,l.__n,void 0!==f.ownerSVGElement,null!=o.__h?[r]:null,u,null==r?_(o):r,o.__h),j(u,o),t!=r&&w(o)));});}function m(n,l,u,i,t,o,r,c,s,h){var y,d,w,k,g,m,b,A=i&&i.__k||e,P=A.length;for(s==f&&(s=null!=r?r[0]:P?_(i,0):null),u.__k=[],y=0;y<l.length;y++)if(null!=(k=u.__k[y]=null==(k=l[y])||\"boolean\"==typeof k?null:\"string\"==typeof k||\"number\"==typeof k?v(null,k,null,null,k):Array.isArray(k)?v(p,{children:k},null,null,null):null!=k.__e||null!=k.__c?v(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(w=A[y])||w&&k.key==w.key&&k.type===w.type)A[y]=void 0;else for(d=0;d<P;d++){if((w=A[d])&&k.key==w.key&&k.type===w.type){A[d]=void 0;break}w=null;}g=$(n,k,w=w||f,t,o,r,c,s,h),(d=k.ref)&&w.ref!=d&&(b||(b=[]),w.ref&&b.push(w.ref,null,k),b.push(d,k.__c||g,k)),null!=g?(null==m&&(m=g),s=x(n,k,w,A,r,g,s),h||\"option\"!=u.type?\"function\"==typeof u.type&&(u.__d=s):n.value=\"\"):s&&w.__e==s&&s.parentNode!=n&&(s=_(w));}if(u.__e=m,null!=r&&\"function\"!=typeof u.type)for(y=r.length;y--;)null!=r[y]&&a(r[y]);for(y=P;y--;)null!=A[y]&&L(A[y],A[y]);if(b)for(y=0;y<b.length;y++)I(b[y],b[++y],b[++y]);}function x(n,l,u,i,t,o,r){var f,e,c;if(void 0!==l.__d)f=l.__d,l.__d=void 0;else if(t==u||o!=r||null==o.parentNode)n:if(null==r||r.parentNode!==n)n.appendChild(o),f=null;else {for(e=r,c=0;(e=e.nextSibling)&&c<i.length;c+=2)if(e==o)break n;n.insertBefore(o,r),f=r;}return void 0!==f?f:o.nextSibling}function A(n,l,u,i,t){var o;for(o in u)\"children\"===o||\"key\"===o||o in l||C(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"children\"===o||\"key\"===o||\"value\"===o||\"checked\"===o||u[o]===l[o]||C(n,o,l[o],u[o],i);}function P(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=null==u?\"\":\"number\"!=typeof u||c.test(l)?u:u+\"px\";}function C(n,l,u,i,t){var o,r,f;if(t&&\"className\"==l&&(l=\"class\"),\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else {if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||P(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||P(n.style,l,u[l]);}else \"o\"===l[0]&&\"n\"===l[1]?(o=l!==(l=l.replace(/Capture$/,\"\")),(r=l.toLowerCase())in n&&(l=r),l=l.slice(2),n.l||(n.l={}),n.l[l+o]=u,f=o?N:z,u?i||n.addEventListener(l,f,o):n.removeEventListener(l,f,o)):\"list\"!==l&&\"tagName\"!==l&&\"form\"!==l&&\"type\"!==l&&\"size\"!==l&&\"download\"!==l&&\"href\"!==l&&!t&&l in n?n[l]=null==u?\"\":u:\"function\"!=typeof u&&\"dangerouslySetInnerHTML\"!==l&&(l!==(l=l.replace(/xlink:?/,\"\"))?null==u||!1===u?n.removeAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase()):n.setAttributeNS(\"http://www.w3.org/1999/xlink\",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u));}function z(l){this.l[l.type+!1](n.event?n.event(l):l);}function N(l){this.l[l.type+!0](n.event?n.event(l):l);}function T(n,l,u){var i,t;for(i=0;i<n.__k.length;i++)(t=n.__k[i])&&(t.__=n,t.__e&&(\"function\"==typeof t.type&&t.__k.length>1&&T(t,l,u),l=x(u,t,t,n.__k,null,t.__e,l),\"function\"==typeof n.type&&(n.__d=l)));}function $(l,u,i,t,o,r,f,e,c){var a,h,v,y,_,w,k,g,b,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=n.__b)&&a(u);try{n:if(\"function\"==typeof P){if(g=u.props,b=(a=P.contextType)&&t[a.__c],x=a?b?b.props.value:a.__:t,i.__c?k=(h=u.__c=i.__c).__=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(g,x):(u.__c=h=new d(g,x),h.constructor=P,h.render=M),b&&b.sub(h),h.props=g,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s({},h.__s)),s(h.__s,P.getDerivedStateFromProps(g,h.__s))),y=h.props,_=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==P.getDerivedStateFromProps&&g!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,x)||u.__v===i.__v){h.props=g,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,h.__h.length&&f.push(h),T(u,e,l);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,w);});}h.context=x,h.props=g,h.state=h.__s,(a=n.__r)&&a(u),h.__d=!1,h.__v=u,h.__P=l,a=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=s(s({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(w=h.getSnapshotBeforeUpdate(y,_)),A=null!=a&&a.type==p&&null==a.key?a.props.children:a,m(l,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),k&&(h.__E=h.__=null),h.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=H(i.__e,u,i,t,o,r,f,c);(a=n.diffed)&&a(u);}catch(l){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),n.__e(l,u,i);}return u.__e}function j(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u);});}catch(l){n.__e(l,u.__v);}});}function H(n,l,u,i,t,o,r,c){var s,a,h,v,y,p=u.props,d=l.props;if(t=\"svg\"===l.type||t,null!=o)for(s=0;s<o.length;s++)if(null!=(a=o[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,o[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=t?document.createElementNS(\"http://www.w3.org/2000/svg\",l.type):document.createElement(l.type,d.is&&{is:d.is}),o=null,c=!1;}if(null===l.type)p===d||c&&n.data===d||(n.data=d);else {if(null!=o&&(o=e.slice.call(n.childNodes)),h=(p=u.props||f).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,!c){if(null!=o)for(p={},y=0;y<n.attributes.length;y++)p[n.attributes[y].name]=n.attributes[y].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===n.innerHTML)||(n.innerHTML=v&&v.__html||\"\"));}A(n,d,p,t,c),v?l.__k=[]:(s=l.props.children,m(n,Array.isArray(s)?s:[s],l,u,i,\"foreignObject\"!==l.type&&t,o,r,f,c)),c||(\"value\"in d&&void 0!==(s=d.value)&&(s!==n.value||\"progress\"===l.type&&!s)&&C(n,\"value\",s,p.value,!1),\"checked\"in d&&void 0!==(s=d.checked)&&s!==n.checked&&C(n,\"checked\",s,p.checked,!1));}return n}function I(l,u,i){try{\"function\"==typeof l?l(u):l.current=u;}catch(l){n.__e(l,i);}}function L(l,u,i){var t,o,r;if(n.unmount&&n.unmount(l),(t=l.ref)&&(t.current&&t.current!==l.__e||I(t,null,u)),i||\"function\"==typeof l.type||(i=null!=(o=l.__e)),l.__e=l.__d=void 0,null!=(t=l.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(l){n.__e(l,u);}t.base=t.__P=null;}if(t=l.__k)for(r=0;r<t.length;r++)t[r]&&L(t[r],u,i);null!=o&&a(o);}function M(n,l,u){return this.constructor(n,u)}function O(l,u,i){var t,r,c;n.__&&n.__(l,u),r=(t=i===o)?null:i&&i.__k||u.__k,l=h(p,null,[l]),c=[],$(u,(t?u:i||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,i&&!t?[i]:r?null:u.childNodes.length?e.slice.call(u.childNodes):null,c,i||f,t),j(c,l);}function B(n,l){var u={__c:l=\"__cC\"+r++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n,u,i){return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(k);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n={__e:function(n,l){for(var u,i,t,o=l.__h;l=l.__;)if((u=l.__c)&&!u.__)try{if((i=u.constructor)&&null!=i.getDerivedStateFromError&&(u.setState(i.getDerivedStateFromError(n)),t=u.__d),null!=u.componentDidCatch&&(u.componentDidCatch(n),t=u.__d),t)return l.__h=o,u.__E=u}catch(l){n=l;}throw n}},d.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s({},this.state),\"function\"==typeof n&&(n=n(s({},u),this.props)),n&&s(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),k(this));},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),k(this));},d.prototype.render=p,u=[],i=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,o=f,r=0;\n\n    var globalObj = typeof globalThis !== 'undefined' ? globalThis : window; // // TODO: streamline when killing IE11 support\n    if (globalObj.FullCalendarVDom) {\n        console.warn('FullCalendar VDOM already loaded');\n    }\n    else {\n        globalObj.FullCalendarVDom = {\n            Component: d,\n            createElement: h,\n            render: O,\n            createRef: y,\n            Fragment: p,\n            createContext: createContext,\n            flushToDom: flushToDom,\n            unmountComponentAtNode: unmountComponentAtNode,\n        };\n    }\n    // HACKS...\n    // TODO: lock version\n    // TODO: link gh issues\n    function flushToDom() {\n        var oldDebounceRendering = n.debounceRendering; // orig\n        var callbackQ = [];\n        function execCallbackSync(callback) {\n            callbackQ.push(callback);\n        }\n        n.debounceRendering = execCallbackSync;\n        O(h(FakeComponent, {}), document.createElement('div'));\n        while (callbackQ.length) {\n            callbackQ.shift()();\n        }\n        n.debounceRendering = oldDebounceRendering;\n    }\n    var FakeComponent = /** @class */ (function (_super) {\n        __extends(FakeComponent, _super);\n        function FakeComponent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        FakeComponent.prototype.render = function () { return h('div', {}); };\n        FakeComponent.prototype.componentDidMount = function () { this.setState({}); };\n        return FakeComponent;\n    }(d));\n    function createContext(defaultValue) {\n        var ContextType = B(defaultValue);\n        var origProvider = ContextType.Provider;\n        ContextType.Provider = function () {\n            var _this = this;\n            var isNew = !this.getChildContext;\n            var children = origProvider.apply(this, arguments); // eslint-disable-line prefer-rest-params\n            if (isNew) {\n                var subs_1 = [];\n                this.shouldComponentUpdate = function (_props) {\n                    if (_this.props.value !== _props.value) {\n                        subs_1.forEach(function (c) {\n                            c.context = _props.value;\n                            c.forceUpdate();\n                        });\n                    }\n                };\n                this.sub = function (c) {\n                    subs_1.push(c);\n                    var old = c.componentWillUnmount;\n                    c.componentWillUnmount = function () {\n                        subs_1.splice(subs_1.indexOf(c), 1);\n                        old && old.call(c);\n                    };\n                };\n            }\n            return children;\n        };\n        return ContextType;\n    }\n    function unmountComponentAtNode(node) {\n        O(null, node);\n    }\n\n    // no public types yet. when there are, export from:\n    // import {} from './api-type-deps'\n    var EventSourceApi = /** @class */ (function () {\n        function EventSourceApi(context, internalEventSource) {\n            this.context = context;\n            this.internalEventSource = internalEventSource;\n        }\n        EventSourceApi.prototype.remove = function () {\n            this.context.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: this.internalEventSource.sourceId,\n            });\n        };\n        EventSourceApi.prototype.refetch = function () {\n            this.context.dispatch({\n                type: 'FETCH_EVENT_SOURCES',\n                sourceIds: [this.internalEventSource.sourceId],\n            });\n        };\n        Object.defineProperty(EventSourceApi.prototype, \"id\", {\n            get: function () {\n                return this.internalEventSource.publicId;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventSourceApi.prototype, \"url\", {\n            // only relevant to json-feed event sources\n            get: function () {\n                return this.internalEventSource.meta.url;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        return EventSourceApi;\n    }());\n\n    function removeElement(el) {\n        if (el.parentNode) {\n            el.parentNode.removeChild(el);\n        }\n    }\n    // Querying\n    // ----------------------------------------------------------------------------------------------------------------\n    function elementClosest(el, selector) {\n        if (el.closest) {\n            return el.closest(selector);\n            // really bad fallback for IE\n            // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n        }\n        if (!document.documentElement.contains(el)) {\n            return null;\n        }\n        do {\n            if (elementMatches(el, selector)) {\n                return el;\n            }\n            el = (el.parentElement || el.parentNode);\n        } while (el !== null && el.nodeType === 1);\n        return null;\n    }\n    function elementMatches(el, selector) {\n        var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n        return method.call(el, selector);\n    }\n    // accepts multiple subject els\n    // returns a real array. good for methods like forEach\n    // TODO: accept the document\n    function findElements(container, selector) {\n        var containers = container instanceof HTMLElement ? [container] : container;\n        var allMatches = [];\n        for (var i = 0; i < containers.length; i += 1) {\n            var matches = containers[i].querySelectorAll(selector);\n            for (var j = 0; j < matches.length; j += 1) {\n                allMatches.push(matches[j]);\n            }\n        }\n        return allMatches;\n    }\n    // accepts multiple subject els\n    // only queries direct child elements // TODO: rename to findDirectChildren!\n    function findDirectChildren(parent, selector) {\n        var parents = parent instanceof HTMLElement ? [parent] : parent;\n        var allMatches = [];\n        for (var i = 0; i < parents.length; i += 1) {\n            var childNodes = parents[i].children; // only ever elements\n            for (var j = 0; j < childNodes.length; j += 1) {\n                var childNode = childNodes[j];\n                if (!selector || elementMatches(childNode, selector)) {\n                    allMatches.push(childNode);\n                }\n            }\n        }\n        return allMatches;\n    }\n    // Style\n    // ----------------------------------------------------------------------------------------------------------------\n    var PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\n    function applyStyle(el, props) {\n        for (var propName in props) {\n            applyStyleProp(el, propName, props[propName]);\n        }\n    }\n    function applyStyleProp(el, name, val) {\n        if (val == null) {\n            el.style[name] = '';\n        }\n        else if (typeof val === 'number' && PIXEL_PROP_RE.test(name)) {\n            el.style[name] = val + \"px\";\n        }\n        else {\n            el.style[name] = val;\n        }\n    }\n\n    // Stops a mouse/touch event from doing it's native browser action\n    function preventDefault(ev) {\n        ev.preventDefault();\n    }\n    // Event Delegation\n    // ----------------------------------------------------------------------------------------------------------------\n    function buildDelegationHandler(selector, handler) {\n        return function (ev) {\n            var matchedChild = elementClosest(ev.target, selector);\n            if (matchedChild) {\n                handler.call(matchedChild, ev, matchedChild);\n            }\n        };\n    }\n    function listenBySelector(container, eventType, selector, handler) {\n        var attachedHandler = buildDelegationHandler(selector, handler);\n        container.addEventListener(eventType, attachedHandler);\n        return function () {\n            container.removeEventListener(eventType, attachedHandler);\n        };\n    }\n    function listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n        var currentMatchedChild;\n        return listenBySelector(container, 'mouseover', selector, function (mouseOverEv, matchedChild) {\n            if (matchedChild !== currentMatchedChild) {\n                currentMatchedChild = matchedChild;\n                onMouseEnter(mouseOverEv, matchedChild);\n                var realOnMouseLeave_1 = function (mouseLeaveEv) {\n                    currentMatchedChild = null;\n                    onMouseLeave(mouseLeaveEv, matchedChild);\n                    matchedChild.removeEventListener('mouseleave', realOnMouseLeave_1);\n                };\n                // listen to the next mouseleave, and then unattach\n                matchedChild.addEventListener('mouseleave', realOnMouseLeave_1);\n            }\n        });\n    }\n    // Animation\n    // ----------------------------------------------------------------------------------------------------------------\n    var transitionEventNames = [\n        'webkitTransitionEnd',\n        'otransitionend',\n        'oTransitionEnd',\n        'msTransitionEnd',\n        'transitionend',\n    ];\n    // triggered only when the next single subsequent transition finishes\n    function whenTransitionDone(el, callback) {\n        var realCallback = function (ev) {\n            callback(ev);\n            transitionEventNames.forEach(function (eventName) {\n                el.removeEventListener(eventName, realCallback);\n            });\n        };\n        transitionEventNames.forEach(function (eventName) {\n            el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n        });\n    }\n\n    var guidNumber = 0;\n    function guid() {\n        guidNumber += 1;\n        return String(guidNumber);\n    }\n    /* FullCalendar-specific DOM Utilities\n    ----------------------------------------------------------------------------------------------------------------------*/\n    // Make the mouse cursor express that an event is not allowed in the current area\n    function disableCursor() {\n        document.body.classList.add('fc-not-allowed');\n    }\n    // Returns the mouse cursor to its original look\n    function enableCursor() {\n        document.body.classList.remove('fc-not-allowed');\n    }\n    /* Selection\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function preventSelection(el) {\n        el.classList.add('fc-unselectable');\n        el.addEventListener('selectstart', preventDefault);\n    }\n    function allowSelection(el) {\n        el.classList.remove('fc-unselectable');\n        el.removeEventListener('selectstart', preventDefault);\n    }\n    /* Context Menu\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function preventContextMenu(el) {\n        el.addEventListener('contextmenu', preventDefault);\n    }\n    function allowContextMenu(el) {\n        el.removeEventListener('contextmenu', preventDefault);\n    }\n    function parseFieldSpecs(input) {\n        var specs = [];\n        var tokens = [];\n        var i;\n        var token;\n        if (typeof input === 'string') {\n            tokens = input.split(/\\s*,\\s*/);\n        }\n        else if (typeof input === 'function') {\n            tokens = [input];\n        }\n        else if (Array.isArray(input)) {\n            tokens = input;\n        }\n        for (i = 0; i < tokens.length; i += 1) {\n            token = tokens[i];\n            if (typeof token === 'string') {\n                specs.push(token.charAt(0) === '-' ?\n                    { field: token.substring(1), order: -1 } :\n                    { field: token, order: 1 });\n            }\n            else if (typeof token === 'function') {\n                specs.push({ func: token });\n            }\n        }\n        return specs;\n    }\n    function compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n        var i;\n        var cmp;\n        for (i = 0; i < fieldSpecs.length; i += 1) {\n            cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n            if (cmp) {\n                return cmp;\n            }\n        }\n        return 0;\n    }\n    function compareByFieldSpec(obj0, obj1, fieldSpec) {\n        if (fieldSpec.func) {\n            return fieldSpec.func(obj0, obj1);\n        }\n        return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field])\n            * (fieldSpec.order || 1);\n    }\n    function flexibleCompare(a, b) {\n        if (!a && !b) {\n            return 0;\n        }\n        if (b == null) {\n            return -1;\n        }\n        if (a == null) {\n            return 1;\n        }\n        if (typeof a === 'string' || typeof b === 'string') {\n            return String(a).localeCompare(String(b));\n        }\n        return a - b;\n    }\n    /* String Utilities\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function padStart(val, len) {\n        var s = String(val);\n        return '000'.substr(0, len - s.length) + s;\n    }\n    /* Number Utilities\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function compareNumbers(a, b) {\n        return a - b;\n    }\n    function isInt(n) {\n        return n % 1 === 0;\n    }\n    /* FC-specific DOM dimension stuff\n    ----------------------------------------------------------------------------------------------------------------------*/\n    function computeSmallestCellWidth(cellEl) {\n        var allWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-frame');\n        var contentWidthEl = cellEl.querySelector('.fc-scrollgrid-shrink-cushion');\n        if (!allWidthEl) {\n            throw new Error('needs fc-scrollgrid-shrink-frame className'); // TODO: use const\n        }\n        if (!contentWidthEl) {\n            throw new Error('needs fc-scrollgrid-shrink-cushion className');\n        }\n        return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n            contentWidthEl.getBoundingClientRect().width;\n    }\n\n    var DAY_IDS = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\n    // Adding\n    function addWeeks(m, n) {\n        var a = dateToUtcArray(m);\n        a[2] += n * 7;\n        return arrayToUtcDate(a);\n    }\n    function addDays(m, n) {\n        var a = dateToUtcArray(m);\n        a[2] += n;\n        return arrayToUtcDate(a);\n    }\n    function addMs(m, n) {\n        var a = dateToUtcArray(m);\n        a[6] += n;\n        return arrayToUtcDate(a);\n    }\n    // Diffing (all return floats)\n    // TODO: why not use ranges?\n    function diffWeeks(m0, m1) {\n        return diffDays(m0, m1) / 7;\n    }\n    function diffDays(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n    }\n    function diffHours(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n    }\n    function diffMinutes(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n    }\n    function diffSeconds(m0, m1) {\n        return (m1.valueOf() - m0.valueOf()) / 1000;\n    }\n    function diffDayAndTime(m0, m1) {\n        var m0day = startOfDay(m0);\n        var m1day = startOfDay(m1);\n        return {\n            years: 0,\n            months: 0,\n            days: Math.round(diffDays(m0day, m1day)),\n            milliseconds: (m1.valueOf() - m1day.valueOf()) - (m0.valueOf() - m0day.valueOf()),\n        };\n    }\n    // Diffing Whole Units\n    function diffWholeWeeks(m0, m1) {\n        var d = diffWholeDays(m0, m1);\n        if (d !== null && d % 7 === 0) {\n            return d / 7;\n        }\n        return null;\n    }\n    function diffWholeDays(m0, m1) {\n        if (timeAsMs(m0) === timeAsMs(m1)) {\n            return Math.round(diffDays(m0, m1));\n        }\n        return null;\n    }\n    // Start-Of\n    function startOfDay(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n        ]);\n    }\n    function startOfHour(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n        ]);\n    }\n    function startOfMinute(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes(),\n        ]);\n    }\n    function startOfSecond(m) {\n        return arrayToUtcDate([\n            m.getUTCFullYear(),\n            m.getUTCMonth(),\n            m.getUTCDate(),\n            m.getUTCHours(),\n            m.getUTCMinutes(),\n            m.getUTCSeconds(),\n        ]);\n    }\n    // Week Computation\n    function weekOfYear(marker, dow, doy) {\n        var y = marker.getUTCFullYear();\n        var w = weekOfGivenYear(marker, y, dow, doy);\n        if (w < 1) {\n            return weekOfGivenYear(marker, y - 1, dow, doy);\n        }\n        var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n        if (nextW >= 1) {\n            return Math.min(w, nextW);\n        }\n        return w;\n    }\n    function weekOfGivenYear(marker, year, dow, doy) {\n        var firstWeekStart = arrayToUtcDate([year, 0, 1 + firstWeekOffset(year, dow, doy)]);\n        var dayStart = startOfDay(marker);\n        var days = Math.round(diffDays(firstWeekStart, dayStart));\n        return Math.floor(days / 7) + 1; // zero-indexed\n    }\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n        var fwd = 7 + dow - doy;\n        // first-week day local weekday -- which local weekday is fwd\n        var fwdlw = (7 + arrayToUtcDate([year, 0, fwd]).getUTCDay() - dow) % 7;\n        return -fwdlw + fwd - 1;\n    }\n    // Array Conversion\n    function dateToLocalArray(date) {\n        return [\n            date.getFullYear(),\n            date.getMonth(),\n            date.getDate(),\n            date.getHours(),\n            date.getMinutes(),\n            date.getSeconds(),\n            date.getMilliseconds(),\n        ];\n    }\n    function arrayToLocalDate(a) {\n        return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], // day of month\n        a[3] || 0, a[4] || 0, a[5] || 0);\n    }\n    function dateToUtcArray(date) {\n        return [\n            date.getUTCFullYear(),\n            date.getUTCMonth(),\n            date.getUTCDate(),\n            date.getUTCHours(),\n            date.getUTCMinutes(),\n            date.getUTCSeconds(),\n            date.getUTCMilliseconds(),\n        ];\n    }\n    function arrayToUtcDate(a) {\n        // according to web standards (and Safari), a month index is required.\n        // massage if only given a year.\n        if (a.length === 1) {\n            a = a.concat([0]);\n        }\n        return new Date(Date.UTC.apply(Date, a));\n    }\n    // Other Utils\n    function isValidDate(m) {\n        return !isNaN(m.valueOf());\n    }\n    function timeAsMs(m) {\n        return m.getUTCHours() * 1000 * 60 * 60 +\n            m.getUTCMinutes() * 1000 * 60 +\n            m.getUTCSeconds() * 1000 +\n            m.getUTCMilliseconds();\n    }\n\n    function createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n        return {\n            instanceId: guid(),\n            defId: defId,\n            range: range,\n            forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n            forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo,\n        };\n    }\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    // Merges an array of objects into a single object.\n    // The second argument allows for an array of property names who's object values will be merged together.\n    function mergeProps(propObjs, complexPropsMap) {\n        var dest = {};\n        if (complexPropsMap) {\n            for (var name_1 in complexPropsMap) {\n                var complexObjs = [];\n                // collect the trailing object values, stopping when a non-object is discovered\n                for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n                    var val = propObjs[i][name_1];\n                    if (typeof val === 'object' && val) { // non-null object\n                        complexObjs.unshift(val);\n                    }\n                    else if (val !== undefined) {\n                        dest[name_1] = val; // if there were no objects, this value will be used\n                        break;\n                    }\n                }\n                // if the trailing values were objects, use the merged value\n                if (complexObjs.length) {\n                    dest[name_1] = mergeProps(complexObjs);\n                }\n            }\n        }\n        // copy values into the destination, going from last to first\n        for (var i = propObjs.length - 1; i >= 0; i -= 1) {\n            var props = propObjs[i];\n            for (var name_2 in props) {\n                if (!(name_2 in dest)) { // if already assigned by previous props or complex props, don't reassign\n                    dest[name_2] = props[name_2];\n                }\n            }\n        }\n        return dest;\n    }\n    function filterHash(hash, func) {\n        var filtered = {};\n        for (var key in hash) {\n            if (func(hash[key], key)) {\n                filtered[key] = hash[key];\n            }\n        }\n        return filtered;\n    }\n    function mapHash(hash, func) {\n        var newHash = {};\n        for (var key in hash) {\n            newHash[key] = func(hash[key], key);\n        }\n        return newHash;\n    }\n    function arrayToHash(a) {\n        var hash = {};\n        for (var _i = 0, a_1 = a; _i < a_1.length; _i++) {\n            var item = a_1[_i];\n            hash[item] = true;\n        }\n        return hash;\n    }\n    function buildHashFromArray(a, func) {\n        var hash = {};\n        for (var i = 0; i < a.length; i += 1) {\n            var tuple = func(a[i], i);\n            hash[tuple[0]] = tuple[1];\n        }\n        return hash;\n    }\n    function hashValuesToArray(obj) {\n        var a = [];\n        for (var key in obj) {\n            a.push(obj[key]);\n        }\n        return a;\n    }\n    function isPropsEqual(obj0, obj1) {\n        if (obj0 === obj1) {\n            return true;\n        }\n        for (var key in obj0) {\n            if (hasOwnProperty.call(obj0, key)) {\n                if (!(key in obj1)) {\n                    return false;\n                }\n            }\n        }\n        for (var key in obj1) {\n            if (hasOwnProperty.call(obj1, key)) {\n                if (obj0[key] !== obj1[key]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    function getUnequalProps(obj0, obj1) {\n        var keys = [];\n        for (var key in obj0) {\n            if (hasOwnProperty.call(obj0, key)) {\n                if (!(key in obj1)) {\n                    keys.push(key);\n                }\n            }\n        }\n        for (var key in obj1) {\n            if (hasOwnProperty.call(obj1, key)) {\n                if (obj0[key] !== obj1[key]) {\n                    keys.push(key);\n                }\n            }\n        }\n        return keys;\n    }\n    function compareObjs(oldProps, newProps, equalityFuncs) {\n        if (equalityFuncs === void 0) { equalityFuncs = {}; }\n        if (oldProps === newProps) {\n            return true;\n        }\n        for (var key in newProps) {\n            if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n            else {\n                return false;\n            }\n        }\n        // check for props that were omitted in the new\n        for (var key in oldProps) {\n            if (!(key in newProps)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /*\n    assumed \"true\" equality for handler names like \"onReceiveSomething\"\n    */\n    function isObjValsEqual(val0, val1, comparator) {\n        if (val0 === val1 || comparator === true) {\n            return true;\n        }\n        if (comparator) {\n            return comparator(val0, val1);\n        }\n        return false;\n    }\n    function collectFromHash(hash, startIndex, endIndex, step) {\n        if (startIndex === void 0) { startIndex = 0; }\n        if (step === void 0) { step = 1; }\n        var res = [];\n        if (endIndex == null) {\n            endIndex = Object.keys(hash).length;\n        }\n        for (var i = startIndex; i < endIndex; i += step) {\n            var val = hash[i];\n            if (val !== undefined) { // will disregard undefined for sparse arrays\n                res.push(val);\n            }\n        }\n        return res;\n    }\n\n    function parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n        for (var i = 0; i < recurringTypes.length; i += 1) {\n            var parsed = recurringTypes[i].parse(refined, dateEnv);\n            if (parsed) {\n                var allDay = refined.allDay;\n                if (allDay == null) {\n                    allDay = defaultAllDay;\n                    if (allDay == null) {\n                        allDay = parsed.allDayGuess;\n                        if (allDay == null) {\n                            allDay = false;\n                        }\n                    }\n                }\n                return {\n                    allDay: allDay,\n                    duration: parsed.duration,\n                    typeData: parsed.typeData,\n                    typeId: i,\n                };\n            }\n        }\n        return null;\n    }\n    function expandRecurring(eventStore, framingRange, context) {\n        var dateEnv = context.dateEnv, pluginHooks = context.pluginHooks, options = context.options;\n        var defs = eventStore.defs, instances = eventStore.instances;\n        // remove existing recurring instances\n        // TODO: bad. always expand events as a second step\n        instances = filterHash(instances, function (instance) { return !defs[instance.defId].recurringDef; });\n        for (var defId in defs) {\n            var def = defs[defId];\n            if (def.recurringDef) {\n                var duration = def.recurringDef.duration;\n                if (!duration) {\n                    duration = def.allDay ?\n                        options.defaultAllDayEventDuration :\n                        options.defaultTimedEventDuration;\n                }\n                var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n                for (var _i = 0, starts_1 = starts; _i < starts_1.length; _i++) {\n                    var start = starts_1[_i];\n                    var instance = createEventInstance(defId, {\n                        start: start,\n                        end: dateEnv.add(start, duration),\n                    });\n                    instances[instance.instanceId] = instance;\n                }\n            }\n        }\n        return { defs: defs, instances: instances };\n    }\n    /*\n    Event MUST have a recurringDef\n    */\n    function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n        var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n        var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n            start: dateEnv.subtract(framingRange.start, duration),\n            end: framingRange.end,\n        }, dateEnv);\n        // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n        if (eventDef.allDay) {\n            markers = markers.map(startOfDay);\n        }\n        return markers;\n    }\n\n    var INTERNAL_UNITS = ['years', 'months', 'days', 'milliseconds'];\n    var PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n    // Parsing and Creation\n    function createDuration(input, unit) {\n        var _a;\n        if (typeof input === 'string') {\n            return parseString(input);\n        }\n        if (typeof input === 'object' && input) { // non-null object\n            return parseObject(input);\n        }\n        if (typeof input === 'number') {\n            return parseObject((_a = {}, _a[unit || 'milliseconds'] = input, _a));\n        }\n        return null;\n    }\n    function parseString(s) {\n        var m = PARSE_RE.exec(s);\n        if (m) {\n            var sign = m[1] ? -1 : 1;\n            return {\n                years: 0,\n                months: 0,\n                days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n                milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n                    (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n                    (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n                    (m[6] ? parseInt(m[6], 10) : 0) // ms\n                ),\n            };\n        }\n        return null;\n    }\n    function parseObject(obj) {\n        var duration = {\n            years: obj.years || obj.year || 0,\n            months: obj.months || obj.month || 0,\n            days: obj.days || obj.day || 0,\n            milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n                (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n                (obj.seconds || obj.second || 0) * 1000 + // seconds\n                (obj.milliseconds || obj.millisecond || obj.ms || 0),\n        };\n        var weeks = obj.weeks || obj.week;\n        if (weeks) {\n            duration.days += weeks * 7;\n            duration.specifiedWeeks = true;\n        }\n        return duration;\n    }\n    // Equality\n    function durationsEqual(d0, d1) {\n        return d0.years === d1.years &&\n            d0.months === d1.months &&\n            d0.days === d1.days &&\n            d0.milliseconds === d1.milliseconds;\n    }\n    function asCleanDays(dur) {\n        if (!dur.years && !dur.months && !dur.milliseconds) {\n            return dur.days;\n        }\n        return 0;\n    }\n    // Simple Math\n    function addDurations(d0, d1) {\n        return {\n            years: d0.years + d1.years,\n            months: d0.months + d1.months,\n            days: d0.days + d1.days,\n            milliseconds: d0.milliseconds + d1.milliseconds,\n        };\n    }\n    function subtractDurations(d1, d0) {\n        return {\n            years: d1.years - d0.years,\n            months: d1.months - d0.months,\n            days: d1.days - d0.days,\n            milliseconds: d1.milliseconds - d0.milliseconds,\n        };\n    }\n    function multiplyDuration(d, n) {\n        return {\n            years: d.years * n,\n            months: d.months * n,\n            days: d.days * n,\n            milliseconds: d.milliseconds * n,\n        };\n    }\n    // Conversions\n    // \"Rough\" because they are based on average-case Gregorian months/years\n    function asRoughYears(dur) {\n        return asRoughDays(dur) / 365;\n    }\n    function asRoughMonths(dur) {\n        return asRoughDays(dur) / 30;\n    }\n    function asRoughDays(dur) {\n        return asRoughMs(dur) / 864e5;\n    }\n    function asRoughMinutes(dur) {\n        return asRoughMs(dur) / (1000 * 60);\n    }\n    function asRoughSeconds(dur) {\n        return asRoughMs(dur) / 1000;\n    }\n    function asRoughMs(dur) {\n        return dur.years * (365 * 864e5) +\n            dur.months * (30 * 864e5) +\n            dur.days * 864e5 +\n            dur.milliseconds;\n    }\n    // Advanced Math\n    function wholeDivideDurations(numerator, denominator) {\n        var res = null;\n        for (var i = 0; i < INTERNAL_UNITS.length; i += 1) {\n            var unit = INTERNAL_UNITS[i];\n            if (denominator[unit]) {\n                var localRes = numerator[unit] / denominator[unit];\n                if (!isInt(localRes) || (res !== null && res !== localRes)) {\n                    return null;\n                }\n                res = localRes;\n            }\n            else if (numerator[unit]) {\n                // needs to divide by something but can't!\n                return null;\n            }\n        }\n        return res;\n    }\n    function greatestDurationDenominator(dur) {\n        var ms = dur.milliseconds;\n        if (ms) {\n            if (ms % 1000 !== 0) {\n                return { unit: 'millisecond', value: ms };\n            }\n            if (ms % (1000 * 60) !== 0) {\n                return { unit: 'second', value: ms / 1000 };\n            }\n            if (ms % (1000 * 60 * 60) !== 0) {\n                return { unit: 'minute', value: ms / (1000 * 60) };\n            }\n            if (ms) {\n                return { unit: 'hour', value: ms / (1000 * 60 * 60) };\n            }\n        }\n        if (dur.days) {\n            if (dur.specifiedWeeks && dur.days % 7 === 0) {\n                return { unit: 'week', value: dur.days / 7 };\n            }\n            return { unit: 'day', value: dur.days };\n        }\n        if (dur.months) {\n            return { unit: 'month', value: dur.months };\n        }\n        if (dur.years) {\n            return { unit: 'year', value: dur.years };\n        }\n        return { unit: 'millisecond', value: 0 };\n    }\n\n    // timeZoneOffset is in minutes\n    function buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n        if (stripZeroTime === void 0) { stripZeroTime = false; }\n        var s = marker.toISOString();\n        s = s.replace('.000', '');\n        if (stripZeroTime) {\n            s = s.replace('T00:00:00Z', '');\n        }\n        if (s.length > 10) { // time part wasn't stripped, can add timezone info\n            if (timeZoneOffset == null) {\n                s = s.replace('Z', '');\n            }\n            else if (timeZoneOffset !== 0) {\n                s = s.replace('Z', formatTimeZoneOffset(timeZoneOffset, true));\n            }\n            // otherwise, its UTC-0 and we want to keep the Z\n        }\n        return s;\n    }\n    // formats the date, but with no time part\n    // TODO: somehow merge with buildIsoString and stripZeroTime\n    // TODO: rename. omit \"string\"\n    function formatDayString(marker) {\n        return marker.toISOString().replace(/T.*$/, '');\n    }\n    // TODO: use Date::toISOString and use everything after the T?\n    function formatIsoTimeString(marker) {\n        return padStart(marker.getUTCHours(), 2) + ':' +\n            padStart(marker.getUTCMinutes(), 2) + ':' +\n            padStart(marker.getUTCSeconds(), 2);\n    }\n    function formatTimeZoneOffset(minutes, doIso) {\n        if (doIso === void 0) { doIso = false; }\n        var sign = minutes < 0 ? '-' : '+';\n        var abs = Math.abs(minutes);\n        var hours = Math.floor(abs / 60);\n        var mins = Math.round(abs % 60);\n        if (doIso) {\n            return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n        }\n        return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : '');\n    }\n\n    // TODO: new util arrayify?\n    function removeExact(array, exactVal) {\n        var removeCnt = 0;\n        var i = 0;\n        while (i < array.length) {\n            if (array[i] === exactVal) {\n                array.splice(i, 1);\n                removeCnt += 1;\n            }\n            else {\n                i += 1;\n            }\n        }\n        return removeCnt;\n    }\n    function isArraysEqual(a0, a1, equalityFunc) {\n        if (a0 === a1) {\n            return true;\n        }\n        var len = a0.length;\n        var i;\n        if (len !== a1.length) { // not array? or not same length?\n            return false;\n        }\n        for (i = 0; i < len; i += 1) {\n            if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function memoize(workerFunc, resEquality, teardownFunc) {\n        var currentArgs;\n        var currentRes;\n        return function () {\n            var newArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                newArgs[_i] = arguments[_i];\n            }\n            if (!currentArgs) {\n                currentRes = workerFunc.apply(this, newArgs);\n            }\n            else if (!isArraysEqual(currentArgs, newArgs)) {\n                if (teardownFunc) {\n                    teardownFunc(currentRes);\n                }\n                var res = workerFunc.apply(this, newArgs);\n                if (!resEquality || !resEquality(res, currentRes)) {\n                    currentRes = res;\n                }\n            }\n            currentArgs = newArgs;\n            return currentRes;\n        };\n    }\n    function memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n        var _this = this;\n        var currentArg;\n        var currentRes;\n        return function (newArg) {\n            if (!currentArg) {\n                currentRes = workerFunc.call(_this, newArg);\n            }\n            else if (!isPropsEqual(currentArg, newArg)) {\n                if (teardownFunc) {\n                    teardownFunc(currentRes);\n                }\n                var res = workerFunc.call(_this, newArg);\n                if (!resEquality || !resEquality(res, currentRes)) {\n                    currentRes = res;\n                }\n            }\n            currentArg = newArg;\n            return currentRes;\n        };\n    }\n    function memoizeArraylike(// used at all?\n    workerFunc, resEquality, teardownFunc) {\n        var _this = this;\n        var currentArgSets = [];\n        var currentResults = [];\n        return function (newArgSets) {\n            var currentLen = currentArgSets.length;\n            var newLen = newArgSets.length;\n            var i = 0;\n            for (; i < currentLen; i += 1) {\n                if (!newArgSets[i]) { // one of the old sets no longer exists\n                    if (teardownFunc) {\n                        teardownFunc(currentResults[i]);\n                    }\n                }\n                else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResults[i]);\n                    }\n                    var res = workerFunc.apply(_this, newArgSets[i]);\n                    if (!resEquality || !resEquality(res, currentResults[i])) {\n                        currentResults[i] = res;\n                    }\n                }\n            }\n            for (; i < newLen; i += 1) {\n                currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n            }\n            currentArgSets = newArgSets;\n            currentResults.splice(newLen); // remove excess\n            return currentResults;\n        };\n    }\n    function memoizeHashlike(// used?\n    workerFunc, resEquality, teardownFunc) {\n        var _this = this;\n        var currentArgHash = {};\n        var currentResHash = {};\n        return function (newArgHash) {\n            var newResHash = {};\n            for (var key in newArgHash) {\n                if (!currentResHash[key]) {\n                    newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n                }\n                else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                    if (teardownFunc) {\n                        teardownFunc(currentResHash[key]);\n                    }\n                    var res = workerFunc.apply(_this, newArgHash[key]);\n                    newResHash[key] = (resEquality && resEquality(res, currentResHash[key]))\n                        ? currentResHash[key]\n                        : res;\n                }\n                else {\n                    newResHash[key] = currentResHash[key];\n                }\n            }\n            currentArgHash = newArgHash;\n            currentResHash = newResHash;\n            return newResHash;\n        };\n    }\n\n    var EXTENDED_SETTINGS_AND_SEVERITIES = {\n        week: 3,\n        separator: 0,\n        omitZeroMinute: 0,\n        meridiem: 0,\n        omitCommas: 0,\n    };\n    var STANDARD_DATE_PROP_SEVERITIES = {\n        timeZoneName: 7,\n        era: 6,\n        year: 5,\n        month: 4,\n        day: 2,\n        weekday: 2,\n        hour: 1,\n        minute: 1,\n        second: 1,\n    };\n    var MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\n    var COMMA_RE = /,/g; // we need re for globalness\n    var MULTI_SPACE_RE = /\\s+/g;\n    var LTR_RE = /\\u200e/g; // control character\n    var UTC_RE = /UTC|GMT/;\n    var NativeFormatter = /** @class */ (function () {\n        function NativeFormatter(formatSettings) {\n            var standardDateProps = {};\n            var extendedSettings = {};\n            var severity = 0;\n            for (var name_1 in formatSettings) {\n                if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                    extendedSettings[name_1] = formatSettings[name_1];\n                    severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n                }\n                else {\n                    standardDateProps[name_1] = formatSettings[name_1];\n                    if (name_1 in STANDARD_DATE_PROP_SEVERITIES) { // TODO: what about hour12? no severity\n                        severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n                    }\n                }\n            }\n            this.standardDateProps = standardDateProps;\n            this.extendedSettings = extendedSettings;\n            this.severity = severity;\n            this.buildFormattingFunc = memoize(buildFormattingFunc);\n        }\n        NativeFormatter.prototype.format = function (date, context) {\n            return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n        };\n        NativeFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n            var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;\n            var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n            if (!diffSeverity) {\n                return this.format(start, context);\n            }\n            var biggestUnitForPartial = diffSeverity;\n            if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n                (standardDateProps.year === 'numeric' || standardDateProps.year === '2-digit') &&\n                (standardDateProps.month === 'numeric' || standardDateProps.month === '2-digit') &&\n                (standardDateProps.day === 'numeric' || standardDateProps.day === '2-digit')) {\n                biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n            }\n            var full0 = this.format(start, context);\n            var full1 = this.format(end, context);\n            if (full0 === full1) {\n                return full0;\n            }\n            var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n            var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n            var partial0 = partialFormattingFunc(start);\n            var partial1 = partialFormattingFunc(end);\n            var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n            var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || '';\n            if (insertion) {\n                return insertion.before + partial0 + separator + partial1 + insertion.after;\n            }\n            return full0 + separator + full1;\n        };\n        NativeFormatter.prototype.getLargestUnit = function () {\n            switch (this.severity) {\n                case 7:\n                case 6:\n                case 5:\n                    return 'year';\n                case 4:\n                    return 'month';\n                case 3:\n                    return 'week';\n                case 2:\n                    return 'day';\n                default:\n                    return 'time'; // really?\n            }\n        };\n        return NativeFormatter;\n    }());\n    function buildFormattingFunc(standardDateProps, extendedSettings, context) {\n        var standardDatePropCnt = Object.keys(standardDateProps).length;\n        if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === 'short') {\n            return function (date) { return (formatTimeZoneOffset(date.timeZoneOffset)); };\n        }\n        if (standardDatePropCnt === 0 && extendedSettings.week) {\n            return function (date) { return (formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.locale, extendedSettings.week)); };\n        }\n        return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n    }\n    function buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n        standardDateProps = __assign({}, standardDateProps); // copy\n        extendedSettings = __assign({}, extendedSettings); // copy\n        sanitizeSettings(standardDateProps, extendedSettings);\n        standardDateProps.timeZone = 'UTC'; // we leverage the only guaranteed timeZone for our UTC markers\n        var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n        var zeroFormat; // needed?\n        if (extendedSettings.omitZeroMinute) {\n            var zeroProps = __assign({}, standardDateProps);\n            delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n            zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n        }\n        return function (date) {\n            var marker = date.marker;\n            var format;\n            if (zeroFormat && !marker.getUTCMinutes()) {\n                format = zeroFormat;\n            }\n            else {\n                format = normalFormat;\n            }\n            var s = format.format(marker);\n            return postProcess(s, date, standardDateProps, extendedSettings, context);\n        };\n    }\n    function sanitizeSettings(standardDateProps, extendedSettings) {\n        // deal with a browser inconsistency where formatting the timezone\n        // requires that the hour/minute be present.\n        if (standardDateProps.timeZoneName) {\n            if (!standardDateProps.hour) {\n                standardDateProps.hour = '2-digit';\n            }\n            if (!standardDateProps.minute) {\n                standardDateProps.minute = '2-digit';\n            }\n        }\n        // only support short timezone names\n        if (standardDateProps.timeZoneName === 'long') {\n            standardDateProps.timeZoneName = 'short';\n        }\n        // if requesting to display seconds, MUST display minutes\n        if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n            delete extendedSettings.omitZeroMinute;\n        }\n    }\n    function postProcess(s, date, standardDateProps, extendedSettings, context) {\n        s = s.replace(LTR_RE, ''); // remove left-to-right control chars. do first. good for other regexes\n        if (standardDateProps.timeZoneName === 'short') {\n            s = injectTzoStr(s, (context.timeZone === 'UTC' || date.timeZoneOffset == null) ?\n                'UTC' : // important to normalize for IE, which does \"GMT\"\n                formatTimeZoneOffset(date.timeZoneOffset));\n        }\n        if (extendedSettings.omitCommas) {\n            s = s.replace(COMMA_RE, '').trim();\n        }\n        if (extendedSettings.omitZeroMinute) {\n            s = s.replace(':00', ''); // zeroFormat doesn't always achieve this\n        }\n        // ^ do anything that might create adjacent spaces before this point,\n        // because MERIDIEM_RE likes to eat up loading spaces\n        if (extendedSettings.meridiem === false) {\n            s = s.replace(MERIDIEM_RE, '').trim();\n        }\n        else if (extendedSettings.meridiem === 'narrow') { // a/p\n            s = s.replace(MERIDIEM_RE, function (m0, m1) { return m1.toLocaleLowerCase(); });\n        }\n        else if (extendedSettings.meridiem === 'short') { // am/pm\n            s = s.replace(MERIDIEM_RE, function (m0, m1) { return m1.toLocaleLowerCase() + \"m\"; });\n        }\n        else if (extendedSettings.meridiem === 'lowercase') { // other meridiem transformers already converted to lowercase\n            s = s.replace(MERIDIEM_RE, function (m0) { return m0.toLocaleLowerCase(); });\n        }\n        s = s.replace(MULTI_SPACE_RE, ' ');\n        s = s.trim();\n        return s;\n    }\n    function injectTzoStr(s, tzoStr) {\n        var replaced = false;\n        s = s.replace(UTC_RE, function () {\n            replaced = true;\n            return tzoStr;\n        });\n        // IE11 doesn't include UTC/GMT in the original string, so append to end\n        if (!replaced) {\n            s += \" \" + tzoStr;\n        }\n        return s;\n    }\n    function formatWeekNumber(num, weekText, locale, display) {\n        var parts = [];\n        if (display === 'narrow') {\n            parts.push(weekText);\n        }\n        else if (display === 'short') {\n            parts.push(weekText, ' ');\n        }\n        // otherwise, considered 'numeric'\n        parts.push(locale.simpleNumberFormat.format(num));\n        if (locale.options.direction === 'rtl') { // TODO: use control characters instead?\n            parts.reverse();\n        }\n        return parts.join('');\n    }\n    // Range Formatting Utils\n    // 0 = exactly the same\n    // 1 = different by time\n    // and bigger\n    function computeMarkerDiffSeverity(d0, d1, ca) {\n        if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n            return 5;\n        }\n        if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n            return 4;\n        }\n        if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n            return 2;\n        }\n        if (timeAsMs(d0) !== timeAsMs(d1)) {\n            return 1;\n        }\n        return 0;\n    }\n    function computePartialFormattingOptions(options, biggestUnit) {\n        var partialOptions = {};\n        for (var name_2 in options) {\n            if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n                STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n                partialOptions[name_2] = options[name_2];\n            }\n        }\n        return partialOptions;\n    }\n    function findCommonInsertion(full0, partial0, full1, partial1) {\n        var i0 = 0;\n        while (i0 < full0.length) {\n            var found0 = full0.indexOf(partial0, i0);\n            if (found0 === -1) {\n                break;\n            }\n            var before0 = full0.substr(0, found0);\n            i0 = found0 + partial0.length;\n            var after0 = full0.substr(i0);\n            var i1 = 0;\n            while (i1 < full1.length) {\n                var found1 = full1.indexOf(partial1, i1);\n                if (found1 === -1) {\n                    break;\n                }\n                var before1 = full1.substr(0, found1);\n                i1 = found1 + partial1.length;\n                var after1 = full1.substr(i1);\n                if (before0 === before1 && after0 === after1) {\n                    return {\n                        before: before0,\n                        after: after0,\n                    };\n                }\n            }\n        }\n        return null;\n    }\n\n    function expandZonedMarker(dateInfo, calendarSystem) {\n        var a = calendarSystem.markerToArray(dateInfo.marker);\n        return {\n            marker: dateInfo.marker,\n            timeZoneOffset: dateInfo.timeZoneOffset,\n            array: a,\n            year: a[0],\n            month: a[1],\n            day: a[2],\n            hour: a[3],\n            minute: a[4],\n            second: a[5],\n            millisecond: a[6],\n        };\n    }\n\n    function createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n        var startInfo = expandZonedMarker(start, context.calendarSystem);\n        var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n        return {\n            date: startInfo,\n            start: startInfo,\n            end: endInfo,\n            timeZone: context.timeZone,\n            localeCodes: context.locale.codes,\n            defaultSeparator: betterDefaultSeparator || context.defaultSeparator,\n        };\n    }\n\n    /*\n    TODO: fix the terminology of \"formatter\" vs \"formatting func\"\n    */\n    /*\n    At the time of instantiation, this object does not know which cmd-formatting system it will use.\n    It receives this at the time of formatting, as a setting.\n    */\n    var CmdFormatter = /** @class */ (function () {\n        function CmdFormatter(cmdStr) {\n            this.cmdStr = cmdStr;\n        }\n        CmdFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n        };\n        CmdFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n            return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n        };\n        return CmdFormatter;\n    }());\n\n    var FuncFormatter = /** @class */ (function () {\n        function FuncFormatter(func) {\n            this.func = func;\n        }\n        FuncFormatter.prototype.format = function (date, context, betterDefaultSeparator) {\n            return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n        };\n        FuncFormatter.prototype.formatRange = function (start, end, context, betterDefaultSeparator) {\n            return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n        };\n        return FuncFormatter;\n    }());\n\n    function createFormatter(input) {\n        if (typeof input === 'object' && input) { // non-null object\n            return new NativeFormatter(input);\n        }\n        if (typeof input === 'string') {\n            return new CmdFormatter(input);\n        }\n        if (typeof input === 'function') {\n            return new FuncFormatter(input);\n        }\n        return null;\n    }\n\n    // base options\n    // ------------\n    var BASE_OPTION_REFINERS = {\n        navLinkDayClick: identity,\n        navLinkWeekClick: identity,\n        duration: createDuration,\n        bootstrapFontAwesome: identity,\n        buttonIcons: identity,\n        customButtons: identity,\n        defaultAllDayEventDuration: createDuration,\n        defaultTimedEventDuration: createDuration,\n        nextDayThreshold: createDuration,\n        scrollTime: createDuration,\n        slotMinTime: createDuration,\n        slotMaxTime: createDuration,\n        dayPopoverFormat: createFormatter,\n        slotDuration: createDuration,\n        snapDuration: createDuration,\n        headerToolbar: identity,\n        footerToolbar: identity,\n        defaultRangeSeparator: String,\n        titleRangeSeparator: String,\n        forceEventDuration: Boolean,\n        dayHeaders: Boolean,\n        dayHeaderFormat: createFormatter,\n        dayHeaderClassNames: identity,\n        dayHeaderContent: identity,\n        dayHeaderDidMount: identity,\n        dayHeaderWillUnmount: identity,\n        dayCellClassNames: identity,\n        dayCellContent: identity,\n        dayCellDidMount: identity,\n        dayCellWillUnmount: identity,\n        initialView: String,\n        aspectRatio: Number,\n        weekends: Boolean,\n        weekNumberCalculation: identity,\n        weekNumbers: Boolean,\n        weekNumberClassNames: identity,\n        weekNumberContent: identity,\n        weekNumberDidMount: identity,\n        weekNumberWillUnmount: identity,\n        editable: Boolean,\n        viewClassNames: identity,\n        viewDidMount: identity,\n        viewWillUnmount: identity,\n        nowIndicator: Boolean,\n        nowIndicatorClassNames: identity,\n        nowIndicatorContent: identity,\n        nowIndicatorDidMount: identity,\n        nowIndicatorWillUnmount: identity,\n        showNonCurrentDates: Boolean,\n        lazyFetching: Boolean,\n        startParam: String,\n        endParam: String,\n        timeZoneParam: String,\n        timeZone: String,\n        locales: identity,\n        locale: identity,\n        themeSystem: String,\n        dragRevertDuration: Number,\n        dragScroll: Boolean,\n        allDayMaintainDuration: Boolean,\n        unselectAuto: Boolean,\n        dropAccept: identity,\n        eventOrder: parseFieldSpecs,\n        handleWindowResize: Boolean,\n        windowResizeDelay: Number,\n        longPressDelay: Number,\n        eventDragMinDistance: Number,\n        expandRows: Boolean,\n        height: identity,\n        contentHeight: identity,\n        direction: String,\n        weekNumberFormat: createFormatter,\n        eventResizableFromStart: Boolean,\n        displayEventTime: Boolean,\n        displayEventEnd: Boolean,\n        weekText: String,\n        progressiveEventRendering: Boolean,\n        businessHours: identity,\n        initialDate: identity,\n        now: identity,\n        eventDataTransform: identity,\n        stickyHeaderDates: identity,\n        stickyFooterScrollbar: identity,\n        viewHeight: identity,\n        defaultAllDay: Boolean,\n        eventSourceFailure: identity,\n        eventSourceSuccess: identity,\n        eventDisplay: String,\n        eventStartEditable: Boolean,\n        eventDurationEditable: Boolean,\n        eventOverlap: identity,\n        eventConstraint: identity,\n        eventAllow: identity,\n        eventBackgroundColor: String,\n        eventBorderColor: String,\n        eventTextColor: String,\n        eventColor: String,\n        eventClassNames: identity,\n        eventContent: identity,\n        eventDidMount: identity,\n        eventWillUnmount: identity,\n        selectConstraint: identity,\n        selectOverlap: identity,\n        selectAllow: identity,\n        droppable: Boolean,\n        unselectCancel: String,\n        slotLabelFormat: identity,\n        slotLaneClassNames: identity,\n        slotLaneContent: identity,\n        slotLaneDidMount: identity,\n        slotLaneWillUnmount: identity,\n        slotLabelClassNames: identity,\n        slotLabelContent: identity,\n        slotLabelDidMount: identity,\n        slotLabelWillUnmount: identity,\n        dayMaxEvents: identity,\n        dayMaxEventRows: identity,\n        dayMinWidth: Number,\n        slotLabelInterval: createDuration,\n        allDayText: String,\n        allDayClassNames: identity,\n        allDayContent: identity,\n        allDayDidMount: identity,\n        allDayWillUnmount: identity,\n        slotMinWidth: Number,\n        navLinks: Boolean,\n        eventTimeFormat: createFormatter,\n        rerenderDelay: Number,\n        moreLinkText: identity,\n        selectMinDistance: Number,\n        selectable: Boolean,\n        selectLongPressDelay: Number,\n        eventLongPressDelay: Number,\n        selectMirror: Boolean,\n        eventMinHeight: Number,\n        slotEventOverlap: Boolean,\n        plugins: identity,\n        firstDay: Number,\n        dayCount: Number,\n        dateAlignment: String,\n        dateIncrement: createDuration,\n        hiddenDays: identity,\n        monthMode: Boolean,\n        fixedWeekCount: Boolean,\n        validRange: identity,\n        visibleRange: identity,\n        titleFormat: identity,\n        // only used by list-view, but languages define the value, so we need it in base options\n        noEventsText: String,\n    };\n    // do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n    // raw values.\n    var BASE_OPTION_DEFAULTS = {\n        eventDisplay: 'auto',\n        defaultRangeSeparator: ' - ',\n        titleRangeSeparator: ' \\u2013 ',\n        defaultTimedEventDuration: '01:00:00',\n        defaultAllDayEventDuration: { day: 1 },\n        forceEventDuration: false,\n        nextDayThreshold: '00:00:00',\n        dayHeaders: true,\n        initialView: '',\n        aspectRatio: 1.35,\n        headerToolbar: {\n            start: 'title',\n            center: '',\n            end: 'today prev,next',\n        },\n        weekends: true,\n        weekNumbers: false,\n        weekNumberCalculation: 'local',\n        editable: false,\n        nowIndicator: false,\n        scrollTime: '06:00:00',\n        slotMinTime: '00:00:00',\n        slotMaxTime: '24:00:00',\n        showNonCurrentDates: true,\n        lazyFetching: true,\n        startParam: 'start',\n        endParam: 'end',\n        timeZoneParam: 'timeZone',\n        timeZone: 'local',\n        locales: [],\n        locale: '',\n        themeSystem: 'standard',\n        dragRevertDuration: 500,\n        dragScroll: true,\n        allDayMaintainDuration: false,\n        unselectAuto: true,\n        dropAccept: '*',\n        eventOrder: 'start,-duration,allDay,title',\n        dayPopoverFormat: { month: 'long', day: 'numeric', year: 'numeric' },\n        handleWindowResize: true,\n        windowResizeDelay: 100,\n        longPressDelay: 1000,\n        eventDragMinDistance: 5,\n        expandRows: false,\n        navLinks: false,\n        selectable: false,\n    };\n    // calendar listeners\n    // ------------------\n    var CALENDAR_LISTENER_REFINERS = {\n        datesSet: identity,\n        eventsSet: identity,\n        eventAdd: identity,\n        eventChange: identity,\n        eventRemove: identity,\n        windowResize: identity,\n        eventClick: identity,\n        eventMouseEnter: identity,\n        eventMouseLeave: identity,\n        select: identity,\n        unselect: identity,\n        loading: identity,\n        // internal\n        _unmount: identity,\n        _beforeprint: identity,\n        _afterprint: identity,\n        _noEventDrop: identity,\n        _noEventResize: identity,\n        _resize: identity,\n        _scrollRequest: identity,\n    };\n    // calendar-specific options\n    // -------------------------\n    var CALENDAR_OPTION_REFINERS = {\n        buttonText: identity,\n        views: identity,\n        plugins: identity,\n        initialEvents: identity,\n        events: identity,\n        eventSources: identity,\n    };\n    var COMPLEX_OPTION_COMPARATORS = {\n        headerToolbar: isBoolComplexEqual,\n        footerToolbar: isBoolComplexEqual,\n        buttonText: isBoolComplexEqual,\n        buttonIcons: isBoolComplexEqual,\n    };\n    function isBoolComplexEqual(a, b) {\n        if (typeof a === 'object' && typeof b === 'object' && a && b) { // both non-null objects\n            return isPropsEqual(a, b);\n        }\n        return a === b;\n    }\n    // view-specific options\n    // ---------------------\n    var VIEW_OPTION_REFINERS = {\n        type: String,\n        component: identity,\n        buttonText: String,\n        buttonTextKey: String,\n        dateProfileGeneratorClass: identity,\n        usesMinMaxTime: Boolean,\n        classNames: identity,\n        content: identity,\n        didMount: identity,\n        willUnmount: identity,\n    };\n    // util funcs\n    // ----------------------------------------------------------------------------------------------------\n    function mergeRawOptions(optionSets) {\n        return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n    }\n    function refineProps(input, refiners) {\n        var refined = {};\n        var extra = {};\n        for (var propName in refiners) {\n            if (propName in input) {\n                refined[propName] = refiners[propName](input[propName]);\n            }\n        }\n        for (var propName in input) {\n            if (!(propName in refiners)) {\n                extra[propName] = input[propName];\n            }\n        }\n        return { refined: refined, extra: extra };\n    }\n    function identity(raw) {\n        return raw;\n    }\n\n    function parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n        var eventStore = createEmptyEventStore();\n        var eventRefiners = buildEventRefiners(context);\n        for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n            var rawEvent = rawEvents_1[_i];\n            var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n            if (tuple) {\n                eventTupleToStore(tuple, eventStore);\n            }\n        }\n        return eventStore;\n    }\n    function eventTupleToStore(tuple, eventStore) {\n        if (eventStore === void 0) { eventStore = createEmptyEventStore(); }\n        eventStore.defs[tuple.def.defId] = tuple.def;\n        if (tuple.instance) {\n            eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n        }\n        return eventStore;\n    }\n    // retrieves events that have the same groupId as the instance specified by `instanceId`\n    // or they are the same as the instance.\n    // why might instanceId not be in the store? an event from another calendar?\n    function getRelevantEvents(eventStore, instanceId) {\n        var instance = eventStore.instances[instanceId];\n        if (instance) {\n            var def_1 = eventStore.defs[instance.defId];\n            // get events/instances with same group\n            var newStore = filterEventStoreDefs(eventStore, function (lookDef) { return isEventDefsGrouped(def_1, lookDef); });\n            // add the original\n            // TODO: wish we could use eventTupleToStore or something like it\n            newStore.defs[def_1.defId] = def_1;\n            newStore.instances[instance.instanceId] = instance;\n            return newStore;\n        }\n        return createEmptyEventStore();\n    }\n    function isEventDefsGrouped(def0, def1) {\n        return Boolean(def0.groupId && def0.groupId === def1.groupId);\n    }\n    function createEmptyEventStore() {\n        return { defs: {}, instances: {} };\n    }\n    function mergeEventStores(store0, store1) {\n        return {\n            defs: __assign(__assign({}, store0.defs), store1.defs),\n            instances: __assign(__assign({}, store0.instances), store1.instances),\n        };\n    }\n    function filterEventStoreDefs(eventStore, filterFunc) {\n        var defs = filterHash(eventStore.defs, filterFunc);\n        var instances = filterHash(eventStore.instances, function (instance) { return (defs[instance.defId] // still exists?\n        ); });\n        return { defs: defs, instances: instances };\n    }\n    function excludeSubEventStore(master, sub) {\n        var defs = master.defs, instances = master.instances;\n        var filteredDefs = {};\n        var filteredInstances = {};\n        for (var defId in defs) {\n            if (!sub.defs[defId]) { // not explicitly excluded\n                filteredDefs[defId] = defs[defId];\n            }\n        }\n        for (var instanceId in instances) {\n            if (!sub.instances[instanceId] && // not explicitly excluded\n                filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n            ) {\n                filteredInstances[instanceId] = instances[instanceId];\n            }\n        }\n        return {\n            defs: filteredDefs,\n            instances: filteredInstances,\n        };\n    }\n\n    function normalizeConstraint(input, context) {\n        if (Array.isArray(input)) {\n            return parseEvents(input, null, context, true); // allowOpenRange=true\n        }\n        if (typeof input === 'object' && input) { // non-null object\n            return parseEvents([input], null, context, true); // allowOpenRange=true\n        }\n        if (input != null) {\n            return String(input);\n        }\n        return null;\n    }\n\n    function parseClassNames(raw) {\n        if (Array.isArray(raw)) {\n            return raw;\n        }\n        if (typeof raw === 'string') {\n            return raw.split(/\\s+/);\n        }\n        return [];\n    }\n\n    // TODO: better called \"EventSettings\" or \"EventConfig\"\n    // TODO: move this file into structs\n    // TODO: separate constraint/overlap/allow, because selection uses only that, not other props\n    var EVENT_UI_REFINERS = {\n        display: String,\n        editable: Boolean,\n        startEditable: Boolean,\n        durationEditable: Boolean,\n        constraint: identity,\n        overlap: identity,\n        allow: identity,\n        className: parseClassNames,\n        classNames: parseClassNames,\n        color: String,\n        backgroundColor: String,\n        borderColor: String,\n        textColor: String,\n    };\n    var EMPTY_EVENT_UI = {\n        display: null,\n        startEditable: null,\n        durationEditable: null,\n        constraints: [],\n        overlap: null,\n        allows: [],\n        backgroundColor: '',\n        borderColor: '',\n        textColor: '',\n        classNames: [],\n    };\n    function createEventUi(refined, context) {\n        var constraint = normalizeConstraint(refined.constraint, context);\n        return {\n            display: refined.display || null,\n            startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n            durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n            constraints: constraint != null ? [constraint] : [],\n            overlap: refined.overlap != null ? refined.overlap : null,\n            allows: refined.allow != null ? [refined.allow] : [],\n            backgroundColor: refined.backgroundColor || refined.color || '',\n            borderColor: refined.borderColor || refined.color || '',\n            textColor: refined.textColor || '',\n            classNames: (refined.className || []).concat(refined.classNames || []),\n        };\n    }\n    // TODO: prevent against problems with <2 args!\n    function combineEventUis(uis) {\n        return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n    }\n    function combineTwoEventUis(item0, item1) {\n        return {\n            display: item1.display != null ? item1.display : item0.display,\n            startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n            durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n            constraints: item0.constraints.concat(item1.constraints),\n            overlap: typeof item1.overlap === 'boolean' ? item1.overlap : item0.overlap,\n            allows: item0.allows.concat(item1.allows),\n            backgroundColor: item1.backgroundColor || item0.backgroundColor,\n            borderColor: item1.borderColor || item0.borderColor,\n            textColor: item1.textColor || item0.textColor,\n            classNames: item0.classNames.concat(item1.classNames),\n        };\n    }\n\n    var EVENT_NON_DATE_REFINERS = {\n        id: String,\n        groupId: String,\n        title: String,\n        url: String,\n    };\n    var EVENT_DATE_REFINERS = {\n        start: identity,\n        end: identity,\n        date: identity,\n        allDay: Boolean,\n    };\n    var EVENT_REFINERS = __assign(__assign(__assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), { extendedProps: identity });\n    function parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n        if (refiners === void 0) { refiners = buildEventRefiners(context); }\n        var _a = refineEventDef(raw, context, refiners), refined = _a.refined, extra = _a.extra;\n        var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n        var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n        if (recurringRes) {\n            var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', recurringRes.allDay, Boolean(recurringRes.duration), context);\n            def.recurringDef = {\n                typeId: recurringRes.typeId,\n                typeData: recurringRes.typeData,\n                duration: recurringRes.duration,\n            };\n            return { def: def, instance: null };\n        }\n        var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n        if (singleRes) {\n            var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : '', singleRes.allDay, singleRes.hasEnd, context);\n            var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n            return { def: def, instance: instance };\n        }\n        return null;\n    }\n    function refineEventDef(raw, context, refiners) {\n        if (refiners === void 0) { refiners = buildEventRefiners(context); }\n        return refineProps(raw, refiners);\n    }\n    function buildEventRefiners(context) {\n        return __assign(__assign(__assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n    }\n    /*\n    Will NOT populate extendedProps with the leftover properties.\n    Will NOT populate date-related props.\n    */\n    function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n        var def = {\n            title: refined.title || '',\n            groupId: refined.groupId || '',\n            publicId: refined.id || '',\n            url: refined.url || '',\n            recurringDef: null,\n            defId: guid(),\n            sourceId: sourceId,\n            allDay: allDay,\n            hasEnd: hasEnd,\n            ui: createEventUi(refined, context),\n            extendedProps: __assign(__assign({}, (refined.extendedProps || {})), extra),\n        };\n        for (var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++) {\n            var memberAdder = _a[_i];\n            __assign(def, memberAdder(refined));\n        }\n        // help out EventApi from having user modify props\n        Object.freeze(def.ui.classNames);\n        Object.freeze(def.extendedProps);\n        return def;\n    }\n    function parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n        var allDay = refined.allDay;\n        var startMeta;\n        var startMarker = null;\n        var hasEnd = false;\n        var endMeta;\n        var endMarker = null;\n        var startInput = refined.start != null ? refined.start : refined.date;\n        startMeta = context.dateEnv.createMarkerMeta(startInput);\n        if (startMeta) {\n            startMarker = startMeta.marker;\n        }\n        else if (!allowOpenRange) {\n            return null;\n        }\n        if (refined.end != null) {\n            endMeta = context.dateEnv.createMarkerMeta(refined.end);\n        }\n        if (allDay == null) {\n            if (defaultAllDay != null) {\n                allDay = defaultAllDay;\n            }\n            else {\n                // fall back to the date props LAST\n                allDay = (!startMeta || startMeta.isTimeUnspecified) &&\n                    (!endMeta || endMeta.isTimeUnspecified);\n            }\n        }\n        if (allDay && startMarker) {\n            startMarker = startOfDay(startMarker);\n        }\n        if (endMeta) {\n            endMarker = endMeta.marker;\n            if (allDay) {\n                endMarker = startOfDay(endMarker);\n            }\n            if (startMarker && endMarker <= startMarker) {\n                endMarker = null;\n            }\n        }\n        if (endMarker) {\n            hasEnd = true;\n        }\n        else if (!allowOpenRange) {\n            hasEnd = context.options.forceEventDuration || false;\n            endMarker = context.dateEnv.add(startMarker, allDay ?\n                context.options.defaultAllDayEventDuration :\n                context.options.defaultTimedEventDuration);\n        }\n        return {\n            allDay: allDay,\n            hasEnd: hasEnd,\n            range: { start: startMarker, end: endMarker },\n            forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n            forcedEndTzo: endMeta ? endMeta.forcedTzo : null,\n        };\n    }\n    function computeIsDefaultAllDay(eventSource, context) {\n        var res = null;\n        if (eventSource) {\n            res = eventSource.defaultAllDay;\n        }\n        if (res == null) {\n            res = context.options.defaultAllDay;\n        }\n        return res;\n    }\n\n    /* Date stuff that doesn't belong in datelib core\n    ----------------------------------------------------------------------------------------------------------------------*/\n    // given a timed range, computes an all-day range that has the same exact duration,\n    // but whose start time is aligned with the start of the day.\n    function computeAlignedDayRange(timedRange) {\n        var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n        var start = startOfDay(timedRange.start);\n        var end = addDays(start, dayCnt);\n        return { start: start, end: end };\n    }\n    // given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n    // TODO: give nextDayThreshold a default arg\n    function computeVisibleDayRange(timedRange, nextDayThreshold) {\n        if (nextDayThreshold === void 0) { nextDayThreshold = createDuration(0); }\n        var startDay = null;\n        var endDay = null;\n        if (timedRange.end) {\n            endDay = startOfDay(timedRange.end);\n            var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n            // If the end time is actually inclusively part of the next day and is equal to or\n            // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n            // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n            if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n                endDay = addDays(endDay, 1);\n            }\n        }\n        if (timedRange.start) {\n            startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n            // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n            if (endDay && endDay <= startDay) {\n                endDay = addDays(startDay, 1);\n            }\n        }\n        return { start: startDay, end: endDay };\n    }\n    // spans from one day into another?\n    function isMultiDayRange(range) {\n        var visibleRange = computeVisibleDayRange(range);\n        return diffDays(visibleRange.start, visibleRange.end) > 1;\n    }\n    function diffDates(date0, date1, dateEnv, largeUnit) {\n        if (largeUnit === 'year') {\n            return createDuration(dateEnv.diffWholeYears(date0, date1), 'year');\n        }\n        if (largeUnit === 'month') {\n            return createDuration(dateEnv.diffWholeMonths(date0, date1), 'month');\n        }\n        return diffDayAndTime(date0, date1); // returns a duration\n    }\n\n    function parseRange(input, dateEnv) {\n        var start = null;\n        var end = null;\n        if (input.start) {\n            start = dateEnv.createMarker(input.start);\n        }\n        if (input.end) {\n            end = dateEnv.createMarker(input.end);\n        }\n        if (!start && !end) {\n            return null;\n        }\n        if (start && end && end < start) {\n            return null;\n        }\n        return { start: start, end: end };\n    }\n    // SIDE-EFFECT: will mutate ranges.\n    // Will return a new array result.\n    function invertRanges(ranges, constraintRange) {\n        var invertedRanges = [];\n        var start = constraintRange.start; // the end of the previous range. the start of the new range\n        var i;\n        var dateRange;\n        // ranges need to be in order. required for our date-walking algorithm\n        ranges.sort(compareRanges);\n        for (i = 0; i < ranges.length; i += 1) {\n            dateRange = ranges[i];\n            // add the span of time before the event (if there is any)\n            if (dateRange.start > start) { // compare millisecond time (skip any ambig logic)\n                invertedRanges.push({ start: start, end: dateRange.start });\n            }\n            if (dateRange.end > start) {\n                start = dateRange.end;\n            }\n        }\n        // add the span of time after the last event (if there is any)\n        if (start < constraintRange.end) { // compare millisecond time (skip any ambig logic)\n            invertedRanges.push({ start: start, end: constraintRange.end });\n        }\n        return invertedRanges;\n    }\n    function compareRanges(range0, range1) {\n        return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n    }\n    function intersectRanges(range0, range1) {\n        var start = range0.start, end = range0.end;\n        var newRange = null;\n        if (range1.start !== null) {\n            if (start === null) {\n                start = range1.start;\n            }\n            else {\n                start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n            }\n        }\n        if (range1.end != null) {\n            if (end === null) {\n                end = range1.end;\n            }\n            else {\n                end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n            }\n        }\n        if (start === null || end === null || start < end) {\n            newRange = { start: start, end: end };\n        }\n        return newRange;\n    }\n    function rangesEqual(range0, range1) {\n        return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) &&\n            (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n    }\n    function rangesIntersect(range0, range1) {\n        return (range0.end === null || range1.start === null || range0.end > range1.start) &&\n            (range0.start === null || range1.end === null || range0.start < range1.end);\n    }\n    function rangeContainsRange(outerRange, innerRange) {\n        return (outerRange.start === null || (innerRange.start !== null && innerRange.start >= outerRange.start)) &&\n            (outerRange.end === null || (innerRange.end !== null && innerRange.end <= outerRange.end));\n    }\n    function rangeContainsMarker(range, date) {\n        return (range.start === null || date >= range.start) &&\n            (range.end === null || date < range.end);\n    }\n    // If the given date is not within the given range, move it inside.\n    // (If it's past the end, make it one millisecond before the end).\n    function constrainMarkerToRange(date, range) {\n        if (range.start != null && date < range.start) {\n            return range.start;\n        }\n        if (range.end != null && date >= range.end) {\n            return new Date(range.end.valueOf() - 1);\n        }\n        return date;\n    }\n\n    /*\n    Specifying nextDayThreshold signals that all-day ranges should be sliced.\n    */\n    function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n        var inverseBgByGroupId = {};\n        var inverseBgByDefId = {};\n        var defByGroupId = {};\n        var bgRanges = [];\n        var fgRanges = [];\n        var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n        for (var defId in eventStore.defs) {\n            var def = eventStore.defs[defId];\n            var ui = eventUis[def.defId];\n            if (ui.display === 'inverse-background') {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId] = [];\n                    if (!defByGroupId[def.groupId]) {\n                        defByGroupId[def.groupId] = def;\n                    }\n                }\n                else {\n                    inverseBgByDefId[defId] = [];\n                }\n            }\n        }\n        for (var instanceId in eventStore.instances) {\n            var instance = eventStore.instances[instanceId];\n            var def = eventStore.defs[instance.defId];\n            var ui = eventUis[def.defId];\n            var origRange = instance.range;\n            var normalRange = (!def.allDay && nextDayThreshold) ?\n                computeVisibleDayRange(origRange, nextDayThreshold) :\n                origRange;\n            var slicedRange = intersectRanges(normalRange, framingRange);\n            if (slicedRange) {\n                if (ui.display === 'inverse-background') {\n                    if (def.groupId) {\n                        inverseBgByGroupId[def.groupId].push(slicedRange);\n                    }\n                    else {\n                        inverseBgByDefId[instance.defId].push(slicedRange);\n                    }\n                }\n                else if (ui.display !== 'none') {\n                    (ui.display === 'background' ? bgRanges : fgRanges).push({\n                        def: def,\n                        ui: ui,\n                        instance: instance,\n                        range: slicedRange,\n                        isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                        isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf(),\n                    });\n                }\n            }\n        }\n        for (var groupId in inverseBgByGroupId) { // BY GROUP\n            var ranges = inverseBgByGroupId[groupId];\n            var invertedRanges = invertRanges(ranges, framingRange);\n            for (var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++) {\n                var invertedRange = invertedRanges_1[_i];\n                var def = defByGroupId[groupId];\n                var ui = eventUis[def.defId];\n                bgRanges.push({\n                    def: def,\n                    ui: ui,\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false,\n                });\n            }\n        }\n        for (var defId in inverseBgByDefId) {\n            var ranges = inverseBgByDefId[defId];\n            var invertedRanges = invertRanges(ranges, framingRange);\n            for (var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++) {\n                var invertedRange = invertedRanges_2[_a];\n                bgRanges.push({\n                    def: eventStore.defs[defId],\n                    ui: eventUis[defId],\n                    instance: null,\n                    range: invertedRange,\n                    isStart: false,\n                    isEnd: false,\n                });\n            }\n        }\n        return { bg: bgRanges, fg: fgRanges };\n    }\n    function hasBgRendering(def) {\n        return def.ui.display === 'background' || def.ui.display === 'inverse-background';\n    }\n    function setElSeg(el, seg) {\n        el.fcSeg = seg;\n    }\n    function getElSeg(el) {\n        return el.fcSeg ||\n            el.parentNode.fcSeg || // for the harness\n            null;\n    }\n    // event ui computation\n    function compileEventUis(eventDefs, eventUiBases) {\n        return mapHash(eventDefs, function (eventDef) { return compileEventUi(eventDef, eventUiBases); });\n    }\n    function compileEventUi(eventDef, eventUiBases) {\n        var uis = [];\n        if (eventUiBases['']) {\n            uis.push(eventUiBases['']);\n        }\n        if (eventUiBases[eventDef.defId]) {\n            uis.push(eventUiBases[eventDef.defId]);\n        }\n        uis.push(eventDef.ui);\n        return combineEventUis(uis);\n    }\n    function sortEventSegs(segs, eventOrderSpecs) {\n        var objs = segs.map(buildSegCompareObj);\n        objs.sort(function (obj0, obj1) { return compareByFieldSpecs(obj0, obj1, eventOrderSpecs); });\n        return objs.map(function (c) { return c._seg; });\n    }\n    // returns a object with all primitive props that can be compared\n    function buildSegCompareObj(seg) {\n        var eventRange = seg.eventRange;\n        var eventDef = eventRange.def;\n        var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n        var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n        var end = range.end ? range.end.valueOf() : 0; // \"\n        return __assign(__assign(__assign({}, eventDef.extendedProps), eventDef), { id: eventDef.publicId, start: start,\n            end: end, duration: end - start, allDay: Number(eventDef.allDay), _seg: seg });\n    }\n    function computeSegDraggable(seg, context) {\n        var pluginHooks = context.pluginHooks;\n        var transformers = pluginHooks.isDraggableTransformers;\n        var _a = seg.eventRange, def = _a.def, ui = _a.ui;\n        var val = ui.startEditable;\n        for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n            var transformer = transformers_1[_i];\n            val = transformer(val, def, ui, context);\n        }\n        return val;\n    }\n    function computeSegStartResizable(seg, context) {\n        return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n    }\n    function computeSegEndResizable(seg, context) {\n        return seg.isEnd && seg.eventRange.ui.durationEditable;\n    }\n    function buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, // defaults to true\n    defaultDisplayEventEnd, // defaults to true\n    startOverride, endOverride) {\n        var dateEnv = context.dateEnv, options = context.options;\n        var displayEventTime = options.displayEventTime, displayEventEnd = options.displayEventEnd;\n        var eventDef = seg.eventRange.def;\n        var eventInstance = seg.eventRange.instance;\n        if (displayEventTime == null) {\n            displayEventTime = defaultDisplayEventTime !== false;\n        }\n        if (displayEventEnd == null) {\n            displayEventEnd = defaultDisplayEventEnd !== false;\n        }\n        if (displayEventTime && !eventDef.allDay && (seg.isStart || seg.isEnd)) {\n            var segStart = startOverride || (seg.isStart ? eventInstance.range.start : (seg.start || seg.eventRange.range.start));\n            var segEnd = endOverride || (seg.isEnd ? eventInstance.range.end : (seg.end || seg.eventRange.range.end));\n            if (displayEventEnd && eventDef.hasEnd) {\n                return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                    forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                    forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo,\n                });\n            }\n            return dateEnv.format(segStart, timeFormat, {\n                forcedTzo: startOverride ? null : eventInstance.forcedStartTzo,\n            });\n        }\n        return '';\n    }\n    function getSegMeta(seg, todayRange, nowDate) {\n        var segRange = seg.eventRange.range;\n        return {\n            isPast: segRange.end < (nowDate || todayRange.start),\n            isFuture: segRange.start >= (nowDate || todayRange.end),\n            isToday: todayRange && rangeContainsMarker(todayRange, segRange.start),\n        };\n    }\n    function getEventClassNames(props) {\n        var classNames = ['fc-event'];\n        if (props.isMirror) {\n            classNames.push('fc-event-mirror');\n        }\n        if (props.isDraggable) {\n            classNames.push('fc-event-draggable');\n        }\n        if (props.isStartResizable || props.isEndResizable) {\n            classNames.push('fc-event-resizable');\n        }\n        if (props.isDragging) {\n            classNames.push('fc-event-dragging');\n        }\n        if (props.isResizing) {\n            classNames.push('fc-event-resizing');\n        }\n        if (props.isSelected) {\n            classNames.push('fc-event-selected');\n        }\n        if (props.isStart) {\n            classNames.push('fc-event-start');\n        }\n        if (props.isEnd) {\n            classNames.push('fc-event-end');\n        }\n        if (props.isPast) {\n            classNames.push('fc-event-past');\n        }\n        if (props.isToday) {\n            classNames.push('fc-event-today');\n        }\n        if (props.isFuture) {\n            classNames.push('fc-event-future');\n        }\n        return classNames;\n    }\n    function buildEventRangeKey(eventRange) {\n        return eventRange.instance\n            ? eventRange.instance.instanceId\n            : eventRange.def.defId + \":\" + eventRange.range.start.toISOString();\n        // inverse-background events don't have specific instances. TODO: better solution\n    }\n\n    var STANDARD_PROPS = {\n        start: identity,\n        end: identity,\n        allDay: Boolean,\n    };\n    function parseDateSpan(raw, dateEnv, defaultDuration) {\n        var span = parseOpenDateSpan(raw, dateEnv);\n        var range = span.range;\n        if (!range.start) {\n            return null;\n        }\n        if (!range.end) {\n            if (defaultDuration == null) {\n                return null;\n            }\n            range.end = dateEnv.add(range.start, defaultDuration);\n        }\n        return span;\n    }\n    /*\n    TODO: somehow combine with parseRange?\n    Will return null if the start/end props were present but parsed invalidly.\n    */\n    function parseOpenDateSpan(raw, dateEnv) {\n        var _a = refineProps(raw, STANDARD_PROPS), standardProps = _a.refined, extra = _a.extra;\n        var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n        var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n        var allDay = standardProps.allDay;\n        if (allDay == null) {\n            allDay = (startMeta && startMeta.isTimeUnspecified) &&\n                (!endMeta || endMeta.isTimeUnspecified);\n        }\n        return __assign({ range: {\n                start: startMeta ? startMeta.marker : null,\n                end: endMeta ? endMeta.marker : null,\n            }, allDay: allDay }, extra);\n    }\n    function isDateSpansEqual(span0, span1) {\n        return rangesEqual(span0.range, span1.range) &&\n            span0.allDay === span1.allDay &&\n            isSpanPropsEqual(span0, span1);\n    }\n    // the NON-DATE-RELATED props\n    function isSpanPropsEqual(span0, span1) {\n        for (var propName in span1) {\n            if (propName !== 'range' && propName !== 'allDay') {\n                if (span0[propName] !== span1[propName]) {\n                    return false;\n                }\n            }\n        }\n        // are there any props that span0 has that span1 DOESN'T have?\n        // both have range/allDay, so no need to special-case.\n        for (var propName in span0) {\n            if (!(propName in span1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function buildDateSpanApi(span, dateEnv) {\n        return __assign(__assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), { allDay: span.allDay });\n    }\n    function buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n        return __assign(__assign({}, buildRangeApi(range, dateEnv, omitTime)), { timeZone: dateEnv.timeZone });\n    }\n    function buildRangeApi(range, dateEnv, omitTime) {\n        return {\n            start: dateEnv.toDate(range.start),\n            end: dateEnv.toDate(range.end),\n            startStr: dateEnv.formatIso(range.start, { omitTime: omitTime }),\n            endStr: dateEnv.formatIso(range.end, { omitTime: omitTime }),\n        };\n    }\n    function fabricateEventRange(dateSpan, eventUiBases, context) {\n        var res = refineEventDef({ editable: false }, context);\n        var def = parseEventDef(res.refined, res.extra, '', // sourceId\n        dateSpan.allDay, true, // hasEnd\n        context);\n        return {\n            def: def,\n            ui: compileEventUi(def, eventUiBases),\n            instance: createEventInstance(def.defId, dateSpan.range),\n            range: dateSpan.range,\n            isStart: true,\n            isEnd: true,\n        };\n    }\n\n    function triggerDateSelect(selection, pev, context) {\n        context.emitter.trigger('select', __assign(__assign({}, buildDateSpanApiWithContext(selection, context)), { jsEvent: pev ? pev.origEvent : null, view: context.viewApi || context.calendarApi.view }));\n    }\n    function triggerDateUnselect(pev, context) {\n        context.emitter.trigger('unselect', {\n            jsEvent: pev ? pev.origEvent : null,\n            view: context.viewApi || context.calendarApi.view,\n        });\n    }\n    function buildDateSpanApiWithContext(dateSpan, context) {\n        var props = {};\n        for (var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++) {\n            var transform = _a[_i];\n            __assign(props, transform(dateSpan, context));\n        }\n        __assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n        return props;\n    }\n    // Given an event's allDay status and start date, return what its fallback end date should be.\n    // TODO: rename to computeDefaultEventEnd\n    function getDefaultEventEnd(allDay, marker, context) {\n        var dateEnv = context.dateEnv, options = context.options;\n        var end = marker;\n        if (allDay) {\n            end = startOfDay(end);\n            end = dateEnv.add(end, options.defaultAllDayEventDuration);\n        }\n        else {\n            end = dateEnv.add(end, options.defaultTimedEventDuration);\n        }\n        return end;\n    }\n\n    // applies the mutation to ALL defs/instances within the event store\n    function applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n        var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n        var dest = createEmptyEventStore();\n        for (var defId in eventStore.defs) {\n            var def = eventStore.defs[defId];\n            dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n        }\n        for (var instanceId in eventStore.instances) {\n            var instance = eventStore.instances[instanceId];\n            var def = dest.defs[instance.defId]; // important to grab the newly modified def\n            dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n        }\n        return dest;\n    }\n    function applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n        var standardProps = mutation.standardProps || {};\n        // if hasEnd has not been specified, guess a good value based on deltas.\n        // if duration will change, there's no way the default duration will persist,\n        // and thus, we need to mark the event as having a real end\n        if (standardProps.hasEnd == null &&\n            eventConfig.durationEditable &&\n            (mutation.startDelta || mutation.endDelta)) {\n            standardProps.hasEnd = true; // TODO: is this mutation okay?\n        }\n        var copy = __assign(__assign(__assign({}, eventDef), standardProps), { ui: __assign(__assign({}, eventDef.ui), standardProps.ui) });\n        if (mutation.extendedProps) {\n            copy.extendedProps = __assign(__assign({}, copy.extendedProps), mutation.extendedProps);\n        }\n        for (var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++) {\n            var applier = _a[_i];\n            applier(copy, mutation, context);\n        }\n        if (!copy.hasEnd && context.options.forceEventDuration) {\n            copy.hasEnd = true;\n        }\n        return copy;\n    }\n    function applyMutationToEventInstance(eventInstance, eventDef, // must first be modified by applyMutationToEventDef\n    eventConfig, mutation, context) {\n        var dateEnv = context.dateEnv;\n        var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n        var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n        var copy = __assign({}, eventInstance);\n        if (forceAllDay) {\n            copy.range = computeAlignedDayRange(copy.range);\n        }\n        if (mutation.datesDelta && eventConfig.startEditable) {\n            copy.range = {\n                start: dateEnv.add(copy.range.start, mutation.datesDelta),\n                end: dateEnv.add(copy.range.end, mutation.datesDelta),\n            };\n        }\n        if (mutation.startDelta && eventConfig.durationEditable) {\n            copy.range = {\n                start: dateEnv.add(copy.range.start, mutation.startDelta),\n                end: copy.range.end,\n            };\n        }\n        if (mutation.endDelta && eventConfig.durationEditable) {\n            copy.range = {\n                start: copy.range.start,\n                end: dateEnv.add(copy.range.end, mutation.endDelta),\n            };\n        }\n        if (clearEnd) {\n            copy.range = {\n                start: copy.range.start,\n                end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context),\n            };\n        }\n        // in case event was all-day but the supplied deltas were not\n        // better util for this?\n        if (eventDef.allDay) {\n            copy.range = {\n                start: startOfDay(copy.range.start),\n                end: startOfDay(copy.range.end),\n            };\n        }\n        // handle invalid durations\n        if (copy.range.end < copy.range.start) {\n            copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n        }\n        return copy;\n    }\n\n    // no public types yet. when there are, export from:\n    // import {} from './api-type-deps'\n    var ViewApi = /** @class */ (function () {\n        function ViewApi(type, getCurrentData, dateEnv) {\n            this.type = type;\n            this.getCurrentData = getCurrentData;\n            this.dateEnv = dateEnv;\n        }\n        Object.defineProperty(ViewApi.prototype, \"calendar\", {\n            get: function () {\n                return this.getCurrentData().calendarApi;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ViewApi.prototype, \"title\", {\n            get: function () {\n                return this.getCurrentData().viewTitle;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n            get: function () {\n                return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n            get: function () {\n                return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n            get: function () {\n                return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n            get: function () {\n                return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n            },\n            enumerable: false,\n            configurable: true\n        });\n        ViewApi.prototype.getOption = function (name) {\n            return this.getCurrentData().options[name]; // are the view-specific options\n        };\n        return ViewApi;\n    }());\n\n    var EVENT_SOURCE_REFINERS = {\n        id: String,\n        defaultAllDay: Boolean,\n        url: String,\n        events: identity,\n        eventDataTransform: identity,\n        // for any network-related sources\n        success: identity,\n        failure: identity,\n    };\n    function parseEventSource(raw, context, refiners) {\n        if (refiners === void 0) { refiners = buildEventSourceRefiners(context); }\n        var rawObj;\n        if (typeof raw === 'string') {\n            rawObj = { url: raw };\n        }\n        else if (typeof raw === 'function' || Array.isArray(raw)) {\n            rawObj = { events: raw };\n        }\n        else if (typeof raw === 'object' && raw) { // not null\n            rawObj = raw;\n        }\n        if (rawObj) {\n            var _a = refineProps(rawObj, refiners), refined = _a.refined, extra = _a.extra;\n            var metaRes = buildEventSourceMeta(refined, context);\n            if (metaRes) {\n                return {\n                    _raw: raw,\n                    isFetching: false,\n                    latestFetchId: '',\n                    fetchRange: null,\n                    defaultAllDay: refined.defaultAllDay,\n                    eventDataTransform: refined.eventDataTransform,\n                    success: refined.success,\n                    failure: refined.failure,\n                    publicId: refined.id || '',\n                    sourceId: guid(),\n                    sourceDefId: metaRes.sourceDefId,\n                    meta: metaRes.meta,\n                    ui: createEventUi(refined, context),\n                    extendedProps: extra,\n                };\n            }\n        }\n        return null;\n    }\n    function buildEventSourceRefiners(context) {\n        return __assign(__assign(__assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n    }\n    function buildEventSourceMeta(raw, context) {\n        var defs = context.pluginHooks.eventSourceDefs;\n        for (var i = defs.length - 1; i >= 0; i -= 1) { // later-added plugins take precedence\n            var def = defs[i];\n            var meta = def.parseMeta(raw);\n            if (meta) {\n                return { sourceDefId: i, meta: meta };\n            }\n        }\n        return null;\n    }\n\n    function reduceCurrentDate(currentDate, action) {\n        switch (action.type) {\n            case 'CHANGE_DATE':\n                return action.dateMarker;\n            default:\n                return currentDate;\n        }\n    }\n    function getInitialDate(options, dateEnv) {\n        var initialDateInput = options.initialDate;\n        // compute the initial ambig-timezone date\n        if (initialDateInput != null) {\n            return dateEnv.createMarker(initialDateInput);\n        }\n        return getNow(options.now, dateEnv); // getNow already returns unzoned\n    }\n    function getNow(nowInput, dateEnv) {\n        if (typeof nowInput === 'function') {\n            nowInput = nowInput();\n        }\n        if (nowInput == null) {\n            return dateEnv.createNowMarker();\n        }\n        return dateEnv.createMarker(nowInput);\n    }\n\n    var CalendarApi = /** @class */ (function () {\n        function CalendarApi() {\n        }\n        CalendarApi.prototype.getCurrentData = function () {\n            return this.currentDataManager.getCurrentData();\n        };\n        CalendarApi.prototype.dispatch = function (action) {\n            return this.currentDataManager.dispatch(action);\n        };\n        Object.defineProperty(CalendarApi.prototype, \"view\", {\n            get: function () { return this.getCurrentData().viewApi; } // for public API\n            ,\n            enumerable: false,\n            configurable: true\n        });\n        CalendarApi.prototype.batchRendering = function (callback) {\n            callback();\n        };\n        CalendarApi.prototype.updateSize = function () {\n            this.trigger('_resize', true);\n        };\n        // Options\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.setOption = function (name, val) {\n            this.dispatch({\n                type: 'SET_OPTION',\n                optionName: name,\n                rawOptionValue: val,\n            });\n        };\n        CalendarApi.prototype.getOption = function (name) {\n            return this.currentDataManager.currentCalendarOptionsInput[name];\n        };\n        CalendarApi.prototype.getAvailableLocaleCodes = function () {\n            return Object.keys(this.getCurrentData().availableRawLocales);\n        };\n        // Trigger\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.on = function (handlerName, handler) {\n            var currentDataManager = this.currentDataManager;\n            if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n                currentDataManager.emitter.on(handlerName, handler);\n            }\n            else {\n                console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n            }\n        };\n        CalendarApi.prototype.off = function (handlerName, handler) {\n            this.currentDataManager.emitter.off(handlerName, handler);\n        };\n        // not meant for public use\n        CalendarApi.prototype.trigger = function (handlerName) {\n            var _a;\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            (_a = this.currentDataManager.emitter).trigger.apply(_a, __spreadArrays([handlerName], args));\n        };\n        // View\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.changeView = function (viewType, dateOrRange) {\n            var _this = this;\n            this.batchRendering(function () {\n                _this.unselect();\n                if (dateOrRange) {\n                    if (dateOrRange.start && dateOrRange.end) { // a range\n                        _this.dispatch({\n                            type: 'CHANGE_VIEW_TYPE',\n                            viewType: viewType,\n                        });\n                        _this.dispatch({\n                            type: 'SET_OPTION',\n                            optionName: 'visibleRange',\n                            rawOptionValue: dateOrRange,\n                        });\n                    }\n                    else {\n                        var dateEnv = _this.getCurrentData().dateEnv;\n                        _this.dispatch({\n                            type: 'CHANGE_VIEW_TYPE',\n                            viewType: viewType,\n                            dateMarker: dateEnv.createMarker(dateOrRange),\n                        });\n                    }\n                }\n                else {\n                    _this.dispatch({\n                        type: 'CHANGE_VIEW_TYPE',\n                        viewType: viewType,\n                    });\n                }\n            });\n        };\n        // Forces navigation to a view for the given date.\n        // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n        // needs to change\n        CalendarApi.prototype.zoomTo = function (dateMarker, viewType) {\n            var state = this.getCurrentData();\n            var spec;\n            viewType = viewType || 'day'; // day is default zoom\n            spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n            this.unselect();\n            if (spec) {\n                this.dispatch({\n                    type: 'CHANGE_VIEW_TYPE',\n                    viewType: spec.type,\n                    dateMarker: dateMarker,\n                });\n            }\n            else {\n                this.dispatch({\n                    type: 'CHANGE_DATE',\n                    dateMarker: dateMarker,\n                });\n            }\n        };\n        // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n        // Preference is given to views that have corresponding buttons.\n        CalendarApi.prototype.getUnitViewSpec = function (unit) {\n            var _a = this.getCurrentData(), viewSpecs = _a.viewSpecs, toolbarConfig = _a.toolbarConfig;\n            var viewTypes = [].concat(toolbarConfig.viewsWithButtons);\n            var i;\n            var spec;\n            for (var viewType in viewSpecs) {\n                viewTypes.push(viewType);\n            }\n            for (i = 0; i < viewTypes.length; i += 1) {\n                spec = viewSpecs[viewTypes[i]];\n                if (spec) {\n                    if (spec.singleUnit === unit) {\n                        return spec;\n                    }\n                }\n            }\n            return null;\n        };\n        // Current Date\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.prev = function () {\n            this.unselect();\n            this.dispatch({ type: 'PREV' });\n        };\n        CalendarApi.prototype.next = function () {\n            this.unselect();\n            this.dispatch({ type: 'NEXT' });\n        };\n        CalendarApi.prototype.prevYear = function () {\n            var state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.addYears(state.currentDate, -1),\n            });\n        };\n        CalendarApi.prototype.nextYear = function () {\n            var state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.addYears(state.currentDate, 1),\n            });\n        };\n        CalendarApi.prototype.today = function () {\n            var state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: getNow(state.calendarOptions.now, state.dateEnv),\n            });\n        };\n        CalendarApi.prototype.gotoDate = function (zonedDateInput) {\n            var state = this.getCurrentData();\n            this.unselect();\n            this.dispatch({\n                type: 'CHANGE_DATE',\n                dateMarker: state.dateEnv.createMarker(zonedDateInput),\n            });\n        };\n        CalendarApi.prototype.incrementDate = function (deltaInput) {\n            var state = this.getCurrentData();\n            var delta = createDuration(deltaInput);\n            if (delta) { // else, warn about invalid input?\n                this.unselect();\n                this.dispatch({\n                    type: 'CHANGE_DATE',\n                    dateMarker: state.dateEnv.add(state.currentDate, delta),\n                });\n            }\n        };\n        // for external API\n        CalendarApi.prototype.getDate = function () {\n            var state = this.getCurrentData();\n            return state.dateEnv.toDate(state.currentDate);\n        };\n        // Date Formatting Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.formatDate = function (d, formatter) {\n            var dateEnv = this.getCurrentData().dateEnv;\n            return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n        };\n        // `settings` is for formatter AND isEndExclusive\n        CalendarApi.prototype.formatRange = function (d0, d1, settings) {\n            var dateEnv = this.getCurrentData().dateEnv;\n            return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n        };\n        CalendarApi.prototype.formatIso = function (d, omitTime) {\n            var dateEnv = this.getCurrentData().dateEnv;\n            return dateEnv.formatIso(dateEnv.createMarker(d), { omitTime: omitTime });\n        };\n        // Date Selection / Event Selection / DayClick\n        // -----------------------------------------------------------------------------------------------------------------\n        // this public method receives start/end dates in any format, with any timezone\n        // NOTE: args were changed from v3\n        CalendarApi.prototype.select = function (dateOrObj, endDate) {\n            var selectionInput;\n            if (endDate == null) {\n                if (dateOrObj.start != null) {\n                    selectionInput = dateOrObj;\n                }\n                else {\n                    selectionInput = {\n                        start: dateOrObj,\n                        end: null,\n                    };\n                }\n            }\n            else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: endDate,\n                };\n            }\n            var state = this.getCurrentData();\n            var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({ days: 1 }));\n            if (selection) { // throw parse error otherwise?\n                this.dispatch({ type: 'SELECT_DATES', selection: selection });\n                triggerDateSelect(selection, null, state);\n            }\n        };\n        // public method\n        CalendarApi.prototype.unselect = function (pev) {\n            var state = this.getCurrentData();\n            if (state.dateSelection) {\n                this.dispatch({ type: 'UNSELECT_DATES' });\n                triggerDateUnselect(pev, state);\n            }\n        };\n        // Public Events API\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.addEvent = function (eventInput, sourceInput) {\n            if (eventInput instanceof EventApi) {\n                var def = eventInput._def;\n                var instance = eventInput._instance;\n                var currentData = this.getCurrentData();\n                // not already present? don't want to add an old snapshot\n                if (!currentData.eventStore.defs[def.defId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENTS',\n                        eventStore: eventTupleToStore({ def: def, instance: instance }),\n                    });\n                    this.triggerEventAdd(eventInput);\n                }\n                return eventInput;\n            }\n            var state = this.getCurrentData();\n            var eventSource;\n            if (sourceInput instanceof EventSourceApi) {\n                eventSource = sourceInput.internalEventSource;\n            }\n            else if (typeof sourceInput === 'boolean') {\n                if (sourceInput) { // true. part of the first event source\n                    eventSource = hashValuesToArray(state.eventSources)[0];\n                }\n            }\n            else if (sourceInput != null) { // an ID. accepts a number too\n                var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n                if (!sourceApi) {\n                    console.warn(\"Could not find an event source with ID \\\"\" + sourceInput + \"\\\"\"); // TODO: test\n                    return null;\n                }\n                eventSource = sourceApi.internalEventSource;\n            }\n            var tuple = parseEvent(eventInput, eventSource, state, false);\n            if (tuple) {\n                var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n                this.dispatch({\n                    type: 'ADD_EVENTS',\n                    eventStore: eventTupleToStore(tuple),\n                });\n                this.triggerEventAdd(newEventApi);\n                return newEventApi;\n            }\n            return null;\n        };\n        CalendarApi.prototype.triggerEventAdd = function (eventApi) {\n            var _this = this;\n            var emitter = this.getCurrentData().emitter;\n            emitter.trigger('eventAdd', {\n                event: eventApi,\n                relatedEvents: [],\n                revert: function () {\n                    _this.dispatch({\n                        type: 'REMOVE_EVENTS',\n                        eventStore: eventApiToStore(eventApi),\n                    });\n                },\n            });\n        };\n        // TODO: optimize\n        CalendarApi.prototype.getEventById = function (id) {\n            var state = this.getCurrentData();\n            var _a = state.eventStore, defs = _a.defs, instances = _a.instances;\n            id = String(id);\n            for (var defId in defs) {\n                var def = defs[defId];\n                if (def.publicId === id) {\n                    if (def.recurringDef) {\n                        return new EventApi(state, def, null);\n                    }\n                    for (var instanceId in instances) {\n                        var instance = instances[instanceId];\n                        if (instance.defId === def.defId) {\n                            return new EventApi(state, def, instance);\n                        }\n                    }\n                }\n            }\n            return null;\n        };\n        CalendarApi.prototype.getEvents = function () {\n            var currentData = this.getCurrentData();\n            return buildEventApis(currentData.eventStore, currentData);\n        };\n        CalendarApi.prototype.removeAllEvents = function () {\n            this.dispatch({ type: 'REMOVE_ALL_EVENTS' });\n        };\n        // Public Event Sources API\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.getEventSources = function () {\n            var state = this.getCurrentData();\n            var sourceHash = state.eventSources;\n            var sourceApis = [];\n            for (var internalId in sourceHash) {\n                sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n            }\n            return sourceApis;\n        };\n        CalendarApi.prototype.getEventSourceById = function (id) {\n            var state = this.getCurrentData();\n            var sourceHash = state.eventSources;\n            id = String(id);\n            for (var sourceId in sourceHash) {\n                if (sourceHash[sourceId].publicId === id) {\n                    return new EventSourceApi(state, sourceHash[sourceId]);\n                }\n            }\n            return null;\n        };\n        CalendarApi.prototype.addEventSource = function (sourceInput) {\n            var state = this.getCurrentData();\n            if (sourceInput instanceof EventSourceApi) {\n                // not already present? don't want to add an old snapshot\n                if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                    this.dispatch({\n                        type: 'ADD_EVENT_SOURCES',\n                        sources: [sourceInput.internalEventSource],\n                    });\n                }\n                return sourceInput;\n            }\n            var eventSource = parseEventSource(sourceInput, state);\n            if (eventSource) { // TODO: error otherwise?\n                this.dispatch({ type: 'ADD_EVENT_SOURCES', sources: [eventSource] });\n                return new EventSourceApi(state, eventSource);\n            }\n            return null;\n        };\n        CalendarApi.prototype.removeAllEventSources = function () {\n            this.dispatch({ type: 'REMOVE_ALL_EVENT_SOURCES' });\n        };\n        CalendarApi.prototype.refetchEvents = function () {\n            this.dispatch({ type: 'FETCH_EVENT_SOURCES' });\n        };\n        // Scroll\n        // -----------------------------------------------------------------------------------------------------------------\n        CalendarApi.prototype.scrollToTime = function (timeInput) {\n            var time = createDuration(timeInput);\n            if (time) {\n                this.trigger('_scrollRequest', { time: time });\n            }\n        };\n        return CalendarApi;\n    }());\n\n    var EventApi = /** @class */ (function () {\n        // instance will be null if expressing a recurring event that has no current instances,\n        // OR if trying to validate an incoming external event that has no dates assigned\n        function EventApi(context, def, instance) {\n            this._context = context;\n            this._def = def;\n            this._instance = instance || null;\n        }\n        /*\n        TODO: make event struct more responsible for this\n        */\n        EventApi.prototype.setProp = function (name, val) {\n            var _a, _b;\n            if (name in EVENT_DATE_REFINERS) {\n                console.warn('Could not set date-related prop \\'name\\'. Use one of the date-related methods instead.');\n            }\n            else if (name in EVENT_NON_DATE_REFINERS) {\n                val = EVENT_NON_DATE_REFINERS[name](val);\n                this.mutate({\n                    standardProps: (_a = {}, _a[name] = val, _a),\n                });\n            }\n            else if (name in EVENT_UI_REFINERS) {\n                var ui = EVENT_UI_REFINERS[name](val);\n                if (name === 'color') {\n                    ui = { backgroundColor: val, borderColor: val };\n                }\n                else if (name === 'editable') {\n                    ui = { startEditable: val, durationEditable: val };\n                }\n                else {\n                    ui = (_b = {}, _b[name] = val, _b);\n                }\n                this.mutate({\n                    standardProps: { ui: ui },\n                });\n            }\n            else {\n                console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n            }\n        };\n        EventApi.prototype.setExtendedProp = function (name, val) {\n            var _a;\n            this.mutate({\n                extendedProps: (_a = {}, _a[name] = val, _a),\n            });\n        };\n        EventApi.prototype.setStart = function (startInput, options) {\n            if (options === void 0) { options = {}; }\n            var dateEnv = this._context.dateEnv;\n            var start = dateEnv.createMarker(startInput);\n            if (start && this._instance) { // TODO: warning if parsed bad\n                var instanceRange = this._instance.range;\n                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n                if (options.maintainDuration) {\n                    this.mutate({ datesDelta: startDelta });\n                }\n                else {\n                    this.mutate({ startDelta: startDelta });\n                }\n            }\n        };\n        EventApi.prototype.setEnd = function (endInput, options) {\n            if (options === void 0) { options = {}; }\n            var dateEnv = this._context.dateEnv;\n            var end;\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) {\n                    return; // TODO: warning if parsed bad\n                }\n            }\n            if (this._instance) {\n                if (end) {\n                    var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                    this.mutate({ endDelta: endDelta });\n                }\n                else {\n                    this.mutate({ standardProps: { hasEnd: false } });\n                }\n            }\n        };\n        EventApi.prototype.setDates = function (startInput, endInput, options) {\n            if (options === void 0) { options = {}; }\n            var dateEnv = this._context.dateEnv;\n            var standardProps = { allDay: options.allDay };\n            var start = dateEnv.createMarker(startInput);\n            var end;\n            if (!start) {\n                return; // TODO: warning if parsed bad\n            }\n            if (endInput != null) {\n                end = dateEnv.createMarker(endInput);\n                if (!end) { // TODO: warning if parsed bad\n                    return;\n                }\n            }\n            if (this._instance) {\n                var instanceRange = this._instance.range;\n                // when computing the diff for an event being converted to all-day,\n                // compute diff off of the all-day values the way event-mutation does.\n                if (options.allDay === true) {\n                    instanceRange = computeAlignedDayRange(instanceRange);\n                }\n                var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n                if (end) {\n                    var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                    if (durationsEqual(startDelta, endDelta)) {\n                        this.mutate({ datesDelta: startDelta, standardProps: standardProps });\n                    }\n                    else {\n                        this.mutate({ startDelta: startDelta, endDelta: endDelta, standardProps: standardProps });\n                    }\n                }\n                else { // means \"clear the end\"\n                    standardProps.hasEnd = false;\n                    this.mutate({ datesDelta: startDelta, standardProps: standardProps });\n                }\n            }\n        };\n        EventApi.prototype.moveStart = function (deltaInput) {\n            var delta = createDuration(deltaInput);\n            if (delta) { // TODO: warning if parsed bad\n                this.mutate({ startDelta: delta });\n            }\n        };\n        EventApi.prototype.moveEnd = function (deltaInput) {\n            var delta = createDuration(deltaInput);\n            if (delta) { // TODO: warning if parsed bad\n                this.mutate({ endDelta: delta });\n            }\n        };\n        EventApi.prototype.moveDates = function (deltaInput) {\n            var delta = createDuration(deltaInput);\n            if (delta) { // TODO: warning if parsed bad\n                this.mutate({ datesDelta: delta });\n            }\n        };\n        EventApi.prototype.setAllDay = function (allDay, options) {\n            if (options === void 0) { options = {}; }\n            var standardProps = { allDay: allDay };\n            var maintainDuration = options.maintainDuration;\n            if (maintainDuration == null) {\n                maintainDuration = this._context.options.allDayMaintainDuration;\n            }\n            if (this._def.allDay !== allDay) {\n                standardProps.hasEnd = maintainDuration;\n            }\n            this.mutate({ standardProps: standardProps });\n        };\n        EventApi.prototype.formatRange = function (formatInput) {\n            var dateEnv = this._context.dateEnv;\n            var instance = this._instance;\n            var formatter = createFormatter(formatInput);\n            if (this._def.hasEnd) {\n                return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                    forcedStartTzo: instance.forcedStartTzo,\n                    forcedEndTzo: instance.forcedEndTzo,\n                });\n            }\n            return dateEnv.format(instance.range.start, formatter, {\n                forcedTzo: instance.forcedStartTzo,\n            });\n        };\n        EventApi.prototype.mutate = function (mutation) {\n            var instance = this._instance;\n            if (instance) {\n                var def = this._def;\n                var context_1 = this._context;\n                var eventStore = context_1.getCurrentData().eventStore;\n                var relevantEvents_1 = getRelevantEvents(eventStore, instance.instanceId);\n                var eventConfigBase = {\n                    '': {\n                        display: '',\n                        startEditable: true,\n                        durationEditable: true,\n                        constraints: [],\n                        overlap: null,\n                        allows: [],\n                        backgroundColor: '',\n                        borderColor: '',\n                        textColor: '',\n                        classNames: [],\n                    },\n                };\n                relevantEvents_1 = applyMutationToEventStore(relevantEvents_1, eventConfigBase, mutation, context_1);\n                var oldEvent = new EventApi(context_1, def, instance); // snapshot\n                this._def = relevantEvents_1.defs[def.defId];\n                this._instance = relevantEvents_1.instances[instance.instanceId];\n                context_1.dispatch({\n                    type: 'MERGE_EVENTS',\n                    eventStore: relevantEvents_1,\n                });\n                context_1.emitter.trigger('eventChange', {\n                    oldEvent: oldEvent,\n                    event: this,\n                    relatedEvents: buildEventApis(relevantEvents_1, context_1, instance),\n                    revert: function () {\n                        context_1.dispatch({\n                            type: 'REMOVE_EVENTS',\n                            eventStore: relevantEvents_1,\n                        });\n                    },\n                });\n            }\n        };\n        EventApi.prototype.remove = function () {\n            var context = this._context;\n            var asStore = eventApiToStore(this);\n            context.dispatch({\n                type: 'REMOVE_EVENTS',\n                eventStore: asStore,\n            });\n            context.emitter.trigger('eventRemove', {\n                event: this,\n                relatedEvents: [],\n                revert: function () {\n                    context.dispatch({\n                        type: 'MERGE_EVENTS',\n                        eventStore: asStore,\n                    });\n                },\n            });\n        };\n        Object.defineProperty(EventApi.prototype, \"source\", {\n            get: function () {\n                var sourceId = this._def.sourceId;\n                if (sourceId) {\n                    return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n                }\n                return null;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"start\", {\n            get: function () {\n                return this._instance ?\n                    this._context.dateEnv.toDate(this._instance.range.start) :\n                    null;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"end\", {\n            get: function () {\n                return (this._instance && this._def.hasEnd) ?\n                    this._context.dateEnv.toDate(this._instance.range.end) :\n                    null;\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"startStr\", {\n            get: function () {\n                var instance = this._instance;\n                if (instance) {\n                    return this._context.dateEnv.formatIso(instance.range.start, {\n                        omitTime: this._def.allDay,\n                        forcedTzo: instance.forcedStartTzo,\n                    });\n                }\n                return '';\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"endStr\", {\n            get: function () {\n                var instance = this._instance;\n                if (instance && this._def.hasEnd) {\n                    return this._context.dateEnv.formatIso(instance.range.end, {\n                        omitTime: this._def.allDay,\n                        forcedTzo: instance.forcedEndTzo,\n                    });\n                }\n                return '';\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"id\", {\n            // computable props that all access the def\n            // TODO: find a TypeScript-compatible way to do this at scale\n            get: function () { return this._def.publicId; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"groupId\", {\n            get: function () { return this._def.groupId; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"allDay\", {\n            get: function () { return this._def.allDay; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"title\", {\n            get: function () { return this._def.title; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"url\", {\n            get: function () { return this._def.url; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"display\", {\n            get: function () { return this._def.ui.display || 'auto'; } // bad. just normalize the type earlier\n            ,\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"startEditable\", {\n            get: function () { return this._def.ui.startEditable; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n            get: function () { return this._def.ui.durationEditable; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"constraint\", {\n            get: function () { return this._def.ui.constraints[0] || null; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"overlap\", {\n            get: function () { return this._def.ui.overlap; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"allow\", {\n            get: function () { return this._def.ui.allows[0] || null; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n            get: function () { return this._def.ui.backgroundColor; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"borderColor\", {\n            get: function () { return this._def.ui.borderColor; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"textColor\", {\n            get: function () { return this._def.ui.textColor; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"classNames\", {\n            // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n            get: function () { return this._def.ui.classNames; },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n            get: function () { return this._def.extendedProps; },\n            enumerable: false,\n            configurable: true\n        });\n        EventApi.prototype.toPlainObject = function (settings) {\n            if (settings === void 0) { settings = {}; }\n            var def = this._def;\n            var ui = def.ui;\n            var _a = this, startStr = _a.startStr, endStr = _a.endStr;\n            var res = {};\n            if (def.title) {\n                res.title = def.title;\n            }\n            if (startStr) {\n                res.start = startStr;\n            }\n            if (endStr) {\n                res.end = endStr;\n            }\n            if (def.publicId) {\n                res.id = def.publicId;\n            }\n            if (def.groupId) {\n                res.groupId = def.groupId;\n            }\n            if (def.url) {\n                res.url = def.url;\n            }\n            if (ui.display && ui.display !== 'auto') {\n                res.display = ui.display;\n            }\n            // TODO: what about recurring-event properties???\n            // TODO: include startEditable/durationEditable/constraint/overlap/allow\n            if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n                res.color = ui.backgroundColor;\n            }\n            else {\n                if (ui.backgroundColor) {\n                    res.backgroundColor = ui.backgroundColor;\n                }\n                if (ui.borderColor) {\n                    res.borderColor = ui.borderColor;\n                }\n            }\n            if (ui.textColor) {\n                res.textColor = ui.textColor;\n            }\n            if (ui.classNames.length) {\n                res.classNames = ui.classNames;\n            }\n            if (Object.keys(def.extendedProps).length) {\n                if (settings.collapseExtendedProps) {\n                    __assign(res, def.extendedProps);\n                }\n                else {\n                    res.extendedProps = def.extendedProps;\n                }\n            }\n            return res;\n        };\n        EventApi.prototype.toJSON = function () {\n            return this.toPlainObject();\n        };\n        return EventApi;\n    }());\n    function eventApiToStore(eventApi) {\n        var _a, _b;\n        var def = eventApi._def;\n        var instance = eventApi._instance;\n        return {\n            defs: (_a = {}, _a[def.defId] = def, _a),\n            instances: instance\n                ? (_b = {}, _b[instance.instanceId] = instance, _b) : {},\n        };\n    }\n    function buildEventApis(eventStore, context, excludeInstance) {\n        var defs = eventStore.defs, instances = eventStore.instances;\n        var eventApis = [];\n        var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : '';\n        for (var id in instances) {\n            var instance = instances[id];\n            var def = defs[instance.defId];\n            if (instance.instanceId !== excludeInstanceId) {\n                eventApis.push(new EventApi(context, def, instance));\n            }\n        }\n        return eventApis;\n    }\n\n    var calendarSystemClassMap = {};\n    function registerCalendarSystem(name, theClass) {\n        calendarSystemClassMap[name] = theClass;\n    }\n    function createCalendarSystem(name) {\n        return new calendarSystemClassMap[name]();\n    }\n    var GregorianCalendarSystem = /** @class */ (function () {\n        function GregorianCalendarSystem() {\n        }\n        GregorianCalendarSystem.prototype.getMarkerYear = function (d) {\n            return d.getUTCFullYear();\n        };\n        GregorianCalendarSystem.prototype.getMarkerMonth = function (d) {\n            return d.getUTCMonth();\n        };\n        GregorianCalendarSystem.prototype.getMarkerDay = function (d) {\n            return d.getUTCDate();\n        };\n        GregorianCalendarSystem.prototype.arrayToMarker = function (arr) {\n            return arrayToUtcDate(arr);\n        };\n        GregorianCalendarSystem.prototype.markerToArray = function (marker) {\n            return dateToUtcArray(marker);\n        };\n        return GregorianCalendarSystem;\n    }());\n    registerCalendarSystem('gregory', GregorianCalendarSystem);\n\n    var ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\n    function parse(str) {\n        var m = ISO_RE.exec(str);\n        if (m) {\n            var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n            if (isValidDate(marker)) {\n                var timeZoneOffset = null;\n                if (m[13]) {\n                    timeZoneOffset = (m[15] === '-' ? -1 : 1) * (Number(m[16] || 0) * 60 +\n                        Number(m[18] || 0));\n                }\n                return {\n                    marker: marker,\n                    isTimeUnspecified: !m[6],\n                    timeZoneOffset: timeZoneOffset,\n                };\n            }\n        }\n        return null;\n    }\n\n    var DateEnv = /** @class */ (function () {\n        function DateEnv(settings) {\n            var timeZone = this.timeZone = settings.timeZone;\n            var isNamedTimeZone = timeZone !== 'local' && timeZone !== 'UTC';\n            if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n                this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n            }\n            this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n            this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n            this.locale = settings.locale;\n            this.weekDow = settings.locale.week.dow;\n            this.weekDoy = settings.locale.week.doy;\n            if (settings.weekNumberCalculation === 'ISO') {\n                this.weekDow = 1;\n                this.weekDoy = 4;\n            }\n            if (typeof settings.firstDay === 'number') {\n                this.weekDow = settings.firstDay;\n            }\n            if (typeof settings.weekNumberCalculation === 'function') {\n                this.weekNumberFunc = settings.weekNumberCalculation;\n            }\n            this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n            this.cmdFormatter = settings.cmdFormatter;\n            this.defaultSeparator = settings.defaultSeparator;\n        }\n        // Creating / Parsing\n        DateEnv.prototype.createMarker = function (input) {\n            var meta = this.createMarkerMeta(input);\n            if (meta === null) {\n                return null;\n            }\n            return meta.marker;\n        };\n        DateEnv.prototype.createNowMarker = function () {\n            if (this.canComputeOffset) {\n                return this.timestampToMarker(new Date().valueOf());\n            }\n            // if we can't compute the current date val for a timezone,\n            // better to give the current local date vals than UTC\n            return arrayToUtcDate(dateToLocalArray(new Date()));\n        };\n        DateEnv.prototype.createMarkerMeta = function (input) {\n            if (typeof input === 'string') {\n                return this.parse(input);\n            }\n            var marker = null;\n            if (typeof input === 'number') {\n                marker = this.timestampToMarker(input);\n            }\n            else if (input instanceof Date) {\n                input = input.valueOf();\n                if (!isNaN(input)) {\n                    marker = this.timestampToMarker(input);\n                }\n            }\n            else if (Array.isArray(input)) {\n                marker = arrayToUtcDate(input);\n            }\n            if (marker === null || !isValidDate(marker)) {\n                return null;\n            }\n            return { marker: marker, isTimeUnspecified: false, forcedTzo: null };\n        };\n        DateEnv.prototype.parse = function (s) {\n            var parts = parse(s);\n            if (parts === null) {\n                return null;\n            }\n            var marker = parts.marker;\n            var forcedTzo = null;\n            if (parts.timeZoneOffset !== null) {\n                if (this.canComputeOffset) {\n                    marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n                }\n                else {\n                    forcedTzo = parts.timeZoneOffset;\n                }\n            }\n            return { marker: marker, isTimeUnspecified: parts.isTimeUnspecified, forcedTzo: forcedTzo };\n        };\n        // Accessors\n        DateEnv.prototype.getYear = function (marker) {\n            return this.calendarSystem.getMarkerYear(marker);\n        };\n        DateEnv.prototype.getMonth = function (marker) {\n            return this.calendarSystem.getMarkerMonth(marker);\n        };\n        // Adding / Subtracting\n        DateEnv.prototype.add = function (marker, dur) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[0] += dur.years;\n            a[1] += dur.months;\n            a[2] += dur.days;\n            a[6] += dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        DateEnv.prototype.subtract = function (marker, dur) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[0] -= dur.years;\n            a[1] -= dur.months;\n            a[2] -= dur.days;\n            a[6] -= dur.milliseconds;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        DateEnv.prototype.addYears = function (marker, n) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[0] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        DateEnv.prototype.addMonths = function (marker, n) {\n            var a = this.calendarSystem.markerToArray(marker);\n            a[1] += n;\n            return this.calendarSystem.arrayToMarker(a);\n        };\n        // Diffing Whole Units\n        DateEnv.prototype.diffWholeYears = function (m0, m1) {\n            var calendarSystem = this.calendarSystem;\n            if (timeAsMs(m0) === timeAsMs(m1) &&\n                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) &&\n                calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n                return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n            }\n            return null;\n        };\n        DateEnv.prototype.diffWholeMonths = function (m0, m1) {\n            var calendarSystem = this.calendarSystem;\n            if (timeAsMs(m0) === timeAsMs(m1) &&\n                calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n                return (calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0)) +\n                    (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n            }\n            return null;\n        };\n        // Range / Duration\n        DateEnv.prototype.greatestWholeUnit = function (m0, m1) {\n            var n = this.diffWholeYears(m0, m1);\n            if (n !== null) {\n                return { unit: 'year', value: n };\n            }\n            n = this.diffWholeMonths(m0, m1);\n            if (n !== null) {\n                return { unit: 'month', value: n };\n            }\n            n = diffWholeWeeks(m0, m1);\n            if (n !== null) {\n                return { unit: 'week', value: n };\n            }\n            n = diffWholeDays(m0, m1);\n            if (n !== null) {\n                return { unit: 'day', value: n };\n            }\n            n = diffHours(m0, m1);\n            if (isInt(n)) {\n                return { unit: 'hour', value: n };\n            }\n            n = diffMinutes(m0, m1);\n            if (isInt(n)) {\n                return { unit: 'minute', value: n };\n            }\n            n = diffSeconds(m0, m1);\n            if (isInt(n)) {\n                return { unit: 'second', value: n };\n            }\n            return { unit: 'millisecond', value: m1.valueOf() - m0.valueOf() };\n        };\n        DateEnv.prototype.countDurationsBetween = function (m0, m1, d) {\n            // TODO: can use greatestWholeUnit\n            var diff;\n            if (d.years) {\n                diff = this.diffWholeYears(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughYears(d);\n                }\n            }\n            if (d.months) {\n                diff = this.diffWholeMonths(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughMonths(d);\n                }\n            }\n            if (d.days) {\n                diff = diffWholeDays(m0, m1);\n                if (diff !== null) {\n                    return diff / asRoughDays(d);\n                }\n            }\n            return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n        };\n        // Start-Of\n        // these DON'T return zoned-dates. only UTC start-of dates\n        DateEnv.prototype.startOf = function (m, unit) {\n            if (unit === 'year') {\n                return this.startOfYear(m);\n            }\n            if (unit === 'month') {\n                return this.startOfMonth(m);\n            }\n            if (unit === 'week') {\n                return this.startOfWeek(m);\n            }\n            if (unit === 'day') {\n                return startOfDay(m);\n            }\n            if (unit === 'hour') {\n                return startOfHour(m);\n            }\n            if (unit === 'minute') {\n                return startOfMinute(m);\n            }\n            if (unit === 'second') {\n                return startOfSecond(m);\n            }\n            return null;\n        };\n        DateEnv.prototype.startOfYear = function (m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n            ]);\n        };\n        DateEnv.prototype.startOfMonth = function (m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m),\n            ]);\n        };\n        DateEnv.prototype.startOfWeek = function (m) {\n            return this.calendarSystem.arrayToMarker([\n                this.calendarSystem.getMarkerYear(m),\n                this.calendarSystem.getMarkerMonth(m),\n                m.getUTCDate() - ((m.getUTCDay() - this.weekDow + 7) % 7),\n            ]);\n        };\n        // Week Number\n        DateEnv.prototype.computeWeekNumber = function (marker) {\n            if (this.weekNumberFunc) {\n                return this.weekNumberFunc(this.toDate(marker));\n            }\n            return weekOfYear(marker, this.weekDow, this.weekDoy);\n        };\n        // TODO: choke on timeZoneName: long\n        DateEnv.prototype.format = function (marker, formatter, dateOptions) {\n            if (dateOptions === void 0) { dateOptions = {}; }\n            return formatter.format({\n                marker: marker,\n                timeZoneOffset: dateOptions.forcedTzo != null ?\n                    dateOptions.forcedTzo :\n                    this.offsetForMarker(marker),\n            }, this);\n        };\n        DateEnv.prototype.formatRange = function (start, end, formatter, dateOptions) {\n            if (dateOptions === void 0) { dateOptions = {}; }\n            if (dateOptions.isEndExclusive) {\n                end = addMs(end, -1);\n            }\n            return formatter.formatRange({\n                marker: start,\n                timeZoneOffset: dateOptions.forcedStartTzo != null ?\n                    dateOptions.forcedStartTzo :\n                    this.offsetForMarker(start),\n            }, {\n                marker: end,\n                timeZoneOffset: dateOptions.forcedEndTzo != null ?\n                    dateOptions.forcedEndTzo :\n                    this.offsetForMarker(end),\n            }, this, dateOptions.defaultSeparator);\n        };\n        /*\n        DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n        might as well use buildIsoString or some other util directly\n        */\n        DateEnv.prototype.formatIso = function (marker, extraOptions) {\n            if (extraOptions === void 0) { extraOptions = {}; }\n            var timeZoneOffset = null;\n            if (!extraOptions.omitTimeZoneOffset) {\n                if (extraOptions.forcedTzo != null) {\n                    timeZoneOffset = extraOptions.forcedTzo;\n                }\n                else {\n                    timeZoneOffset = this.offsetForMarker(marker);\n                }\n            }\n            return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n        };\n        // TimeZone\n        DateEnv.prototype.timestampToMarker = function (ms) {\n            if (this.timeZone === 'local') {\n                return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n            }\n            if (this.timeZone === 'UTC' || !this.namedTimeZoneImpl) {\n                return new Date(ms);\n            }\n            return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n        };\n        DateEnv.prototype.offsetForMarker = function (m) {\n            if (this.timeZone === 'local') {\n                return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n            }\n            if (this.timeZone === 'UTC') {\n                return 0;\n            }\n            if (this.namedTimeZoneImpl) {\n                return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n            }\n            return null;\n        };\n        // Conversion\n        DateEnv.prototype.toDate = function (m, forcedTzo) {\n            if (this.timeZone === 'local') {\n                return arrayToLocalDate(dateToUtcArray(m));\n            }\n            if (this.timeZone === 'UTC') {\n                return new Date(m.valueOf()); // make sure it's a copy\n            }\n            if (!this.namedTimeZoneImpl) {\n                return new Date(m.valueOf() - (forcedTzo || 0));\n            }\n            return new Date(m.valueOf() -\n                this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n        };\n        return DateEnv;\n    }());\n\n    var globalLocales = [];\n\n    var RAW_EN_LOCALE = {\n        code: 'en',\n        week: {\n            dow: 0,\n            doy: 4,\n        },\n        direction: 'ltr',\n        buttonText: {\n            prev: 'prev',\n            next: 'next',\n            prevYear: 'prev year',\n            nextYear: 'next year',\n            year: 'year',\n            today: 'today',\n            month: 'month',\n            week: 'week',\n            day: 'day',\n            list: 'list',\n        },\n        weekText: 'W',\n        allDayText: 'all-day',\n        moreLinkText: 'more',\n        noEventsText: 'No events to display',\n    };\n    function organizeRawLocales(explicitRawLocales) {\n        var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : 'en';\n        var allRawLocales = globalLocales.concat(explicitRawLocales);\n        var rawLocaleMap = {\n            en: RAW_EN_LOCALE,\n        };\n        for (var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++) {\n            var rawLocale = allRawLocales_1[_i];\n            rawLocaleMap[rawLocale.code] = rawLocale;\n        }\n        return {\n            map: rawLocaleMap,\n            defaultCode: defaultCode,\n        };\n    }\n    function buildLocale(inputSingular, available) {\n        if (typeof inputSingular === 'object' && !Array.isArray(inputSingular)) {\n            return parseLocale(inputSingular.code, [inputSingular.code], inputSingular);\n        }\n        return queryLocale(inputSingular, available);\n    }\n    function queryLocale(codeArg, available) {\n        var codes = [].concat(codeArg || []); // will convert to array\n        var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n        return parseLocale(codeArg, codes, raw);\n    }\n    function queryRawLocale(codes, available) {\n        for (var i = 0; i < codes.length; i += 1) {\n            var parts = codes[i].toLocaleLowerCase().split('-');\n            for (var j = parts.length; j > 0; j -= 1) {\n                var simpleId = parts.slice(0, j).join('-');\n                if (available[simpleId]) {\n                    return available[simpleId];\n                }\n            }\n        }\n        return null;\n    }\n    function parseLocale(codeArg, codes, raw) {\n        var merged = mergeProps([RAW_EN_LOCALE, raw], ['buttonText']);\n        delete merged.code; // don't want this part of the options\n        var week = merged.week;\n        delete merged.week;\n        return {\n            codeArg: codeArg,\n            codes: codes,\n            week: week,\n            simpleNumberFormat: new Intl.NumberFormat(codeArg),\n            options: merged,\n        };\n    }\n\n    function formatDate(dateInput, options) {\n        if (options === void 0) { options = {}; }\n        var dateEnv = buildDateEnv(options);\n        var formatter = createFormatter(options);\n        var dateMeta = dateEnv.createMarkerMeta(dateInput);\n        if (!dateMeta) { // TODO: warning?\n            return '';\n        }\n        return dateEnv.format(dateMeta.marker, formatter, {\n            forcedTzo: dateMeta.forcedTzo,\n        });\n    }\n    function formatRange(startInput, endInput, options) {\n        var dateEnv = buildDateEnv(typeof options === 'object' && options ? options : {}); // pass in if non-null object\n        var formatter = createFormatter(options);\n        var startMeta = dateEnv.createMarkerMeta(startInput);\n        var endMeta = dateEnv.createMarkerMeta(endInput);\n        if (!startMeta || !endMeta) { // TODO: warning?\n            return '';\n        }\n        return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n            forcedStartTzo: startMeta.forcedTzo,\n            forcedEndTzo: endMeta.forcedTzo,\n            isEndExclusive: options.isEndExclusive,\n            defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator,\n        });\n    }\n    // TODO: more DRY and optimized\n    function buildDateEnv(settings) {\n        var locale = buildLocale(settings.locale || 'en', organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n        return new DateEnv(__assign(__assign({ timeZone: BASE_OPTION_DEFAULTS.timeZone, calendarSystem: 'gregory' }, settings), { locale: locale }));\n    }\n\n    var DEF_DEFAULTS = {\n        startTime: '09:00',\n        endTime: '17:00',\n        daysOfWeek: [1, 2, 3, 4, 5],\n        display: 'inverse-background',\n        classNames: 'fc-non-business',\n        groupId: '_businessHours',\n    };\n    /*\n    TODO: pass around as EventDefHash!!!\n    */\n    function parseBusinessHours(input, context) {\n        return parseEvents(refineInputs(input), null, context);\n    }\n    function refineInputs(input) {\n        var rawDefs;\n        if (input === true) {\n            rawDefs = [{}]; // will get DEF_DEFAULTS verbatim\n        }\n        else if (Array.isArray(input)) {\n            // if specifying an array, every sub-definition NEEDS a day-of-week\n            rawDefs = input.filter(function (rawDef) { return rawDef.daysOfWeek; });\n        }\n        else if (typeof input === 'object' && input) { // non-null object\n            rawDefs = [input];\n        }\n        else { // is probably false\n            rawDefs = [];\n        }\n        rawDefs = rawDefs.map(function (rawDef) { return (__assign(__assign({}, DEF_DEFAULTS), rawDef)); });\n        return rawDefs;\n    }\n\n    function pointInsideRect(point, rect) {\n        return point.left >= rect.left &&\n            point.left < rect.right &&\n            point.top >= rect.top &&\n            point.top < rect.bottom;\n    }\n    // Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\n    function intersectRects(rect1, rect2) {\n        var res = {\n            left: Math.max(rect1.left, rect2.left),\n            right: Math.min(rect1.right, rect2.right),\n            top: Math.max(rect1.top, rect2.top),\n            bottom: Math.min(rect1.bottom, rect2.bottom),\n        };\n        if (res.left < res.right && res.top < res.bottom) {\n            return res;\n        }\n        return false;\n    }\n    function translateRect(rect, deltaX, deltaY) {\n        return {\n            left: rect.left + deltaX,\n            right: rect.right + deltaX,\n            top: rect.top + deltaY,\n            bottom: rect.bottom + deltaY,\n        };\n    }\n    // Returns a new point that will have been moved to reside within the given rectangle\n    function constrainPoint(point, rect) {\n        return {\n            left: Math.min(Math.max(point.left, rect.left), rect.right),\n            top: Math.min(Math.max(point.top, rect.top), rect.bottom),\n        };\n    }\n    // Returns a point that is the center of the given rectangle\n    function getRectCenter(rect) {\n        return {\n            left: (rect.left + rect.right) / 2,\n            top: (rect.top + rect.bottom) / 2,\n        };\n    }\n    // Subtracts point2's coordinates from point1's coordinates, returning a delta\n    function diffPoints(point1, point2) {\n        return {\n            left: point1.left - point2.left,\n            top: point1.top - point2.top,\n        };\n    }\n\n    var canVGrowWithinCell;\n    function getCanVGrowWithinCell() {\n        if (canVGrowWithinCell == null) {\n            canVGrowWithinCell = computeCanVGrowWithinCell();\n        }\n        return canVGrowWithinCell;\n    }\n    function computeCanVGrowWithinCell() {\n        // for SSR, because this function is call immediately at top-level\n        // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n        if (typeof document === 'undefined') {\n            return true;\n        }\n        var el = document.createElement('div');\n        el.style.position = 'absolute';\n        el.style.top = '0px';\n        el.style.left = '0px';\n        el.innerHTML = '<table><tr><td><div></div></td></tr></table>';\n        el.querySelector('table').style.height = '100px';\n        el.querySelector('div').style.height = '100%';\n        document.body.appendChild(el);\n        var div = el.querySelector('div');\n        var possible = div.offsetHeight > 0;\n        document.body.removeChild(el);\n        return possible;\n    }\n\n    var EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\n    var Splitter = /** @class */ (function () {\n        function Splitter() {\n            this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n            this.splitDateSelection = memoize(this._splitDateSpan);\n            this.splitEventStore = memoize(this._splitEventStore);\n            this.splitIndividualUi = memoize(this._splitIndividualUi);\n            this.splitEventDrag = memoize(this._splitInteraction);\n            this.splitEventResize = memoize(this._splitInteraction);\n            this.eventUiBuilders = {}; // TODO: typescript protection\n        }\n        Splitter.prototype.splitProps = function (props) {\n            var _this = this;\n            var keyInfos = this.getKeyInfo(props);\n            var defKeys = this.getKeysForEventDefs(props.eventStore);\n            var dateSelections = this.splitDateSelection(props.dateSelection);\n            var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n            var eventStores = this.splitEventStore(props.eventStore, defKeys);\n            var eventDrags = this.splitEventDrag(props.eventDrag);\n            var eventResizes = this.splitEventResize(props.eventResize);\n            var splitProps = {};\n            this.eventUiBuilders = mapHash(keyInfos, function (info, key) { return _this.eventUiBuilders[key] || memoize(buildEventUiForKey); });\n            for (var key in keyInfos) {\n                var keyInfo = keyInfos[key];\n                var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n                var buildEventUi = this.eventUiBuilders[key];\n                splitProps[key] = {\n                    businessHours: keyInfo.businessHours || props.businessHours,\n                    dateSelection: dateSelections[key] || null,\n                    eventStore: eventStore,\n                    eventUiBases: buildEventUi(props.eventUiBases[''], keyInfo.ui, individualUi[key]),\n                    eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : '',\n                    eventDrag: eventDrags[key] || null,\n                    eventResize: eventResizes[key] || null,\n                };\n            }\n            return splitProps;\n        };\n        Splitter.prototype._splitDateSpan = function (dateSpan) {\n            var dateSpans = {};\n            if (dateSpan) {\n                var keys = this.getKeysForDateSpan(dateSpan);\n                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n                    var key = keys_1[_i];\n                    dateSpans[key] = dateSpan;\n                }\n            }\n            return dateSpans;\n        };\n        Splitter.prototype._getKeysForEventDefs = function (eventStore) {\n            var _this = this;\n            return mapHash(eventStore.defs, function (eventDef) { return _this.getKeysForEventDef(eventDef); });\n        };\n        Splitter.prototype._splitEventStore = function (eventStore, defKeys) {\n            var defs = eventStore.defs, instances = eventStore.instances;\n            var splitStores = {};\n            for (var defId in defs) {\n                for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n                    var key = _a[_i];\n                    if (!splitStores[key]) {\n                        splitStores[key] = createEmptyEventStore();\n                    }\n                    splitStores[key].defs[defId] = defs[defId];\n                }\n            }\n            for (var instanceId in instances) {\n                var instance = instances[instanceId];\n                for (var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++) {\n                    var key = _c[_b];\n                    if (splitStores[key]) { // must have already been created\n                        splitStores[key].instances[instanceId] = instance;\n                    }\n                }\n            }\n            return splitStores;\n        };\n        Splitter.prototype._splitIndividualUi = function (eventUiBases, defKeys) {\n            var splitHashes = {};\n            for (var defId in eventUiBases) {\n                if (defId) { // not the '' key\n                    for (var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++) {\n                        var key = _a[_i];\n                        if (!splitHashes[key]) {\n                            splitHashes[key] = {};\n                        }\n                        splitHashes[key][defId] = eventUiBases[defId];\n                    }\n                }\n            }\n            return splitHashes;\n        };\n        Splitter.prototype._splitInteraction = function (interaction) {\n            var splitStates = {};\n            if (interaction) {\n                var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n                // can't rely on defKeys because event data is mutated\n                var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n                var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n                var populate = function (key) {\n                    if (!splitStates[key]) {\n                        splitStates[key] = {\n                            affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n                            mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n                            isEvent: interaction.isEvent,\n                        };\n                    }\n                };\n                for (var key in affectedStores_1) {\n                    populate(key);\n                }\n                for (var key in mutatedStores_1) {\n                    populate(key);\n                }\n            }\n            return splitStates;\n        };\n        return Splitter;\n    }());\n    function buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n        var baseParts = [];\n        if (allUi) {\n            baseParts.push(allUi);\n        }\n        if (eventUiForKey) {\n            baseParts.push(eventUiForKey);\n        }\n        var stuff = {\n            '': combineEventUis(baseParts),\n        };\n        if (individualUi) {\n            __assign(stuff, individualUi);\n        }\n        return stuff;\n    }\n\n    function getDateMeta(date, todayRange, nowDate, dateProfile) {\n        return {\n            dow: date.getUTCDay(),\n            isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n            isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n            isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n            isPast: Boolean(nowDate ? (date < nowDate) : todayRange ? (date < todayRange.start) : false),\n            isFuture: Boolean(nowDate ? (date > nowDate) : todayRange ? (date >= todayRange.end) : false),\n        };\n    }\n    function getDayClassNames(meta, theme) {\n        var classNames = [\n            'fc-day',\n            \"fc-day-\" + DAY_IDS[meta.dow],\n        ];\n        if (meta.isDisabled) {\n            classNames.push('fc-day-disabled');\n        }\n        else {\n            if (meta.isToday) {\n                classNames.push('fc-day-today');\n                classNames.push(theme.getClass('today'));\n            }\n            if (meta.isPast) {\n                classNames.push('fc-day-past');\n            }\n            if (meta.isFuture) {\n                classNames.push('fc-day-future');\n            }\n            if (meta.isOther) {\n                classNames.push('fc-day-other');\n            }\n        }\n        return classNames;\n    }\n    function getSlotClassNames(meta, theme) {\n        var classNames = [\n            'fc-slot',\n            \"fc-slot-\" + DAY_IDS[meta.dow],\n        ];\n        if (meta.isDisabled) {\n            classNames.push('fc-slot-disabled');\n        }\n        else {\n            if (meta.isToday) {\n                classNames.push('fc-slot-today');\n                classNames.push(theme.getClass('today'));\n            }\n            if (meta.isPast) {\n                classNames.push('fc-slot-past');\n            }\n            if (meta.isFuture) {\n                classNames.push('fc-slot-future');\n            }\n        }\n        return classNames;\n    }\n\n    function buildNavLinkData(date, type) {\n        if (type === void 0) { type = 'day'; }\n        return JSON.stringify({\n            date: formatDayString(date),\n            type: type,\n        });\n    }\n\n    var _isRtlScrollbarOnLeft = null;\n    function getIsRtlScrollbarOnLeft() {\n        if (_isRtlScrollbarOnLeft === null) {\n            _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n        }\n        return _isRtlScrollbarOnLeft;\n    }\n    function computeIsRtlScrollbarOnLeft() {\n        var outerEl = document.createElement('div');\n        applyStyle(outerEl, {\n            position: 'absolute',\n            top: -1000,\n            left: 0,\n            border: 0,\n            padding: 0,\n            overflow: 'scroll',\n            direction: 'rtl',\n        });\n        outerEl.innerHTML = '<div></div>';\n        document.body.appendChild(outerEl);\n        var innerEl = outerEl.firstChild;\n        var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n        removeElement(outerEl);\n        return res;\n    }\n\n    var _scrollbarWidths;\n    function getScrollbarWidths() {\n        if (!_scrollbarWidths) {\n            _scrollbarWidths = computeScrollbarWidths();\n        }\n        return _scrollbarWidths;\n    }\n    function computeScrollbarWidths() {\n        var el = document.createElement('div');\n        el.style.overflow = 'scroll';\n        document.body.appendChild(el);\n        var res = computeScrollbarWidthsForEl(el);\n        document.body.removeChild(el);\n        return res;\n    }\n    // WARNING: will include border\n    function computeScrollbarWidthsForEl(el) {\n        return {\n            x: el.offsetHeight - el.clientHeight,\n            y: el.offsetWidth - el.clientWidth,\n        };\n    }\n\n    function computeEdges(el, getPadding) {\n        if (getPadding === void 0) { getPadding = false; }\n        var computedStyle = window.getComputedStyle(el);\n        var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n        var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n        var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n        var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n        var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n        var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n        var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n        var res = {\n            borderLeft: borderLeft,\n            borderRight: borderRight,\n            borderTop: borderTop,\n            borderBottom: borderBottom,\n            scrollbarBottom: scrollbarBottom,\n            scrollbarLeft: 0,\n            scrollbarRight: 0,\n        };\n        if (getIsRtlScrollbarOnLeft() && computedStyle.direction === 'rtl') { // is the scrollbar on the left side?\n            res.scrollbarLeft = scrollbarLeftRight;\n        }\n        else {\n            res.scrollbarRight = scrollbarLeftRight;\n        }\n        if (getPadding) {\n            res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n            res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n            res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n            res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n        }\n        return res;\n    }\n    function computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n        if (goWithinPadding === void 0) { goWithinPadding = false; }\n        var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n        var edges = computeEdges(el, goWithinPadding);\n        var res = {\n            left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n            right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n            top: outerRect.top + edges.borderTop,\n            bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom,\n        };\n        if (goWithinPadding) {\n            res.left += edges.paddingLeft;\n            res.right -= edges.paddingRight;\n            res.top += edges.paddingTop;\n            res.bottom -= edges.paddingBottom;\n        }\n        return res;\n    }\n    function computeRect(el) {\n        var rect = el.getBoundingClientRect();\n        return {\n            left: rect.left + window.pageXOffset,\n            top: rect.top + window.pageYOffset,\n            right: rect.right + window.pageXOffset,\n            bottom: rect.bottom + window.pageYOffset,\n        };\n    }\n    function computeHeightAndMargins(el) {\n        return el.getBoundingClientRect().height + computeVMargins(el);\n    }\n    function computeVMargins(el) {\n        var computed = window.getComputedStyle(el);\n        return parseInt(computed.marginTop, 10) +\n            parseInt(computed.marginBottom, 10);\n    }\n    // does not return window\n    function getClippingParents(el) {\n        var parents = [];\n        while (el instanceof HTMLElement) { // will stop when gets to document or null\n            var computedStyle = window.getComputedStyle(el);\n            if (computedStyle.position === 'fixed') {\n                break;\n            }\n            if ((/(auto|scroll)/).test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n                parents.push(el);\n            }\n            el = el.parentNode;\n        }\n        return parents;\n    }\n\n    // given a function that resolves a result asynchronously.\n    // the function can either call passed-in success and failure callbacks,\n    // or it can return a promise.\n    // if you need to pass additional params to func, bind them first.\n    function unpromisify(func, success, failure) {\n        // guard against success/failure callbacks being called more than once\n        // and guard against a promise AND callback being used together.\n        var isResolved = false;\n        var wrappedSuccess = function () {\n            if (!isResolved) {\n                isResolved = true;\n                success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n            }\n        };\n        var wrappedFailure = function () {\n            if (!isResolved) {\n                isResolved = true;\n                if (failure) {\n                    failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n                }\n            }\n        };\n        var res = func(wrappedSuccess, wrappedFailure);\n        if (res && typeof res.then === 'function') {\n            res.then(wrappedSuccess, wrappedFailure);\n        }\n    }\n\n    var Emitter = /** @class */ (function () {\n        function Emitter() {\n            this.handlers = {};\n            this.thisContext = null;\n        }\n        Emitter.prototype.setThisContext = function (thisContext) {\n            this.thisContext = thisContext;\n        };\n        Emitter.prototype.setOptions = function (options) {\n            this.options = options;\n        };\n        Emitter.prototype.on = function (type, handler) {\n            addToHash(this.handlers, type, handler);\n        };\n        Emitter.prototype.off = function (type, handler) {\n            removeFromHash(this.handlers, type, handler);\n        };\n        Emitter.prototype.trigger = function (type) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var attachedHandlers = this.handlers[type] || [];\n            var optionHandler = this.options && this.options[type];\n            var handlers = [].concat(optionHandler || [], attachedHandlers);\n            for (var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++) {\n                var handler = handlers_1[_a];\n                handler.apply(this.thisContext, args);\n            }\n        };\n        Emitter.prototype.hasHandlers = function (type) {\n            return (this.handlers[type] && this.handlers[type].length) ||\n                (this.options && this.options[type]);\n        };\n        return Emitter;\n    }());\n    function addToHash(hash, type, handler) {\n        (hash[type] || (hash[type] = []))\n            .push(handler);\n    }\n    function removeFromHash(hash, type, handler) {\n        if (handler) {\n            if (hash[type]) {\n                hash[type] = hash[type].filter(function (func) { return func !== handler; });\n            }\n        }\n        else {\n            delete hash[type]; // remove all handler funcs for this type\n        }\n    }\n\n    /*\n    Records offset information for a set of elements, relative to an origin element.\n    Can record the left/right OR the top/bottom OR both.\n    Provides methods for querying the cache by position.\n    */\n    var PositionCache = /** @class */ (function () {\n        function PositionCache(originEl, els, isHorizontal, isVertical) {\n            this.els = els;\n            var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n            if (isHorizontal) {\n                this.buildElHorizontals(originClientRect.left);\n            }\n            if (isVertical) {\n                this.buildElVerticals(originClientRect.top);\n            }\n        }\n        // Populates the left/right internal coordinate arrays\n        PositionCache.prototype.buildElHorizontals = function (originClientLeft) {\n            var lefts = [];\n            var rights = [];\n            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n                var el = _a[_i];\n                var rect = el.getBoundingClientRect();\n                lefts.push(rect.left - originClientLeft);\n                rights.push(rect.right - originClientLeft);\n            }\n            this.lefts = lefts;\n            this.rights = rights;\n        };\n        // Populates the top/bottom internal coordinate arrays\n        PositionCache.prototype.buildElVerticals = function (originClientTop) {\n            var tops = [];\n            var bottoms = [];\n            for (var _i = 0, _a = this.els; _i < _a.length; _i++) {\n                var el = _a[_i];\n                var rect = el.getBoundingClientRect();\n                tops.push(rect.top - originClientTop);\n                bottoms.push(rect.bottom - originClientTop);\n            }\n            this.tops = tops;\n            this.bottoms = bottoms;\n        };\n        // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n        // If no intersection is made, returns undefined.\n        PositionCache.prototype.leftToIndex = function (leftPosition) {\n            var _a = this, lefts = _a.lefts, rights = _a.rights;\n            var len = lefts.length;\n            var i;\n            for (i = 0; i < len; i += 1) {\n                if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                    return i;\n                }\n            }\n            return undefined; // TODO: better\n        };\n        // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n        // If no intersection is made, returns undefined.\n        PositionCache.prototype.topToIndex = function (topPosition) {\n            var _a = this, tops = _a.tops, bottoms = _a.bottoms;\n            var len = tops.length;\n            var i;\n            for (i = 0; i < len; i += 1) {\n                if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                    return i;\n                }\n            }\n            return undefined; // TODO: better\n        };\n        // Gets the width of the element at the given index\n        PositionCache.prototype.getWidth = function (leftIndex) {\n            return this.rights[leftIndex] - this.lefts[leftIndex];\n        };\n        // Gets the height of the element at the given index\n        PositionCache.prototype.getHeight = function (topIndex) {\n            return this.bottoms[topIndex] - this.tops[topIndex];\n        };\n        return PositionCache;\n    }());\n\n    /* eslint max-classes-per-file: \"off\" */\n    /*\n    An object for getting/setting scroll-related information for an element.\n    Internally, this is done very differently for window versus DOM element,\n    so this object serves as a common interface.\n    */\n    var ScrollController = /** @class */ (function () {\n        function ScrollController() {\n        }\n        ScrollController.prototype.getMaxScrollTop = function () {\n            return this.getScrollHeight() - this.getClientHeight();\n        };\n        ScrollController.prototype.getMaxScrollLeft = function () {\n            return this.getScrollWidth() - this.getClientWidth();\n        };\n        ScrollController.prototype.canScrollVertically = function () {\n            return this.getMaxScrollTop() > 0;\n        };\n        ScrollController.prototype.canScrollHorizontally = function () {\n            return this.getMaxScrollLeft() > 0;\n        };\n        ScrollController.prototype.canScrollUp = function () {\n            return this.getScrollTop() > 0;\n        };\n        ScrollController.prototype.canScrollDown = function () {\n            return this.getScrollTop() < this.getMaxScrollTop();\n        };\n        ScrollController.prototype.canScrollLeft = function () {\n            return this.getScrollLeft() > 0;\n        };\n        ScrollController.prototype.canScrollRight = function () {\n            return this.getScrollLeft() < this.getMaxScrollLeft();\n        };\n        return ScrollController;\n    }());\n    var ElementScrollController = /** @class */ (function (_super) {\n        __extends(ElementScrollController, _super);\n        function ElementScrollController(el) {\n            var _this = _super.call(this) || this;\n            _this.el = el;\n            return _this;\n        }\n        ElementScrollController.prototype.getScrollTop = function () {\n            return this.el.scrollTop;\n        };\n        ElementScrollController.prototype.getScrollLeft = function () {\n            return this.el.scrollLeft;\n        };\n        ElementScrollController.prototype.setScrollTop = function (top) {\n            this.el.scrollTop = top;\n        };\n        ElementScrollController.prototype.setScrollLeft = function (left) {\n            this.el.scrollLeft = left;\n        };\n        ElementScrollController.prototype.getScrollWidth = function () {\n            return this.el.scrollWidth;\n        };\n        ElementScrollController.prototype.getScrollHeight = function () {\n            return this.el.scrollHeight;\n        };\n        ElementScrollController.prototype.getClientHeight = function () {\n            return this.el.clientHeight;\n        };\n        ElementScrollController.prototype.getClientWidth = function () {\n            return this.el.clientWidth;\n        };\n        return ElementScrollController;\n    }(ScrollController));\n    var WindowScrollController = /** @class */ (function (_super) {\n        __extends(WindowScrollController, _super);\n        function WindowScrollController() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        WindowScrollController.prototype.getScrollTop = function () {\n            return window.pageYOffset;\n        };\n        WindowScrollController.prototype.getScrollLeft = function () {\n            return window.pageXOffset;\n        };\n        WindowScrollController.prototype.setScrollTop = function (n) {\n            window.scroll(window.pageXOffset, n);\n        };\n        WindowScrollController.prototype.setScrollLeft = function (n) {\n            window.scroll(n, window.pageYOffset);\n        };\n        WindowScrollController.prototype.getScrollWidth = function () {\n            return document.documentElement.scrollWidth;\n        };\n        WindowScrollController.prototype.getScrollHeight = function () {\n            return document.documentElement.scrollHeight;\n        };\n        WindowScrollController.prototype.getClientHeight = function () {\n            return document.documentElement.clientHeight;\n        };\n        WindowScrollController.prototype.getClientWidth = function () {\n            return document.documentElement.clientWidth;\n        };\n        return WindowScrollController;\n    }(ScrollController));\n\n    var Theme = /** @class */ (function () {\n        function Theme(calendarOptions) {\n            if (this.iconOverrideOption) {\n                this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n            }\n        }\n        Theme.prototype.setIconOverride = function (iconOverrideHash) {\n            var iconClassesCopy;\n            var buttonName;\n            if (typeof iconOverrideHash === 'object' && iconOverrideHash) { // non-null object\n                iconClassesCopy = __assign({}, this.iconClasses);\n                for (buttonName in iconOverrideHash) {\n                    iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n                }\n                this.iconClasses = iconClassesCopy;\n            }\n            else if (iconOverrideHash === false) {\n                this.iconClasses = {};\n            }\n        };\n        Theme.prototype.applyIconOverridePrefix = function (className) {\n            var prefix = this.iconOverridePrefix;\n            if (prefix && className.indexOf(prefix) !== 0) { // if not already present\n                className = prefix + className;\n            }\n            return className;\n        };\n        Theme.prototype.getClass = function (key) {\n            return this.classes[key] || '';\n        };\n        Theme.prototype.getIconClass = function (buttonName, isRtl) {\n            var className;\n            if (isRtl && this.rtlIconClasses) {\n                className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n            }\n            else {\n                className = this.iconClasses[buttonName];\n            }\n            if (className) {\n                return this.baseIconClass + \" \" + className;\n            }\n            return '';\n        };\n        Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {\n            var className;\n            if (this.iconOverrideCustomButtonOption) {\n                className = customButtonProps[this.iconOverrideCustomButtonOption];\n                if (className) {\n                    return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n                }\n            }\n            return '';\n        };\n        return Theme;\n    }());\n    Theme.prototype.classes = {};\n    Theme.prototype.iconClasses = {};\n    Theme.prototype.baseIconClass = '';\n    Theme.prototype.iconOverridePrefix = '';\n\n    /// <reference types=\"@fullcalendar/core-preact\" />\n    if (typeof FullCalendarVDom === 'undefined') {\n        throw new Error('Please import the top-level fullcalendar lib before attempting to import a plugin.');\n    }\n    var Component = FullCalendarVDom.Component;\n    var createElement = FullCalendarVDom.createElement;\n    var render = FullCalendarVDom.render;\n    var createRef = FullCalendarVDom.createRef;\n    var Fragment = FullCalendarVDom.Fragment;\n    var createContext$1 = FullCalendarVDom.createContext;\n    var flushToDom$1 = FullCalendarVDom.flushToDom;\n    var unmountComponentAtNode$1 = FullCalendarVDom.unmountComponentAtNode;\n\n    var ScrollResponder = /** @class */ (function () {\n        function ScrollResponder(execFunc, emitter, scrollTime) {\n            var _this = this;\n            this.execFunc = execFunc;\n            this.emitter = emitter;\n            this.scrollTime = scrollTime;\n            this.handleScrollRequest = function (request) {\n                _this.queuedRequest = __assign({}, _this.queuedRequest || {}, request);\n                _this.drain();\n            };\n            emitter.on('_scrollRequest', this.handleScrollRequest);\n            this.fireInitialScroll();\n        }\n        ScrollResponder.prototype.detach = function () {\n            this.emitter.off('_scrollRequest', this.handleScrollRequest);\n        };\n        ScrollResponder.prototype.update = function (isDatesNew) {\n            if (isDatesNew) {\n                this.fireInitialScroll(); // will drain\n            }\n            else {\n                this.drain();\n            }\n        };\n        ScrollResponder.prototype.fireInitialScroll = function () {\n            this.handleScrollRequest({\n                time: this.scrollTime,\n            });\n        };\n        ScrollResponder.prototype.drain = function () {\n            if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n                this.queuedRequest = null;\n            }\n        };\n        return ScrollResponder;\n    }());\n\n    var ViewContextType = createContext$1({}); // for Components\n    function buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n        return {\n            dateEnv: dateEnv,\n            options: viewOptions,\n            pluginHooks: pluginHooks,\n            emitter: emitter,\n            dispatch: dispatch,\n            getCurrentData: getCurrentData,\n            calendarApi: calendarApi,\n            viewSpec: viewSpec,\n            viewApi: viewApi,\n            dateProfileGenerator: dateProfileGenerator,\n            theme: theme,\n            isRtl: viewOptions.direction === 'rtl',\n            addResizeHandler: function (handler) {\n                emitter.on('_resize', handler);\n            },\n            removeResizeHandler: function (handler) {\n                emitter.off('_resize', handler);\n            },\n            createScrollResponder: function (execFunc) {\n                return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime));\n            },\n            registerInteractiveComponent: registerInteractiveComponent,\n            unregisterInteractiveComponent: unregisterInteractiveComponent,\n        };\n    }\n\n    /* eslint max-classes-per-file: off */\n    var PureComponent = /** @class */ (function (_super) {\n        __extends(PureComponent, _super);\n        function PureComponent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        PureComponent.prototype.shouldComponentUpdate = function (nextProps, nextState) {\n            if (this.debug) {\n                // eslint-disable-next-line no-console\n                console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n            }\n            return !compareObjs(this.props, nextProps, this.propEquality) ||\n                !compareObjs(this.state, nextState, this.stateEquality);\n        };\n        PureComponent.addPropsEquality = addPropsEquality;\n        PureComponent.addStateEquality = addStateEquality;\n        PureComponent.contextType = ViewContextType;\n        return PureComponent;\n    }(Component));\n    PureComponent.prototype.propEquality = {};\n    PureComponent.prototype.stateEquality = {};\n    var BaseComponent = /** @class */ (function (_super) {\n        __extends(BaseComponent, _super);\n        function BaseComponent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        BaseComponent.contextType = ViewContextType;\n        return BaseComponent;\n    }(PureComponent));\n    function addPropsEquality(propEquality) {\n        var hash = Object.create(this.prototype.propEquality);\n        __assign(hash, propEquality);\n        this.prototype.propEquality = hash;\n    }\n    function addStateEquality(stateEquality) {\n        var hash = Object.create(this.prototype.stateEquality);\n        __assign(hash, stateEquality);\n        this.prototype.stateEquality = hash;\n    }\n    // use other one\n    function setRef(ref, current) {\n        if (typeof ref === 'function') {\n            ref(current);\n        }\n        else if (ref) {\n            // see https://github.com/facebook/react/issues/13029\n            ref.current = current;\n        }\n    }\n\n    function reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n        switch (action.type) {\n            case 'RECEIVE_EVENTS': // raw\n                return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n            case 'ADD_EVENTS': // already parsed, but not expanded\n                return addEvent(eventStore, action.eventStore, // new ones\n                dateProfile ? dateProfile.activeRange : null, context);\n            case 'MERGE_EVENTS': // already parsed and expanded\n                return mergeEventStores(eventStore, action.eventStore);\n            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n            case 'NEXT':\n            case 'CHANGE_DATE':\n            case 'CHANGE_VIEW_TYPE':\n                if (dateProfile) {\n                    return expandRecurring(eventStore, dateProfile.activeRange, context);\n                }\n                return eventStore;\n            case 'REMOVE_EVENTS':\n                return excludeSubEventStore(eventStore, action.eventStore);\n            case 'REMOVE_EVENT_SOURCE':\n                return excludeEventsBySourceId(eventStore, action.sourceId);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return filterEventStoreDefs(eventStore, function (eventDef) { return (!eventDef.sourceId // only keep events with no source id\n                ); });\n            case 'REMOVE_ALL_EVENTS':\n                return createEmptyEventStore();\n            default:\n                return eventStore;\n        }\n    }\n    function receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n        if (eventSource && // not already removed\n            fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n        ) {\n            var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n            if (fetchRange) {\n                subset = expandRecurring(subset, fetchRange, context);\n            }\n            return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n        }\n        return eventStore;\n    }\n    function transformRawEvents(rawEvents, eventSource, context) {\n        var calEachTransform = context.options.eventDataTransform;\n        var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n        if (sourceEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n        }\n        if (calEachTransform) {\n            rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n        }\n        return rawEvents;\n    }\n    function transformEachRawEvent(rawEvents, func) {\n        var refinedEvents;\n        if (!func) {\n            refinedEvents = rawEvents;\n        }\n        else {\n            refinedEvents = [];\n            for (var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++) {\n                var rawEvent = rawEvents_1[_i];\n                var refinedEvent = func(rawEvent);\n                if (refinedEvent) {\n                    refinedEvents.push(refinedEvent);\n                }\n                else if (refinedEvent == null) {\n                    refinedEvents.push(rawEvent);\n                } // if a different falsy value, do nothing\n            }\n        }\n        return refinedEvents;\n    }\n    function addEvent(eventStore, subset, expandRange, context) {\n        if (expandRange) {\n            subset = expandRecurring(subset, expandRange, context);\n        }\n        return mergeEventStores(eventStore, subset);\n    }\n    function rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n        var defs = eventStore.defs;\n        var instances = mapHash(eventStore.instances, function (instance) {\n            var def = defs[instance.defId];\n            if (def.allDay || def.recurringDef) {\n                return instance; // isn't dependent on timezone\n            }\n            return __assign(__assign({}, instance), { range: {\n                    start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                    end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo)),\n                }, forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo, forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo });\n        });\n        return { defs: defs, instances: instances };\n    }\n    function excludeEventsBySourceId(eventStore, sourceId) {\n        return filterEventStoreDefs(eventStore, function (eventDef) { return eventDef.sourceId !== sourceId; });\n    }\n    // QUESTION: why not just return instances? do a general object-property-exclusion util\n    function excludeInstances(eventStore, removals) {\n        return {\n            defs: eventStore.defs,\n            instances: filterHash(eventStore.instances, function (instance) { return !removals[instance.instanceId]; }),\n        };\n    }\n\n    // high-level segmenting-aware tester functions\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionValid(interaction, context) {\n        return isNewPropsValid({ eventDrag: interaction }, context); // HACK: the eventDrag props is used for ALL interactions\n    }\n    function isDateSelectionValid(dateSelection, context) {\n        return isNewPropsValid({ dateSelection: dateSelection }, context);\n    }\n    function isNewPropsValid(newProps, context) {\n        var calendarState = context.getCurrentData();\n        var props = __assign({ businessHours: calendarState.businessHours, dateSelection: '', eventStore: calendarState.eventStore, eventUiBases: calendarState.eventUiBases, eventSelection: '', eventDrag: null, eventResize: null }, newProps);\n        return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n    }\n    function isPropsValid(state, context, dateSpanMeta, filterConfig) {\n        if (dateSpanMeta === void 0) { dateSpanMeta = {}; }\n        if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n            return false;\n        }\n        return true;\n    }\n    // Moving Event Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n        var currentState = context.getCurrentData();\n        var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n        var subjectEventStore = interaction.mutatedEvents;\n        var subjectDefs = subjectEventStore.defs;\n        var subjectInstances = subjectEventStore.instances;\n        var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ?\n            state.eventUiBases :\n            { '': currentState.selectionConfig });\n        if (filterConfig) {\n            subjectConfigs = mapHash(subjectConfigs, filterConfig);\n        }\n        // exclude the subject events. TODO: exclude defs too?\n        var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n        var otherDefs = otherEventStore.defs;\n        var otherInstances = otherEventStore.instances;\n        var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n        for (var subjectInstanceId in subjectInstances) {\n            var subjectInstance = subjectInstances[subjectInstanceId];\n            var subjectRange = subjectInstance.range;\n            var subjectConfig = subjectConfigs[subjectInstance.defId];\n            var subjectDef = subjectDefs[subjectInstance.defId];\n            // constraint\n            if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n                return false;\n            }\n            // overlap\n            var eventOverlap = context.options.eventOverlap;\n            var eventOverlapFunc = typeof eventOverlap === 'function' ? eventOverlap : null;\n            for (var otherInstanceId in otherInstances) {\n                var otherInstance = otherInstances[otherInstanceId];\n                // intersect! evaluate\n                if (rangesIntersect(subjectRange, otherInstance.range)) {\n                    var otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                    // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                    if (otherOverlap === false && interaction.isEvent) {\n                        return false;\n                    }\n                    if (subjectConfig.overlap === false) {\n                        return false;\n                    }\n                    if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), // still event\n                    new EventApi(context, subjectDef, subjectInstance))) {\n                        return false;\n                    }\n                }\n            }\n            // allow (a function)\n            var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n            for (var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++) {\n                var subjectAllow = _a[_i];\n                var subjectDateSpan = __assign(__assign({}, dateSpanMeta), { range: subjectInstance.range, allDay: subjectDef.allDay });\n                var origDef = calendarEventStore.defs[subjectDef.defId];\n                var origInstance = calendarEventStore.instances[subjectInstanceId];\n                var eventApi = void 0;\n                if (origDef) { // was previously in the calendar\n                    eventApi = new EventApi(context, origDef, origInstance);\n                }\n                else { // was an external event\n                    eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n                }\n                if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    // Date Selection Validation\n    // ------------------------------------------------------------------------------------------------------------------------\n    function isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n        var relevantEventStore = state.eventStore;\n        var relevantDefs = relevantEventStore.defs;\n        var relevantInstances = relevantEventStore.instances;\n        var selection = state.dateSelection;\n        var selectionRange = selection.range;\n        var selectionConfig = context.getCurrentData().selectionConfig;\n        if (filterConfig) {\n            selectionConfig = filterConfig(selectionConfig);\n        }\n        // constraint\n        if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        var selectOverlap = context.options.selectOverlap;\n        var selectOverlapFunc = typeof selectOverlap === 'function' ? selectOverlap : null;\n        for (var relevantInstanceId in relevantInstances) {\n            var relevantInstance = relevantInstances[relevantInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(selectionRange, relevantInstance.range)) {\n                if (selectionConfig.overlap === false) {\n                    return false;\n                }\n                if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        for (var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++) {\n            var selectionAllow = _a[_i];\n            var fullDateSpan = __assign(__assign({}, dateSpanMeta), selection);\n            if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Constraint Utils\n    // ------------------------------------------------------------------------------------------------------------------------\n    function allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n        for (var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++) {\n            var constraint = constraints_1[_i];\n            if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    function constraintToRanges(constraint, subjectRange, // for expanding a recurring constraint, or expanding business hours\n    otherEventStore, // for if constraint is an even group ID\n    businessHoursUnexpanded, // for if constraint is 'businessHours'\n    context) {\n        if (constraint === 'businessHours') {\n            return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n        }\n        if (typeof constraint === 'string') { // an group ID\n            return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function (eventDef) { return eventDef.groupId === constraint; }));\n        }\n        if (typeof constraint === 'object' && constraint) { // non-null object\n            return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n        }\n        return []; // if it's false\n    }\n    // TODO: move to event-store file?\n    function eventStoreToRanges(eventStore) {\n        var instances = eventStore.instances;\n        var ranges = [];\n        for (var instanceId in instances) {\n            ranges.push(instances[instanceId].range);\n        }\n        return ranges;\n    }\n    // TODO: move to geom file?\n    function anyRangesContainRange(outerRanges, innerRange) {\n        for (var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++) {\n            var outerRange = outerRanges_1[_i];\n            if (rangeContainsRange(outerRange, innerRange)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /*\n    an INTERACTABLE date component\n\n    PURPOSES:\n    - hook up to fg, fill, and mirror renderers\n    - interface for dragging and hits\n    */\n    var DateComponent = /** @class */ (function (_super) {\n        __extends(DateComponent, _super);\n        function DateComponent() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.uid = guid();\n            return _this;\n        }\n        // Hit System\n        // -----------------------------------------------------------------------------------------------------------------\n        DateComponent.prototype.prepareHits = function () {\n        };\n        DateComponent.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n            return null; // this should be abstract\n        };\n        // Validation\n        // -----------------------------------------------------------------------------------------------------------------\n        DateComponent.prototype.isInteractionValid = function (interaction) {\n            var dateProfile = this.props.dateProfile; // HACK\n            var instances = interaction.mutatedEvents.instances;\n            if (dateProfile) { // HACK for MorePopover\n                for (var instanceId in instances) {\n                    if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n                        return false;\n                    }\n                }\n            }\n            return isInteractionValid(interaction, this.context);\n        };\n        DateComponent.prototype.isDateSelectionValid = function (selection) {\n            var dateProfile = this.props.dateProfile; // HACK\n            if (dateProfile && // HACK for MorePopover\n                !rangeContainsRange(dateProfile.validRange, selection.range)) {\n                return false;\n            }\n            return isDateSelectionValid(selection, this.context);\n        };\n        // Pointer Interaction Utils\n        // -----------------------------------------------------------------------------------------------------------------\n        DateComponent.prototype.isValidSegDownEl = function (el) {\n            return !this.props.eventDrag && // HACK\n                !this.props.eventResize && // HACK\n                !elementClosest(el, '.fc-event-mirror') &&\n                (this.isPopover() || !this.isInPopover(el));\n            // ^above line ensures we don't detect a seg interaction within a nested component.\n            // it's a HACK because it only supports a popover as the nested component.\n        };\n        DateComponent.prototype.isValidDateDownEl = function (el) {\n            return !elementClosest(el, '.fc-event:not(.fc-bg-event)') &&\n                !elementClosest(el, '.fc-daygrid-more-link') && // a \"more..\" link\n                !elementClosest(el, 'a[data-navlink]') && // a clickable nav link\n                !this.isInPopover(el);\n        };\n        DateComponent.prototype.isPopover = function () {\n            return false;\n        };\n        DateComponent.prototype.isInPopover = function (el) {\n            return Boolean(elementClosest(el, '.fc-popover'));\n        };\n        return DateComponent;\n    }(BaseComponent));\n\n    // TODO: easier way to add new hooks? need to update a million things\n    function createPlugin(input) {\n        return {\n            id: guid(),\n            deps: input.deps || [],\n            reducers: input.reducers || [],\n            contextInit: [].concat(input.contextInit || []),\n            eventRefiners: input.eventRefiners || {},\n            eventDefMemberAdders: input.eventDefMemberAdders || [],\n            eventSourceRefiners: input.eventSourceRefiners || {},\n            isDraggableTransformers: input.isDraggableTransformers || [],\n            eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n            eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n            dateSelectionTransformers: input.dateSelectionTransformers || [],\n            datePointTransforms: input.datePointTransforms || [],\n            dateSpanTransforms: input.dateSpanTransforms || [],\n            views: input.views || {},\n            viewPropsTransformers: input.viewPropsTransformers || [],\n            isPropsValid: input.isPropsValid || null,\n            externalDefTransforms: input.externalDefTransforms || [],\n            eventResizeJoinTransforms: input.eventResizeJoinTransforms || [],\n            viewContainerAppends: input.viewContainerAppends || [],\n            eventDropTransformers: input.eventDropTransformers || [],\n            componentInteractions: input.componentInteractions || [],\n            calendarInteractions: input.calendarInteractions || [],\n            themeClasses: input.themeClasses || {},\n            eventSourceDefs: input.eventSourceDefs || [],\n            cmdFormatter: input.cmdFormatter,\n            recurringTypes: input.recurringTypes || [],\n            namedTimeZonedImpl: input.namedTimeZonedImpl,\n            initialView: input.initialView || '',\n            elementDraggingImpl: input.elementDraggingImpl,\n            optionChangeHandlers: input.optionChangeHandlers || {},\n            scrollGridImpl: input.scrollGridImpl || null,\n            contentTypeHandlers: input.contentTypeHandlers || {},\n            listenerRefiners: input.listenerRefiners || {},\n            optionRefiners: input.optionRefiners || {},\n            propSetHandlers: input.propSetHandlers || {},\n        };\n    }\n    function buildPluginHooks(pluginDefs, globalDefs) {\n        var isAdded = {};\n        var hooks = {\n            reducers: [],\n            contextInit: [],\n            eventRefiners: {},\n            eventDefMemberAdders: [],\n            eventSourceRefiners: {},\n            isDraggableTransformers: [],\n            eventDragMutationMassagers: [],\n            eventDefMutationAppliers: [],\n            dateSelectionTransformers: [],\n            datePointTransforms: [],\n            dateSpanTransforms: [],\n            views: {},\n            viewPropsTransformers: [],\n            isPropsValid: null,\n            externalDefTransforms: [],\n            eventResizeJoinTransforms: [],\n            viewContainerAppends: [],\n            eventDropTransformers: [],\n            componentInteractions: [],\n            calendarInteractions: [],\n            themeClasses: {},\n            eventSourceDefs: [],\n            cmdFormatter: null,\n            recurringTypes: [],\n            namedTimeZonedImpl: null,\n            initialView: '',\n            elementDraggingImpl: null,\n            optionChangeHandlers: {},\n            scrollGridImpl: null,\n            contentTypeHandlers: {},\n            listenerRefiners: {},\n            optionRefiners: {},\n            propSetHandlers: {},\n        };\n        function addDefs(defs) {\n            for (var _i = 0, defs_1 = defs; _i < defs_1.length; _i++) {\n                var def = defs_1[_i];\n                if (!isAdded[def.id]) {\n                    isAdded[def.id] = true;\n                    addDefs(def.deps);\n                    hooks = combineHooks(hooks, def);\n                }\n            }\n        }\n        if (pluginDefs) {\n            addDefs(pluginDefs);\n        }\n        addDefs(globalDefs);\n        return hooks;\n    }\n    function buildBuildPluginHooks() {\n        var currentOverrideDefs = [];\n        var currentGlobalDefs = [];\n        var currentHooks;\n        return function (overrideDefs, globalDefs) {\n            if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n                currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n            }\n            currentOverrideDefs = overrideDefs;\n            currentGlobalDefs = globalDefs;\n            return currentHooks;\n        };\n    }\n    function combineHooks(hooks0, hooks1) {\n        return {\n            reducers: hooks0.reducers.concat(hooks1.reducers),\n            contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n            eventRefiners: __assign(__assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n            eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n            eventSourceRefiners: __assign(__assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n            isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n            eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n            eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n            dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n            datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n            dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n            views: __assign(__assign({}, hooks0.views), hooks1.views),\n            viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n            isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n            externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n            eventResizeJoinTransforms: hooks0.eventResizeJoinTransforms.concat(hooks1.eventResizeJoinTransforms),\n            viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n            eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n            calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n            componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n            themeClasses: __assign(__assign({}, hooks0.themeClasses), hooks1.themeClasses),\n            eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n            cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n            recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n            namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n            initialView: hooks0.initialView || hooks1.initialView,\n            elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n            optionChangeHandlers: __assign(__assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n            scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n            contentTypeHandlers: __assign(__assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n            listenerRefiners: __assign(__assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n            optionRefiners: __assign(__assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n            propSetHandlers: __assign(__assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers),\n        };\n    }\n\n    var StandardTheme = /** @class */ (function (_super) {\n        __extends(StandardTheme, _super);\n        function StandardTheme() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return StandardTheme;\n    }(Theme));\n    StandardTheme.prototype.classes = {\n        root: 'fc-theme-standard',\n        tableCellShaded: 'fc-cell-shaded',\n        buttonGroup: 'fc-button-group',\n        button: 'fc-button fc-button-primary',\n        buttonActive: 'fc-button-active',\n    };\n    StandardTheme.prototype.baseIconClass = 'fc-icon';\n    StandardTheme.prototype.iconClasses = {\n        close: 'fc-icon-x',\n        prev: 'fc-icon-chevron-left',\n        next: 'fc-icon-chevron-right',\n        prevYear: 'fc-icon-chevrons-left',\n        nextYear: 'fc-icon-chevrons-right',\n    };\n    StandardTheme.prototype.rtlIconClasses = {\n        prev: 'fc-icon-chevron-right',\n        next: 'fc-icon-chevron-left',\n        prevYear: 'fc-icon-chevrons-right',\n        nextYear: 'fc-icon-chevrons-left',\n    };\n    StandardTheme.prototype.iconOverrideOption = 'buttonIcons'; // TODO: make TS-friendly\n    StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';\n    StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';\n\n    function compileViewDefs(defaultConfigs, overrideConfigs) {\n        var hash = {};\n        var viewType;\n        for (viewType in defaultConfigs) {\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        for (viewType in overrideConfigs) {\n            ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        }\n        return hash;\n    }\n    function ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        if (hash[viewType]) {\n            return hash[viewType];\n        }\n        var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n        if (viewDef) {\n            hash[viewType] = viewDef;\n        }\n        return viewDef;\n    }\n    function buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n        var defaultConfig = defaultConfigs[viewType];\n        var overrideConfig = overrideConfigs[viewType];\n        var queryProp = function (name) { return ((defaultConfig && defaultConfig[name] !== null) ? defaultConfig[name] :\n            ((overrideConfig && overrideConfig[name] !== null) ? overrideConfig[name] : null)); };\n        var theComponent = queryProp('component');\n        var superType = queryProp('superType');\n        var superDef = null;\n        if (superType) {\n            if (superType === viewType) {\n                throw new Error('Can\\'t have a custom view type that references itself');\n            }\n            superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n        }\n        if (!theComponent && superDef) {\n            theComponent = superDef.component;\n        }\n        if (!theComponent) {\n            return null; // don't throw a warning, might be settings for a single-unit view\n        }\n        return {\n            type: viewType,\n            component: theComponent,\n            defaults: __assign(__assign({}, (superDef ? superDef.defaults : {})), (defaultConfig ? defaultConfig.rawOptions : {})),\n            overrides: __assign(__assign({}, (superDef ? superDef.overrides : {})), (overrideConfig ? overrideConfig.rawOptions : {})),\n        };\n    }\n\n    /* eslint max-classes-per-file: off */\n    // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\n    var RenderHook = /** @class */ (function (_super) {\n        __extends(RenderHook, _super);\n        function RenderHook() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.rootElRef = createRef();\n            _this.handleRootEl = function (el) {\n                setRef(_this.rootElRef, el);\n                if (_this.props.elRef) {\n                    setRef(_this.props.elRef, el);\n                }\n            };\n            return _this;\n        }\n        RenderHook.prototype.render = function () {\n            var _this = this;\n            var props = this.props;\n            var hookProps = props.hookProps;\n            return (createElement(MountHook, { hookProps: hookProps, didMount: props.didMount, willUnmount: props.willUnmount, elRef: this.handleRootEl }, function (rootElRef) { return (createElement(ContentHook, { hookProps: hookProps, content: props.content, defaultContent: props.defaultContent, backupElRef: _this.rootElRef }, function (innerElRef, innerContent) { return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent); })); }));\n        };\n        return RenderHook;\n    }(BaseComponent));\n    // TODO: rename to be about function, not default. use in above type\n    // for forcing rerender of components that use the ContentHook\n    var CustomContentRenderContext = createContext$1(0);\n    function ContentHook(props) {\n        return (createElement(CustomContentRenderContext.Consumer, null, function (renderId) { return (createElement(ContentHookInner, __assign({ renderId: renderId }, props))); }));\n    }\n    var ContentHookInner = /** @class */ (function (_super) {\n        __extends(ContentHookInner, _super);\n        function ContentHookInner() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.innerElRef = createRef();\n            return _this;\n        }\n        ContentHookInner.prototype.render = function () {\n            return this.props.children(this.innerElRef, this.renderInnerContent());\n        };\n        ContentHookInner.prototype.componentDidMount = function () {\n            this.updateCustomContent();\n        };\n        ContentHookInner.prototype.componentDidUpdate = function () {\n            this.updateCustomContent();\n        };\n        ContentHookInner.prototype.componentWillUnmount = function () {\n            if (this.customContentInfo && this.customContentInfo.destroy) {\n                this.customContentInfo.destroy();\n            }\n        };\n        ContentHookInner.prototype.renderInnerContent = function () {\n            var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n            var _a = this, props = _a.props, customContentInfo = _a.customContentInfo;\n            var rawVal = props.content;\n            var innerContent = normalizeContent(rawVal, props.hookProps);\n            var innerContentVDom = null;\n            if (innerContent === undefined) { // use the default\n                innerContent = normalizeContent(props.defaultContent, props.hookProps);\n            }\n            if (innerContent !== undefined) { // we allow custom content handlers to return nothing\n                if (customContentInfo) {\n                    customContentInfo.contentVal = innerContent[customContentInfo.contentKey];\n                }\n                else if (typeof innerContent === 'object') {\n                    // look for a prop that would indicate a custom content handler is needed\n                    for (var contentKey in contentTypeHandlers) {\n                        if (innerContent[contentKey] !== undefined) {\n                            var stuff = contentTypeHandlers[contentKey]();\n                            customContentInfo = this.customContentInfo = __assign({ contentKey: contentKey, contentVal: innerContent[contentKey] }, stuff);\n                            break;\n                        }\n                    }\n                }\n                if (customContentInfo) {\n                    innerContentVDom = []; // signal that something was specified\n                }\n                else {\n                    innerContentVDom = innerContent; // assume a [p]react vdom node. use it\n                }\n            }\n            return innerContentVDom;\n        };\n        ContentHookInner.prototype.updateCustomContent = function () {\n            if (this.customContentInfo) {\n                this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, // the element to render into\n                this.customContentInfo.contentVal);\n            }\n        };\n        return ContentHookInner;\n    }(BaseComponent));\n    var MountHook = /** @class */ (function (_super) {\n        __extends(MountHook, _super);\n        function MountHook() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.handleRootEl = function (rootEl) {\n                _this.rootEl = rootEl;\n                if (_this.props.elRef) {\n                    setRef(_this.props.elRef, rootEl);\n                }\n            };\n            return _this;\n        }\n        MountHook.prototype.render = function () {\n            return this.props.children(this.handleRootEl);\n        };\n        MountHook.prototype.componentDidMount = function () {\n            var callback = this.props.didMount;\n            if (callback) {\n                callback(__assign(__assign({}, this.props.hookProps), { el: this.rootEl }));\n            }\n        };\n        MountHook.prototype.componentWillUnmount = function () {\n            var callback = this.props.willUnmount;\n            if (callback) {\n                callback(__assign(__assign({}, this.props.hookProps), { el: this.rootEl }));\n            }\n        };\n        return MountHook;\n    }(BaseComponent));\n    function buildClassNameNormalizer() {\n        var currentGenerator;\n        var currentHookProps;\n        var currentClassNames = [];\n        return function (generator, hookProps) {\n            if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n                currentGenerator = generator;\n                currentHookProps = hookProps;\n                currentClassNames = normalizeClassNames(generator, hookProps);\n            }\n            return currentClassNames;\n        };\n    }\n    function normalizeClassNames(classNames, hookProps) {\n        if (typeof classNames === 'function') {\n            classNames = classNames(hookProps);\n        }\n        return parseClassNames(classNames);\n    }\n    function normalizeContent(input, hookProps) {\n        if (typeof input === 'function') {\n            return input(hookProps, createElement); // give the function the vdom-creation func\n        }\n        return input;\n    }\n\n    var ViewRoot = /** @class */ (function (_super) {\n        __extends(ViewRoot, _super);\n        function ViewRoot() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.normalizeClassNames = buildClassNameNormalizer();\n            return _this;\n        }\n        ViewRoot.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var options = context.options;\n            var hookProps = { view: context.viewApi };\n            var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n            return (createElement(MountHook, { hookProps: hookProps, didMount: options.viewDidMount, willUnmount: options.viewWillUnmount, elRef: props.elRef }, function (rootElRef) { return props.children(rootElRef, [\"fc-\" + props.viewSpec.type + \"-view\", 'fc-view'].concat(customClassNames)); }));\n        };\n        return ViewRoot;\n    }(BaseComponent));\n\n    function parseViewConfigs(inputs) {\n        return mapHash(inputs, parseViewConfig);\n    }\n    function parseViewConfig(input) {\n        var rawOptions = typeof input === 'function' ?\n            { component: input } :\n            input;\n        var component = rawOptions.component;\n        if (rawOptions.content) {\n            component = createViewHookComponent(rawOptions);\n            // TODO: remove content/classNames/didMount/etc from options?\n        }\n        return {\n            superType: rawOptions.type,\n            component: component,\n            rawOptions: rawOptions,\n        };\n    }\n    function createViewHookComponent(options) {\n        return function (viewProps) { return (createElement(ViewContextType.Consumer, null, function (context) { return (createElement(ViewRoot, { viewSpec: context.viewSpec }, function (viewElRef, viewClassNames) {\n            var hookProps = __assign(__assign({}, viewProps), { nextDayThreshold: context.options.nextDayThreshold });\n            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.classNames, content: options.content, didMount: options.didMount, willUnmount: options.willUnmount, elRef: viewElRef }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement(\"div\", { className: viewClassNames.concat(customClassNames).join(' '), ref: rootElRef }, innerContent)); }));\n        })); })); };\n    }\n\n    function buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n        var defaultConfigs = parseViewConfigs(defaultInputs);\n        var overrideConfigs = parseViewConfigs(optionOverrides.views);\n        var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n        return mapHash(viewDefs, function (viewDef) { return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults); });\n    }\n    function buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n        var durationInput = viewDef.overrides.duration ||\n            viewDef.defaults.duration ||\n            dynamicOptionOverrides.duration ||\n            optionOverrides.duration;\n        var duration = null;\n        var durationUnit = '';\n        var singleUnit = '';\n        var singleUnitOverrides = {};\n        if (durationInput) {\n            duration = createDurationCached(durationInput);\n            if (duration) { // valid?\n                var denom = greatestDurationDenominator(duration);\n                durationUnit = denom.unit;\n                if (denom.value === 1) {\n                    singleUnit = durationUnit;\n                    singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n                }\n            }\n        }\n        var queryButtonText = function (optionsSubset) {\n            var buttonTextMap = optionsSubset.buttonText || {};\n            var buttonTextKey = viewDef.defaults.buttonTextKey;\n            if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n                return buttonTextMap[buttonTextKey];\n            }\n            if (buttonTextMap[viewDef.type] != null) {\n                return buttonTextMap[viewDef.type];\n            }\n            if (buttonTextMap[singleUnit] != null) {\n                return buttonTextMap[singleUnit];\n            }\n            return null;\n        };\n        return {\n            type: viewDef.type,\n            component: viewDef.component,\n            duration: duration,\n            durationUnit: durationUnit,\n            singleUnit: singleUnit,\n            optionDefaults: viewDef.defaults,\n            optionOverrides: __assign(__assign({}, singleUnitOverrides), viewDef.overrides),\n            buttonTextOverride: queryButtonText(dynamicOptionOverrides) ||\n                queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n                viewDef.overrides.buttonText,\n            buttonTextDefault: queryButtonText(localeDefaults) ||\n                viewDef.defaults.buttonText ||\n                queryButtonText(BASE_OPTION_DEFAULTS) ||\n                viewDef.type,\n        };\n    }\n    // hack to get memoization working\n    var durationInputMap = {};\n    function createDurationCached(durationInput) {\n        var json = JSON.stringify(durationInput);\n        var res = durationInputMap[json];\n        if (res === undefined) {\n            res = createDuration(durationInput);\n            durationInputMap[json] = res;\n        }\n        return res;\n    }\n\n    var DateProfileGenerator = /** @class */ (function () {\n        function DateProfileGenerator(props) {\n            this.props = props;\n            this.nowDate = getNow(props.nowInput, props.dateEnv);\n            this.initHiddenDays();\n        }\n        /* Date Range Computation\n        ------------------------------------------------------------------------------------------------------------------*/\n        // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n        DateProfileGenerator.prototype.buildPrev = function (currentDateProfile, currentDate, forceToValid) {\n            var dateEnv = this.props.dateEnv;\n            var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n            currentDateProfile.dateIncrement);\n            return this.build(prevDate, -1, forceToValid);\n        };\n        // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n        DateProfileGenerator.prototype.buildNext = function (currentDateProfile, currentDate, forceToValid) {\n            var dateEnv = this.props.dateEnv;\n            var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), // important for start-of-month\n            currentDateProfile.dateIncrement);\n            return this.build(nextDate, 1, forceToValid);\n        };\n        // Builds a structure holding dates/ranges for rendering around the given date.\n        // Optional direction param indicates whether the date is being incremented/decremented\n        // from its previous value. decremented = -1, incremented = 1 (default).\n        DateProfileGenerator.prototype.build = function (currentDate, direction, forceToValid) {\n            if (forceToValid === void 0) { forceToValid = true; }\n            var props = this.props;\n            var validRange;\n            var currentInfo;\n            var isRangeAllDay;\n            var renderRange;\n            var activeRange;\n            var isValid;\n            validRange = this.buildValidRange();\n            validRange = this.trimHiddenDays(validRange);\n            if (forceToValid) {\n                currentDate = constrainMarkerToRange(currentDate, validRange);\n            }\n            currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n            isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n            renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n            renderRange = this.trimHiddenDays(renderRange);\n            activeRange = renderRange;\n            if (!props.showNonCurrentDates) {\n                activeRange = intersectRanges(activeRange, currentInfo.range);\n            }\n            activeRange = this.adjustActiveRange(activeRange);\n            activeRange = intersectRanges(activeRange, validRange); // might return null\n            // it's invalid if the originally requested date is not contained,\n            // or if the range is completely outside of the valid range.\n            isValid = rangesIntersect(currentInfo.range, validRange);\n            return {\n                // constraint for where prev/next operations can go and where events can be dragged/resized to.\n                // an object with optional start and end properties.\n                validRange: validRange,\n                // range the view is formally responsible for.\n                // for example, a month view might have 1st-31st, excluding padded dates\n                currentRange: currentInfo.range,\n                // name of largest unit being displayed, like \"month\" or \"week\"\n                currentRangeUnit: currentInfo.unit,\n                isRangeAllDay: isRangeAllDay,\n                // dates that display events and accept drag-n-drop\n                // will be `null` if no dates accept events\n                activeRange: activeRange,\n                // date range with a rendered skeleton\n                // includes not-active days that need some sort of DOM\n                renderRange: renderRange,\n                // Duration object that denotes the first visible time of any given day\n                slotMinTime: props.slotMinTime,\n                // Duration object that denotes the exclusive visible end time of any given day\n                slotMaxTime: props.slotMaxTime,\n                isValid: isValid,\n                // how far the current date will move for a prev/next operation\n                dateIncrement: this.buildDateIncrement(currentInfo.duration),\n            };\n        };\n        // Builds an object with optional start/end properties.\n        // Indicates the minimum/maximum dates to display.\n        // not responsible for trimming hidden days.\n        DateProfileGenerator.prototype.buildValidRange = function () {\n            var input = this.props.validRangeInput;\n            var simpleInput = typeof input === 'function'\n                ? input.call(this.props.calendarApi, this.nowDate)\n                : input;\n            return this.refineRange(simpleInput) ||\n                { start: null, end: null }; // completely open-ended\n        };\n        // Builds a structure with info about the \"current\" range, the range that is\n        // highlighted as being the current month for example.\n        // See build() for a description of `direction`.\n        // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n        DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {\n            var props = this.props;\n            var duration = null;\n            var unit = null;\n            var range = null;\n            var dayCount;\n            if (props.duration) {\n                duration = props.duration;\n                unit = props.durationUnit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n            else if ((dayCount = this.props.dayCount)) {\n                unit = 'day';\n                range = this.buildRangeFromDayCount(date, direction, dayCount);\n            }\n            else if ((range = this.buildCustomVisibleRange(date))) {\n                unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n            }\n            else {\n                duration = this.getFallbackDuration();\n                unit = greatestDurationDenominator(duration).unit;\n                range = this.buildRangeFromDuration(date, direction, duration, unit);\n            }\n            return { duration: duration, unit: unit, range: range };\n        };\n        DateProfileGenerator.prototype.getFallbackDuration = function () {\n            return createDuration({ day: 1 });\n        };\n        // Returns a new activeRange to have time values (un-ambiguate)\n        // slotMinTime or slotMaxTime causes the range to expand.\n        DateProfileGenerator.prototype.adjustActiveRange = function (range) {\n            var _a = this.props, dateEnv = _a.dateEnv, usesMinMaxTime = _a.usesMinMaxTime, slotMinTime = _a.slotMinTime, slotMaxTime = _a.slotMaxTime;\n            var start = range.start, end = range.end;\n            if (usesMinMaxTime) {\n                // expand active range if slotMinTime is negative (why not when positive?)\n                if (asRoughDays(slotMinTime) < 0) {\n                    start = startOfDay(start); // necessary?\n                    start = dateEnv.add(start, slotMinTime);\n                }\n                // expand active range if slotMaxTime is beyond one day (why not when negative?)\n                if (asRoughDays(slotMaxTime) > 1) {\n                    end = startOfDay(end); // necessary?\n                    end = addDays(end, -1);\n                    end = dateEnv.add(end, slotMaxTime);\n                }\n            }\n            return { start: start, end: end };\n        };\n        // Builds the \"current\" range when it is specified as an explicit duration.\n        // `unit` is the already-computed greatestDurationDenominator unit of duration.\n        DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {\n            var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n            var start;\n            var end;\n            var res;\n            // compute what the alignment should be\n            if (!dateAlignment) {\n                var dateIncrement = this.props.dateIncrement;\n                if (dateIncrement) {\n                    // use the smaller of the two units\n                    if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                        dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                    }\n                    else {\n                        dateAlignment = unit;\n                    }\n                }\n                else {\n                    dateAlignment = unit;\n                }\n            }\n            // if the view displays a single day or smaller\n            if (asRoughDays(duration) <= 1) {\n                if (this.isHiddenDay(start)) {\n                    start = this.skipHiddenDays(start, direction);\n                    start = startOfDay(start);\n                }\n            }\n            function computeRes() {\n                start = dateEnv.startOf(date, dateAlignment);\n                end = dateEnv.add(start, duration);\n                res = { start: start, end: end };\n            }\n            computeRes();\n            // if range is completely enveloped by hidden days, go past the hidden days\n            if (!this.trimHiddenDays(res)) {\n                date = this.skipHiddenDays(date, direction);\n                computeRes();\n            }\n            return res;\n        };\n        // Builds the \"current\" range when a dayCount is specified.\n        DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {\n            var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n            var runningCount = 0;\n            var start = date;\n            var end;\n            if (dateAlignment) {\n                start = dateEnv.startOf(start, dateAlignment);\n            }\n            start = startOfDay(start);\n            start = this.skipHiddenDays(start, direction);\n            end = start;\n            do {\n                end = addDays(end, 1);\n                if (!this.isHiddenDay(end)) {\n                    runningCount += 1;\n                }\n            } while (runningCount < dayCount);\n            return { start: start, end: end };\n        };\n        // Builds a normalized range object for the \"visible\" range,\n        // which is a way to define the currentRange and activeRange at the same time.\n        DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {\n            var props = this.props;\n            var input = props.visibleRangeInput;\n            var simpleInput = typeof input === 'function'\n                ? input.call(props.calendarApi, props.dateEnv.toDate(date))\n                : input;\n            var range = this.refineRange(simpleInput);\n            if (range && (range.start == null || range.end == null)) {\n                return null;\n            }\n            return range;\n        };\n        // Computes the range that will represent the element/cells for *rendering*,\n        // but which may have voided days/times.\n        // not responsible for trimming hidden days.\n        DateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n            return currentRange;\n        };\n        // Compute the duration value that should be added/substracted to the current date\n        // when a prev/next operation happens.\n        DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {\n            var dateIncrement = this.props.dateIncrement;\n            var customAlignment;\n            if (dateIncrement) {\n                return dateIncrement;\n            }\n            if ((customAlignment = this.props.dateAlignment)) {\n                return createDuration(1, customAlignment);\n            }\n            if (fallback) {\n                return fallback;\n            }\n            return createDuration({ days: 1 });\n        };\n        DateProfileGenerator.prototype.refineRange = function (rangeInput) {\n            if (rangeInput) {\n                var range = parseRange(rangeInput, this.props.dateEnv);\n                if (range) {\n                    range = computeVisibleDayRange(range);\n                }\n                return range;\n            }\n            return null;\n        };\n        /* Hidden Days\n        ------------------------------------------------------------------------------------------------------------------*/\n        // Initializes internal variables related to calculating hidden days-of-week\n        DateProfileGenerator.prototype.initHiddenDays = function () {\n            var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n            var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n            var dayCnt = 0;\n            var i;\n            if (this.props.weekends === false) {\n                hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n            }\n            for (i = 0; i < 7; i += 1) {\n                if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                    dayCnt += 1;\n                }\n            }\n            if (!dayCnt) {\n                throw new Error('invalid hiddenDays'); // all days were hidden? bad.\n            }\n            this.isHiddenDayHash = isHiddenDayHash;\n        };\n        // Remove days from the beginning and end of the range that are computed as hidden.\n        // If the whole range is trimmed off, returns null\n        DateProfileGenerator.prototype.trimHiddenDays = function (range) {\n            var start = range.start, end = range.end;\n            if (start) {\n                start = this.skipHiddenDays(start);\n            }\n            if (end) {\n                end = this.skipHiddenDays(end, -1, true);\n            }\n            if (start == null || end == null || start < end) {\n                return { start: start, end: end };\n            }\n            return null;\n        };\n        // Is the current day hidden?\n        // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n        DateProfileGenerator.prototype.isHiddenDay = function (day) {\n            if (day instanceof Date) {\n                day = day.getUTCDay();\n            }\n            return this.isHiddenDayHash[day];\n        };\n        // Incrementing the current day until it is no longer a hidden day, returning a copy.\n        // DOES NOT CONSIDER validRange!\n        // If the initial value of `date` is not a hidden day, don't do anything.\n        // Pass `isExclusive` as `true` if you are dealing with an end date.\n        // `inc` defaults to `1` (increment one day forward each time)\n        DateProfileGenerator.prototype.skipHiddenDays = function (date, inc, isExclusive) {\n            if (inc === void 0) { inc = 1; }\n            if (isExclusive === void 0) { isExclusive = false; }\n            while (this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]) {\n                date = addDays(date, inc);\n            }\n            return date;\n        };\n        return DateProfileGenerator;\n    }());\n\n    function reduceViewType(viewType, action) {\n        switch (action.type) {\n            case 'CHANGE_VIEW_TYPE':\n                viewType = action.viewType;\n        }\n        return viewType;\n    }\n\n    function reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n        var _a;\n        switch (action.type) {\n            case 'SET_OPTION':\n                return __assign(__assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n            default:\n                return dynamicOptionOverrides;\n        }\n    }\n\n    function reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n        var dp;\n        switch (action.type) {\n            case 'CHANGE_VIEW_TYPE':\n                return dateProfileGenerator.build(action.dateMarker || currentDate);\n            case 'CHANGE_DATE':\n                if (!currentDateProfile.activeRange ||\n                    !rangeContainsMarker(currentDateProfile.currentRange, action.dateMarker) // don't move if date already in view\n                ) {\n                    return dateProfileGenerator.build(action.dateMarker);\n                }\n                break;\n            case 'PREV':\n                dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n                if (dp.isValid) {\n                    return dp;\n                }\n                break;\n            case 'NEXT':\n                dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n                if (dp.isValid) {\n                    return dp;\n                }\n                break;\n        }\n        return currentDateProfile;\n    }\n\n    function initEventSources(calendarOptions, dateProfile, context) {\n        var activeRange = dateProfile ? dateProfile.activeRange : null;\n        return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n    }\n    function reduceEventSources(eventSources, action, dateProfile, context) {\n        var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n        switch (action.type) {\n            case 'ADD_EVENT_SOURCES': // already parsed\n                return addSources(eventSources, action.sources, activeRange, context);\n            case 'REMOVE_EVENT_SOURCE':\n                return removeSource(eventSources, action.sourceId);\n            case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n            case 'NEXT':\n            case 'CHANGE_DATE':\n            case 'CHANGE_VIEW_TYPE':\n                if (dateProfile) {\n                    return fetchDirtySources(eventSources, activeRange, context);\n                }\n                return eventSources;\n            case 'FETCH_EVENT_SOURCES':\n                return fetchSourcesByIds(eventSources, action.sourceIds ? // why no type?\n                    arrayToHash(action.sourceIds) :\n                    excludeStaticSources(eventSources, context), activeRange, context);\n            case 'RECEIVE_EVENTS':\n            case 'RECEIVE_EVENT_ERROR':\n                return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n            case 'REMOVE_ALL_EVENT_SOURCES':\n                return {};\n            default:\n                return eventSources;\n        }\n    }\n    function reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n        var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n        return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, context);\n    }\n    function computeEventSourceLoadingLevel(eventSources) {\n        var cnt = 0;\n        for (var sourceId in eventSources) {\n            if (eventSources[sourceId].isFetching) {\n                cnt += 1;\n            }\n        }\n        return cnt;\n    }\n    function addSources(eventSourceHash, sources, fetchRange, context) {\n        var hash = {};\n        for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {\n            var source = sources_1[_i];\n            hash[source.sourceId] = source;\n        }\n        if (fetchRange) {\n            hash = fetchDirtySources(hash, fetchRange, context);\n        }\n        return __assign(__assign({}, eventSourceHash), hash);\n    }\n    function removeSource(eventSourceHash, sourceId) {\n        return filterHash(eventSourceHash, function (eventSource) { return eventSource.sourceId !== sourceId; });\n    }\n    function fetchDirtySources(sourceHash, fetchRange, context) {\n        return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function (eventSource) { return isSourceDirty(eventSource, fetchRange, context); }), fetchRange, context);\n    }\n    function isSourceDirty(eventSource, fetchRange, context) {\n        if (!doesSourceNeedRange(eventSource, context)) {\n            return !eventSource.latestFetchId;\n        }\n        return !context.options.lazyFetching ||\n            !eventSource.fetchRange ||\n            eventSource.isFetching || // always cancel outdated in-progress fetches\n            fetchRange.start < eventSource.fetchRange.start ||\n            fetchRange.end > eventSource.fetchRange.end;\n    }\n    function fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, context) {\n        var nextSources = {};\n        for (var sourceId in prevSources) {\n            var source = prevSources[sourceId];\n            if (sourceIdHash[sourceId]) {\n                nextSources[sourceId] = fetchSource(source, fetchRange, context);\n            }\n            else {\n                nextSources[sourceId] = source;\n            }\n        }\n        return nextSources;\n    }\n    function fetchSource(eventSource, fetchRange, context) {\n        var options = context.options, calendarApi = context.calendarApi;\n        var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n        var fetchId = guid();\n        sourceDef.fetch({\n            eventSource: eventSource,\n            range: fetchRange,\n            context: context,\n        }, function (res) {\n            var rawEvents = res.rawEvents;\n            if (options.eventSourceSuccess) {\n                rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n            }\n            if (eventSource.success) {\n                rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n            }\n            context.dispatch({\n                type: 'RECEIVE_EVENTS',\n                sourceId: eventSource.sourceId,\n                fetchId: fetchId,\n                fetchRange: fetchRange,\n                rawEvents: rawEvents,\n            });\n        }, function (error) {\n            console.warn(error.message, error);\n            if (options.eventSourceFailure) {\n                options.eventSourceFailure.call(calendarApi, error);\n            }\n            if (eventSource.failure) {\n                eventSource.failure(error);\n            }\n            context.dispatch({\n                type: 'RECEIVE_EVENT_ERROR',\n                sourceId: eventSource.sourceId,\n                fetchId: fetchId,\n                fetchRange: fetchRange,\n                error: error,\n            });\n        });\n        return __assign(__assign({}, eventSource), { isFetching: true, latestFetchId: fetchId });\n    }\n    function receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n        var _a;\n        var eventSource = sourceHash[sourceId];\n        if (eventSource && // not already removed\n            fetchId === eventSource.latestFetchId) {\n            return __assign(__assign({}, sourceHash), (_a = {}, _a[sourceId] = __assign(__assign({}, eventSource), { isFetching: false, fetchRange: fetchRange }), _a));\n        }\n        return sourceHash;\n    }\n    function excludeStaticSources(eventSources, context) {\n        return filterHash(eventSources, function (eventSource) { return doesSourceNeedRange(eventSource, context); });\n    }\n    function parseInitialSources(rawOptions, context) {\n        var refiners = buildEventSourceRefiners(context);\n        var rawSources = [].concat(rawOptions.eventSources || []);\n        var sources = []; // parsed\n        if (rawOptions.initialEvents) {\n            rawSources.unshift(rawOptions.initialEvents);\n        }\n        if (rawOptions.events) {\n            rawSources.unshift(rawOptions.events);\n        }\n        for (var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++) {\n            var rawSource = rawSources_1[_i];\n            var source = parseEventSource(rawSource, context, refiners);\n            if (source) {\n                sources.push(source);\n            }\n        }\n        return sources;\n    }\n    function doesSourceNeedRange(eventSource, context) {\n        var defs = context.pluginHooks.eventSourceDefs;\n        return !defs[eventSource.sourceDefId].ignoreRange;\n    }\n\n    function reduceDateSelection(currentSelection, action) {\n        switch (action.type) {\n            case 'UNSELECT_DATES':\n                return null;\n            case 'SELECT_DATES':\n                return action.selection;\n            default:\n                return currentSelection;\n        }\n    }\n\n    function reduceSelectedEvent(currentInstanceId, action) {\n        switch (action.type) {\n            case 'UNSELECT_EVENT':\n                return '';\n            case 'SELECT_EVENT':\n                return action.eventInstanceId;\n            default:\n                return currentInstanceId;\n        }\n    }\n\n    function reduceEventDrag(currentDrag, action) {\n        var newDrag;\n        switch (action.type) {\n            case 'UNSET_EVENT_DRAG':\n                return null;\n            case 'SET_EVENT_DRAG':\n                newDrag = action.state;\n                return {\n                    affectedEvents: newDrag.affectedEvents,\n                    mutatedEvents: newDrag.mutatedEvents,\n                    isEvent: newDrag.isEvent,\n                };\n            default:\n                return currentDrag;\n        }\n    }\n\n    function reduceEventResize(currentResize, action) {\n        var newResize;\n        switch (action.type) {\n            case 'UNSET_EVENT_RESIZE':\n                return null;\n            case 'SET_EVENT_RESIZE':\n                newResize = action.state;\n                return {\n                    affectedEvents: newResize.affectedEvents,\n                    mutatedEvents: newResize.mutatedEvents,\n                    isEvent: newResize.isEvent,\n                };\n            default:\n                return currentResize;\n        }\n    }\n\n    function parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n        var viewsWithButtons = [];\n        var headerToolbar = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n        var footerToolbar = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) : null;\n        return { headerToolbar: headerToolbar, footerToolbar: footerToolbar, viewsWithButtons: viewsWithButtons };\n    }\n    function parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {\n        return mapHash(sectionStrHash, function (sectionStr) { return parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons); });\n    }\n    /*\n    BAD: querying icons and text here. should be done at render time\n    */\n    function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi, viewsWithButtons) {\n        var isRtl = calendarOptions.direction === 'rtl';\n        var calendarCustomButtons = calendarOptions.customButtons || {};\n        var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n        var calendarButtonText = calendarOptions.buttonText || {};\n        var sectionSubstrs = sectionStr ? sectionStr.split(' ') : [];\n        return sectionSubstrs.map(function (buttonGroupStr) { return (buttonGroupStr.split(',').map(function (buttonName) {\n            if (buttonName === 'title') {\n                return { buttonName: buttonName };\n            }\n            var customButtonProps;\n            var viewSpec;\n            var buttonClick;\n            var buttonIcon; // only one of these will be set\n            var buttonText; // \"\n            if ((customButtonProps = calendarCustomButtons[buttonName])) {\n                buttonClick = function (ev) {\n                    if (customButtonProps.click) {\n                        customButtonProps.click.call(ev.target, ev, ev.target);\n                    }\n                };\n                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||\n                    (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||\n                    (buttonText = customButtonProps.text);\n            }\n            else if ((viewSpec = viewSpecs[buttonName])) {\n                viewsWithButtons.push(buttonName);\n                buttonClick = function () {\n                    calendarApi.changeView(buttonName);\n                };\n                (buttonText = viewSpec.buttonTextOverride) ||\n                    (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||\n                    (buttonText = viewSpec.buttonTextDefault);\n            }\n            else if (calendarApi[buttonName]) { // a calendarApi method\n                buttonClick = function () {\n                    calendarApi[buttonName]();\n                };\n                (buttonText = calendarButtonTextOverrides[buttonName]) ||\n                    (buttonIcon = theme.getIconClass(buttonName, isRtl)) ||\n                    (buttonText = calendarButtonText[buttonName]);\n                //            ^ everything else is considered default\n            }\n            return { buttonName: buttonName, buttonClick: buttonClick, buttonIcon: buttonIcon, buttonText: buttonText };\n        })); });\n    }\n\n    var eventSourceDef = {\n        ignoreRange: true,\n        parseMeta: function (refined) {\n            if (Array.isArray(refined.events)) {\n                return refined.events;\n            }\n            return null;\n        },\n        fetch: function (arg, success) {\n            success({\n                rawEvents: arg.eventSource.meta,\n            });\n        },\n    };\n    var arrayEventSourcePlugin = createPlugin({\n        eventSourceDefs: [eventSourceDef],\n    });\n\n    var eventSourceDef$1 = {\n        parseMeta: function (refined) {\n            if (typeof refined.events === 'function') {\n                return refined.events;\n            }\n            return null;\n        },\n        fetch: function (arg, success, failure) {\n            var dateEnv = arg.context.dateEnv;\n            var func = arg.eventSource.meta;\n            unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function (rawEvents) {\n                success({ rawEvents: rawEvents }); // needs an object response\n            }, failure);\n        },\n    };\n    var funcEventSourcePlugin = createPlugin({\n        eventSourceDefs: [eventSourceDef$1],\n    });\n\n    function requestJson(method, url, params, successCallback, failureCallback) {\n        method = method.toUpperCase();\n        var body = null;\n        if (method === 'GET') {\n            url = injectQueryStringParams(url, params);\n        }\n        else {\n            body = encodeParams(params);\n        }\n        var xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (method !== 'GET') {\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        }\n        xhr.onload = function () {\n            if (xhr.status >= 200 && xhr.status < 400) {\n                var parsed = false;\n                var res = void 0;\n                try {\n                    res = JSON.parse(xhr.responseText);\n                    parsed = true;\n                }\n                catch (err) {\n                    // will handle parsed=false\n                }\n                if (parsed) {\n                    successCallback(res, xhr);\n                }\n                else {\n                    failureCallback('Failure parsing JSON', xhr);\n                }\n            }\n            else {\n                failureCallback('Request failed', xhr);\n            }\n        };\n        xhr.onerror = function () {\n            failureCallback('Request failed', xhr);\n        };\n        xhr.send(body);\n    }\n    function injectQueryStringParams(url, params) {\n        return url +\n            (url.indexOf('?') === -1 ? '?' : '&') +\n            encodeParams(params);\n    }\n    function encodeParams(params) {\n        var parts = [];\n        for (var key in params) {\n            parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n        }\n        return parts.join('&');\n    }\n\n    var JSON_FEED_EVENT_SOURCE_REFINERS = {\n        method: String,\n        extraParams: identity,\n        startParam: String,\n        endParam: String,\n        timeZoneParam: String,\n    };\n\n    var eventSourceDef$2 = {\n        parseMeta: function (refined) {\n            if (refined.url) {\n                return {\n                    url: refined.url,\n                    method: (refined.method || 'GET').toUpperCase(),\n                    extraParams: refined.extraParams,\n                    startParam: refined.startParam,\n                    endParam: refined.endParam,\n                    timeZoneParam: refined.timeZoneParam,\n                };\n            }\n            return null;\n        },\n        fetch: function (arg, success, failure) {\n            var meta = arg.eventSource.meta;\n            var requestParams = buildRequestParams(meta, arg.range, arg.context);\n            requestJson(meta.method, meta.url, requestParams, function (rawEvents, xhr) {\n                success({ rawEvents: rawEvents, xhr: xhr });\n            }, function (errorMessage, xhr) {\n                failure({ message: errorMessage, xhr: xhr });\n            });\n        },\n    };\n    var jsonFeedEventSourcePlugin = createPlugin({\n        eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n        eventSourceDefs: [eventSourceDef$2],\n    });\n    function buildRequestParams(meta, range, context) {\n        var dateEnv = context.dateEnv, options = context.options;\n        var startParam;\n        var endParam;\n        var timeZoneParam;\n        var customRequestParams;\n        var params = {};\n        startParam = meta.startParam;\n        if (startParam == null) {\n            startParam = options.startParam;\n        }\n        endParam = meta.endParam;\n        if (endParam == null) {\n            endParam = options.endParam;\n        }\n        timeZoneParam = meta.timeZoneParam;\n        if (timeZoneParam == null) {\n            timeZoneParam = options.timeZoneParam;\n        }\n        // retrieve any outbound GET/POST data from the options\n        if (typeof meta.extraParams === 'function') {\n            // supplied as a function that returns a key/value object\n            customRequestParams = meta.extraParams();\n        }\n        else {\n            // probably supplied as a straight key/value object\n            customRequestParams = meta.extraParams || {};\n        }\n        __assign(params, customRequestParams);\n        params[startParam] = dateEnv.formatIso(range.start);\n        params[endParam] = dateEnv.formatIso(range.end);\n        if (dateEnv.timeZone !== 'local') {\n            params[timeZoneParam] = dateEnv.timeZone;\n        }\n        return params;\n    }\n\n    var SIMPLE_RECURRING_REFINERS = {\n        daysOfWeek: identity,\n        startTime: createDuration,\n        endTime: createDuration,\n        duration: createDuration,\n        startRecur: identity,\n        endRecur: identity,\n    };\n\n    var recurring = {\n        parse: function (refined, dateEnv) {\n            if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n                var recurringData = {\n                    daysOfWeek: refined.daysOfWeek || null,\n                    startTime: refined.startTime || null,\n                    endTime: refined.endTime || null,\n                    startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                    endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null,\n                };\n                var duration = void 0;\n                if (refined.duration) {\n                    duration = refined.duration;\n                }\n                if (!duration && refined.startTime && refined.endTime) {\n                    duration = subtractDurations(refined.endTime, refined.startTime);\n                }\n                return {\n                    allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                    duration: duration,\n                    typeData: recurringData,\n                };\n            }\n            return null;\n        },\n        expand: function (typeData, framingRange, dateEnv) {\n            var clippedFramingRange = intersectRanges(framingRange, { start: typeData.startRecur, end: typeData.endRecur });\n            if (clippedFramingRange) {\n                return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n            }\n            return [];\n        },\n    };\n    var simpleRecurringEventsPlugin = createPlugin({\n        recurringTypes: [recurring],\n        eventRefiners: SIMPLE_RECURRING_REFINERS,\n    });\n    function expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n        var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n        var dayMarker = startOfDay(framingRange.start);\n        var endMarker = framingRange.end;\n        var instanceStarts = [];\n        while (dayMarker < endMarker) {\n            var instanceStart \n            // if everyday, or this particular day-of-week\n            = void 0;\n            // if everyday, or this particular day-of-week\n            if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n                if (startTime) {\n                    instanceStart = dateEnv.add(dayMarker, startTime);\n                }\n                else {\n                    instanceStart = dayMarker;\n                }\n                instanceStarts.push(instanceStart);\n            }\n            dayMarker = addDays(dayMarker, 1);\n        }\n        return instanceStarts;\n    }\n\n    var changeHandlerPlugin = createPlugin({\n        optionChangeHandlers: {\n            events: function (events, context) {\n                handleEventSources([events], context);\n            },\n            eventSources: handleEventSources,\n        },\n    });\n    /*\n    BUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n    */\n    function handleEventSources(inputs, context) {\n        var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n        var newInputs = [];\n        for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n            var input = inputs_1[_i];\n            var inputFound = false;\n            for (var i = 0; i < unfoundSources.length; i += 1) {\n                if (unfoundSources[i]._raw === input) {\n                    unfoundSources.splice(i, 1); // delete\n                    inputFound = true;\n                    break;\n                }\n            }\n            if (!inputFound) {\n                newInputs.push(input);\n            }\n        }\n        for (var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++) {\n            var unfoundSource = unfoundSources_1[_a];\n            context.dispatch({\n                type: 'REMOVE_EVENT_SOURCE',\n                sourceId: unfoundSource.sourceId,\n            });\n        }\n        for (var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++) {\n            var newInput = newInputs_1[_b];\n            context.calendarApi.addEventSource(newInput);\n        }\n    }\n\n    function handleDateProfile(dateProfile, context) {\n        context.emitter.trigger('datesSet', __assign(__assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), { view: context.viewApi }));\n    }\n\n    function handleEventStore(eventStore, context) {\n        var emitter = context.emitter;\n        if (emitter.hasHandlers('eventsSet')) {\n            emitter.trigger('eventsSet', buildEventApis(eventStore, context));\n        }\n    }\n\n    /*\n    this array is exposed on the root namespace so that UMD plugins can add to it.\n    see the rollup-bundles script.\n    */\n    var globalPlugins = [\n        arrayEventSourcePlugin,\n        funcEventSourcePlugin,\n        jsonFeedEventSourcePlugin,\n        simpleRecurringEventsPlugin,\n        changeHandlerPlugin,\n        createPlugin({\n            contentTypeHandlers: {\n                html: function () { return ({ render: injectHtml }); },\n                domNodes: function () { return ({ render: injectDomNodes }); },\n            },\n            propSetHandlers: {\n                dateProfile: handleDateProfile,\n                eventStore: handleEventStore,\n            },\n        }),\n    ];\n    function injectHtml(el, html) {\n        el.innerHTML = html;\n    }\n    function injectDomNodes(el, domNodes) {\n        var oldNodes = Array.prototype.slice.call(el.childNodes); // TODO: use array util\n        var newNodes = Array.prototype.slice.call(domNodes); // TODO: use array util\n        if (!isArraysEqual(oldNodes, newNodes)) {\n            for (var _i = 0, newNodes_1 = newNodes; _i < newNodes_1.length; _i++) {\n                var newNode = newNodes_1[_i];\n                el.appendChild(newNode);\n            }\n            oldNodes.forEach(removeElement);\n        }\n    }\n\n    var DelayedRunner = /** @class */ (function () {\n        function DelayedRunner(drainedOption) {\n            this.drainedOption = drainedOption;\n            this.isRunning = false;\n            this.isDirty = false;\n            this.pauseDepths = {};\n            this.timeoutId = 0;\n        }\n        DelayedRunner.prototype.request = function (delay) {\n            this.isDirty = true;\n            if (!this.isPaused()) {\n                this.clearTimeout();\n                if (delay == null) {\n                    this.tryDrain();\n                }\n                else {\n                    this.timeoutId = setTimeout(// NOT OPTIMAL! TODO: look at debounce\n                    this.tryDrain.bind(this), delay);\n                }\n            }\n        };\n        DelayedRunner.prototype.pause = function (scope) {\n            if (scope === void 0) { scope = ''; }\n            var pauseDepths = this.pauseDepths;\n            pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n            this.clearTimeout();\n        };\n        DelayedRunner.prototype.resume = function (scope, force) {\n            if (scope === void 0) { scope = ''; }\n            var pauseDepths = this.pauseDepths;\n            if (scope in pauseDepths) {\n                if (force) {\n                    delete pauseDepths[scope];\n                }\n                else {\n                    pauseDepths[scope] -= 1;\n                    var depth = pauseDepths[scope];\n                    if (depth <= 0) {\n                        delete pauseDepths[scope];\n                    }\n                }\n                this.tryDrain();\n            }\n        };\n        DelayedRunner.prototype.isPaused = function () {\n            return Object.keys(this.pauseDepths).length;\n        };\n        DelayedRunner.prototype.tryDrain = function () {\n            if (!this.isRunning && !this.isPaused()) {\n                this.isRunning = true;\n                while (this.isDirty) {\n                    this.isDirty = false;\n                    this.drained(); // might set isDirty to true again\n                }\n                this.isRunning = false;\n            }\n        };\n        DelayedRunner.prototype.clear = function () {\n            this.clearTimeout();\n            this.isDirty = false;\n            this.pauseDepths = {};\n        };\n        DelayedRunner.prototype.clearTimeout = function () {\n            if (this.timeoutId) {\n                clearTimeout(this.timeoutId);\n                this.timeoutId = 0;\n            }\n        };\n        DelayedRunner.prototype.drained = function () {\n            if (this.drainedOption) {\n                this.drainedOption();\n            }\n        };\n        return DelayedRunner;\n    }());\n\n    var TaskRunner = /** @class */ (function () {\n        function TaskRunner(runTaskOption, drainedOption) {\n            this.runTaskOption = runTaskOption;\n            this.drainedOption = drainedOption;\n            this.queue = [];\n            this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n        }\n        TaskRunner.prototype.request = function (task, delay) {\n            this.queue.push(task);\n            this.delayedRunner.request(delay);\n        };\n        TaskRunner.prototype.pause = function (scope) {\n            this.delayedRunner.pause(scope);\n        };\n        TaskRunner.prototype.resume = function (scope, force) {\n            this.delayedRunner.resume(scope, force);\n        };\n        TaskRunner.prototype.drain = function () {\n            var queue = this.queue;\n            while (queue.length) {\n                var completedTasks = [];\n                var task = void 0;\n                while ((task = queue.shift())) {\n                    this.runTask(task);\n                    completedTasks.push(task);\n                }\n                this.drained(completedTasks);\n            } // keep going, in case new tasks were added in the drained handler\n        };\n        TaskRunner.prototype.runTask = function (task) {\n            if (this.runTaskOption) {\n                this.runTaskOption(task);\n            }\n        };\n        TaskRunner.prototype.drained = function (completedTasks) {\n            if (this.drainedOption) {\n                this.drainedOption(completedTasks);\n            }\n        };\n        return TaskRunner;\n    }());\n\n    // Computes what the title at the top of the calendarApi should be for this view\n    function buildTitle(dateProfile, viewOptions, dateEnv) {\n        var range;\n        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n            range = dateProfile.currentRange;\n        }\n        else { // for day units or smaller, use the actual day range\n            range = dateProfile.activeRange;\n        }\n        return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n            isEndExclusive: dateProfile.isRangeAllDay,\n            defaultSeparator: viewOptions.titleRangeSeparator,\n        });\n    }\n    // Generates the format string that should be used to generate the title for the current date range.\n    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\n    function buildTitleFormat(dateProfile) {\n        var currentRangeUnit = dateProfile.currentRangeUnit;\n        if (currentRangeUnit === 'year') {\n            return { year: 'numeric' };\n        }\n        if (currentRangeUnit === 'month') {\n            return { year: 'numeric', month: 'long' }; // like \"September 2014\"\n        }\n        var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n        if (days !== null && days > 1) {\n            // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n            return { year: 'numeric', month: 'short', day: 'numeric' };\n        }\n        // one day. longer, like \"September 9 2014\"\n        return { year: 'numeric', month: 'long', day: 'numeric' };\n    }\n\n    // in future refactor, do the redux-style function(state=initial) for initial-state\n    // also, whatever is happening in constructor, have it happen in action queue too\n    var CalendarDataManager = /** @class */ (function () {\n        function CalendarDataManager(props) {\n            var _this = this;\n            this.computeOptionsData = memoize(this._computeOptionsData);\n            this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n            this.organizeRawLocales = memoize(organizeRawLocales);\n            this.buildLocale = memoize(buildLocale);\n            this.buildPluginHooks = buildBuildPluginHooks();\n            this.buildDateEnv = memoize(buildDateEnv$1);\n            this.buildTheme = memoize(buildTheme);\n            this.parseToolbars = memoize(parseToolbars);\n            this.buildViewSpecs = memoize(buildViewSpecs);\n            this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n            this.buildViewApi = memoize(buildViewApi);\n            this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n            this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n            this.buildEventUiBases = memoize(buildEventUiBases);\n            this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n            this.buildTitle = memoize(buildTitle);\n            this.emitter = new Emitter();\n            this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n            this.currentCalendarOptionsInput = {};\n            this.currentCalendarOptionsRefined = {};\n            this.currentViewOptionsInput = {};\n            this.currentViewOptionsRefined = {};\n            this.currentCalendarOptionsRefiners = {};\n            this.getCurrentData = function () { return _this.data; };\n            this.dispatch = function (action) {\n                _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n            };\n            this.props = props;\n            this.actionRunner.pause();\n            var dynamicOptionOverrides = {};\n            var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n            var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n            var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n            // wire things up\n            // TODO: not DRY\n            props.calendarApi.currentDataManager = this;\n            this.emitter.setThisContext(props.calendarApi);\n            this.emitter.setOptions(currentViewData.options);\n            var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n            var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n            if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n                currentDate = dateProfile.currentRange.start;\n            }\n            var calendarContext = {\n                dateEnv: optionsData.dateEnv,\n                options: optionsData.calendarOptions,\n                pluginHooks: optionsData.pluginHooks,\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter: this.emitter,\n                getCurrentData: this.getCurrentData,\n            };\n            // needs to be after setThisContext\n            for (var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++) {\n                var callback = _a[_i];\n                callback(calendarContext);\n            }\n            // NOT DRY\n            var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n            var initialState = {\n                dynamicOptionOverrides: dynamicOptionOverrides,\n                currentViewType: currentViewType,\n                currentDate: currentDate,\n                dateProfile: dateProfile,\n                businessHours: this.parseContextBusinessHours(calendarContext),\n                eventSources: eventSources,\n                eventUiBases: {},\n                loadingLevel: computeEventSourceLoadingLevel(eventSources),\n                eventStore: createEmptyEventStore(),\n                renderableEventStore: createEmptyEventStore(),\n                dateSelection: null,\n                eventSelection: '',\n                eventDrag: null,\n                eventResize: null,\n                selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig,\n            };\n            var contextAndState = __assign(__assign({}, calendarContext), initialState);\n            for (var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++) {\n                var reducer = _c[_b];\n                __assign(initialState, reducer(null, null, contextAndState));\n            }\n            if (initialState.loadingLevel) {\n                this.emitter.trigger('loading', true); // NOT DRY\n            }\n            this.state = initialState;\n            this.updateData();\n            this.actionRunner.resume();\n        }\n        CalendarDataManager.prototype.resetOptions = function (optionOverrides, append) {\n            var props = this.props;\n            props.optionOverrides = append\n                ? __assign(__assign({}, props.optionOverrides), optionOverrides) : optionOverrides;\n            this.actionRunner.request({\n                type: 'NOTHING',\n            });\n        };\n        CalendarDataManager.prototype._handleAction = function (action) {\n            var _a = this, props = _a.props, state = _a.state, emitter = _a.emitter;\n            var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n            var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n            var currentViewType = reduceViewType(state.currentViewType, action);\n            var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n            // wire things up\n            // TODO: not DRY\n            props.calendarApi.currentDataManager = this;\n            emitter.setThisContext(props.calendarApi);\n            emitter.setOptions(currentViewData.options);\n            var calendarContext = {\n                dateEnv: optionsData.dateEnv,\n                options: optionsData.calendarOptions,\n                pluginHooks: optionsData.pluginHooks,\n                calendarApi: props.calendarApi,\n                dispatch: this.dispatch,\n                emitter: emitter,\n                getCurrentData: this.getCurrentData,\n            };\n            var currentDate = state.currentDate, dateProfile = state.dateProfile;\n            if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) { // hack\n                dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n            }\n            currentDate = reduceCurrentDate(currentDate, action);\n            dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n            if (!rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n                currentDate = dateProfile.currentRange.start;\n            }\n            var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n            var eventSourceLoadingLevel = computeEventSourceLoadingLevel(eventSources);\n            var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n            var renderableEventStore = (eventSourceLoadingLevel && !currentViewData.options.progressiveEventRendering) ?\n                (state.renderableEventStore || eventStore) : // try from previous state\n                eventStore;\n            var _b = this.buildViewUiProps(calendarContext), eventUiSingleBase = _b.eventUiSingleBase, selectionConfig = _b.selectionConfig; // will memoize obj\n            var eventUiBySource = this.buildEventUiBySource(eventSources);\n            var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n            var prevLoadingLevel = state.loadingLevel || 0;\n            var loadingLevel = eventSourceLoadingLevel;\n            var newState = {\n                dynamicOptionOverrides: dynamicOptionOverrides,\n                currentViewType: currentViewType,\n                currentDate: currentDate,\n                dateProfile: dateProfile,\n                eventSources: eventSources,\n                eventStore: eventStore,\n                renderableEventStore: renderableEventStore,\n                selectionConfig: selectionConfig,\n                eventUiBases: eventUiBases,\n                loadingLevel: loadingLevel,\n                businessHours: this.parseContextBusinessHours(calendarContext),\n                dateSelection: reduceDateSelection(state.dateSelection, action),\n                eventSelection: reduceSelectedEvent(state.eventSelection, action),\n                eventDrag: reduceEventDrag(state.eventDrag, action),\n                eventResize: reduceEventResize(state.eventResize, action),\n            };\n            var contextAndState = __assign(__assign({}, calendarContext), newState);\n            for (var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++) {\n                var reducer = _c[_i];\n                __assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n            }\n            // TODO: use propSetHandlers in plugin system\n            if (!prevLoadingLevel && loadingLevel) {\n                emitter.trigger('loading', true);\n            }\n            else if (prevLoadingLevel && !loadingLevel) {\n                emitter.trigger('loading', false);\n            }\n            this.state = newState;\n            if (props.onAction) {\n                props.onAction(action);\n            }\n        };\n        CalendarDataManager.prototype.updateData = function () {\n            var _a = this, props = _a.props, state = _a.state;\n            var oldData = this.data;\n            var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n            var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n            var data = this.data = __assign(__assign(__assign({ viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv), calendarApi: props.calendarApi, dispatch: this.dispatch, emitter: this.emitter, getCurrentData: this.getCurrentData }, optionsData), currentViewData), state);\n            var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n            var oldCalendarOptions = oldData && oldData.calendarOptions;\n            var newCalendarOptions = optionsData.calendarOptions;\n            if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n                if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                    // hack\n                    state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                    state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n                }\n                for (var optionName in changeHandlers) {\n                    if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                        changeHandlers[optionName](newCalendarOptions[optionName], data);\n                    }\n                }\n            }\n            if (props.onData) {\n                props.onData(data);\n            }\n        };\n        CalendarDataManager.prototype._computeOptionsData = function (optionOverrides, dynamicOptionOverrides, calendarApi) {\n            // TODO: blacklist options that are handled by optionChangeHandlers\n            var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, pluginHooks = _a.pluginHooks, localeDefaults = _a.localeDefaults, availableLocaleData = _a.availableLocaleData, extra = _a.extra;\n            warnUnknownOptions(extra);\n            var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n            var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n            var theme = this.buildTheme(refinedOptions, pluginHooks);\n            var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n            return {\n                calendarOptions: refinedOptions,\n                pluginHooks: pluginHooks,\n                dateEnv: dateEnv,\n                viewSpecs: viewSpecs,\n                theme: theme,\n                toolbarConfig: toolbarConfig,\n                localeDefaults: localeDefaults,\n                availableRawLocales: availableLocaleData.map,\n            };\n        };\n        // always called from behind a memoizer\n        CalendarDataManager.prototype.processRawCalendarOptions = function (optionOverrides, dynamicOptionOverrides) {\n            var _a = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                optionOverrides,\n                dynamicOptionOverrides,\n            ]), locales = _a.locales, locale = _a.locale;\n            var availableLocaleData = this.organizeRawLocales(locales);\n            var availableRawLocales = availableLocaleData.map;\n            var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n            var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n            var refiners = this.currentCalendarOptionsRefiners = __assign(__assign(__assign(__assign(__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n            var extra = {};\n            var raw = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                localeDefaults,\n                optionOverrides,\n                dynamicOptionOverrides,\n            ]);\n            var refined = {};\n            var currentRaw = this.currentCalendarOptionsInput;\n            var currentRefined = this.currentCalendarOptionsRefined;\n            var anyChanges = false;\n            for (var optionName in raw) {\n                if (optionName !== 'plugins') { // because plugins is special-cased\n                    if (raw[optionName] === currentRaw[optionName] ||\n                        (COMPLEX_OPTION_COMPARATORS[optionName] &&\n                            (optionName in currentRaw) &&\n                            COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName]))) {\n                        refined[optionName] = currentRefined[optionName];\n                    }\n                    else if (refiners[optionName]) {\n                        refined[optionName] = refiners[optionName](raw[optionName]);\n                        anyChanges = true;\n                    }\n                    else {\n                        extra[optionName] = currentRaw[optionName];\n                    }\n                }\n            }\n            if (anyChanges) {\n                this.currentCalendarOptionsInput = raw;\n                this.currentCalendarOptionsRefined = refined;\n            }\n            return {\n                rawOptions: this.currentCalendarOptionsInput,\n                refinedOptions: this.currentCalendarOptionsRefined,\n                pluginHooks: pluginHooks,\n                availableLocaleData: availableLocaleData,\n                localeDefaults: localeDefaults,\n                extra: extra,\n            };\n        };\n        CalendarDataManager.prototype._computeCurrentViewData = function (viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n            var viewSpec = optionsData.viewSpecs[viewType];\n            if (!viewSpec) {\n                throw new Error(\"viewType \\\"\" + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n            }\n            var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, extra = _a.extra;\n            warnUnknownOptions(extra);\n            var dateProfileGenerator = this.buildDateProfileGenerator({\n                dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n                duration: viewSpec.duration,\n                durationUnit: viewSpec.durationUnit,\n                usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n                dateEnv: optionsData.dateEnv,\n                calendarApi: this.props.calendarApi,\n                slotMinTime: refinedOptions.slotMinTime,\n                slotMaxTime: refinedOptions.slotMaxTime,\n                showNonCurrentDates: refinedOptions.showNonCurrentDates,\n                dayCount: refinedOptions.dayCount,\n                dateAlignment: refinedOptions.dateAlignment,\n                dateIncrement: refinedOptions.dateIncrement,\n                hiddenDays: refinedOptions.hiddenDays,\n                weekends: refinedOptions.weekends,\n                nowInput: refinedOptions.now,\n                validRangeInput: refinedOptions.validRange,\n                visibleRangeInput: refinedOptions.visibleRange,\n                monthMode: refinedOptions.monthMode,\n                fixedWeekCount: refinedOptions.fixedWeekCount,\n            });\n            var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n            return { viewSpec: viewSpec, options: refinedOptions, dateProfileGenerator: dateProfileGenerator, viewApi: viewApi };\n        };\n        CalendarDataManager.prototype.processRawViewOptions = function (viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n            var raw = mergeRawOptions([\n                BASE_OPTION_DEFAULTS,\n                viewSpec.optionDefaults,\n                localeDefaults,\n                optionOverrides,\n                viewSpec.optionOverrides,\n                dynamicOptionOverrides,\n            ]);\n            var refiners = __assign(__assign(__assign(__assign(__assign(__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n            var refined = {};\n            var currentRaw = this.currentViewOptionsInput;\n            var currentRefined = this.currentViewOptionsRefined;\n            var anyChanges = false;\n            var extra = {};\n            for (var optionName in raw) {\n                if (raw[optionName] === currentRaw[optionName]) {\n                    refined[optionName] = currentRefined[optionName];\n                }\n                else {\n                    if (raw[optionName] === this.currentCalendarOptionsInput[optionName]) {\n                        if (optionName in this.currentCalendarOptionsRefined) { // might be an \"extra\" prop\n                            refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                        }\n                    }\n                    else if (refiners[optionName]) {\n                        refined[optionName] = refiners[optionName](raw[optionName]);\n                    }\n                    else {\n                        extra[optionName] = raw[optionName];\n                    }\n                    anyChanges = true;\n                }\n            }\n            if (anyChanges) {\n                this.currentViewOptionsInput = raw;\n                this.currentViewOptionsRefined = refined;\n            }\n            return {\n                rawOptions: this.currentViewOptionsInput,\n                refinedOptions: this.currentViewOptionsRefined,\n                extra: extra,\n            };\n        };\n        return CalendarDataManager;\n    }());\n    function buildDateEnv$1(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n        var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n        return new DateEnv({\n            calendarSystem: 'gregory',\n            timeZone: timeZone,\n            namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n            locale: locale,\n            weekNumberCalculation: weekNumberCalculation,\n            firstDay: firstDay,\n            weekText: weekText,\n            cmdFormatter: pluginHooks.cmdFormatter,\n            defaultSeparator: defaultSeparator,\n        });\n    }\n    function buildTheme(options, pluginHooks) {\n        var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n        return new ThemeClass(options);\n    }\n    function buildDateProfileGenerator(props) {\n        var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n        return new DateProfileGeneratorClass(props);\n    }\n    function buildViewApi(type, getCurrentData, dateEnv) {\n        return new ViewApi(type, getCurrentData, dateEnv);\n    }\n    function buildEventUiBySource(eventSources) {\n        return mapHash(eventSources, function (eventSource) { return eventSource.ui; });\n    }\n    function buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n        var eventUiBases = { '': eventUiSingleBase };\n        for (var defId in eventDefs) {\n            var def = eventDefs[defId];\n            if (def.sourceId && eventUiBySource[def.sourceId]) {\n                eventUiBases[defId] = eventUiBySource[def.sourceId];\n            }\n        }\n        return eventUiBases;\n    }\n    function buildViewUiProps(calendarContext) {\n        var options = calendarContext.options;\n        return {\n            eventUiSingleBase: createEventUi({\n                display: options.eventDisplay,\n                editable: options.editable,\n                startEditable: options.eventStartEditable,\n                durationEditable: options.eventDurationEditable,\n                constraint: options.eventConstraint,\n                overlap: typeof options.eventOverlap === 'boolean' ? options.eventOverlap : undefined,\n                allow: options.eventAllow,\n                backgroundColor: options.eventBackgroundColor,\n                borderColor: options.eventBorderColor,\n                textColor: options.eventTextColor,\n                color: options.eventColor,\n            }, calendarContext),\n            selectionConfig: createEventUi({\n                constraint: options.selectConstraint,\n                overlap: typeof options.selectOverlap === 'boolean' ? options.selectOverlap : undefined,\n                allow: options.selectAllow,\n            }, calendarContext),\n        };\n    }\n    function parseContextBusinessHours(calendarContext) {\n        return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n    }\n    function warnUnknownOptions(options, viewName) {\n        for (var optionName in options) {\n            console.warn(\"Unknown option '\" + optionName + \"'\" +\n                (viewName ? \" for view '\" + viewName + \"'\" : ''));\n        }\n    }\n\n    // TODO: move this to react plugin?\n    var CalendarDataProvider = /** @class */ (function (_super) {\n        __extends(CalendarDataProvider, _super);\n        function CalendarDataProvider(props) {\n            var _this = _super.call(this, props) || this;\n            _this.handleData = function (data) {\n                if (!_this.dataManager) { // still within initial run, before assignment in constructor\n                    // eslint-disable-next-line react/no-direct-mutation-state\n                    _this.state = data; // can't use setState yet\n                }\n                else {\n                    _this.setState(data);\n                }\n            };\n            _this.dataManager = new CalendarDataManager({\n                optionOverrides: props.optionOverrides,\n                calendarApi: props.calendarApi,\n                onData: _this.handleData,\n            });\n            return _this;\n        }\n        CalendarDataProvider.prototype.render = function () {\n            return this.props.children(this.state);\n        };\n        CalendarDataProvider.prototype.componentDidUpdate = function (prevProps) {\n            var newOptionOverrides = this.props.optionOverrides;\n            if (newOptionOverrides !== prevProps.optionOverrides) { // prevent recursive handleData\n                this.dataManager.resetOptions(newOptionOverrides);\n            }\n        };\n        return CalendarDataProvider;\n    }(Component));\n\n    // HELPERS\n    /*\n    if nextDayThreshold is specified, slicing is done in an all-day fashion.\n    you can get nextDayThreshold from context.nextDayThreshold\n    */\n    function sliceEvents(props, allDay) {\n        return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n    }\n\n    var NamedTimeZoneImpl = /** @class */ (function () {\n        function NamedTimeZoneImpl(timeZoneName) {\n            this.timeZoneName = timeZoneName;\n        }\n        return NamedTimeZoneImpl;\n    }());\n\n    var Interaction = /** @class */ (function () {\n        function Interaction(settings) {\n            this.component = settings.component;\n        }\n        Interaction.prototype.destroy = function () {\n        };\n        return Interaction;\n    }());\n    function parseInteractionSettings(component, input) {\n        return {\n            component: component,\n            el: input.el,\n            useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        };\n    }\n    function interactionSettingsToStore(settings) {\n        var _a;\n        return _a = {},\n            _a[settings.component.uid] = settings,\n            _a;\n    }\n    // global state\n    var interactionSettingsStore = {};\n\n    /*\n    An abstraction for a dragging interaction originating on an event.\n    Does higher-level things than PointerDragger, such as possibly:\n    - a \"mirror\" that moves with the pointer\n    - a minimum number of pixels or other criteria for a true drag to begin\n\n    subclasses must emit:\n    - pointerdown\n    - dragstart\n    - dragmove\n    - pointerup\n    - dragend\n    */\n    var ElementDragging = /** @class */ (function () {\n        function ElementDragging(el, selector) {\n            this.emitter = new Emitter();\n        }\n        ElementDragging.prototype.destroy = function () {\n        };\n        ElementDragging.prototype.setMirrorIsVisible = function (bool) {\n            // optional if subclass doesn't want to support a mirror\n        };\n        ElementDragging.prototype.setMirrorNeedsRevert = function (bool) {\n            // optional if subclass doesn't want to support a mirror\n        };\n        ElementDragging.prototype.setAutoScrollEnabled = function (bool) {\n            // optional\n        };\n        return ElementDragging;\n    }());\n\n    // TODO: get rid of this in favor of options system,\n    // tho it's really easy to access this globally rather than pass thru options.\n    var config = {};\n\n    /*\n    Information about what will happen when an external element is dragged-and-dropped\n    onto a calendar. Contains information for creating an event.\n    */\n    var DRAG_META_REFINERS = {\n        startTime: createDuration,\n        duration: createDuration,\n        create: Boolean,\n        sourceId: String,\n    };\n    function parseDragMeta(raw) {\n        var _a = refineProps(raw, DRAG_META_REFINERS), refined = _a.refined, extra = _a.extra;\n        return {\n            startTime: refined.startTime || null,\n            duration: refined.duration || null,\n            create: refined.create != null ? refined.create : true,\n            sourceId: refined.sourceId,\n            leftoverProps: extra,\n        };\n    }\n\n    var ToolbarSection = /** @class */ (function (_super) {\n        __extends(ToolbarSection, _super);\n        function ToolbarSection() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ToolbarSection.prototype.render = function () {\n            var _this = this;\n            var children = this.props.widgetGroups.map(function (widgetGroup) { return _this.renderWidgetGroup(widgetGroup); });\n            return createElement.apply(void 0, __spreadArrays(['div', { className: 'fc-toolbar-chunk' }], children));\n        };\n        ToolbarSection.prototype.renderWidgetGroup = function (widgetGroup) {\n            var props = this.props;\n            var theme = this.context.theme;\n            var children = [];\n            var isOnlyButtons = true;\n            for (var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++) {\n                var widget = widgetGroup_1[_i];\n                var buttonName = widget.buttonName, buttonClick = widget.buttonClick, buttonText = widget.buttonText, buttonIcon = widget.buttonIcon;\n                if (buttonName === 'title') {\n                    isOnlyButtons = false;\n                    children.push(createElement(\"h2\", { className: \"fc-toolbar-title\" }, props.title));\n                }\n                else {\n                    var ariaAttrs = buttonIcon ? { 'aria-label': buttonName } : {};\n                    var buttonClasses = [\"fc-\" + buttonName + \"-button\", theme.getClass('button')];\n                    if (buttonName === props.activeButton) {\n                        buttonClasses.push(theme.getClass('buttonActive'));\n                    }\n                    var isDisabled = (!props.isTodayEnabled && buttonName === 'today') ||\n                        (!props.isPrevEnabled && buttonName === 'prev') ||\n                        (!props.isNextEnabled && buttonName === 'next');\n                    children.push(createElement(\"button\", __assign({ disabled: isDisabled, className: buttonClasses.join(' '), onClick: buttonClick, type: \"button\" }, ariaAttrs), buttonText || (buttonIcon ? createElement(\"span\", { className: buttonIcon }) : '')));\n                }\n            }\n            if (children.length > 1) {\n                var groupClassName = (isOnlyButtons && theme.getClass('buttonGroup')) || '';\n                return createElement.apply(void 0, __spreadArrays(['div', { className: groupClassName }], children));\n            }\n            return children[0];\n        };\n        return ToolbarSection;\n    }(BaseComponent));\n\n    var Toolbar = /** @class */ (function (_super) {\n        __extends(Toolbar, _super);\n        function Toolbar() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        Toolbar.prototype.render = function () {\n            var _a = this.props, model = _a.model, extraClassName = _a.extraClassName;\n            var forceLtr = false;\n            var startContent;\n            var endContent;\n            var centerContent = model.center;\n            if (model.left) {\n                forceLtr = true;\n                startContent = model.left;\n            }\n            else {\n                startContent = model.start;\n            }\n            if (model.right) {\n                forceLtr = true;\n                endContent = model.right;\n            }\n            else {\n                endContent = model.end;\n            }\n            var classNames = [\n                extraClassName || '',\n                'fc-toolbar',\n                forceLtr ? 'fc-toolbar-ltr' : '',\n            ];\n            return (createElement(\"div\", { className: classNames.join(' ') },\n                this.renderSection('start', startContent || []),\n                this.renderSection('center', centerContent || []),\n                this.renderSection('end', endContent || [])));\n        };\n        Toolbar.prototype.renderSection = function (key, widgetGroups) {\n            var props = this.props;\n            return (createElement(ToolbarSection, { key: key, widgetGroups: widgetGroups, title: props.title, activeButton: props.activeButton, isTodayEnabled: props.isTodayEnabled, isPrevEnabled: props.isPrevEnabled, isNextEnabled: props.isNextEnabled }));\n        };\n        return Toolbar;\n    }(BaseComponent));\n\n    // TODO: do function component?\n    var ViewContainer = /** @class */ (function (_super) {\n        __extends(ViewContainer, _super);\n        function ViewContainer() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.state = {\n                availableWidth: null,\n            };\n            _this.handleEl = function (el) {\n                _this.el = el;\n                setRef(_this.props.elRef, el);\n                _this.updateAvailableWidth();\n            };\n            _this.handleResize = function () {\n                _this.updateAvailableWidth();\n            };\n            return _this;\n        }\n        ViewContainer.prototype.render = function () {\n            var _a = this, props = _a.props, state = _a.state;\n            var aspectRatio = props.aspectRatio;\n            var classNames = [\n                'fc-view-harness',\n                (aspectRatio || props.liquid || props.height)\n                    ? 'fc-view-harness-active' // harness controls the height\n                    : 'fc-view-harness-passive',\n            ];\n            var height = '';\n            var paddingBottom = '';\n            if (aspectRatio) {\n                if (state.availableWidth !== null) {\n                    height = state.availableWidth / aspectRatio;\n                }\n                else {\n                    // while waiting to know availableWidth, we can't set height to *zero*\n                    // because will cause lots of unnecessary scrollbars within scrollgrid.\n                    // BETTER: don't start rendering ANYTHING yet until we know container width\n                    // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                    paddingBottom = (1 / aspectRatio) * 100 + \"%\";\n                }\n            }\n            else {\n                height = props.height || '';\n            }\n            return (createElement(\"div\", { ref: this.handleEl, onClick: props.onClick, className: classNames.join(' '), style: { height: height, paddingBottom: paddingBottom } }, props.children));\n        };\n        ViewContainer.prototype.componentDidMount = function () {\n            this.context.addResizeHandler(this.handleResize);\n        };\n        ViewContainer.prototype.componentWillUnmount = function () {\n            this.context.removeResizeHandler(this.handleResize);\n        };\n        ViewContainer.prototype.updateAvailableWidth = function () {\n            if (this.el && // needed. but why?\n                this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n            ) {\n                this.setState({ availableWidth: this.el.offsetWidth });\n            }\n        };\n        return ViewContainer;\n    }(BaseComponent));\n\n    /*\n    Detects when the user clicks on an event within a DateComponent\n    */\n    var EventClicking = /** @class */ (function (_super) {\n        __extends(EventClicking, _super);\n        function EventClicking(settings) {\n            var _this = _super.call(this, settings) || this;\n            _this.handleSegClick = function (ev, segEl) {\n                var component = _this.component;\n                var context = component.context;\n                var seg = getElSeg(segEl);\n                if (seg && // might be the <div> surrounding the more link\n                    component.isValidSegDownEl(ev.target)) {\n                    // our way to simulate a link click for elements that can't be <a> tags\n                    // grab before trigger fired in case trigger trashes DOM thru rerendering\n                    var hasUrlContainer = elementClosest(ev.target, '.fc-event-forced-url');\n                    var url = hasUrlContainer ? hasUrlContainer.querySelector('a[href]').href : '';\n                    context.emitter.trigger('eventClick', {\n                        el: segEl,\n                        event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n                        jsEvent: ev,\n                        view: context.viewApi,\n                    });\n                    if (url && !ev.defaultPrevented) {\n                        window.location.href = url;\n                    }\n                }\n            };\n            _this.destroy = listenBySelector(settings.el, 'click', '.fc-event', // on both fg and bg events\n            _this.handleSegClick);\n            return _this;\n        }\n        return EventClicking;\n    }(Interaction));\n\n    /*\n    Triggers events and adds/removes core classNames when the user's pointer\n    enters/leaves event-elements of a component.\n    */\n    var EventHovering = /** @class */ (function (_super) {\n        __extends(EventHovering, _super);\n        function EventHovering(settings) {\n            var _this = _super.call(this, settings) || this;\n            // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n            _this.handleEventElRemove = function (el) {\n                if (el === _this.currentSegEl) {\n                    _this.handleSegLeave(null, _this.currentSegEl);\n                }\n            };\n            _this.handleSegEnter = function (ev, segEl) {\n                if (getElSeg(segEl)) { // TODO: better way to make sure not hovering over more+ link or its wrapper\n                    _this.currentSegEl = segEl;\n                    _this.triggerEvent('eventMouseEnter', ev, segEl);\n                }\n            };\n            _this.handleSegLeave = function (ev, segEl) {\n                if (_this.currentSegEl) {\n                    _this.currentSegEl = null;\n                    _this.triggerEvent('eventMouseLeave', ev, segEl);\n                }\n            };\n            _this.removeHoverListeners = listenToHoverBySelector(settings.el, '.fc-event', // on both fg and bg events\n            _this.handleSegEnter, _this.handleSegLeave);\n            return _this;\n        }\n        EventHovering.prototype.destroy = function () {\n            this.removeHoverListeners();\n        };\n        EventHovering.prototype.triggerEvent = function (publicEvName, ev, segEl) {\n            var component = this.component;\n            var context = component.context;\n            var seg = getElSeg(segEl);\n            if (!ev || component.isValidSegDownEl(ev.target)) {\n                context.emitter.trigger(publicEvName, {\n                    el: segEl,\n                    event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi,\n                });\n            }\n        };\n        return EventHovering;\n    }(Interaction));\n\n    var CalendarContent = /** @class */ (function (_super) {\n        __extends(CalendarContent, _super);\n        function CalendarContent() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.buildViewContext = memoize(buildViewContext);\n            _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n            _this.buildToolbarProps = memoize(buildToolbarProps);\n            _this.handleNavLinkClick = buildDelegationHandler('a[data-navlink]', _this._handleNavLinkClick.bind(_this));\n            _this.headerRef = createRef();\n            _this.footerRef = createRef();\n            _this.interactionsStore = {};\n            // Component Registration\n            // -----------------------------------------------------------------------------------------------------------------\n            _this.registerInteractiveComponent = function (component, settingsInput) {\n                var settings = parseInteractionSettings(component, settingsInput);\n                var DEFAULT_INTERACTIONS = [\n                    EventClicking,\n                    EventHovering,\n                ];\n                var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n                var interactions = interactionClasses.map(function (TheInteractionClass) { return new TheInteractionClass(settings); });\n                _this.interactionsStore[component.uid] = interactions;\n                interactionSettingsStore[component.uid] = settings;\n            };\n            _this.unregisterInteractiveComponent = function (component) {\n                for (var _i = 0, _a = _this.interactionsStore[component.uid]; _i < _a.length; _i++) {\n                    var listener = _a[_i];\n                    listener.destroy();\n                }\n                delete _this.interactionsStore[component.uid];\n                delete interactionSettingsStore[component.uid];\n            };\n            // Resizing\n            // -----------------------------------------------------------------------------------------------------------------\n            _this.resizeRunner = new DelayedRunner(function () {\n                _this.props.emitter.trigger('_resize', true); // should window resizes be considered \"forced\" ?\n                _this.props.emitter.trigger('windowResize', { view: _this.props.viewApi });\n            });\n            _this.handleWindowResize = function (ev) {\n                var options = _this.props.options;\n                if (options.handleWindowResize &&\n                    ev.target === window // avoid jqui events\n                ) {\n                    _this.resizeRunner.request(options.windowResizeDelay);\n                }\n            };\n            return _this;\n        }\n        /*\n        renders INSIDE of an outer div\n        */\n        CalendarContent.prototype.render = function () {\n            var props = this.props;\n            var toolbarConfig = props.toolbarConfig, options = props.options;\n            var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), // TODO: use NowTimer????\n            props.viewTitle);\n            var viewVGrow = false;\n            var viewHeight = '';\n            var viewAspectRatio;\n            if (props.isHeightAuto || props.forPrint) {\n                viewHeight = '';\n            }\n            else if (options.height != null) {\n                viewVGrow = true;\n            }\n            else if (options.contentHeight != null) {\n                viewHeight = options.contentHeight;\n            }\n            else {\n                viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n            }\n            var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n            return (createElement(ViewContextType.Provider, { value: viewContext },\n                toolbarConfig.headerToolbar && (createElement(Toolbar, __assign({ ref: this.headerRef, extraClassName: \"fc-header-toolbar\", model: toolbarConfig.headerToolbar }, toolbarProps))),\n                createElement(ViewContainer, { liquid: viewVGrow, height: viewHeight, aspectRatio: viewAspectRatio, onClick: this.handleNavLinkClick },\n                    this.renderView(props),\n                    this.buildAppendContent()),\n                toolbarConfig.footerToolbar && (createElement(Toolbar, __assign({ ref: this.footerRef, extraClassName: \"fc-footer-toolbar\", model: toolbarConfig.footerToolbar }, toolbarProps)))));\n        };\n        CalendarContent.prototype.componentDidMount = function () {\n            var props = this.props;\n            this.calendarInteractions = props.pluginHooks.calendarInteractions\n                .map(function (CalendarInteractionClass) { return new CalendarInteractionClass(props); });\n            window.addEventListener('resize', this.handleWindowResize);\n            var propSetHandlers = props.pluginHooks.propSetHandlers;\n            for (var propName in propSetHandlers) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        };\n        CalendarContent.prototype.componentDidUpdate = function (prevProps) {\n            var props = this.props;\n            var propSetHandlers = props.pluginHooks.propSetHandlers;\n            for (var propName in propSetHandlers) {\n                if (props[propName] !== prevProps[propName]) {\n                    propSetHandlers[propName](props[propName], props);\n                }\n            }\n        };\n        CalendarContent.prototype.componentWillUnmount = function () {\n            window.removeEventListener('resize', this.handleWindowResize);\n            this.resizeRunner.clear();\n            for (var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++) {\n                var interaction = _a[_i];\n                interaction.destroy();\n            }\n            this.props.emitter.trigger('_unmount');\n        };\n        CalendarContent.prototype._handleNavLinkClick = function (ev, anchorEl) {\n            var _a = this.props, dateEnv = _a.dateEnv, options = _a.options, calendarApi = _a.calendarApi;\n            var navLinkOptions = anchorEl.getAttribute('data-navlink');\n            navLinkOptions = navLinkOptions ? JSON.parse(navLinkOptions) : {};\n            var dateMarker = dateEnv.createMarker(navLinkOptions.date);\n            var viewType = navLinkOptions.type;\n            var customAction = viewType === 'day' ? options.navLinkDayClick :\n                viewType === 'week' ? options.navLinkWeekClick : null;\n            if (typeof customAction === 'function') {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            }\n            else {\n                if (typeof customAction === 'string') {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        CalendarContent.prototype.buildAppendContent = function () {\n            var props = this.props;\n            var children = props.pluginHooks.viewContainerAppends.map(function (buildAppendContent) { return buildAppendContent(props); });\n            return createElement.apply(void 0, __spreadArrays([Fragment, {}], children));\n        };\n        CalendarContent.prototype.renderView = function (props) {\n            var pluginHooks = props.pluginHooks;\n            var viewSpec = props.viewSpec;\n            var viewProps = {\n                dateProfile: props.dateProfile,\n                businessHours: props.businessHours,\n                eventStore: props.renderableEventStore,\n                eventUiBases: props.eventUiBases,\n                dateSelection: props.dateSelection,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                isHeightAuto: props.isHeightAuto,\n                forPrint: props.forPrint,\n            };\n            var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n            for (var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++) {\n                var transformer = transformers_1[_i];\n                __assign(viewProps, transformer.transform(viewProps, props));\n            }\n            var ViewComponent = viewSpec.component;\n            return (createElement(ViewComponent, __assign({}, viewProps)));\n        };\n        return CalendarContent;\n    }(PureComponent));\n    function buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n        // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n        var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n        var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n        var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n        return {\n            title: title,\n            activeButton: viewSpec.type,\n            isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n            isPrevEnabled: prevInfo.isValid,\n            isNextEnabled: nextInfo.isValid,\n        };\n    }\n    // Plugin\n    // -----------------------------------------------------------------------------------------------------------------\n    function buildViewPropTransformers(theClasses) {\n        return theClasses.map(function (TheClass) { return new TheClass(); });\n    }\n\n    var CalendarRoot = /** @class */ (function (_super) {\n        __extends(CalendarRoot, _super);\n        function CalendarRoot() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.state = {\n                forPrint: false,\n            };\n            _this.handleBeforePrint = function () {\n                _this.setState({ forPrint: true });\n            };\n            _this.handleAfterPrint = function () {\n                _this.setState({ forPrint: false });\n            };\n            return _this;\n        }\n        CalendarRoot.prototype.render = function () {\n            var props = this.props;\n            var options = props.options;\n            var forPrint = this.state.forPrint;\n            var isHeightAuto = forPrint || options.height === 'auto' || options.contentHeight === 'auto';\n            var height = (!isHeightAuto && options.height != null) ? options.height : '';\n            var classNames = [\n                'fc',\n                forPrint ? 'fc-media-print' : 'fc-media-screen',\n                \"fc-direction-\" + options.direction,\n                props.theme.getClass('root'),\n            ];\n            if (!getCanVGrowWithinCell()) {\n                classNames.push('fc-liquid-hack');\n            }\n            return props.children(classNames, height, isHeightAuto, forPrint);\n        };\n        CalendarRoot.prototype.componentDidMount = function () {\n            var emitter = this.props.emitter;\n            emitter.on('_beforeprint', this.handleBeforePrint);\n            emitter.on('_afterprint', this.handleAfterPrint);\n        };\n        CalendarRoot.prototype.componentWillUnmount = function () {\n            var emitter = this.props.emitter;\n            emitter.off('_beforeprint', this.handleBeforePrint);\n            emitter.off('_afterprint', this.handleAfterPrint);\n        };\n        return CalendarRoot;\n    }(BaseComponent));\n\n    // Computes a default column header formatting string if `colFormat` is not explicitly defined\n    function computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n        // if more than one week row, or if there are a lot of columns with not much space,\n        // put just the day numbers will be in each cell\n        if (!datesRepDistinctDays || dayCnt > 10) {\n            return createFormatter({ weekday: 'short' }); // \"Sat\"\n        }\n        if (dayCnt > 1) {\n            return createFormatter({ weekday: 'short', month: 'numeric', day: 'numeric', omitCommas: true }); // \"Sat 11/12\"\n        }\n        return createFormatter({ weekday: 'long' }); // \"Saturday\"\n    }\n\n    var CLASS_NAME = 'fc-col-header-cell'; // do the cushion too? no\n    function renderInner(hookProps) {\n        return hookProps.text;\n    }\n\n    var TableDateCell = /** @class */ (function (_super) {\n        __extends(TableDateCell, _super);\n        function TableDateCell() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TableDateCell.prototype.render = function () {\n            var _a = this.context, dateEnv = _a.dateEnv, options = _a.options, theme = _a.theme, viewApi = _a.viewApi;\n            var props = this.props;\n            var date = props.date, dateProfile = props.dateProfile;\n            var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n            var classNames = [CLASS_NAME].concat(getDayClassNames(dayMeta, theme));\n            var text = dateEnv.format(date, props.dayHeaderFormat);\n            // if colCnt is 1, we are already in a day-view and don't need a navlink\n            var navLinkAttrs = (options.navLinks && !dayMeta.isDisabled && props.colCnt > 1)\n                ? { 'data-navlink': buildNavLinkData(date), tabIndex: 0 }\n                : {};\n            var hookProps = __assign(__assign(__assign({ date: dateEnv.toDate(date), view: viewApi }, props.extraHookProps), { text: text }), dayMeta);\n            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.dayHeaderClassNames, content: options.dayHeaderContent, defaultContent: renderInner, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement(\"th\", __assign({ ref: rootElRef, className: classNames.concat(customClassNames).join(' '), \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined, colSpan: props.colSpan }, props.extraDataAttrs),\n                createElement(\"div\", { className: \"fc-scrollgrid-sync-inner\" }, !dayMeta.isDisabled && (createElement(\"a\", __assign({ ref: innerElRef, className: [\n                        'fc-col-header-cell-cushion',\n                        props.isSticky ? 'fc-sticky' : '',\n                    ].join(' ') }, navLinkAttrs), innerContent))))); }));\n        };\n        return TableDateCell;\n    }(BaseComponent));\n\n    var TableDowCell = /** @class */ (function (_super) {\n        __extends(TableDowCell, _super);\n        function TableDowCell() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TableDowCell.prototype.render = function () {\n            var props = this.props;\n            var _a = this.context, dateEnv = _a.dateEnv, theme = _a.theme, viewApi = _a.viewApi, options = _a.options;\n            var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n            var dateMeta = {\n                dow: props.dow,\n                isDisabled: false,\n                isFuture: false,\n                isPast: false,\n                isToday: false,\n                isOther: false,\n            };\n            var classNames = [CLASS_NAME].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n            var text = dateEnv.format(date, props.dayHeaderFormat);\n            var hookProps = __assign(__assign(__assign(__assign({ // TODO: make this public?\n                date: date }, dateMeta), { view: viewApi }), props.extraHookProps), { text: text });\n            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.dayHeaderClassNames, content: options.dayHeaderContent, defaultContent: renderInner, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement(\"th\", __assign({ ref: rootElRef, className: classNames.concat(customClassNames).join(' '), colSpan: props.colSpan }, props.extraDataAttrs),\n                createElement(\"div\", { className: \"fc-scrollgrid-sync-inner\" },\n                    createElement(\"a\", { className: [\n                            'fc-col-header-cell-cushion',\n                            props.isSticky ? 'fc-sticky' : '',\n                        ].join(' '), ref: innerElRef }, innerContent)))); }));\n        };\n        return TableDowCell;\n    }(BaseComponent));\n\n    var NowTimer = /** @class */ (function (_super) {\n        __extends(NowTimer, _super);\n        function NowTimer(props, context) {\n            var _this = _super.call(this, props, context) || this;\n            _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n            _this.initialNowQueriedMs = new Date().valueOf();\n            _this.state = _this.computeTiming().currentState;\n            return _this;\n        }\n        NowTimer.prototype.render = function () {\n            var _a = this, props = _a.props, state = _a.state;\n            return props.children(state.nowDate, state.todayRange);\n        };\n        NowTimer.prototype.componentDidMount = function () {\n            this.setTimeout();\n        };\n        NowTimer.prototype.componentDidUpdate = function (prevProps) {\n            if (prevProps.unit !== this.props.unit) {\n                this.clearTimeout();\n                this.setTimeout();\n            }\n        };\n        NowTimer.prototype.componentWillUnmount = function () {\n            this.clearTimeout();\n        };\n        NowTimer.prototype.computeTiming = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n            var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n            var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n            var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n            return {\n                currentState: { nowDate: currentUnitStart, todayRange: buildDayRange(currentUnitStart) },\n                nextState: { nowDate: nextUnitStart, todayRange: buildDayRange(nextUnitStart) },\n                waitMs: waitMs,\n            };\n        };\n        NowTimer.prototype.setTimeout = function () {\n            var _this = this;\n            var _a = this.computeTiming(), nextState = _a.nextState, waitMs = _a.waitMs;\n            this.timeoutId = setTimeout(function () {\n                _this.setState(nextState, function () {\n                    _this.setTimeout();\n                });\n            }, waitMs);\n        };\n        NowTimer.prototype.clearTimeout = function () {\n            if (this.timeoutId) {\n                clearTimeout(this.timeoutId);\n            }\n        };\n        NowTimer.contextType = ViewContextType;\n        return NowTimer;\n    }(Component));\n    function buildDayRange(date) {\n        var start = startOfDay(date);\n        var end = addDays(start, 1);\n        return { start: start, end: end };\n    }\n\n    var DayHeader = /** @class */ (function (_super) {\n        __extends(DayHeader, _super);\n        function DayHeader() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n            return _this;\n        }\n        DayHeader.prototype.render = function () {\n            var context = this.context;\n            var _a = this.props, dates = _a.dates, dateProfile = _a.dateProfile, datesRepDistinctDays = _a.datesRepDistinctDays, renderIntro = _a.renderIntro;\n            var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n            return (createElement(NowTimer, { unit: \"day\" }, function (nowDate, todayRange) { return (createElement(\"tr\", null,\n                renderIntro && renderIntro(),\n                dates.map(function (date) { return (datesRepDistinctDays ? (createElement(TableDateCell, { key: date.toISOString(), date: date, dateProfile: dateProfile, todayRange: todayRange, colCnt: dates.length, dayHeaderFormat: dayHeaderFormat })) : (createElement(TableDowCell, { key: date.getUTCDay(), dow: date.getUTCDay(), dayHeaderFormat: dayHeaderFormat }))); }))); }));\n        };\n        return DayHeader;\n    }(BaseComponent));\n    function createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n        return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n    }\n\n    var DaySeriesModel = /** @class */ (function () {\n        function DaySeriesModel(range, dateProfileGenerator) {\n            var date = range.start;\n            var end = range.end;\n            var indices = [];\n            var dates = [];\n            var dayIndex = -1;\n            while (date < end) { // loop each day from start to end\n                if (dateProfileGenerator.isHiddenDay(date)) {\n                    indices.push(dayIndex + 0.5); // mark that it's between indices\n                }\n                else {\n                    dayIndex += 1;\n                    indices.push(dayIndex);\n                    dates.push(date);\n                }\n                date = addDays(date, 1);\n            }\n            this.dates = dates;\n            this.indices = indices;\n            this.cnt = dates.length;\n        }\n        DaySeriesModel.prototype.sliceRange = function (range) {\n            var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n            var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n            var clippedFirstIndex = Math.max(0, firstIndex);\n            var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n            // deal with in-between indices\n            clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n            clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n            if (clippedFirstIndex <= clippedLastIndex) {\n                return {\n                    firstIndex: clippedFirstIndex,\n                    lastIndex: clippedLastIndex,\n                    isStart: firstIndex === clippedFirstIndex,\n                    isEnd: lastIndex === clippedLastIndex,\n                };\n            }\n            return null;\n        };\n        // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n        // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n        // If before the first offset, returns a negative number.\n        // If after the last offset, returns an offset past the last cell offset.\n        // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n        DaySeriesModel.prototype.getDateDayIndex = function (date) {\n            var indices = this.indices;\n            var dayOffset = Math.floor(diffDays(this.dates[0], date));\n            if (dayOffset < 0) {\n                return indices[0] - 1;\n            }\n            if (dayOffset >= indices.length) {\n                return indices[indices.length - 1] + 1;\n            }\n            return indices[dayOffset];\n        };\n        return DaySeriesModel;\n    }());\n\n    var DayTableModel = /** @class */ (function () {\n        function DayTableModel(daySeries, breakOnWeeks) {\n            var dates = daySeries.dates;\n            var daysPerRow;\n            var firstDay;\n            var rowCnt;\n            if (breakOnWeeks) {\n                // count columns until the day-of-week repeats\n                firstDay = dates[0].getUTCDay();\n                for (daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1) {\n                    if (dates[daysPerRow].getUTCDay() === firstDay) {\n                        break;\n                    }\n                }\n                rowCnt = Math.ceil(dates.length / daysPerRow);\n            }\n            else {\n                rowCnt = 1;\n                daysPerRow = dates.length;\n            }\n            this.rowCnt = rowCnt;\n            this.colCnt = daysPerRow;\n            this.daySeries = daySeries;\n            this.cells = this.buildCells();\n            this.headerDates = this.buildHeaderDates();\n        }\n        DayTableModel.prototype.buildCells = function () {\n            var rows = [];\n            for (var row = 0; row < this.rowCnt; row += 1) {\n                var cells = [];\n                for (var col = 0; col < this.colCnt; col += 1) {\n                    cells.push(this.buildCell(row, col));\n                }\n                rows.push(cells);\n            }\n            return rows;\n        };\n        DayTableModel.prototype.buildCell = function (row, col) {\n            var date = this.daySeries.dates[row * this.colCnt + col];\n            return {\n                key: date.toISOString(),\n                date: date,\n            };\n        };\n        DayTableModel.prototype.buildHeaderDates = function () {\n            var dates = [];\n            for (var col = 0; col < this.colCnt; col += 1) {\n                dates.push(this.cells[0][col].date);\n            }\n            return dates;\n        };\n        DayTableModel.prototype.sliceRange = function (range) {\n            var colCnt = this.colCnt;\n            var seriesSeg = this.daySeries.sliceRange(range);\n            var segs = [];\n            if (seriesSeg) {\n                var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;\n                var index = firstIndex;\n                while (index <= lastIndex) {\n                    var row = Math.floor(index / colCnt);\n                    var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                    segs.push({\n                        row: row,\n                        firstCol: index % colCnt,\n                        lastCol: (nextIndex - 1) % colCnt,\n                        isStart: seriesSeg.isStart && index === firstIndex,\n                        isEnd: seriesSeg.isEnd && (nextIndex - 1) === lastIndex,\n                    });\n                    index = nextIndex;\n                }\n            }\n            return segs;\n        };\n        return DayTableModel;\n    }());\n\n    var Slicer = /** @class */ (function () {\n        function Slicer() {\n            this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n            this.sliceDateSelection = memoize(this._sliceDateSpan);\n            this.sliceEventStore = memoize(this._sliceEventStore);\n            this.sliceEventDrag = memoize(this._sliceInteraction);\n            this.sliceEventResize = memoize(this._sliceInteraction);\n            this.forceDayIfListItem = false; // hack\n        }\n        Slicer.prototype.sliceProps = function (props, dateProfile, nextDayThreshold, context) {\n            var extraArgs = [];\n            for (var _i = 4; _i < arguments.length; _i++) {\n                extraArgs[_i - 4] = arguments[_i];\n            }\n            var eventUiBases = props.eventUiBases;\n            var eventSegs = this.sliceEventStore.apply(this, __spreadArrays([props.eventStore, eventUiBases, dateProfile, nextDayThreshold], extraArgs));\n            return {\n                dateSelectionSegs: this.sliceDateSelection.apply(this, __spreadArrays([props.dateSelection, eventUiBases, context], extraArgs)),\n                businessHourSegs: this.sliceBusinessHours.apply(this, __spreadArrays([props.businessHours, dateProfile, nextDayThreshold, context], extraArgs)),\n                fgEventSegs: eventSegs.fg,\n                bgEventSegs: eventSegs.bg,\n                eventDrag: this.sliceEventDrag.apply(this, __spreadArrays([props.eventDrag, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n                eventResize: this.sliceEventResize.apply(this, __spreadArrays([props.eventResize, eventUiBases, dateProfile, nextDayThreshold], extraArgs)),\n                eventSelection: props.eventSelection,\n            }; // TODO: give interactionSegs?\n        };\n        Slicer.prototype.sliceNowDate = function (// does not memoize\n        date, context) {\n            var extraArgs = [];\n            for (var _i = 2; _i < arguments.length; _i++) {\n                extraArgs[_i - 2] = arguments[_i];\n            }\n            return this._sliceDateSpan.apply(this, __spreadArrays([{ range: { start: date, end: addMs(date, 1) }, allDay: false },\n                {},\n                context], extraArgs));\n        };\n        Slicer.prototype._sliceBusinessHours = function (businessHours, dateProfile, nextDayThreshold, context) {\n            var extraArgs = [];\n            for (var _i = 4; _i < arguments.length; _i++) {\n                extraArgs[_i - 4] = arguments[_i];\n            }\n            if (!businessHours) {\n                return [];\n            }\n            return this._sliceEventStore.apply(this, __spreadArrays([expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context),\n                {},\n                dateProfile,\n                nextDayThreshold], extraArgs)).bg;\n        };\n        Slicer.prototype._sliceEventStore = function (eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n            var extraArgs = [];\n            for (var _i = 4; _i < arguments.length; _i++) {\n                extraArgs[_i - 4] = arguments[_i];\n            }\n            if (eventStore) {\n                var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n                return {\n                    bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                    fg: this.sliceEventRanges(rangeRes.fg, extraArgs),\n                };\n            }\n            return { bg: [], fg: [] };\n        };\n        Slicer.prototype._sliceInteraction = function (interaction, eventUiBases, dateProfile, nextDayThreshold) {\n            var extraArgs = [];\n            for (var _i = 4; _i < arguments.length; _i++) {\n                extraArgs[_i - 4] = arguments[_i];\n            }\n            if (!interaction) {\n                return null;\n            }\n            var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n                affectedInstances: interaction.affectedEvents.instances,\n                isEvent: interaction.isEvent,\n            };\n        };\n        Slicer.prototype._sliceDateSpan = function (dateSpan, eventUiBases, context) {\n            var extraArgs = [];\n            for (var _i = 3; _i < arguments.length; _i++) {\n                extraArgs[_i - 3] = arguments[_i];\n            }\n            if (!dateSpan) {\n                return [];\n            }\n            var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n            var segs = this.sliceRange.apply(this, __spreadArrays([dateSpan.range], extraArgs));\n            for (var _a = 0, segs_1 = segs; _a < segs_1.length; _a++) {\n                var seg = segs_1[_a];\n                seg.eventRange = eventRange;\n            }\n            return segs;\n        };\n        /*\n        \"complete\" seg means it has component and eventRange\n        */\n        Slicer.prototype.sliceEventRanges = function (eventRanges, extraArgs) {\n            var segs = [];\n            for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n                var eventRange = eventRanges_1[_i];\n                segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n            }\n            return segs;\n        };\n        /*\n        \"complete\" seg means it has component and eventRange\n        */\n        Slicer.prototype.sliceEventRange = function (eventRange, extraArgs) {\n            var dateRange = eventRange.range;\n            // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n            if (this.forceDayIfListItem && eventRange.ui.display === 'list-item') {\n                dateRange = {\n                    start: dateRange.start,\n                    end: addDays(dateRange.start, 1),\n                };\n            }\n            var segs = this.sliceRange.apply(this, __spreadArrays([dateRange], extraArgs));\n            for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n                var seg = segs_2[_i];\n                seg.eventRange = eventRange;\n                seg.isStart = eventRange.isStart && seg.isStart;\n                seg.isEnd = eventRange.isEnd && seg.isEnd;\n            }\n            return segs;\n        };\n        return Slicer;\n    }());\n    /*\n    for incorporating slotMinTime/slotMaxTime if appropriate\n    TODO: should be part of DateProfile!\n    TimelineDateProfile already does this btw\n    */\n    function computeActiveRange(dateProfile, isComponentAllDay) {\n        var range = dateProfile.activeRange;\n        if (isComponentAllDay) {\n            return range;\n        }\n        return {\n            start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n            end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5),\n        };\n    }\n\n    var VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\n    var Scroller = /** @class */ (function (_super) {\n        __extends(Scroller, _super);\n        function Scroller() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.handleEl = function (el) {\n                _this.el = el;\n                setRef(_this.props.elRef, el);\n            };\n            return _this;\n        }\n        Scroller.prototype.render = function () {\n            var props = this.props;\n            var liquid = props.liquid, liquidIsAbsolute = props.liquidIsAbsolute;\n            var isAbsolute = liquid && liquidIsAbsolute;\n            var className = ['fc-scroller'];\n            if (liquid) {\n                if (liquidIsAbsolute) {\n                    className.push('fc-scroller-liquid-absolute');\n                }\n                else {\n                    className.push('fc-scroller-liquid');\n                }\n            }\n            return (createElement(\"div\", { ref: this.handleEl, className: className.join(' '), style: {\n                    overflowX: props.overflowX,\n                    overflowY: props.overflowY,\n                    left: (isAbsolute && -(props.overcomeLeft || 0)) || '',\n                    right: (isAbsolute && -(props.overcomeRight || 0)) || '',\n                    bottom: (isAbsolute && -(props.overcomeBottom || 0)) || '',\n                    marginLeft: (!isAbsolute && -(props.overcomeLeft || 0)) || '',\n                    marginRight: (!isAbsolute && -(props.overcomeRight || 0)) || '',\n                    marginBottom: (!isAbsolute && -(props.overcomeBottom || 0)) || '',\n                    maxHeight: props.maxHeight || '',\n                } }, props.children));\n        };\n        Scroller.prototype.needsXScrolling = function () {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n                return false;\n            }\n            // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n            // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n            // inner-child margins and absolute positioning\n            var el = this.el;\n            var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n            var children = el.children;\n            for (var i = 0; i < children.length; i += 1) {\n                var childEl = children[i];\n                if (childEl.getBoundingClientRect().width > realClientWidth) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        Scroller.prototype.needsYScrolling = function () {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n                return false;\n            }\n            // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n            // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n            // inner-child margins and absolute positioning\n            var el = this.el;\n            var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n            var children = el.children;\n            for (var i = 0; i < children.length; i += 1) {\n                var childEl = children[i];\n                if (childEl.getBoundingClientRect().height > realClientHeight) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        Scroller.prototype.getXScrollbarWidth = function () {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n                return 0;\n            }\n            return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n        };\n        Scroller.prototype.getYScrollbarWidth = function () {\n            if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n                return 0;\n            }\n            return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n        };\n        return Scroller;\n    }(BaseComponent));\n\n    /*\n    TODO: somehow infer OtherArgs from masterCallback?\n    TODO: infer RefType from masterCallback if provided\n    */\n    var RefMap = /** @class */ (function () {\n        function RefMap(masterCallback) {\n            var _this = this;\n            this.masterCallback = masterCallback;\n            this.currentMap = {};\n            this.depths = {};\n            this.callbackMap = {};\n            this.handleValue = function (val, key) {\n                var _a = _this, depths = _a.depths, currentMap = _a.currentMap;\n                var removed = false;\n                var added = false;\n                if (val !== null) {\n                    // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                    removed = (key in currentMap);\n                    currentMap[key] = val;\n                    depths[key] = (depths[key] || 0) + 1;\n                    added = true;\n                }\n                else {\n                    depths[key] -= 1;\n                    if (!depths[key]) {\n                        delete currentMap[key];\n                        delete _this.callbackMap[key];\n                        removed = true;\n                    }\n                }\n                if (_this.masterCallback) {\n                    if (removed) {\n                        _this.masterCallback(null, String(key));\n                    }\n                    if (added) {\n                        _this.masterCallback(val, String(key));\n                    }\n                }\n            };\n        }\n        RefMap.prototype.createRef = function (key) {\n            var _this = this;\n            var refCallback = this.callbackMap[key];\n            if (!refCallback) {\n                refCallback = this.callbackMap[key] = function (val) {\n                    _this.handleValue(val, String(key));\n                };\n            }\n            return refCallback;\n        };\n        // TODO: check callers that don't care about order. should use getAll instead\n        // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n        // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n        RefMap.prototype.collect = function (startIndex, endIndex, step) {\n            return collectFromHash(this.currentMap, startIndex, endIndex, step);\n        };\n        RefMap.prototype.getAll = function () {\n            return hashValuesToArray(this.currentMap);\n        };\n        return RefMap;\n    }());\n\n    function computeShrinkWidth(chunkEls) {\n        var shrinkCells = findElements(chunkEls, '.fc-scrollgrid-shrink');\n        var largestWidth = 0;\n        for (var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++) {\n            var shrinkCell = shrinkCells_1[_i];\n            largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n        }\n        return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n    }\n    function getSectionHasLiquidHeight(props, sectionConfig) {\n        return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n    }\n    function getAllowYScrolling(props, sectionConfig) {\n        return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n            getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n    }\n    // TODO: ONLY use `arg`. force out internal function to use same API\n    function renderChunkContent(sectionConfig, chunkConfig, arg) {\n        var expandRows = arg.expandRows;\n        var content = typeof chunkConfig.content === 'function' ?\n            chunkConfig.content(arg) :\n            createElement('table', {\n                className: [\n                    chunkConfig.tableClassName,\n                    sectionConfig.syncRowHeights ? 'fc-scrollgrid-sync-table' : '',\n                ].join(' '),\n                style: {\n                    minWidth: arg.tableMinWidth,\n                    width: arg.clientWidth,\n                    height: expandRows ? arg.clientHeight : '',\n                },\n            }, arg.tableColGroupNode, createElement('tbody', {}, typeof chunkConfig.rowContent === 'function' ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n        return content;\n    }\n    function isColPropsEqual(cols0, cols1) {\n        return isArraysEqual(cols0, cols1, isPropsEqual);\n    }\n    function renderMicroColGroup(cols, shrinkWidth) {\n        var colNodes = [];\n        /*\n        for ColProps with spans, it would have been great to make a single <col span=\"\">\n        HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n        SOLUTION: making individual <col> elements makes Chrome behave.\n        */\n        for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {\n            var colProps = cols_1[_i];\n            var span = colProps.span || 1;\n            for (var i = 0; i < span; i += 1) {\n                colNodes.push(createElement(\"col\", { style: {\n                        width: colProps.width === 'shrink' ? sanitizeShrinkWidth(shrinkWidth) : (colProps.width || ''),\n                        minWidth: colProps.minWidth || '',\n                    } }));\n            }\n        }\n        return createElement.apply(void 0, __spreadArrays(['colgroup', {}], colNodes));\n    }\n    function sanitizeShrinkWidth(shrinkWidth) {\n        /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n        4 accounts for 2 2-pixel borders. TODO: better solution? */\n        return shrinkWidth == null ? 4 : shrinkWidth;\n    }\n    function hasShrinkWidth(cols) {\n        for (var _i = 0, cols_2 = cols; _i < cols_2.length; _i++) {\n            var col = cols_2[_i];\n            if (col.width === 'shrink') {\n                return true;\n            }\n        }\n        return false;\n    }\n    function getScrollGridClassNames(liquid, context) {\n        var classNames = [\n            'fc-scrollgrid',\n            context.theme.getClass('table'),\n        ];\n        if (liquid) {\n            classNames.push('fc-scrollgrid-liquid');\n        }\n        return classNames;\n    }\n    function getSectionClassNames(sectionConfig, wholeTableVGrow) {\n        var classNames = [\n            'fc-scrollgrid-section',\n            \"fc-scrollgrid-section-\" + sectionConfig.type,\n            sectionConfig.className,\n        ];\n        if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n            classNames.push('fc-scrollgrid-section-liquid');\n        }\n        if (sectionConfig.isSticky) {\n            classNames.push('fc-scrollgrid-section-sticky');\n        }\n        return classNames;\n    }\n    function renderScrollShim(arg) {\n        return (createElement(\"div\", { className: \"fc-scrollgrid-sticky-shim\", style: {\n                width: arg.clientWidth,\n                minWidth: arg.tableMinWidth,\n            } }));\n    }\n    function getStickyHeaderDates(options) {\n        var stickyHeaderDates = options.stickyHeaderDates;\n        if (stickyHeaderDates == null || stickyHeaderDates === 'auto') {\n            stickyHeaderDates = options.height === 'auto' || options.viewHeight === 'auto';\n        }\n        return stickyHeaderDates;\n    }\n    function getStickyFooterScrollbar(options) {\n        var stickyFooterScrollbar = options.stickyFooterScrollbar;\n        if (stickyFooterScrollbar == null || stickyFooterScrollbar === 'auto') {\n            stickyFooterScrollbar = options.height === 'auto' || options.viewHeight === 'auto';\n        }\n        return stickyFooterScrollbar;\n    }\n\n    var SimpleScrollGrid = /** @class */ (function (_super) {\n        __extends(SimpleScrollGrid, _super);\n        function SimpleScrollGrid() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.processCols = memoize(function (a) { return a; }, isColPropsEqual); // so we get same `cols` props every time\n            // yucky to memoize VNodes, but much more efficient for consumers\n            _this.renderMicroColGroup = memoize(renderMicroColGroup);\n            _this.scrollerRefs = new RefMap();\n            _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n            _this.state = {\n                shrinkWidth: null,\n                forceYScrollbars: false,\n                scrollerClientWidths: {},\n                scrollerClientHeights: {},\n            };\n            // TODO: can do a really simple print-view. dont need to join rows\n            _this.handleSizing = function () {\n                _this.setState(__assign({ shrinkWidth: _this.computeShrinkWidth() }, _this.computeScrollerDims()));\n            };\n            return _this;\n        }\n        SimpleScrollGrid.prototype.render = function () {\n            var _a = this, props = _a.props, state = _a.state, context = _a.context;\n            var sectionConfigs = props.sections || [];\n            var cols = this.processCols(props.cols);\n            var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n            var classNames = getScrollGridClassNames(props.liquid, context);\n            // TODO: make DRY\n            var configCnt = sectionConfigs.length;\n            var configI = 0;\n            var currentConfig;\n            var headSectionNodes = [];\n            var bodySectionNodes = [];\n            var footSectionNodes = [];\n            while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'header') {\n                headSectionNodes.push(this.renderSection(currentConfig, configI, microColGroupNode));\n                configI += 1;\n            }\n            while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'body') {\n                bodySectionNodes.push(this.renderSection(currentConfig, configI, microColGroupNode));\n                configI += 1;\n            }\n            while (configI < configCnt && (currentConfig = sectionConfigs[configI]).type === 'footer') {\n                footSectionNodes.push(this.renderSection(currentConfig, configI, microColGroupNode));\n                configI += 1;\n            }\n            // firefox bug: when setting height on table and there is a thead or tfoot,\n            // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n            // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n            // if so, use a simpler dom structure, jam everything into a lone tbody.\n            var isBuggy = !getCanVGrowWithinCell();\n            return createElement('table', {\n                className: classNames.join(' '),\n                style: { height: props.height },\n            }, Boolean(!isBuggy && headSectionNodes.length) && createElement.apply(void 0, __spreadArrays(['thead', {}], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && createElement.apply(void 0, __spreadArrays(['tbody', {}], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && createElement.apply(void 0, __spreadArrays(['tfoot', {}], footSectionNodes)), isBuggy && createElement.apply(void 0, __spreadArrays(['tbody', {}], headSectionNodes, bodySectionNodes, footSectionNodes)));\n        };\n        SimpleScrollGrid.prototype.renderSection = function (sectionConfig, sectionI, microColGroupNode) {\n            if ('outerContent' in sectionConfig) {\n                return (createElement(Fragment, { key: sectionConfig.key }, sectionConfig.outerContent));\n            }\n            return (createElement(\"tr\", { key: sectionConfig.key, className: getSectionClassNames(sectionConfig, this.props.liquid).join(' ') }, this.renderChunkTd(sectionConfig, sectionI, microColGroupNode, sectionConfig.chunk)));\n        };\n        SimpleScrollGrid.prototype.renderChunkTd = function (sectionConfig, sectionI, microColGroupNode, chunkConfig) {\n            if ('outerContent' in chunkConfig) {\n                return chunkConfig.outerContent;\n            }\n            var props = this.props;\n            var _a = this.state, forceYScrollbars = _a.forceYScrollbars, scrollerClientWidths = _a.scrollerClientWidths, scrollerClientHeights = _a.scrollerClientHeights;\n            var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n            var isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n            // for `!props.liquid` - is WHOLE scrollgrid natural height?\n            // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n            var overflowY = !props.liquid ? 'visible' :\n                forceYScrollbars ? 'scroll' :\n                    !needsYScrolling ? 'hidden' :\n                        'auto';\n            var content = renderChunkContent(sectionConfig, chunkConfig, {\n                tableColGroupNode: microColGroupNode,\n                tableMinWidth: '',\n                clientWidth: scrollerClientWidths[sectionI] !== undefined ? scrollerClientWidths[sectionI] : null,\n                clientHeight: scrollerClientHeights[sectionI] !== undefined ? scrollerClientHeights[sectionI] : null,\n                expandRows: sectionConfig.expandRows,\n                syncRowHeights: false,\n                rowSyncHeights: [],\n                reportRowHeightChange: function () { },\n            });\n            return (createElement(\"td\", { ref: chunkConfig.elRef },\n                createElement(\"div\", { className: \"fc-scroller-harness\" + (isLiquid ? ' fc-scroller-harness-liquid' : '') },\n                    createElement(Scroller, { ref: this.scrollerRefs.createRef(sectionI), elRef: this.scrollerElRefs.createRef(sectionI), overflowY: overflowY, overflowX: !props.liquid ? 'visible' : 'hidden' /* natural height? */, maxHeight: sectionConfig.maxHeight, liquid: isLiquid, liquidIsAbsolute // because its within a harness\n                        : true }, content))));\n        };\n        SimpleScrollGrid.prototype._handleScrollerEl = function (scrollerEl, key) {\n            var sectionI = parseInt(key, 10);\n            var chunkConfig = this.props.sections[sectionI].chunk;\n            setRef(chunkConfig.scrollerElRef, scrollerEl);\n        };\n        SimpleScrollGrid.prototype.componentDidMount = function () {\n            this.handleSizing();\n            this.context.addResizeHandler(this.handleSizing);\n        };\n        SimpleScrollGrid.prototype.componentDidUpdate = function () {\n            // TODO: need better solution when state contains non-sizing things\n            this.handleSizing();\n        };\n        SimpleScrollGrid.prototype.componentWillUnmount = function () {\n            this.context.removeResizeHandler(this.handleSizing);\n        };\n        SimpleScrollGrid.prototype.computeShrinkWidth = function () {\n            return hasShrinkWidth(this.props.cols)\n                ? computeShrinkWidth(this.scrollerElRefs.getAll())\n                : 0;\n        };\n        SimpleScrollGrid.prototype.computeScrollerDims = function () {\n            var scrollbarWidth = getScrollbarWidths();\n            var sectionCnt = this.props.sections.length;\n            var _a = this, scrollerRefs = _a.scrollerRefs, scrollerElRefs = _a.scrollerElRefs;\n            var forceYScrollbars = false;\n            var scrollerClientWidths = {};\n            var scrollerClientHeights = {};\n            for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n                var scroller = scrollerRefs.currentMap[sectionI];\n                if (scroller && scroller.needsYScrolling()) {\n                    forceYScrollbars = true;\n                    break;\n                }\n            }\n            for (var sectionI = 0; sectionI < sectionCnt; sectionI += 1) { // along edge\n                var scrollerEl = scrollerElRefs.currentMap[sectionI];\n                if (scrollerEl) {\n                    var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                    scrollerClientWidths[sectionI] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars\n                        ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                        : 0));\n                    scrollerClientHeights[sectionI] = Math.floor(harnessEl.getBoundingClientRect().height);\n                }\n            }\n            return { forceYScrollbars: forceYScrollbars, scrollerClientWidths: scrollerClientWidths, scrollerClientHeights: scrollerClientHeights };\n        };\n        return SimpleScrollGrid;\n    }(BaseComponent));\n    SimpleScrollGrid.addStateEquality({\n        scrollerClientWidths: isPropsEqual,\n        scrollerClientHeights: isPropsEqual,\n    });\n\n    var EventRoot = /** @class */ (function (_super) {\n        __extends(EventRoot, _super);\n        function EventRoot() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.elRef = createRef();\n            return _this;\n        }\n        EventRoot.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var options = context.options;\n            var seg = props.seg;\n            var eventRange = seg.eventRange;\n            var ui = eventRange.ui;\n            var hookProps = {\n                event: new EventApi(context, eventRange.def, eventRange.instance),\n                view: context.viewApi,\n                timeText: props.timeText,\n                textColor: ui.textColor,\n                backgroundColor: ui.backgroundColor,\n                borderColor: ui.borderColor,\n                isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n                isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n                isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n                isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n                isStart: Boolean(seg.isStart),\n                isEnd: Boolean(seg.isEnd),\n                isPast: Boolean(props.isPast),\n                isFuture: Boolean(props.isFuture),\n                isToday: Boolean(props.isToday),\n                isSelected: Boolean(props.isSelected),\n                isDragging: Boolean(props.isDragging),\n                isResizing: Boolean(props.isResizing),\n            };\n            var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.eventClassNames, content: options.eventContent, defaultContent: props.defaultContent, didMount: options.eventDidMount, willUnmount: options.eventWillUnmount, elRef: this.elRef }, function (rootElRef, customClassNames, innerElRef, innerContent) { return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps); }));\n        };\n        EventRoot.prototype.componentDidMount = function () {\n            setElSeg(this.elRef.current, this.props.seg);\n        };\n        /*\n        need to re-assign seg to the element if seg changes, even if the element is the same\n        */\n        EventRoot.prototype.componentDidUpdate = function (prevProps) {\n            var seg = this.props.seg;\n            if (seg !== prevProps.seg) {\n                setElSeg(this.elRef.current, seg);\n            }\n        };\n        return EventRoot;\n    }(BaseComponent));\n\n    // should not be a purecomponent\n    var StandardEvent = /** @class */ (function (_super) {\n        __extends(StandardEvent, _super);\n        function StandardEvent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        StandardEvent.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var seg = props.seg;\n            var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n            var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n            return (createElement(EventRoot, { seg: seg, timeText: timeText, disableDragging: props.disableDragging, disableResizing: props.disableResizing, defaultContent: props.defaultContent || renderInnerContent, isDragging: props.isDragging, isResizing: props.isResizing, isDateSelecting: props.isDateSelecting, isSelected: props.isSelected, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) { return (createElement(\"a\", __assign({ className: props.extraClassNames.concat(classNames).join(' '), style: {\n                    borderColor: hookProps.borderColor,\n                    backgroundColor: hookProps.backgroundColor,\n                }, ref: rootElRef }, getSegAnchorAttrs(seg)),\n                createElement(\"div\", { className: \"fc-event-main\", ref: innerElRef, style: { color: hookProps.textColor } }, innerContent),\n                hookProps.isStartResizable &&\n                    createElement(\"div\", { className: \"fc-event-resizer fc-event-resizer-start\" }),\n                hookProps.isEndResizable &&\n                    createElement(\"div\", { className: \"fc-event-resizer fc-event-resizer-end\" }))); }));\n        };\n        return StandardEvent;\n    }(BaseComponent));\n    function renderInnerContent(innerProps) {\n        return (createElement(\"div\", { className: \"fc-event-main-frame\" },\n            innerProps.timeText && (createElement(\"div\", { className: \"fc-event-time\" }, innerProps.timeText)),\n            createElement(\"div\", { className: \"fc-event-title-container\" },\n                createElement(\"div\", { className: \"fc-event-title fc-sticky\" }, innerProps.event.title || createElement(Fragment, null, \"\\u00A0\")))));\n    }\n    function getSegAnchorAttrs(seg) {\n        var url = seg.eventRange.def.url;\n        return url ? { href: url } : {};\n    }\n\n    var NowIndicatorRoot = function (props) { return (createElement(ViewContextType.Consumer, null, function (context) {\n        var options = context.options;\n        var hookProps = {\n            isAxis: props.isAxis,\n            date: context.dateEnv.toDate(props.date),\n            view: context.viewApi,\n        };\n        return (createElement(RenderHook, { hookProps: hookProps, classNames: options.nowIndicatorClassNames, content: options.nowIndicatorContent, didMount: options.nowIndicatorDidMount, willUnmount: options.nowIndicatorWillUnmount }, props.children));\n    })); };\n\n    var DAY_NUM_FORMAT = createFormatter({ day: 'numeric' });\n    var DayCellContent = /** @class */ (function (_super) {\n        __extends(DayCellContent, _super);\n        function DayCellContent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DayCellContent.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var options = context.options;\n            var hookProps = refineDayCellHookProps({\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                showDayNumber: props.showDayNumber,\n                extraProps: props.extraHookProps,\n                viewApi: context.viewApi,\n                dateEnv: context.dateEnv,\n            });\n            return (createElement(ContentHook, { hookProps: hookProps, content: options.dayCellContent, defaultContent: props.defaultContent }, props.children));\n        };\n        return DayCellContent;\n    }(BaseComponent));\n    function refineDayCellHookProps(raw) {\n        var date = raw.date, dateEnv = raw.dateEnv;\n        var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n        return __assign(__assign(__assign({ date: dateEnv.toDate(date), view: raw.viewApi }, dayMeta), { dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : '' }), raw.extraProps);\n    }\n\n    var DayCellRoot = /** @class */ (function (_super) {\n        __extends(DayCellRoot, _super);\n        function DayCellRoot() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n            _this.normalizeClassNames = buildClassNameNormalizer();\n            return _this;\n        }\n        DayCellRoot.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var options = context.options;\n            var hookProps = this.refineHookProps({\n                date: props.date,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                showDayNumber: props.showDayNumber,\n                extraProps: props.extraHookProps,\n                viewApi: context.viewApi,\n                dateEnv: context.dateEnv,\n            });\n            var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled\n                ? [] // don't use custom classNames if disabled\n                : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n            var dataAttrs = hookProps.isDisabled ? {} : {\n                'data-date': formatDayString(props.date),\n            };\n            return (createElement(MountHook, { hookProps: hookProps, didMount: options.dayCellDidMount, willUnmount: options.dayCellWillUnmount, elRef: props.elRef }, function (rootElRef) { return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled); }));\n        };\n        return DayCellRoot;\n    }(BaseComponent));\n\n    function renderFill(fillType) {\n        return (createElement(\"div\", { className: \"fc-\" + fillType }));\n    }\n    var BgEvent = function (props) { return (createElement(EventRoot, { defaultContent: renderInnerContent$1, seg: props.seg /* uselesss i think */, timeText: \"\", disableDragging: true, disableResizing: true, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) { return (createElement(\"div\", { ref: rootElRef, className: ['fc-bg-event'].concat(classNames).join(' '), style: {\n            backgroundColor: hookProps.backgroundColor,\n        } }, innerContent)); })); };\n    function renderInnerContent$1(props) {\n        var title = props.event.title;\n        return title && (createElement(\"div\", { className: \"fc-event-title\" }, props.event.title));\n    }\n\n    var WeekNumberRoot = function (props) { return (createElement(ViewContextType.Consumer, null, function (context) {\n        var dateEnv = context.dateEnv, options = context.options;\n        var date = props.date;\n        var format = options.weekNumberFormat || props.defaultFormat;\n        var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n        var text = dateEnv.format(date, format);\n        var hookProps = { num: num, text: text, date: date };\n        return (createElement(RenderHook, { hookProps: hookProps, classNames: options.weekNumberClassNames, content: options.weekNumberContent, defaultContent: renderInner$1, didMount: options.weekNumberDidMount, willUnmount: options.weekNumberWillUnmount }, props.children));\n    })); };\n    function renderInner$1(innerProps) {\n        return innerProps.text;\n    }\n\n    // exports\n    // --------------------------------------------------------------------------------------------------\n    var version = '5.3.2'; // important to type it, so .d.ts has generic string\n\n    var Calendar = /** @class */ (function (_super) {\n        __extends(Calendar, _super);\n        function Calendar(el, optionOverrides) {\n            if (optionOverrides === void 0) { optionOverrides = {}; }\n            var _this = _super.call(this) || this;\n            _this.isRendering = false;\n            _this.isRendered = false;\n            _this.currentClassNames = [];\n            _this.customContentRenderId = 0; // will affect custom generated classNames?\n            _this.handleAction = function (action) {\n                // actions we know we want to render immediately\n                switch (action.type) {\n                    case 'SET_EVENT_DRAG':\n                    case 'SET_EVENT_RESIZE':\n                        _this.renderRunner.tryDrain();\n                }\n            };\n            _this.handleData = function (data) {\n                _this.currentData = data;\n                _this.renderRunner.request(data.calendarOptions.rerenderDelay);\n            };\n            _this.handleRenderRequest = function () {\n                if (_this.isRendering) {\n                    _this.isRendered = true;\n                    var currentData_1 = _this.currentData;\n                    render(createElement(CalendarRoot, { options: currentData_1.calendarOptions, theme: currentData_1.theme, emitter: currentData_1.emitter }, function (classNames, height, isHeightAuto, forPrint) {\n                        _this.setClassNames(classNames);\n                        _this.setHeight(height);\n                        return (createElement(CustomContentRenderContext.Provider, { value: _this.customContentRenderId },\n                            createElement(CalendarContent, __assign({ isHeightAuto: isHeightAuto, forPrint: forPrint }, currentData_1))));\n                    }), _this.el);\n                }\n                else if (_this.isRendered) {\n                    _this.isRendered = false;\n                    unmountComponentAtNode$1(_this.el);\n                    _this.setClassNames([]);\n                    _this.setHeight('');\n                }\n                flushToDom$1();\n            };\n            _this.el = el;\n            _this.renderRunner = new DelayedRunner(_this.handleRenderRequest);\n            new CalendarDataManager({\n                optionOverrides: optionOverrides,\n                calendarApi: _this,\n                onAction: _this.handleAction,\n                onData: _this.handleData,\n            });\n            return _this;\n        }\n        Object.defineProperty(Calendar.prototype, \"view\", {\n            get: function () { return this.currentData.viewApi; } // for public API\n            ,\n            enumerable: false,\n            configurable: true\n        });\n        Calendar.prototype.render = function () {\n            var wasRendering = this.isRendering;\n            if (!wasRendering) {\n                this.isRendering = true;\n            }\n            else {\n                this.customContentRenderId += 1;\n            }\n            this.renderRunner.request();\n            if (wasRendering) {\n                this.updateSize();\n            }\n        };\n        Calendar.prototype.destroy = function () {\n            if (this.isRendering) {\n                this.isRendering = false;\n                this.renderRunner.request();\n            }\n        };\n        Calendar.prototype.updateSize = function () {\n            _super.prototype.updateSize.call(this);\n            flushToDom$1();\n        };\n        Calendar.prototype.batchRendering = function (func) {\n            this.renderRunner.pause('batchRendering');\n            func();\n            this.renderRunner.resume('batchRendering');\n        };\n        Calendar.prototype.pauseRendering = function () {\n            this.renderRunner.pause('pauseRendering');\n        };\n        Calendar.prototype.resumeRendering = function () {\n            this.renderRunner.resume('pauseRendering', true);\n        };\n        Calendar.prototype.resetOptions = function (optionOverrides, append) {\n            this.currentDataManager.resetOptions(optionOverrides, append);\n        };\n        Calendar.prototype.setClassNames = function (classNames) {\n            if (!isArraysEqual(classNames, this.currentClassNames)) {\n                var classList = this.el.classList;\n                for (var _i = 0, _a = this.currentClassNames; _i < _a.length; _i++) {\n                    var className = _a[_i];\n                    classList.remove(className);\n                }\n                for (var _b = 0, classNames_1 = classNames; _b < classNames_1.length; _b++) {\n                    var className = classNames_1[_b];\n                    classList.add(className);\n                }\n                this.currentClassNames = classNames;\n            }\n        };\n        Calendar.prototype.setHeight = function (height) {\n            applyStyleProp(this.el, 'height', height);\n        };\n        return Calendar;\n    }(CalendarApi));\n\n    config.touchMouseIgnoreWait = 500;\n    var ignoreMouseDepth = 0;\n    var listenerCnt = 0;\n    var isWindowTouchMoveCancelled = false;\n    /*\n    Uses a \"pointer\" abstraction, which monitors UI events for both mouse and touch.\n    Tracks when the pointer \"drags\" on a certain element, meaning down+move+up.\n\n    Also, tracks if there was touch-scrolling.\n    Also, can prevent touch-scrolling from happening.\n    Also, can fire pointermove events when scrolling happens underneath, even when no real pointer movement.\n\n    emits:\n    - pointerdown\n    - pointermove\n    - pointerup\n    */\n    var PointerDragging = /** @class */ (function () {\n        function PointerDragging(containerEl) {\n            var _this = this;\n            this.subjectEl = null;\n            // options that can be directly assigned by caller\n            this.selector = ''; // will cause subjectEl in all emitted events to be this element\n            this.handleSelector = '';\n            this.shouldIgnoreMove = false;\n            this.shouldWatchScroll = true; // for simulating pointermove on scroll\n            // internal states\n            this.isDragging = false;\n            this.isTouchDragging = false;\n            this.wasTouchScroll = false;\n            // Mouse\n            // ----------------------------------------------------------------------------------------------------\n            this.handleMouseDown = function (ev) {\n                if (!_this.shouldIgnoreMouse() &&\n                    isPrimaryMouseButton(ev) &&\n                    _this.tryStart(ev)) {\n                    var pev = _this.createEventFromMouse(ev, true);\n                    _this.emitter.trigger('pointerdown', pev);\n                    _this.initScrollWatch(pev);\n                    if (!_this.shouldIgnoreMove) {\n                        document.addEventListener('mousemove', _this.handleMouseMove);\n                    }\n                    document.addEventListener('mouseup', _this.handleMouseUp);\n                }\n            };\n            this.handleMouseMove = function (ev) {\n                var pev = _this.createEventFromMouse(ev);\n                _this.recordCoords(pev);\n                _this.emitter.trigger('pointermove', pev);\n            };\n            this.handleMouseUp = function (ev) {\n                document.removeEventListener('mousemove', _this.handleMouseMove);\n                document.removeEventListener('mouseup', _this.handleMouseUp);\n                _this.emitter.trigger('pointerup', _this.createEventFromMouse(ev));\n                _this.cleanup(); // call last so that pointerup has access to props\n            };\n            // Touch\n            // ----------------------------------------------------------------------------------------------------\n            this.handleTouchStart = function (ev) {\n                if (_this.tryStart(ev)) {\n                    _this.isTouchDragging = true;\n                    var pev = _this.createEventFromTouch(ev, true);\n                    _this.emitter.trigger('pointerdown', pev);\n                    _this.initScrollWatch(pev);\n                    // unlike mouse, need to attach to target, not document\n                    // https://stackoverflow.com/a/45760014\n                    var targetEl = ev.target;\n                    if (!_this.shouldIgnoreMove) {\n                        targetEl.addEventListener('touchmove', _this.handleTouchMove);\n                    }\n                    targetEl.addEventListener('touchend', _this.handleTouchEnd);\n                    targetEl.addEventListener('touchcancel', _this.handleTouchEnd); // treat it as a touch end\n                    // attach a handler to get called when ANY scroll action happens on the page.\n                    // this was impossible to do with normal on/off because 'scroll' doesn't bubble.\n                    // http://stackoverflow.com/a/32954565/96342\n                    window.addEventListener('scroll', _this.handleTouchScroll, true);\n                }\n            };\n            this.handleTouchMove = function (ev) {\n                var pev = _this.createEventFromTouch(ev);\n                _this.recordCoords(pev);\n                _this.emitter.trigger('pointermove', pev);\n            };\n            this.handleTouchEnd = function (ev) {\n                if (_this.isDragging) { // done to guard against touchend followed by touchcancel\n                    var targetEl = ev.target;\n                    targetEl.removeEventListener('touchmove', _this.handleTouchMove);\n                    targetEl.removeEventListener('touchend', _this.handleTouchEnd);\n                    targetEl.removeEventListener('touchcancel', _this.handleTouchEnd);\n                    window.removeEventListener('scroll', _this.handleTouchScroll, true); // useCaptured=true\n                    _this.emitter.trigger('pointerup', _this.createEventFromTouch(ev));\n                    _this.cleanup(); // call last so that pointerup has access to props\n                    _this.isTouchDragging = false;\n                    startIgnoringMouse();\n                }\n            };\n            this.handleTouchScroll = function () {\n                _this.wasTouchScroll = true;\n            };\n            this.handleScroll = function (ev) {\n                if (!_this.shouldIgnoreMove) {\n                    var pageX = (window.pageXOffset - _this.prevScrollX) + _this.prevPageX;\n                    var pageY = (window.pageYOffset - _this.prevScrollY) + _this.prevPageY;\n                    _this.emitter.trigger('pointermove', {\n                        origEvent: ev,\n                        isTouch: _this.isTouchDragging,\n                        subjectEl: _this.subjectEl,\n                        pageX: pageX,\n                        pageY: pageY,\n                        deltaX: pageX - _this.origPageX,\n                        deltaY: pageY - _this.origPageY,\n                    });\n                }\n            };\n            this.containerEl = containerEl;\n            this.emitter = new Emitter();\n            containerEl.addEventListener('mousedown', this.handleMouseDown);\n            containerEl.addEventListener('touchstart', this.handleTouchStart, { passive: true });\n            listenerCreated();\n        }\n        PointerDragging.prototype.destroy = function () {\n            this.containerEl.removeEventListener('mousedown', this.handleMouseDown);\n            this.containerEl.removeEventListener('touchstart', this.handleTouchStart, { passive: true });\n            listenerDestroyed();\n        };\n        PointerDragging.prototype.tryStart = function (ev) {\n            var subjectEl = this.querySubjectEl(ev);\n            var downEl = ev.target;\n            if (subjectEl &&\n                (!this.handleSelector || elementClosest(downEl, this.handleSelector))) {\n                this.subjectEl = subjectEl;\n                this.isDragging = true; // do this first so cancelTouchScroll will work\n                this.wasTouchScroll = false;\n                return true;\n            }\n            return false;\n        };\n        PointerDragging.prototype.cleanup = function () {\n            isWindowTouchMoveCancelled = false;\n            this.isDragging = false;\n            this.subjectEl = null;\n            // keep wasTouchScroll around for later access\n            this.destroyScrollWatch();\n        };\n        PointerDragging.prototype.querySubjectEl = function (ev) {\n            if (this.selector) {\n                return elementClosest(ev.target, this.selector);\n            }\n            return this.containerEl;\n        };\n        PointerDragging.prototype.shouldIgnoreMouse = function () {\n            return ignoreMouseDepth || this.isTouchDragging;\n        };\n        // can be called by user of this class, to cancel touch-based scrolling for the current drag\n        PointerDragging.prototype.cancelTouchScroll = function () {\n            if (this.isDragging) {\n                isWindowTouchMoveCancelled = true;\n            }\n        };\n        // Scrolling that simulates pointermoves\n        // ----------------------------------------------------------------------------------------------------\n        PointerDragging.prototype.initScrollWatch = function (ev) {\n            if (this.shouldWatchScroll) {\n                this.recordCoords(ev);\n                window.addEventListener('scroll', this.handleScroll, true); // useCapture=true\n            }\n        };\n        PointerDragging.prototype.recordCoords = function (ev) {\n            if (this.shouldWatchScroll) {\n                this.prevPageX = ev.pageX;\n                this.prevPageY = ev.pageY;\n                this.prevScrollX = window.pageXOffset;\n                this.prevScrollY = window.pageYOffset;\n            }\n        };\n        PointerDragging.prototype.destroyScrollWatch = function () {\n            if (this.shouldWatchScroll) {\n                window.removeEventListener('scroll', this.handleScroll, true); // useCaptured=true\n            }\n        };\n        // Event Normalization\n        // ----------------------------------------------------------------------------------------------------\n        PointerDragging.prototype.createEventFromMouse = function (ev, isFirst) {\n            var deltaX = 0;\n            var deltaY = 0;\n            // TODO: repeat code\n            if (isFirst) {\n                this.origPageX = ev.pageX;\n                this.origPageY = ev.pageY;\n            }\n            else {\n                deltaX = ev.pageX - this.origPageX;\n                deltaY = ev.pageY - this.origPageY;\n            }\n            return {\n                origEvent: ev,\n                isTouch: false,\n                subjectEl: this.subjectEl,\n                pageX: ev.pageX,\n                pageY: ev.pageY,\n                deltaX: deltaX,\n                deltaY: deltaY,\n            };\n        };\n        PointerDragging.prototype.createEventFromTouch = function (ev, isFirst) {\n            var touches = ev.touches;\n            var pageX;\n            var pageY;\n            var deltaX = 0;\n            var deltaY = 0;\n            // if touch coords available, prefer,\n            // because FF would give bad ev.pageX ev.pageY\n            if (touches && touches.length) {\n                pageX = touches[0].pageX;\n                pageY = touches[0].pageY;\n            }\n            else {\n                pageX = ev.pageX;\n                pageY = ev.pageY;\n            }\n            // TODO: repeat code\n            if (isFirst) {\n                this.origPageX = pageX;\n                this.origPageY = pageY;\n            }\n            else {\n                deltaX = pageX - this.origPageX;\n                deltaY = pageY - this.origPageY;\n            }\n            return {\n                origEvent: ev,\n                isTouch: true,\n                subjectEl: this.subjectEl,\n                pageX: pageX,\n                pageY: pageY,\n                deltaX: deltaX,\n                deltaY: deltaY,\n            };\n        };\n        return PointerDragging;\n    }());\n    // Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)\n    function isPrimaryMouseButton(ev) {\n        return ev.button === 0 && !ev.ctrlKey;\n    }\n    // Ignoring fake mouse events generated by touch\n    // ----------------------------------------------------------------------------------------------------\n    function startIgnoringMouse() {\n        ignoreMouseDepth += 1;\n        setTimeout(function () {\n            ignoreMouseDepth -= 1;\n        }, config.touchMouseIgnoreWait);\n    }\n    // We want to attach touchmove as early as possible for Safari\n    // ----------------------------------------------------------------------------------------------------\n    function listenerCreated() {\n        listenerCnt += 1;\n        if (listenerCnt === 1) {\n            window.addEventListener('touchmove', onWindowTouchMove, { passive: false });\n        }\n    }\n    function listenerDestroyed() {\n        listenerCnt -= 1;\n        if (!listenerCnt) {\n            window.removeEventListener('touchmove', onWindowTouchMove, { passive: false });\n        }\n    }\n    function onWindowTouchMove(ev) {\n        if (isWindowTouchMoveCancelled) {\n            ev.preventDefault();\n        }\n    }\n\n    /*\n    An effect in which an element follows the movement of a pointer across the screen.\n    The moving element is a clone of some other element.\n    Must call start + handleMove + stop.\n    */\n    var ElementMirror = /** @class */ (function () {\n        function ElementMirror() {\n            this.isVisible = false; // must be explicitly enabled\n            this.sourceEl = null;\n            this.mirrorEl = null;\n            this.sourceElRect = null; // screen coords relative to viewport\n            // options that can be set directly by caller\n            this.parentNode = document.body;\n            this.zIndex = 9999;\n            this.revertDuration = 0;\n        }\n        ElementMirror.prototype.start = function (sourceEl, pageX, pageY) {\n            this.sourceEl = sourceEl;\n            this.sourceElRect = this.sourceEl.getBoundingClientRect();\n            this.origScreenX = pageX - window.pageXOffset;\n            this.origScreenY = pageY - window.pageYOffset;\n            this.deltaX = 0;\n            this.deltaY = 0;\n            this.updateElPosition();\n        };\n        ElementMirror.prototype.handleMove = function (pageX, pageY) {\n            this.deltaX = (pageX - window.pageXOffset) - this.origScreenX;\n            this.deltaY = (pageY - window.pageYOffset) - this.origScreenY;\n            this.updateElPosition();\n        };\n        // can be called before start\n        ElementMirror.prototype.setIsVisible = function (bool) {\n            if (bool) {\n                if (!this.isVisible) {\n                    if (this.mirrorEl) {\n                        this.mirrorEl.style.display = '';\n                    }\n                    this.isVisible = bool; // needs to happen before updateElPosition\n                    this.updateElPosition(); // because was not updating the position while invisible\n                }\n            }\n            else if (this.isVisible) {\n                if (this.mirrorEl) {\n                    this.mirrorEl.style.display = 'none';\n                }\n                this.isVisible = bool;\n            }\n        };\n        // always async\n        ElementMirror.prototype.stop = function (needsRevertAnimation, callback) {\n            var _this = this;\n            var done = function () {\n                _this.cleanup();\n                callback();\n            };\n            if (needsRevertAnimation &&\n                this.mirrorEl &&\n                this.isVisible &&\n                this.revertDuration && // if 0, transition won't work\n                (this.deltaX || this.deltaY) // if same coords, transition won't work\n            ) {\n                this.doRevertAnimation(done, this.revertDuration);\n            }\n            else {\n                setTimeout(done, 0);\n            }\n        };\n        ElementMirror.prototype.doRevertAnimation = function (callback, revertDuration) {\n            var mirrorEl = this.mirrorEl;\n            var finalSourceElRect = this.sourceEl.getBoundingClientRect(); // because autoscrolling might have happened\n            mirrorEl.style.transition =\n                'top ' + revertDuration + 'ms,' +\n                    'left ' + revertDuration + 'ms';\n            applyStyle(mirrorEl, {\n                left: finalSourceElRect.left,\n                top: finalSourceElRect.top,\n            });\n            whenTransitionDone(mirrorEl, function () {\n                mirrorEl.style.transition = '';\n                callback();\n            });\n        };\n        ElementMirror.prototype.cleanup = function () {\n            if (this.mirrorEl) {\n                removeElement(this.mirrorEl);\n                this.mirrorEl = null;\n            }\n            this.sourceEl = null;\n        };\n        ElementMirror.prototype.updateElPosition = function () {\n            if (this.sourceEl && this.isVisible) {\n                applyStyle(this.getMirrorEl(), {\n                    left: this.sourceElRect.left + this.deltaX,\n                    top: this.sourceElRect.top + this.deltaY,\n                });\n            }\n        };\n        ElementMirror.prototype.getMirrorEl = function () {\n            var sourceElRect = this.sourceElRect;\n            var mirrorEl = this.mirrorEl;\n            if (!mirrorEl) {\n                mirrorEl = this.mirrorEl = this.sourceEl.cloneNode(true); // cloneChildren=true\n                // we don't want long taps or any mouse interaction causing selection/menus.\n                // would use preventSelection(), but that prevents selectstart, causing problems.\n                mirrorEl.classList.add('fc-unselectable');\n                mirrorEl.classList.add('fc-event-dragging');\n                applyStyle(mirrorEl, {\n                    position: 'fixed',\n                    zIndex: this.zIndex,\n                    visibility: '',\n                    boxSizing: 'border-box',\n                    width: sourceElRect.right - sourceElRect.left,\n                    height: sourceElRect.bottom - sourceElRect.top,\n                    right: 'auto',\n                    bottom: 'auto',\n                    margin: 0,\n                });\n                this.parentNode.appendChild(mirrorEl);\n            }\n            return mirrorEl;\n        };\n        return ElementMirror;\n    }());\n\n    /*\n    Is a cache for a given element's scroll information (all the info that ScrollController stores)\n    in addition the \"client rectangle\" of the element.. the area within the scrollbars.\n\n    The cache can be in one of two modes:\n    - doesListening:false - ignores when the container is scrolled by someone else\n    - doesListening:true - watch for scrolling and update the cache\n    */\n    var ScrollGeomCache = /** @class */ (function (_super) {\n        __extends(ScrollGeomCache, _super);\n        function ScrollGeomCache(scrollController, doesListening) {\n            var _this = _super.call(this) || this;\n            _this.handleScroll = function () {\n                _this.scrollTop = _this.scrollController.getScrollTop();\n                _this.scrollLeft = _this.scrollController.getScrollLeft();\n                _this.handleScrollChange();\n            };\n            _this.scrollController = scrollController;\n            _this.doesListening = doesListening;\n            _this.scrollTop = _this.origScrollTop = scrollController.getScrollTop();\n            _this.scrollLeft = _this.origScrollLeft = scrollController.getScrollLeft();\n            _this.scrollWidth = scrollController.getScrollWidth();\n            _this.scrollHeight = scrollController.getScrollHeight();\n            _this.clientWidth = scrollController.getClientWidth();\n            _this.clientHeight = scrollController.getClientHeight();\n            _this.clientRect = _this.computeClientRect(); // do last in case it needs cached values\n            if (_this.doesListening) {\n                _this.getEventTarget().addEventListener('scroll', _this.handleScroll);\n            }\n            return _this;\n        }\n        ScrollGeomCache.prototype.destroy = function () {\n            if (this.doesListening) {\n                this.getEventTarget().removeEventListener('scroll', this.handleScroll);\n            }\n        };\n        ScrollGeomCache.prototype.getScrollTop = function () {\n            return this.scrollTop;\n        };\n        ScrollGeomCache.prototype.getScrollLeft = function () {\n            return this.scrollLeft;\n        };\n        ScrollGeomCache.prototype.setScrollTop = function (top) {\n            this.scrollController.setScrollTop(top);\n            if (!this.doesListening) {\n                // we are not relying on the element to normalize out-of-bounds scroll values\n                // so we need to sanitize ourselves\n                this.scrollTop = Math.max(Math.min(top, this.getMaxScrollTop()), 0);\n                this.handleScrollChange();\n            }\n        };\n        ScrollGeomCache.prototype.setScrollLeft = function (top) {\n            this.scrollController.setScrollLeft(top);\n            if (!this.doesListening) {\n                // we are not relying on the element to normalize out-of-bounds scroll values\n                // so we need to sanitize ourselves\n                this.scrollLeft = Math.max(Math.min(top, this.getMaxScrollLeft()), 0);\n                this.handleScrollChange();\n            }\n        };\n        ScrollGeomCache.prototype.getClientWidth = function () {\n            return this.clientWidth;\n        };\n        ScrollGeomCache.prototype.getClientHeight = function () {\n            return this.clientHeight;\n        };\n        ScrollGeomCache.prototype.getScrollWidth = function () {\n            return this.scrollWidth;\n        };\n        ScrollGeomCache.prototype.getScrollHeight = function () {\n            return this.scrollHeight;\n        };\n        ScrollGeomCache.prototype.handleScrollChange = function () {\n        };\n        return ScrollGeomCache;\n    }(ScrollController));\n\n    var ElementScrollGeomCache = /** @class */ (function (_super) {\n        __extends(ElementScrollGeomCache, _super);\n        function ElementScrollGeomCache(el, doesListening) {\n            return _super.call(this, new ElementScrollController(el), doesListening) || this;\n        }\n        ElementScrollGeomCache.prototype.getEventTarget = function () {\n            return this.scrollController.el;\n        };\n        ElementScrollGeomCache.prototype.computeClientRect = function () {\n            return computeInnerRect(this.scrollController.el);\n        };\n        return ElementScrollGeomCache;\n    }(ScrollGeomCache));\n\n    var WindowScrollGeomCache = /** @class */ (function (_super) {\n        __extends(WindowScrollGeomCache, _super);\n        function WindowScrollGeomCache(doesListening) {\n            return _super.call(this, new WindowScrollController(), doesListening) || this;\n        }\n        WindowScrollGeomCache.prototype.getEventTarget = function () {\n            return window;\n        };\n        WindowScrollGeomCache.prototype.computeClientRect = function () {\n            return {\n                left: this.scrollLeft,\n                right: this.scrollLeft + this.clientWidth,\n                top: this.scrollTop,\n                bottom: this.scrollTop + this.clientHeight,\n            };\n        };\n        // the window is the only scroll object that changes it's rectangle relative\n        // to the document's topleft as it scrolls\n        WindowScrollGeomCache.prototype.handleScrollChange = function () {\n            this.clientRect = this.computeClientRect();\n        };\n        return WindowScrollGeomCache;\n    }(ScrollGeomCache));\n\n    // If available we are using native \"performance\" API instead of \"Date\"\n    // Read more about it on MDN:\n    // https://developer.mozilla.org/en-US/docs/Web/API/Performance\n    var getTime = typeof performance === 'function' ? performance.now : Date.now;\n    /*\n    For a pointer interaction, automatically scrolls certain scroll containers when the pointer\n    approaches the edge.\n\n    The caller must call start + handleMove + stop.\n    */\n    var AutoScroller = /** @class */ (function () {\n        function AutoScroller() {\n            var _this = this;\n            // options that can be set by caller\n            this.isEnabled = true;\n            this.scrollQuery = [window, '.fc-scroller'];\n            this.edgeThreshold = 50; // pixels\n            this.maxVelocity = 300; // pixels per second\n            // internal state\n            this.pointerScreenX = null;\n            this.pointerScreenY = null;\n            this.isAnimating = false;\n            this.scrollCaches = null;\n            // protect against the initial pointerdown being too close to an edge and starting the scroll\n            this.everMovedUp = false;\n            this.everMovedDown = false;\n            this.everMovedLeft = false;\n            this.everMovedRight = false;\n            this.animate = function () {\n                if (_this.isAnimating) { // wasn't cancelled between animation calls\n                    var edge = _this.computeBestEdge(_this.pointerScreenX + window.pageXOffset, _this.pointerScreenY + window.pageYOffset);\n                    if (edge) {\n                        var now = getTime();\n                        _this.handleSide(edge, (now - _this.msSinceRequest) / 1000);\n                        _this.requestAnimation(now);\n                    }\n                    else {\n                        _this.isAnimating = false; // will stop animation\n                    }\n                }\n            };\n        }\n        AutoScroller.prototype.start = function (pageX, pageY) {\n            if (this.isEnabled) {\n                this.scrollCaches = this.buildCaches();\n                this.pointerScreenX = null;\n                this.pointerScreenY = null;\n                this.everMovedUp = false;\n                this.everMovedDown = false;\n                this.everMovedLeft = false;\n                this.everMovedRight = false;\n                this.handleMove(pageX, pageY);\n            }\n        };\n        AutoScroller.prototype.handleMove = function (pageX, pageY) {\n            if (this.isEnabled) {\n                var pointerScreenX = pageX - window.pageXOffset;\n                var pointerScreenY = pageY - window.pageYOffset;\n                var yDelta = this.pointerScreenY === null ? 0 : pointerScreenY - this.pointerScreenY;\n                var xDelta = this.pointerScreenX === null ? 0 : pointerScreenX - this.pointerScreenX;\n                if (yDelta < 0) {\n                    this.everMovedUp = true;\n                }\n                else if (yDelta > 0) {\n                    this.everMovedDown = true;\n                }\n                if (xDelta < 0) {\n                    this.everMovedLeft = true;\n                }\n                else if (xDelta > 0) {\n                    this.everMovedRight = true;\n                }\n                this.pointerScreenX = pointerScreenX;\n                this.pointerScreenY = pointerScreenY;\n                if (!this.isAnimating) {\n                    this.isAnimating = true;\n                    this.requestAnimation(getTime());\n                }\n            }\n        };\n        AutoScroller.prototype.stop = function () {\n            if (this.isEnabled) {\n                this.isAnimating = false; // will stop animation\n                for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n                    var scrollCache = _a[_i];\n                    scrollCache.destroy();\n                }\n                this.scrollCaches = null;\n            }\n        };\n        AutoScroller.prototype.requestAnimation = function (now) {\n            this.msSinceRequest = now;\n            requestAnimationFrame(this.animate);\n        };\n        AutoScroller.prototype.handleSide = function (edge, seconds) {\n            var scrollCache = edge.scrollCache;\n            var edgeThreshold = this.edgeThreshold;\n            var invDistance = edgeThreshold - edge.distance;\n            var velocity = // the closer to the edge, the faster we scroll\n             ((invDistance * invDistance) / (edgeThreshold * edgeThreshold)) * // quadratic\n                this.maxVelocity * seconds;\n            var sign = 1;\n            switch (edge.name) {\n                case 'left':\n                    sign = -1;\n                // falls through\n                case 'right':\n                    scrollCache.setScrollLeft(scrollCache.getScrollLeft() + velocity * sign);\n                    break;\n                case 'top':\n                    sign = -1;\n                // falls through\n                case 'bottom':\n                    scrollCache.setScrollTop(scrollCache.getScrollTop() + velocity * sign);\n                    break;\n            }\n        };\n        // left/top are relative to document topleft\n        AutoScroller.prototype.computeBestEdge = function (left, top) {\n            var edgeThreshold = this.edgeThreshold;\n            var bestSide = null;\n            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n                var scrollCache = _a[_i];\n                var rect = scrollCache.clientRect;\n                var leftDist = left - rect.left;\n                var rightDist = rect.right - left;\n                var topDist = top - rect.top;\n                var bottomDist = rect.bottom - top;\n                // completely within the rect?\n                if (leftDist >= 0 && rightDist >= 0 && topDist >= 0 && bottomDist >= 0) {\n                    if (topDist <= edgeThreshold && this.everMovedUp && scrollCache.canScrollUp() &&\n                        (!bestSide || bestSide.distance > topDist)) {\n                        bestSide = { scrollCache: scrollCache, name: 'top', distance: topDist };\n                    }\n                    if (bottomDist <= edgeThreshold && this.everMovedDown && scrollCache.canScrollDown() &&\n                        (!bestSide || bestSide.distance > bottomDist)) {\n                        bestSide = { scrollCache: scrollCache, name: 'bottom', distance: bottomDist };\n                    }\n                    if (leftDist <= edgeThreshold && this.everMovedLeft && scrollCache.canScrollLeft() &&\n                        (!bestSide || bestSide.distance > leftDist)) {\n                        bestSide = { scrollCache: scrollCache, name: 'left', distance: leftDist };\n                    }\n                    if (rightDist <= edgeThreshold && this.everMovedRight && scrollCache.canScrollRight() &&\n                        (!bestSide || bestSide.distance > rightDist)) {\n                        bestSide = { scrollCache: scrollCache, name: 'right', distance: rightDist };\n                    }\n                }\n            }\n            return bestSide;\n        };\n        AutoScroller.prototype.buildCaches = function () {\n            return this.queryScrollEls().map(function (el) {\n                if (el === window) {\n                    return new WindowScrollGeomCache(false); // false = don't listen to user-generated scrolls\n                }\n                return new ElementScrollGeomCache(el, false); // false = don't listen to user-generated scrolls\n            });\n        };\n        AutoScroller.prototype.queryScrollEls = function () {\n            var els = [];\n            for (var _i = 0, _a = this.scrollQuery; _i < _a.length; _i++) {\n                var query = _a[_i];\n                if (typeof query === 'object') {\n                    els.push(query);\n                }\n                else {\n                    els.push.apply(els, Array.prototype.slice.call(document.querySelectorAll(query)));\n                }\n            }\n            return els;\n        };\n        return AutoScroller;\n    }());\n\n    /*\n    Monitors dragging on an element. Has a number of high-level features:\n    - minimum distance required before dragging\n    - minimum wait time (\"delay\") before dragging\n    - a mirror element that follows the pointer\n    */\n    var FeaturefulElementDragging = /** @class */ (function (_super) {\n        __extends(FeaturefulElementDragging, _super);\n        function FeaturefulElementDragging(containerEl, selector) {\n            var _this = _super.call(this, containerEl) || this;\n            // options that can be directly set by caller\n            // the caller can also set the PointerDragging's options as well\n            _this.delay = null;\n            _this.minDistance = 0;\n            _this.touchScrollAllowed = true; // prevents drag from starting and blocks scrolling during drag\n            _this.mirrorNeedsRevert = false;\n            _this.isInteracting = false; // is the user validly moving the pointer? lasts until pointerup\n            _this.isDragging = false; // is it INTENTFULLY dragging? lasts until after revert animation\n            _this.isDelayEnded = false;\n            _this.isDistanceSurpassed = false;\n            _this.delayTimeoutId = null;\n            _this.onPointerDown = function (ev) {\n                if (!_this.isDragging) { // so new drag doesn't happen while revert animation is going\n                    _this.isInteracting = true;\n                    _this.isDelayEnded = false;\n                    _this.isDistanceSurpassed = false;\n                    preventSelection(document.body);\n                    preventContextMenu(document.body);\n                    // prevent links from being visited if there's an eventual drag.\n                    // also prevents selection in older browsers (maybe?).\n                    // not necessary for touch, besides, browser would complain about passiveness.\n                    if (!ev.isTouch) {\n                        ev.origEvent.preventDefault();\n                    }\n                    _this.emitter.trigger('pointerdown', ev);\n                    if (_this.isInteracting && // not destroyed via pointerdown handler\n                        !_this.pointer.shouldIgnoreMove) {\n                        // actions related to initiating dragstart+dragmove+dragend...\n                        _this.mirror.setIsVisible(false); // reset. caller must set-visible\n                        _this.mirror.start(ev.subjectEl, ev.pageX, ev.pageY); // must happen on first pointer down\n                        _this.startDelay(ev);\n                        if (!_this.minDistance) {\n                            _this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                }\n            };\n            _this.onPointerMove = function (ev) {\n                if (_this.isInteracting) {\n                    _this.emitter.trigger('pointermove', ev);\n                    if (!_this.isDistanceSurpassed) {\n                        var minDistance = _this.minDistance;\n                        var distanceSq = void 0; // current distance from the origin, squared\n                        var deltaX = ev.deltaX, deltaY = ev.deltaY;\n                        distanceSq = deltaX * deltaX + deltaY * deltaY;\n                        if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem\n                            _this.handleDistanceSurpassed(ev);\n                        }\n                    }\n                    if (_this.isDragging) {\n                        // a real pointer move? (not one simulated by scrolling)\n                        if (ev.origEvent.type !== 'scroll') {\n                            _this.mirror.handleMove(ev.pageX, ev.pageY);\n                            _this.autoScroller.handleMove(ev.pageX, ev.pageY);\n                        }\n                        _this.emitter.trigger('dragmove', ev);\n                    }\n                }\n            };\n            _this.onPointerUp = function (ev) {\n                if (_this.isInteracting) {\n                    _this.isInteracting = false;\n                    allowSelection(document.body);\n                    allowContextMenu(document.body);\n                    _this.emitter.trigger('pointerup', ev); // can potentially set mirrorNeedsRevert\n                    if (_this.isDragging) {\n                        _this.autoScroller.stop();\n                        _this.tryStopDrag(ev); // which will stop the mirror\n                    }\n                    if (_this.delayTimeoutId) {\n                        clearTimeout(_this.delayTimeoutId);\n                        _this.delayTimeoutId = null;\n                    }\n                }\n            };\n            var pointer = _this.pointer = new PointerDragging(containerEl);\n            pointer.emitter.on('pointerdown', _this.onPointerDown);\n            pointer.emitter.on('pointermove', _this.onPointerMove);\n            pointer.emitter.on('pointerup', _this.onPointerUp);\n            if (selector) {\n                pointer.selector = selector;\n            }\n            _this.mirror = new ElementMirror();\n            _this.autoScroller = new AutoScroller();\n            return _this;\n        }\n        FeaturefulElementDragging.prototype.destroy = function () {\n            this.pointer.destroy();\n            // HACK: simulate a pointer-up to end the current drag\n            // TODO: fire 'dragend' directly and stop interaction. discourage use of pointerup event (b/c might not fire)\n            this.onPointerUp({});\n        };\n        FeaturefulElementDragging.prototype.startDelay = function (ev) {\n            var _this = this;\n            if (typeof this.delay === 'number') {\n                this.delayTimeoutId = setTimeout(function () {\n                    _this.delayTimeoutId = null;\n                    _this.handleDelayEnd(ev);\n                }, this.delay); // not assignable to number!\n            }\n            else {\n                this.handleDelayEnd(ev);\n            }\n        };\n        FeaturefulElementDragging.prototype.handleDelayEnd = function (ev) {\n            this.isDelayEnded = true;\n            this.tryStartDrag(ev);\n        };\n        FeaturefulElementDragging.prototype.handleDistanceSurpassed = function (ev) {\n            this.isDistanceSurpassed = true;\n            this.tryStartDrag(ev);\n        };\n        FeaturefulElementDragging.prototype.tryStartDrag = function (ev) {\n            if (this.isDelayEnded && this.isDistanceSurpassed) {\n                if (!this.pointer.wasTouchScroll || this.touchScrollAllowed) {\n                    this.isDragging = true;\n                    this.mirrorNeedsRevert = false;\n                    this.autoScroller.start(ev.pageX, ev.pageY);\n                    this.emitter.trigger('dragstart', ev);\n                    if (this.touchScrollAllowed === false) {\n                        this.pointer.cancelTouchScroll();\n                    }\n                }\n            }\n        };\n        FeaturefulElementDragging.prototype.tryStopDrag = function (ev) {\n            // .stop() is ALWAYS asynchronous, which we NEED because we want all pointerup events\n            // that come from the document to fire beforehand. much more convenient this way.\n            this.mirror.stop(this.mirrorNeedsRevert, this.stopDrag.bind(this, ev));\n        };\n        FeaturefulElementDragging.prototype.stopDrag = function (ev) {\n            this.isDragging = false;\n            this.emitter.trigger('dragend', ev);\n        };\n        // fill in the implementations...\n        FeaturefulElementDragging.prototype.setIgnoreMove = function (bool) {\n            this.pointer.shouldIgnoreMove = bool;\n        };\n        FeaturefulElementDragging.prototype.setMirrorIsVisible = function (bool) {\n            this.mirror.setIsVisible(bool);\n        };\n        FeaturefulElementDragging.prototype.setMirrorNeedsRevert = function (bool) {\n            this.mirrorNeedsRevert = bool;\n        };\n        FeaturefulElementDragging.prototype.setAutoScrollEnabled = function (bool) {\n            this.autoScroller.isEnabled = bool;\n        };\n        return FeaturefulElementDragging;\n    }(ElementDragging));\n\n    /*\n    When this class is instantiated, it records the offset of an element (relative to the document topleft),\n    and continues to monitor scrolling, updating the cached coordinates if it needs to.\n    Does not access the DOM after instantiation, so highly performant.\n\n    Also keeps track of all scrolling/overflow:hidden containers that are parents of the given element\n    and an determine if a given point is inside the combined clipping rectangle.\n    */\n    var OffsetTracker = /** @class */ (function () {\n        function OffsetTracker(el) {\n            this.origRect = computeRect(el);\n            // will work fine for divs that have overflow:hidden\n            this.scrollCaches = getClippingParents(el).map(function (scrollEl) { return new ElementScrollGeomCache(scrollEl, true); });\n        }\n        OffsetTracker.prototype.destroy = function () {\n            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n                var scrollCache = _a[_i];\n                scrollCache.destroy();\n            }\n        };\n        OffsetTracker.prototype.computeLeft = function () {\n            var left = this.origRect.left;\n            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n                var scrollCache = _a[_i];\n                left += scrollCache.origScrollLeft - scrollCache.getScrollLeft();\n            }\n            return left;\n        };\n        OffsetTracker.prototype.computeTop = function () {\n            var top = this.origRect.top;\n            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n                var scrollCache = _a[_i];\n                top += scrollCache.origScrollTop - scrollCache.getScrollTop();\n            }\n            return top;\n        };\n        OffsetTracker.prototype.isWithinClipping = function (pageX, pageY) {\n            var point = { left: pageX, top: pageY };\n            for (var _i = 0, _a = this.scrollCaches; _i < _a.length; _i++) {\n                var scrollCache = _a[_i];\n                if (!isIgnoredClipping(scrollCache.getEventTarget()) &&\n                    !pointInsideRect(point, scrollCache.clientRect)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        return OffsetTracker;\n    }());\n    // certain clipping containers should never constrain interactions, like <html> and <body>\n    // https://github.com/fullcalendar/fullcalendar/issues/3615\n    function isIgnoredClipping(node) {\n        var tagName = node.tagName;\n        return tagName === 'HTML' || tagName === 'BODY';\n    }\n\n    /*\n    Tracks movement over multiple droppable areas (aka \"hits\")\n    that exist in one or more DateComponents.\n    Relies on an existing draggable.\n\n    emits:\n    - pointerdown\n    - dragstart\n    - hitchange - fires initially, even if not over a hit\n    - pointerup\n    - (hitchange - again, to null, if ended over a hit)\n    - dragend\n    */\n    var HitDragging = /** @class */ (function () {\n        function HitDragging(dragging, droppableStore) {\n            var _this = this;\n            // options that can be set by caller\n            this.useSubjectCenter = false;\n            this.requireInitial = true; // if doesn't start out on a hit, won't emit any events\n            this.initialHit = null;\n            this.movingHit = null;\n            this.finalHit = null; // won't ever be populated if shouldIgnoreMove\n            this.handlePointerDown = function (ev) {\n                var dragging = _this.dragging;\n                _this.initialHit = null;\n                _this.movingHit = null;\n                _this.finalHit = null;\n                _this.prepareHits();\n                _this.processFirstCoord(ev);\n                if (_this.initialHit || !_this.requireInitial) {\n                    dragging.setIgnoreMove(false);\n                    // TODO: fire this before computing processFirstCoord, so listeners can cancel. this gets fired by almost every handler :(\n                    _this.emitter.trigger('pointerdown', ev);\n                }\n                else {\n                    dragging.setIgnoreMove(true);\n                }\n            };\n            this.handleDragStart = function (ev) {\n                _this.emitter.trigger('dragstart', ev);\n                _this.handleMove(ev, true); // force = fire even if initially null\n            };\n            this.handleDragMove = function (ev) {\n                _this.emitter.trigger('dragmove', ev);\n                _this.handleMove(ev);\n            };\n            this.handlePointerUp = function (ev) {\n                _this.releaseHits();\n                _this.emitter.trigger('pointerup', ev);\n            };\n            this.handleDragEnd = function (ev) {\n                if (_this.movingHit) {\n                    _this.emitter.trigger('hitupdate', null, true, ev);\n                }\n                _this.finalHit = _this.movingHit;\n                _this.movingHit = null;\n                _this.emitter.trigger('dragend', ev);\n            };\n            this.droppableStore = droppableStore;\n            dragging.emitter.on('pointerdown', this.handlePointerDown);\n            dragging.emitter.on('dragstart', this.handleDragStart);\n            dragging.emitter.on('dragmove', this.handleDragMove);\n            dragging.emitter.on('pointerup', this.handlePointerUp);\n            dragging.emitter.on('dragend', this.handleDragEnd);\n            this.dragging = dragging;\n            this.emitter = new Emitter();\n        }\n        // sets initialHit\n        // sets coordAdjust\n        HitDragging.prototype.processFirstCoord = function (ev) {\n            var origPoint = { left: ev.pageX, top: ev.pageY };\n            var adjustedPoint = origPoint;\n            var subjectEl = ev.subjectEl;\n            var subjectRect;\n            if (subjectEl !== document) {\n                subjectRect = computeRect(subjectEl);\n                adjustedPoint = constrainPoint(adjustedPoint, subjectRect);\n            }\n            var initialHit = this.initialHit = this.queryHitForOffset(adjustedPoint.left, adjustedPoint.top);\n            if (initialHit) {\n                if (this.useSubjectCenter && subjectRect) {\n                    var slicedSubjectRect = intersectRects(subjectRect, initialHit.rect);\n                    if (slicedSubjectRect) {\n                        adjustedPoint = getRectCenter(slicedSubjectRect);\n                    }\n                }\n                this.coordAdjust = diffPoints(adjustedPoint, origPoint);\n            }\n            else {\n                this.coordAdjust = { left: 0, top: 0 };\n            }\n        };\n        HitDragging.prototype.handleMove = function (ev, forceHandle) {\n            var hit = this.queryHitForOffset(ev.pageX + this.coordAdjust.left, ev.pageY + this.coordAdjust.top);\n            if (forceHandle || !isHitsEqual(this.movingHit, hit)) {\n                this.movingHit = hit;\n                this.emitter.trigger('hitupdate', hit, false, ev);\n            }\n        };\n        HitDragging.prototype.prepareHits = function () {\n            this.offsetTrackers = mapHash(this.droppableStore, function (interactionSettings) {\n                interactionSettings.component.prepareHits();\n                return new OffsetTracker(interactionSettings.el);\n            });\n        };\n        HitDragging.prototype.releaseHits = function () {\n            var offsetTrackers = this.offsetTrackers;\n            for (var id in offsetTrackers) {\n                offsetTrackers[id].destroy();\n            }\n            this.offsetTrackers = {};\n        };\n        HitDragging.prototype.queryHitForOffset = function (offsetLeft, offsetTop) {\n            var _a = this, droppableStore = _a.droppableStore, offsetTrackers = _a.offsetTrackers;\n            var bestHit = null;\n            for (var id in droppableStore) {\n                var component = droppableStore[id].component;\n                var offsetTracker = offsetTrackers[id];\n                if (offsetTracker && // wasn't destroyed mid-drag\n                    offsetTracker.isWithinClipping(offsetLeft, offsetTop)) {\n                    var originLeft = offsetTracker.computeLeft();\n                    var originTop = offsetTracker.computeTop();\n                    var positionLeft = offsetLeft - originLeft;\n                    var positionTop = offsetTop - originTop;\n                    var origRect = offsetTracker.origRect;\n                    var width = origRect.right - origRect.left;\n                    var height = origRect.bottom - origRect.top;\n                    if (\n                    // must be within the element's bounds\n                    positionLeft >= 0 && positionLeft < width &&\n                        positionTop >= 0 && positionTop < height) {\n                        var hit = component.queryHit(positionLeft, positionTop, width, height);\n                        var dateProfile = component.context.getCurrentData().dateProfile;\n                        if (hit &&\n                            (\n                            // make sure the hit is within activeRange, meaning it's not a deal cell\n                            rangeContainsRange(dateProfile.activeRange, hit.dateSpan.range)) &&\n                            (!bestHit || hit.layer > bestHit.layer)) {\n                            // TODO: better way to re-orient rectangle\n                            hit.rect.left += originLeft;\n                            hit.rect.right += originLeft;\n                            hit.rect.top += originTop;\n                            hit.rect.bottom += originTop;\n                            bestHit = hit;\n                        }\n                    }\n                }\n            }\n            return bestHit;\n        };\n        return HitDragging;\n    }());\n    function isHitsEqual(hit0, hit1) {\n        if (!hit0 && !hit1) {\n            return true;\n        }\n        if (Boolean(hit0) !== Boolean(hit1)) {\n            return false;\n        }\n        return isDateSpansEqual(hit0.dateSpan, hit1.dateSpan);\n    }\n\n    function buildDatePointApiWithContext(dateSpan, context) {\n        var props = {};\n        for (var _i = 0, _a = context.pluginHooks.datePointTransforms; _i < _a.length; _i++) {\n            var transform = _a[_i];\n            __assign(props, transform(dateSpan, context));\n        }\n        __assign(props, buildDatePointApi(dateSpan, context.dateEnv));\n        return props;\n    }\n    function buildDatePointApi(span, dateEnv) {\n        return {\n            date: dateEnv.toDate(span.range.start),\n            dateStr: dateEnv.formatIso(span.range.start, { omitTime: span.allDay }),\n            allDay: span.allDay,\n        };\n    }\n\n    /*\n    Monitors when the user clicks on a specific date/time of a component.\n    A pointerdown+pointerup on the same \"hit\" constitutes a click.\n    */\n    var DateClicking = /** @class */ (function (_super) {\n        __extends(DateClicking, _super);\n        function DateClicking(settings) {\n            var _this = _super.call(this, settings) || this;\n            _this.handlePointerDown = function (pev) {\n                var dragging = _this.dragging;\n                var downEl = pev.origEvent.target;\n                // do this in pointerdown (not dragend) because DOM might be mutated by the time dragend is fired\n                dragging.setIgnoreMove(!_this.component.isValidDateDownEl(downEl));\n            };\n            // won't even fire if moving was ignored\n            _this.handleDragEnd = function (ev) {\n                var component = _this.component;\n                var pointer = _this.dragging.pointer;\n                if (!pointer.wasTouchScroll) {\n                    var _a = _this.hitDragging, initialHit = _a.initialHit, finalHit = _a.finalHit;\n                    if (initialHit && finalHit && isHitsEqual(initialHit, finalHit)) {\n                        var context = component.context;\n                        var arg = __assign(__assign({}, buildDatePointApiWithContext(initialHit.dateSpan, context)), { dayEl: initialHit.dayEl, jsEvent: ev.origEvent, view: context.viewApi || context.calendarApi.view });\n                        context.emitter.trigger('dateClick', arg);\n                    }\n                }\n            };\n            // we DO want to watch pointer moves because otherwise finalHit won't get populated\n            _this.dragging = new FeaturefulElementDragging(settings.el);\n            _this.dragging.autoScroller.isEnabled = false;\n            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n            hitDragging.emitter.on('dragend', _this.handleDragEnd);\n            return _this;\n        }\n        DateClicking.prototype.destroy = function () {\n            this.dragging.destroy();\n        };\n        return DateClicking;\n    }(Interaction));\n\n    /*\n    Tracks when the user selects a portion of time of a component,\n    constituted by a drag over date cells, with a possible delay at the beginning of the drag.\n    */\n    var DateSelecting = /** @class */ (function (_super) {\n        __extends(DateSelecting, _super);\n        function DateSelecting(settings) {\n            var _this = _super.call(this, settings) || this;\n            _this.dragSelection = null;\n            _this.handlePointerDown = function (ev) {\n                var _a = _this, component = _a.component, dragging = _a.dragging;\n                var options = component.context.options;\n                var canSelect = options.selectable &&\n                    component.isValidDateDownEl(ev.origEvent.target);\n                // don't bother to watch expensive moves if component won't do selection\n                dragging.setIgnoreMove(!canSelect);\n                // if touch, require user to hold down\n                dragging.delay = ev.isTouch ? getComponentTouchDelay(component) : null;\n            };\n            _this.handleDragStart = function (ev) {\n                _this.component.context.calendarApi.unselect(ev); // unselect previous selections\n            };\n            _this.handleHitUpdate = function (hit, isFinal) {\n                var context = _this.component.context;\n                var dragSelection = null;\n                var isInvalid = false;\n                if (hit) {\n                    dragSelection = joinHitsIntoSelection(_this.hitDragging.initialHit, hit, context.pluginHooks.dateSelectionTransformers);\n                    if (!dragSelection || !_this.component.isDateSelectionValid(dragSelection)) {\n                        isInvalid = true;\n                        dragSelection = null;\n                    }\n                }\n                if (dragSelection) {\n                    context.dispatch({ type: 'SELECT_DATES', selection: dragSelection });\n                }\n                else if (!isFinal) { // only unselect if moved away while dragging\n                    context.dispatch({ type: 'UNSELECT_DATES' });\n                }\n                if (!isInvalid) {\n                    enableCursor();\n                }\n                else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    _this.dragSelection = dragSelection; // only clear if moved away from all hits while dragging\n                }\n            };\n            _this.handlePointerUp = function (pev) {\n                if (_this.dragSelection) {\n                    // selection is already rendered, so just need to report selection\n                    triggerDateSelect(_this.dragSelection, pev, _this.component.context);\n                    _this.dragSelection = null;\n                }\n            };\n            var component = settings.component;\n            var options = component.context.options;\n            var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.touchScrollAllowed = false;\n            dragging.minDistance = options.selectMinDistance || 0;\n            dragging.autoScroller.isEnabled = options.dragScroll;\n            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', _this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n            hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n            return _this;\n        }\n        DateSelecting.prototype.destroy = function () {\n            this.dragging.destroy();\n        };\n        return DateSelecting;\n    }(Interaction));\n    function getComponentTouchDelay(component) {\n        var options = component.context.options;\n        var delay = options.selectLongPressDelay;\n        if (delay == null) {\n            delay = options.longPressDelay;\n        }\n        return delay;\n    }\n    function joinHitsIntoSelection(hit0, hit1, dateSelectionTransformers) {\n        var dateSpan0 = hit0.dateSpan;\n        var dateSpan1 = hit1.dateSpan;\n        var ms = [\n            dateSpan0.range.start,\n            dateSpan0.range.end,\n            dateSpan1.range.start,\n            dateSpan1.range.end,\n        ];\n        ms.sort(compareNumbers);\n        var props = {};\n        for (var _i = 0, dateSelectionTransformers_1 = dateSelectionTransformers; _i < dateSelectionTransformers_1.length; _i++) {\n            var transformer = dateSelectionTransformers_1[_i];\n            var res = transformer(hit0, hit1);\n            if (res === false) {\n                return null;\n            }\n            if (res) {\n                __assign(props, res);\n            }\n        }\n        props.range = { start: ms[0], end: ms[3] };\n        props.allDay = dateSpan0.allDay;\n        return props;\n    }\n\n    var EventDragging = /** @class */ (function (_super) {\n        __extends(EventDragging, _super);\n        function EventDragging(settings) {\n            var _this = _super.call(this, settings) || this;\n            // internal state\n            _this.subjectEl = null;\n            _this.subjectSeg = null; // the seg being selected/dragged\n            _this.isDragging = false;\n            _this.eventRange = null;\n            _this.relevantEvents = null; // the events being dragged\n            _this.receivingContext = null;\n            _this.validMutation = null;\n            _this.mutatedRelevantEvents = null;\n            _this.handlePointerDown = function (ev) {\n                var origTarget = ev.origEvent.target;\n                var _a = _this, component = _a.component, dragging = _a.dragging;\n                var mirror = dragging.mirror;\n                var options = component.context.options;\n                var initialContext = component.context;\n                _this.subjectEl = ev.subjectEl;\n                var subjectSeg = _this.subjectSeg = getElSeg(ev.subjectEl);\n                var eventRange = _this.eventRange = subjectSeg.eventRange;\n                var eventInstanceId = eventRange.instance.instanceId;\n                _this.relevantEvents = getRelevantEvents(initialContext.getCurrentData().eventStore, eventInstanceId);\n                dragging.minDistance = ev.isTouch ? 0 : options.eventDragMinDistance;\n                dragging.delay =\n                    // only do a touch delay if touch and this event hasn't been selected yet\n                    (ev.isTouch && eventInstanceId !== component.props.eventSelection) ?\n                        getComponentTouchDelay$1(component) :\n                        null;\n                if (options.fixedMirrorParent) {\n                    mirror.parentNode = options.fixedMirrorParent;\n                }\n                else {\n                    mirror.parentNode = elementClosest(origTarget, '.fc');\n                }\n                mirror.revertDuration = options.dragRevertDuration;\n                var isValid = component.isValidSegDownEl(origTarget) &&\n                    !elementClosest(origTarget, '.fc-event-resizer'); // NOT on a resizer\n                dragging.setIgnoreMove(!isValid);\n                // disable dragging for elements that are resizable (ie, selectable)\n                // but are not draggable\n                _this.isDragging = isValid &&\n                    ev.subjectEl.classList.contains('fc-event-draggable');\n            };\n            _this.handleDragStart = function (ev) {\n                var initialContext = _this.component.context;\n                var eventRange = _this.eventRange;\n                var eventInstanceId = eventRange.instance.instanceId;\n                if (ev.isTouch) {\n                    // need to select a different event?\n                    if (eventInstanceId !== _this.component.props.eventSelection) {\n                        initialContext.dispatch({ type: 'SELECT_EVENT', eventInstanceId: eventInstanceId });\n                    }\n                }\n                else {\n                    // if now using mouse, but was previous touch interaction, clear selected event\n                    initialContext.dispatch({ type: 'UNSELECT_EVENT' });\n                }\n                if (_this.isDragging) {\n                    initialContext.calendarApi.unselect(ev); // unselect *date* selection\n                    initialContext.emitter.trigger('eventDragStart', {\n                        el: _this.subjectEl,\n                        event: new EventApi(initialContext, eventRange.def, eventRange.instance),\n                        jsEvent: ev.origEvent,\n                        view: initialContext.viewApi,\n                    });\n                }\n            };\n            _this.handleHitUpdate = function (hit, isFinal) {\n                if (!_this.isDragging) {\n                    return;\n                }\n                var relevantEvents = _this.relevantEvents;\n                var initialHit = _this.hitDragging.initialHit;\n                var initialContext = _this.component.context;\n                // states based on new hit\n                var receivingContext = null;\n                var mutation = null;\n                var mutatedRelevantEvents = null;\n                var isInvalid = false;\n                var interaction = {\n                    affectedEvents: relevantEvents,\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: true,\n                };\n                if (hit) {\n                    var receivingComponent = hit.component;\n                    receivingContext = receivingComponent.context;\n                    var receivingOptions = receivingContext.options;\n                    if (initialContext === receivingContext ||\n                        (receivingOptions.editable && receivingOptions.droppable)) {\n                        mutation = computeEventMutation(initialHit, hit, receivingContext.getCurrentData().pluginHooks.eventDragMutationMassagers);\n                        if (mutation) {\n                            mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, receivingContext.getCurrentData().eventUiBases, mutation, receivingContext);\n                            interaction.mutatedEvents = mutatedRelevantEvents;\n                            if (!receivingComponent.isInteractionValid(interaction)) {\n                                isInvalid = true;\n                                mutation = null;\n                                mutatedRelevantEvents = null;\n                                interaction.mutatedEvents = createEmptyEventStore();\n                            }\n                        }\n                    }\n                    else {\n                        receivingContext = null;\n                    }\n                }\n                _this.displayDrag(receivingContext, interaction);\n                if (!isInvalid) {\n                    enableCursor();\n                }\n                else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    if (initialContext === receivingContext && // TODO: write test for this\n                        isHitsEqual(initialHit, hit)) {\n                        mutation = null;\n                    }\n                    _this.dragging.setMirrorNeedsRevert(!mutation);\n                    // render the mirror if no already-rendered mirror\n                    // TODO: wish we could somehow wait for dispatch to guarantee render\n                    _this.dragging.setMirrorIsVisible(!hit || !document.querySelector('.fc-event-mirror'));\n                    // assign states based on new hit\n                    _this.receivingContext = receivingContext;\n                    _this.validMutation = mutation;\n                    _this.mutatedRelevantEvents = mutatedRelevantEvents;\n                }\n            };\n            _this.handlePointerUp = function () {\n                if (!_this.isDragging) {\n                    _this.cleanup(); // because handleDragEnd won't fire\n                }\n            };\n            _this.handleDragEnd = function (ev) {\n                if (_this.isDragging) {\n                    var initialContext_1 = _this.component.context;\n                    var initialView = initialContext_1.viewApi;\n                    var _a = _this, receivingContext_1 = _a.receivingContext, validMutation = _a.validMutation;\n                    var eventDef = _this.eventRange.def;\n                    var eventInstance = _this.eventRange.instance;\n                    var eventApi = new EventApi(initialContext_1, eventDef, eventInstance);\n                    var relevantEvents_1 = _this.relevantEvents;\n                    var mutatedRelevantEvents_1 = _this.mutatedRelevantEvents;\n                    var finalHit = _this.hitDragging.finalHit;\n                    _this.clearDrag(); // must happen after revert animation\n                    initialContext_1.emitter.trigger('eventDragStop', {\n                        el: _this.subjectEl,\n                        event: eventApi,\n                        jsEvent: ev.origEvent,\n                        view: initialView,\n                    });\n                    if (validMutation) {\n                        // dropped within same calendar\n                        if (receivingContext_1 === initialContext_1) {\n                            var updatedEventApi = new EventApi(initialContext_1, mutatedRelevantEvents_1.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents_1.instances[eventInstance.instanceId] : null);\n                            initialContext_1.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: mutatedRelevantEvents_1,\n                            });\n                            var eventChangeArg = {\n                                oldEvent: eventApi,\n                                event: updatedEventApi,\n                                relatedEvents: buildEventApis(mutatedRelevantEvents_1, initialContext_1, eventInstance),\n                                revert: function () {\n                                    initialContext_1.dispatch({\n                                        type: 'MERGE_EVENTS',\n                                        eventStore: relevantEvents_1,\n                                    });\n                                },\n                            };\n                            var transformed = {};\n                            for (var _i = 0, _b = initialContext_1.getCurrentData().pluginHooks.eventDropTransformers; _i < _b.length; _i++) {\n                                var transformer = _b[_i];\n                                __assign(transformed, transformer(validMutation, initialContext_1));\n                            }\n                            initialContext_1.emitter.trigger('eventDrop', __assign(__assign(__assign({}, eventChangeArg), transformed), { el: ev.subjectEl, delta: validMutation.datesDelta, jsEvent: ev.origEvent, view: initialView }));\n                            initialContext_1.emitter.trigger('eventChange', eventChangeArg);\n                            // dropped in different calendar\n                        }\n                        else if (receivingContext_1) {\n                            var eventRemoveArg = {\n                                event: eventApi,\n                                relatedEvents: buildEventApis(relevantEvents_1, initialContext_1, eventInstance),\n                                revert: function () {\n                                    initialContext_1.dispatch({\n                                        type: 'MERGE_EVENTS',\n                                        eventStore: relevantEvents_1,\n                                    });\n                                },\n                            };\n                            initialContext_1.emitter.trigger('eventLeave', __assign(__assign({}, eventRemoveArg), { draggedEl: ev.subjectEl, view: initialView }));\n                            initialContext_1.dispatch({\n                                type: 'REMOVE_EVENTS',\n                                eventStore: relevantEvents_1,\n                            });\n                            initialContext_1.emitter.trigger('eventRemove', eventRemoveArg);\n                            var addedEventDef = mutatedRelevantEvents_1.defs[eventDef.defId];\n                            var addedEventInstance = mutatedRelevantEvents_1.instances[eventInstance.instanceId];\n                            var addedEventApi = new EventApi(receivingContext_1, addedEventDef, addedEventInstance);\n                            receivingContext_1.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: mutatedRelevantEvents_1,\n                            });\n                            var eventAddArg = {\n                                event: addedEventApi,\n                                relatedEvents: buildEventApis(mutatedRelevantEvents_1, receivingContext_1, addedEventInstance),\n                                revert: function () {\n                                    receivingContext_1.dispatch({\n                                        type: 'REMOVE_EVENTS',\n                                        eventStore: mutatedRelevantEvents_1,\n                                    });\n                                },\n                            };\n                            receivingContext_1.emitter.trigger('eventAdd', eventAddArg);\n                            if (ev.isTouch) {\n                                receivingContext_1.dispatch({\n                                    type: 'SELECT_EVENT',\n                                    eventInstanceId: eventInstance.instanceId,\n                                });\n                            }\n                            receivingContext_1.emitter.trigger('drop', __assign(__assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext_1)), { draggedEl: ev.subjectEl, jsEvent: ev.origEvent, view: finalHit.component.context.viewApi }));\n                            receivingContext_1.emitter.trigger('eventReceive', __assign(__assign({}, eventAddArg), { draggedEl: ev.subjectEl, view: finalHit.component.context.viewApi }));\n                        }\n                    }\n                    else {\n                        initialContext_1.emitter.trigger('_noEventDrop');\n                    }\n                }\n                _this.cleanup();\n            };\n            var component = _this.component;\n            var options = component.context.options;\n            var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.pointer.selector = EventDragging.SELECTOR;\n            dragging.touchScrollAllowed = false;\n            dragging.autoScroller.isEnabled = options.dragScroll;\n            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsStore);\n            hitDragging.useSubjectCenter = settings.useEventCenter;\n            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', _this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n            hitDragging.emitter.on('pointerup', _this.handlePointerUp);\n            hitDragging.emitter.on('dragend', _this.handleDragEnd);\n            return _this;\n        }\n        EventDragging.prototype.destroy = function () {\n            this.dragging.destroy();\n        };\n        // render a drag state on the next receivingCalendar\n        EventDragging.prototype.displayDrag = function (nextContext, state) {\n            var initialContext = this.component.context;\n            var prevContext = this.receivingContext;\n            // does the previous calendar need to be cleared?\n            if (prevContext && prevContext !== nextContext) {\n                // does the initial calendar need to be cleared?\n                // if so, don't clear all the way. we still need to to hide the affectedEvents\n                if (prevContext === initialContext) {\n                    prevContext.dispatch({\n                        type: 'SET_EVENT_DRAG',\n                        state: {\n                            affectedEvents: state.affectedEvents,\n                            mutatedEvents: createEmptyEventStore(),\n                            isEvent: true,\n                        },\n                    });\n                    // completely clear the old calendar if it wasn't the initial\n                }\n                else {\n                    prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n                }\n            }\n            if (nextContext) {\n                nextContext.dispatch({ type: 'SET_EVENT_DRAG', state: state });\n            }\n        };\n        EventDragging.prototype.clearDrag = function () {\n            var initialCalendar = this.component.context;\n            var receivingContext = this.receivingContext;\n            if (receivingContext) {\n                receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n            }\n            // the initial calendar might have an dummy drag state from displayDrag\n            if (initialCalendar !== receivingContext) {\n                initialCalendar.dispatch({ type: 'UNSET_EVENT_DRAG' });\n            }\n        };\n        EventDragging.prototype.cleanup = function () {\n            this.subjectSeg = null;\n            this.isDragging = false;\n            this.eventRange = null;\n            this.relevantEvents = null;\n            this.receivingContext = null;\n            this.validMutation = null;\n            this.mutatedRelevantEvents = null;\n        };\n        // TODO: test this in IE11\n        // QUESTION: why do we need it on the resizable???\n        EventDragging.SELECTOR = '.fc-event-draggable, .fc-event-resizable';\n        return EventDragging;\n    }(Interaction));\n    function computeEventMutation(hit0, hit1, massagers) {\n        var dateSpan0 = hit0.dateSpan;\n        var dateSpan1 = hit1.dateSpan;\n        var date0 = dateSpan0.range.start;\n        var date1 = dateSpan1.range.start;\n        var standardProps = {};\n        if (dateSpan0.allDay !== dateSpan1.allDay) {\n            standardProps.allDay = dateSpan1.allDay;\n            standardProps.hasEnd = hit1.component.context.options.allDayMaintainDuration;\n            if (dateSpan1.allDay) {\n                // means date1 is already start-of-day,\n                // but date0 needs to be converted\n                date0 = startOfDay(date0);\n            }\n        }\n        var delta = diffDates(date0, date1, hit0.component.context.dateEnv, hit0.component === hit1.component ?\n            hit0.component.largeUnit :\n            null);\n        if (delta.milliseconds) { // has hours/minutes/seconds\n            standardProps.allDay = false;\n        }\n        var mutation = {\n            datesDelta: delta,\n            standardProps: standardProps,\n        };\n        for (var _i = 0, massagers_1 = massagers; _i < massagers_1.length; _i++) {\n            var massager = massagers_1[_i];\n            massager(mutation, hit0, hit1);\n        }\n        return mutation;\n    }\n    function getComponentTouchDelay$1(component) {\n        var options = component.context.options;\n        var delay = options.eventLongPressDelay;\n        if (delay == null) {\n            delay = options.longPressDelay;\n        }\n        return delay;\n    }\n\n    var EventResizing = /** @class */ (function (_super) {\n        __extends(EventResizing, _super);\n        function EventResizing(settings) {\n            var _this = _super.call(this, settings) || this;\n            // internal state\n            _this.draggingSegEl = null;\n            _this.draggingSeg = null; // TODO: rename to resizingSeg? subjectSeg?\n            _this.eventRange = null;\n            _this.relevantEvents = null;\n            _this.validMutation = null;\n            _this.mutatedRelevantEvents = null;\n            _this.handlePointerDown = function (ev) {\n                var component = _this.component;\n                var segEl = _this.querySegEl(ev);\n                var seg = getElSeg(segEl);\n                var eventRange = _this.eventRange = seg.eventRange;\n                _this.dragging.minDistance = component.context.options.eventDragMinDistance;\n                // if touch, need to be working with a selected event\n                _this.dragging.setIgnoreMove(!_this.component.isValidSegDownEl(ev.origEvent.target) ||\n                    (ev.isTouch && _this.component.props.eventSelection !== eventRange.instance.instanceId));\n            };\n            _this.handleDragStart = function (ev) {\n                var context = _this.component.context;\n                var eventRange = _this.eventRange;\n                _this.relevantEvents = getRelevantEvents(context.getCurrentData().eventStore, _this.eventRange.instance.instanceId);\n                var segEl = _this.querySegEl(ev);\n                _this.draggingSegEl = segEl;\n                _this.draggingSeg = getElSeg(segEl);\n                context.calendarApi.unselect();\n                context.emitter.trigger('eventResizeStart', {\n                    el: segEl,\n                    event: new EventApi(context, eventRange.def, eventRange.instance),\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi,\n                });\n            };\n            _this.handleHitUpdate = function (hit, isFinal, ev) {\n                var context = _this.component.context;\n                var relevantEvents = _this.relevantEvents;\n                var initialHit = _this.hitDragging.initialHit;\n                var eventInstance = _this.eventRange.instance;\n                var mutation = null;\n                var mutatedRelevantEvents = null;\n                var isInvalid = false;\n                var interaction = {\n                    affectedEvents: relevantEvents,\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: true,\n                };\n                if (hit) {\n                    mutation = computeMutation(initialHit, hit, ev.subjectEl.classList.contains('fc-event-resizer-start'), eventInstance.range, context.pluginHooks.eventResizeJoinTransforms);\n                }\n                if (mutation) {\n                    mutatedRelevantEvents = applyMutationToEventStore(relevantEvents, context.getCurrentData().eventUiBases, mutation, context);\n                    interaction.mutatedEvents = mutatedRelevantEvents;\n                    if (!_this.component.isInteractionValid(interaction)) {\n                        isInvalid = true;\n                        mutation = null;\n                        mutatedRelevantEvents = null;\n                        interaction.mutatedEvents = null;\n                    }\n                }\n                if (mutatedRelevantEvents) {\n                    context.dispatch({\n                        type: 'SET_EVENT_RESIZE',\n                        state: interaction,\n                    });\n                }\n                else {\n                    context.dispatch({ type: 'UNSET_EVENT_RESIZE' });\n                }\n                if (!isInvalid) {\n                    enableCursor();\n                }\n                else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    if (mutation && isHitsEqual(initialHit, hit)) {\n                        mutation = null;\n                    }\n                    _this.validMutation = mutation;\n                    _this.mutatedRelevantEvents = mutatedRelevantEvents;\n                }\n            };\n            _this.handleDragEnd = function (ev) {\n                var context = _this.component.context;\n                var eventDef = _this.eventRange.def;\n                var eventInstance = _this.eventRange.instance;\n                var eventApi = new EventApi(context, eventDef, eventInstance);\n                var relevantEvents = _this.relevantEvents;\n                var mutatedRelevantEvents = _this.mutatedRelevantEvents;\n                context.emitter.trigger('eventResizeStop', {\n                    el: _this.draggingSegEl,\n                    event: eventApi,\n                    jsEvent: ev.origEvent,\n                    view: context.viewApi,\n                });\n                if (_this.validMutation) {\n                    var updatedEventApi = new EventApi(context, mutatedRelevantEvents.defs[eventDef.defId], eventInstance ? mutatedRelevantEvents.instances[eventInstance.instanceId] : null);\n                    context.dispatch({\n                        type: 'MERGE_EVENTS',\n                        eventStore: mutatedRelevantEvents,\n                    });\n                    var eventChangeArg = {\n                        oldEvent: eventApi,\n                        event: updatedEventApi,\n                        relatedEvents: buildEventApis(mutatedRelevantEvents, context, eventInstance),\n                        revert: function () {\n                            context.dispatch({\n                                type: 'MERGE_EVENTS',\n                                eventStore: relevantEvents,\n                            });\n                        },\n                    };\n                    context.emitter.trigger('eventResize', __assign(__assign({}, eventChangeArg), { el: _this.draggingSegEl, startDelta: _this.validMutation.startDelta || createDuration(0), endDelta: _this.validMutation.endDelta || createDuration(0), jsEvent: ev.origEvent, view: context.viewApi }));\n                    context.emitter.trigger('eventChange', eventChangeArg);\n                }\n                else {\n                    context.emitter.trigger('_noEventResize');\n                }\n                // reset all internal state\n                _this.draggingSeg = null;\n                _this.relevantEvents = null;\n                _this.validMutation = null;\n                // okay to keep eventInstance around. useful to set it in handlePointerDown\n            };\n            var component = settings.component;\n            var dragging = _this.dragging = new FeaturefulElementDragging(settings.el);\n            dragging.pointer.selector = '.fc-event-resizer';\n            dragging.touchScrollAllowed = false;\n            dragging.autoScroller.isEnabled = component.context.options.dragScroll;\n            var hitDragging = _this.hitDragging = new HitDragging(_this.dragging, interactionSettingsToStore(settings));\n            hitDragging.emitter.on('pointerdown', _this.handlePointerDown);\n            hitDragging.emitter.on('dragstart', _this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', _this.handleHitUpdate);\n            hitDragging.emitter.on('dragend', _this.handleDragEnd);\n            return _this;\n        }\n        EventResizing.prototype.destroy = function () {\n            this.dragging.destroy();\n        };\n        EventResizing.prototype.querySegEl = function (ev) {\n            return elementClosest(ev.subjectEl, '.fc-event');\n        };\n        return EventResizing;\n    }(Interaction));\n    function computeMutation(hit0, hit1, isFromStart, instanceRange, transforms) {\n        var dateEnv = hit0.component.context.dateEnv;\n        var date0 = hit0.dateSpan.range.start;\n        var date1 = hit1.dateSpan.range.start;\n        var delta = diffDates(date0, date1, dateEnv, hit0.component.largeUnit);\n        var props = {};\n        for (var _i = 0, transforms_1 = transforms; _i < transforms_1.length; _i++) {\n            var transform = transforms_1[_i];\n            var res = transform(hit0, hit1);\n            if (res === false) {\n                return null;\n            }\n            if (res) {\n                __assign(props, res);\n            }\n        }\n        if (isFromStart) {\n            if (dateEnv.add(instanceRange.start, delta) < instanceRange.end) {\n                props.startDelta = delta;\n                return props;\n            }\n        }\n        else if (dateEnv.add(instanceRange.end, delta) > instanceRange.start) {\n            props.endDelta = delta;\n            return props;\n        }\n        return null;\n    }\n\n    var UnselectAuto = /** @class */ (function () {\n        function UnselectAuto(context) {\n            var _this = this;\n            this.context = context;\n            this.isRecentPointerDateSelect = false; // wish we could use a selector to detect date selection, but uses hit system\n            this.matchesCancel = false;\n            this.matchesEvent = false;\n            this.onSelect = function (selectInfo) {\n                if (selectInfo.jsEvent) {\n                    _this.isRecentPointerDateSelect = true;\n                }\n            };\n            this.onDocumentPointerDown = function (pev) {\n                var unselectCancel = _this.context.options.unselectCancel;\n                var downEl = pev.origEvent.target;\n                _this.matchesCancel = !!elementClosest(downEl, unselectCancel);\n                _this.matchesEvent = !!elementClosest(downEl, EventDragging.SELECTOR); // interaction started on an event?\n            };\n            this.onDocumentPointerUp = function (pev) {\n                var context = _this.context;\n                var documentPointer = _this.documentPointer;\n                var calendarState = context.getCurrentData();\n                // touch-scrolling should never unfocus any type of selection\n                if (!documentPointer.wasTouchScroll) {\n                    if (calendarState.dateSelection && // an existing date selection?\n                        !_this.isRecentPointerDateSelect // a new pointer-initiated date selection since last onDocumentPointerUp?\n                    ) {\n                        var unselectAuto = context.options.unselectAuto;\n                        if (unselectAuto && (!unselectAuto || !_this.matchesCancel)) {\n                            context.calendarApi.unselect(pev);\n                        }\n                    }\n                    if (calendarState.eventSelection && // an existing event selected?\n                        !_this.matchesEvent // interaction DIDN'T start on an event\n                    ) {\n                        context.dispatch({ type: 'UNSELECT_EVENT' });\n                    }\n                }\n                _this.isRecentPointerDateSelect = false;\n            };\n            var documentPointer = this.documentPointer = new PointerDragging(document);\n            documentPointer.shouldIgnoreMove = true;\n            documentPointer.shouldWatchScroll = false;\n            documentPointer.emitter.on('pointerdown', this.onDocumentPointerDown);\n            documentPointer.emitter.on('pointerup', this.onDocumentPointerUp);\n            /*\n            TODO: better way to know about whether there was a selection with the pointer\n            */\n            context.emitter.on('select', this.onSelect);\n        }\n        UnselectAuto.prototype.destroy = function () {\n            this.context.emitter.off('select', this.onSelect);\n            this.documentPointer.destroy();\n        };\n        return UnselectAuto;\n    }());\n\n    var OPTION_REFINERS = {\n        fixedMirrorParent: identity,\n    };\n    var LISTENER_REFINERS = {\n        dateClick: identity,\n        eventDragStart: identity,\n        eventDragStop: identity,\n        eventDrop: identity,\n        eventResizeStart: identity,\n        eventResizeStop: identity,\n        eventResize: identity,\n        drop: identity,\n        eventReceive: identity,\n        eventLeave: identity,\n    };\n\n    /*\n    Given an already instantiated draggable object for one-or-more elements,\n    Interprets any dragging as an attempt to drag an events that lives outside\n    of a calendar onto a calendar.\n    */\n    var ExternalElementDragging = /** @class */ (function () {\n        function ExternalElementDragging(dragging, suppliedDragMeta) {\n            var _this = this;\n            this.receivingContext = null;\n            this.droppableEvent = null; // will exist for all drags, even if create:false\n            this.suppliedDragMeta = null;\n            this.dragMeta = null;\n            this.handleDragStart = function (ev) {\n                _this.dragMeta = _this.buildDragMeta(ev.subjectEl);\n            };\n            this.handleHitUpdate = function (hit, isFinal, ev) {\n                var dragging = _this.hitDragging.dragging;\n                var receivingContext = null;\n                var droppableEvent = null;\n                var isInvalid = false;\n                var interaction = {\n                    affectedEvents: createEmptyEventStore(),\n                    mutatedEvents: createEmptyEventStore(),\n                    isEvent: _this.dragMeta.create,\n                };\n                if (hit) {\n                    receivingContext = hit.component.context;\n                    if (_this.canDropElOnCalendar(ev.subjectEl, receivingContext)) {\n                        droppableEvent = computeEventForDateSpan(hit.dateSpan, _this.dragMeta, receivingContext);\n                        interaction.mutatedEvents = eventTupleToStore(droppableEvent);\n                        isInvalid = !isInteractionValid(interaction, receivingContext);\n                        if (isInvalid) {\n                            interaction.mutatedEvents = createEmptyEventStore();\n                            droppableEvent = null;\n                        }\n                    }\n                }\n                _this.displayDrag(receivingContext, interaction);\n                // show mirror if no already-rendered mirror element OR if we are shutting down the mirror (?)\n                // TODO: wish we could somehow wait for dispatch to guarantee render\n                dragging.setMirrorIsVisible(isFinal || !droppableEvent || !document.querySelector('.fc-event-mirror'));\n                if (!isInvalid) {\n                    enableCursor();\n                }\n                else {\n                    disableCursor();\n                }\n                if (!isFinal) {\n                    dragging.setMirrorNeedsRevert(!droppableEvent);\n                    _this.receivingContext = receivingContext;\n                    _this.droppableEvent = droppableEvent;\n                }\n            };\n            this.handleDragEnd = function (pev) {\n                var _a = _this, receivingContext = _a.receivingContext, droppableEvent = _a.droppableEvent;\n                _this.clearDrag();\n                if (receivingContext && droppableEvent) {\n                    var finalHit = _this.hitDragging.finalHit;\n                    var finalView = finalHit.component.context.viewApi;\n                    var dragMeta = _this.dragMeta;\n                    receivingContext.emitter.trigger('drop', __assign(__assign({}, buildDatePointApiWithContext(finalHit.dateSpan, receivingContext)), { draggedEl: pev.subjectEl, jsEvent: pev.origEvent, view: finalView }));\n                    if (dragMeta.create) {\n                        var addingEvents_1 = eventTupleToStore(droppableEvent);\n                        receivingContext.dispatch({\n                            type: 'MERGE_EVENTS',\n                            eventStore: addingEvents_1,\n                        });\n                        if (pev.isTouch) {\n                            receivingContext.dispatch({\n                                type: 'SELECT_EVENT',\n                                eventInstanceId: droppableEvent.instance.instanceId,\n                            });\n                        }\n                        // signal that an external event landed\n                        receivingContext.emitter.trigger('eventReceive', {\n                            event: new EventApi(receivingContext, droppableEvent.def, droppableEvent.instance),\n                            relatedEvents: [],\n                            revert: function () {\n                                receivingContext.dispatch({\n                                    type: 'REMOVE_EVENTS',\n                                    eventStore: addingEvents_1,\n                                });\n                            },\n                            draggedEl: pev.subjectEl,\n                            view: finalView,\n                        });\n                    }\n                }\n                _this.receivingContext = null;\n                _this.droppableEvent = null;\n            };\n            var hitDragging = this.hitDragging = new HitDragging(dragging, interactionSettingsStore);\n            hitDragging.requireInitial = false; // will start outside of a component\n            hitDragging.emitter.on('dragstart', this.handleDragStart);\n            hitDragging.emitter.on('hitupdate', this.handleHitUpdate);\n            hitDragging.emitter.on('dragend', this.handleDragEnd);\n            this.suppliedDragMeta = suppliedDragMeta;\n        }\n        ExternalElementDragging.prototype.buildDragMeta = function (subjectEl) {\n            if (typeof this.suppliedDragMeta === 'object') {\n                return parseDragMeta(this.suppliedDragMeta);\n            }\n            if (typeof this.suppliedDragMeta === 'function') {\n                return parseDragMeta(this.suppliedDragMeta(subjectEl));\n            }\n            return getDragMetaFromEl(subjectEl);\n        };\n        ExternalElementDragging.prototype.displayDrag = function (nextContext, state) {\n            var prevContext = this.receivingContext;\n            if (prevContext && prevContext !== nextContext) {\n                prevContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n            }\n            if (nextContext) {\n                nextContext.dispatch({ type: 'SET_EVENT_DRAG', state: state });\n            }\n        };\n        ExternalElementDragging.prototype.clearDrag = function () {\n            if (this.receivingContext) {\n                this.receivingContext.dispatch({ type: 'UNSET_EVENT_DRAG' });\n            }\n        };\n        ExternalElementDragging.prototype.canDropElOnCalendar = function (el, receivingContext) {\n            var dropAccept = receivingContext.options.dropAccept;\n            if (typeof dropAccept === 'function') {\n                return dropAccept.call(receivingContext.calendarApi, el);\n            }\n            if (typeof dropAccept === 'string' && dropAccept) {\n                return Boolean(elementMatches(el, dropAccept));\n            }\n            return true;\n        };\n        return ExternalElementDragging;\n    }());\n    // Utils for computing event store from the DragMeta\n    // ----------------------------------------------------------------------------------------------------\n    function computeEventForDateSpan(dateSpan, dragMeta, context) {\n        var defProps = __assign({}, dragMeta.leftoverProps);\n        for (var _i = 0, _a = context.pluginHooks.externalDefTransforms; _i < _a.length; _i++) {\n            var transform = _a[_i];\n            __assign(defProps, transform(dateSpan, dragMeta));\n        }\n        var _b = refineEventDef(defProps, context), refined = _b.refined, extra = _b.extra;\n        var def = parseEventDef(refined, extra, dragMeta.sourceId, dateSpan.allDay, context.options.forceEventDuration || Boolean(dragMeta.duration), // hasEnd\n        context);\n        var start = dateSpan.range.start;\n        // only rely on time info if drop zone is all-day,\n        // otherwise, we already know the time\n        if (dateSpan.allDay && dragMeta.startTime) {\n            start = context.dateEnv.add(start, dragMeta.startTime);\n        }\n        var end = dragMeta.duration ?\n            context.dateEnv.add(start, dragMeta.duration) :\n            getDefaultEventEnd(dateSpan.allDay, start, context);\n        var instance = createEventInstance(def.defId, { start: start, end: end });\n        return { def: def, instance: instance };\n    }\n    // Utils for extracting data from element\n    // ----------------------------------------------------------------------------------------------------\n    function getDragMetaFromEl(el) {\n        var str = getEmbeddedElData(el, 'event');\n        var obj = str ?\n            JSON.parse(str) :\n            { create: false }; // if no embedded data, assume no event creation\n        return parseDragMeta(obj);\n    }\n    config.dataAttrPrefix = '';\n    function getEmbeddedElData(el, name) {\n        var prefix = config.dataAttrPrefix;\n        var prefixedName = (prefix ? prefix + '-' : '') + name;\n        return el.getAttribute('data-' + prefixedName) || '';\n    }\n\n    /*\n    Makes an element (that is *external* to any calendar) draggable.\n    Can pass in data that determines how an event will be created when dropped onto a calendar.\n    Leverages FullCalendar's internal drag-n-drop functionality WITHOUT a third-party drag system.\n    */\n    var ExternalDraggable = /** @class */ (function () {\n        function ExternalDraggable(el, settings) {\n            var _this = this;\n            if (settings === void 0) { settings = {}; }\n            this.handlePointerDown = function (ev) {\n                var dragging = _this.dragging;\n                var _a = _this.settings, minDistance = _a.minDistance, longPressDelay = _a.longPressDelay;\n                dragging.minDistance =\n                    minDistance != null ?\n                        minDistance :\n                        (ev.isTouch ? 0 : BASE_OPTION_DEFAULTS.eventDragMinDistance);\n                dragging.delay =\n                    ev.isTouch ? // TODO: eventually read eventLongPressDelay instead vvv\n                        (longPressDelay != null ? longPressDelay : BASE_OPTION_DEFAULTS.longPressDelay) :\n                        0;\n            };\n            this.handleDragStart = function (ev) {\n                if (ev.isTouch &&\n                    _this.dragging.delay &&\n                    ev.subjectEl.classList.contains('fc-event')) {\n                    _this.dragging.mirror.getMirrorEl().classList.add('fc-event-selected');\n                }\n            };\n            this.settings = settings;\n            var dragging = this.dragging = new FeaturefulElementDragging(el);\n            dragging.touchScrollAllowed = false;\n            if (settings.itemSelector != null) {\n                dragging.pointer.selector = settings.itemSelector;\n            }\n            if (settings.appendTo != null) {\n                dragging.mirror.parentNode = settings.appendTo; // TODO: write tests\n            }\n            dragging.emitter.on('pointerdown', this.handlePointerDown);\n            dragging.emitter.on('dragstart', this.handleDragStart);\n            new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n        }\n        ExternalDraggable.prototype.destroy = function () {\n            this.dragging.destroy();\n        };\n        return ExternalDraggable;\n    }());\n\n    /*\n    Detects when a *THIRD-PARTY* drag-n-drop system interacts with elements.\n    The third-party system is responsible for drawing the visuals effects of the drag.\n    This class simply monitors for pointer movements and fires events.\n    It also has the ability to hide the moving element (the \"mirror\") during the drag.\n    */\n    var InferredElementDragging = /** @class */ (function (_super) {\n        __extends(InferredElementDragging, _super);\n        function InferredElementDragging(containerEl) {\n            var _this = _super.call(this, containerEl) || this;\n            _this.shouldIgnoreMove = false;\n            _this.mirrorSelector = '';\n            _this.currentMirrorEl = null;\n            _this.handlePointerDown = function (ev) {\n                _this.emitter.trigger('pointerdown', ev);\n                if (!_this.shouldIgnoreMove) {\n                    // fire dragstart right away. does not support delay or min-distance\n                    _this.emitter.trigger('dragstart', ev);\n                }\n            };\n            _this.handlePointerMove = function (ev) {\n                if (!_this.shouldIgnoreMove) {\n                    _this.emitter.trigger('dragmove', ev);\n                }\n            };\n            _this.handlePointerUp = function (ev) {\n                _this.emitter.trigger('pointerup', ev);\n                if (!_this.shouldIgnoreMove) {\n                    // fire dragend right away. does not support a revert animation\n                    _this.emitter.trigger('dragend', ev);\n                }\n            };\n            var pointer = _this.pointer = new PointerDragging(containerEl);\n            pointer.emitter.on('pointerdown', _this.handlePointerDown);\n            pointer.emitter.on('pointermove', _this.handlePointerMove);\n            pointer.emitter.on('pointerup', _this.handlePointerUp);\n            return _this;\n        }\n        InferredElementDragging.prototype.destroy = function () {\n            this.pointer.destroy();\n        };\n        InferredElementDragging.prototype.setIgnoreMove = function (bool) {\n            this.shouldIgnoreMove = bool;\n        };\n        InferredElementDragging.prototype.setMirrorIsVisible = function (bool) {\n            if (bool) {\n                // restore a previously hidden element.\n                // use the reference in case the selector class has already been removed.\n                if (this.currentMirrorEl) {\n                    this.currentMirrorEl.style.visibility = '';\n                    this.currentMirrorEl = null;\n                }\n            }\n            else {\n                var mirrorEl = this.mirrorSelector ?\n                    document.querySelector(this.mirrorSelector) :\n                    null;\n                if (mirrorEl) {\n                    this.currentMirrorEl = mirrorEl;\n                    mirrorEl.style.visibility = 'hidden';\n                }\n            }\n        };\n        return InferredElementDragging;\n    }(ElementDragging));\n\n    /*\n    Bridges third-party drag-n-drop systems with FullCalendar.\n    Must be instantiated and destroyed by caller.\n    */\n    var ThirdPartyDraggable = /** @class */ (function () {\n        function ThirdPartyDraggable(containerOrSettings, settings) {\n            var containerEl = document;\n            if (\n            // wish we could just test instanceof EventTarget, but doesn't work in IE11\n            containerOrSettings === document ||\n                containerOrSettings instanceof Element) {\n                containerEl = containerOrSettings;\n                settings = settings || {};\n            }\n            else {\n                settings = (containerOrSettings || {});\n            }\n            var dragging = this.dragging = new InferredElementDragging(containerEl);\n            if (typeof settings.itemSelector === 'string') {\n                dragging.pointer.selector = settings.itemSelector;\n            }\n            else if (containerEl === document) {\n                dragging.pointer.selector = '[data-event]';\n            }\n            if (typeof settings.mirrorSelector === 'string') {\n                dragging.mirrorSelector = settings.mirrorSelector;\n            }\n            new ExternalElementDragging(dragging, settings.eventData); // eslint-disable-line no-new\n        }\n        ThirdPartyDraggable.prototype.destroy = function () {\n            this.dragging.destroy();\n        };\n        return ThirdPartyDraggable;\n    }());\n\n    var interactionPlugin = createPlugin({\n        componentInteractions: [DateClicking, DateSelecting, EventDragging, EventResizing],\n        calendarInteractions: [UnselectAuto],\n        elementDraggingImpl: FeaturefulElementDragging,\n        optionRefiners: OPTION_REFINERS,\n        listenerRefiners: LISTENER_REFINERS,\n    });\n\n    /* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n    ----------------------------------------------------------------------------------------------------------------------*/\n    // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n    // It is responsible for managing width/height.\n    var TableView = /** @class */ (function (_super) {\n        __extends(TableView, _super);\n        function TableView() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.headerElRef = createRef();\n            return _this;\n        }\n        TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {\n            var _a = this, props = _a.props, context = _a.context;\n            var sections = [];\n            var stickyHeaderDates = getStickyHeaderDates(context.options);\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunk: {\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent,\n                    },\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunk: { content: bodyContent },\n            });\n            return (createElement(ViewRoot, { viewSpec: context.viewSpec }, function (rootElRef, classNames) { return (createElement(\"div\", { ref: rootElRef, className: ['fc-daygrid'].concat(classNames).join(' ') },\n                createElement(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, cols: [] /* TODO: make optional? */, sections: sections }))); }));\n        };\n        TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {\n            var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n            if (!ScrollGrid) {\n                throw new Error('No ScrollGrid implementation');\n            }\n            var _a = this, props = _a.props, context = _a.context;\n            var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n            var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n            var sections = [];\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunks: [{\n                            key: 'main',\n                            elRef: this.headerElRef,\n                            tableClassName: 'fc-col-header',\n                            rowContent: headerRowContent,\n                        }],\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                chunks: [{\n                        key: 'main',\n                        content: bodyContent,\n                    }],\n            });\n            if (stickyFooterScrollbar) {\n                sections.push({\n                    type: 'footer',\n                    key: 'footer',\n                    isSticky: true,\n                    chunks: [{\n                            key: 'main',\n                            content: renderScrollShim,\n                        }],\n                });\n            }\n            return (createElement(ViewRoot, { viewSpec: context.viewSpec }, function (rootElRef, classNames) { return (createElement(\"div\", { ref: rootElRef, className: ['fc-daygrid'].concat(classNames).join(' ') },\n                createElement(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, colGroups: [{ cols: [{ span: colCnt, minWidth: dayMinWidth }] }], sections: sections }))); }));\n        };\n        return TableView;\n    }(DateComponent));\n\n    function splitSegsByRow(segs, rowCnt) {\n        var byRow = [];\n        for (var i = 0; i < rowCnt; i += 1) {\n            byRow[i] = [];\n        }\n        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n            var seg = segs_1[_i];\n            byRow[seg.row].push(seg);\n        }\n        return byRow;\n    }\n    function splitSegsByFirstCol(segs, colCnt) {\n        var byCol = [];\n        for (var i = 0; i < colCnt; i += 1) {\n            byCol[i] = [];\n        }\n        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n            var seg = segs_2[_i];\n            byCol[seg.firstCol].push(seg);\n        }\n        return byCol;\n    }\n    function splitInteractionByRow(ui, rowCnt) {\n        var byRow = [];\n        if (!ui) {\n            for (var i = 0; i < rowCnt; i += 1) {\n                byRow[i] = null;\n            }\n        }\n        else {\n            for (var i = 0; i < rowCnt; i += 1) {\n                byRow[i] = {\n                    affectedInstances: ui.affectedInstances,\n                    isEvent: ui.isEvent,\n                    segs: [],\n                };\n            }\n            for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n                var seg = _a[_i];\n                byRow[seg.row].segs.push(seg);\n            }\n        }\n        return byRow;\n    }\n\n    var TableCellTop = /** @class */ (function (_super) {\n        __extends(TableCellTop, _super);\n        function TableCellTop() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TableCellTop.prototype.render = function () {\n            var props = this.props;\n            var navLinkAttrs = this.context.options.navLinks\n                ? { 'data-navlink': buildNavLinkData(props.date), tabIndex: 0 }\n                : {};\n            return (createElement(DayCellContent, { date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, extraHookProps: props.extraHookProps, defaultContent: renderTopInner }, function (innerElRef, innerContent) { return ((innerContent || props.forceDayTop) && (createElement(\"div\", { className: \"fc-daygrid-day-top\", ref: innerElRef },\n                createElement(\"a\", __assign({ className: \"fc-daygrid-day-number\" }, navLinkAttrs), innerContent || createElement(Fragment, null, \"\\u00A0\"))))); }));\n        };\n        return TableCellTop;\n    }(BaseComponent));\n    function renderTopInner(props) {\n        return props.dayNumberText;\n    }\n\n    var DEFAULT_WEEK_NUM_FORMAT = createFormatter({ week: 'narrow' });\n    var TableCell = /** @class */ (function (_super) {\n        __extends(TableCell, _super);\n        function TableCell() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.handleRootEl = function (el) {\n                _this.rootEl = el;\n                setRef(_this.props.elRef, el);\n            };\n            _this.handleMoreLinkClick = function (ev) {\n                var props = _this.props;\n                if (props.onMoreClick) {\n                    var allSegs = props.segsByEachCol;\n                    var hiddenSegs = allSegs.filter(function (seg) { return props.segIsHidden[seg.eventRange.instance.instanceId]; });\n                    props.onMoreClick({\n                        date: props.date,\n                        allSegs: allSegs,\n                        hiddenSegs: hiddenSegs,\n                        moreCnt: props.moreCnt,\n                        dayEl: _this.rootEl,\n                        ev: ev,\n                    });\n                }\n            };\n            return _this;\n        }\n        TableCell.prototype.render = function () {\n            var _this = this;\n            var _a = this.context, options = _a.options, viewApi = _a.viewApi;\n            var props = this.props;\n            var date = props.date, dateProfile = props.dateProfile;\n            var hookProps = {\n                num: props.moreCnt,\n                text: props.buildMoreLinkText(props.moreCnt),\n                view: viewApi,\n            };\n            var navLinkAttrs = options.navLinks\n                ? { 'data-navlink': buildNavLinkData(date, 'week'), tabIndex: 0 }\n                : {};\n            return (createElement(DayCellRoot, { date: date, dateProfile: dateProfile, todayRange: props.todayRange, showDayNumber: props.showDayNumber, extraHookProps: props.extraHookProps, elRef: this.handleRootEl }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) { return (createElement(\"td\", __assign({ ref: dayElRef, className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ') }, rootDataAttrs, props.extraDataAttrs),\n                createElement(\"div\", { className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\", ref: props.innerElRef /* different from hook system! RENAME */ },\n                    props.showWeekNumber && (createElement(WeekNumberRoot, { date: date, defaultFormat: DEFAULT_WEEK_NUM_FORMAT }, function (weekElRef, weekClassNames, innerElRef, innerContent) { return (createElement(\"a\", __assign({ ref: weekElRef, className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ') }, navLinkAttrs), innerContent)); })),\n                    !isDisabled && (createElement(TableCellTop, { date: date, dateProfile: dateProfile, showDayNumber: props.showDayNumber, forceDayTop: props.forceDayTop, todayRange: props.todayRange, extraHookProps: props.extraHookProps })),\n                    createElement(\"div\", { className: \"fc-daygrid-day-events\", ref: props.fgContentElRef, style: { paddingBottom: props.fgPaddingBottom } },\n                        props.fgContent,\n                        Boolean(props.moreCnt) && (createElement(\"div\", { className: \"fc-daygrid-day-bottom\", style: { marginTop: props.moreMarginTop } },\n                            createElement(RenderHook, { hookProps: hookProps, classNames: options.moreLinkClassNames, content: options.moreLinkContent, defaultContent: renderMoreLinkInner, didMount: options.moreLinkDidMount, willUnmount: options.moreLinkWillUnmount }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"a\", { ref: rootElRef, className: ['fc-daygrid-more-link'].concat(classNames).join(' '), onClick: _this.handleMoreLinkClick }, innerContent)); })))),\n                    createElement(\"div\", { className: \"fc-daygrid-day-bg\" }, props.bgContent)))); }));\n        };\n        return TableCell;\n    }(DateComponent));\n    function renderMoreLinkInner(props) {\n        return props.text;\n    }\n\n    var DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'narrow',\n    });\n    function hasListItemDisplay(seg) {\n        var display = seg.eventRange.ui.display;\n        return display === 'list-item' || (display === 'auto' &&\n            !seg.eventRange.def.allDay &&\n            seg.firstCol === seg.lastCol && // can't be multi-day\n            seg.isStart && // \"\n            seg.isEnd // \"\n        );\n    }\n\n    var TableListItemEvent = /** @class */ (function (_super) {\n        __extends(TableListItemEvent, _super);\n        function TableListItemEvent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TableListItemEvent.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n            var timeText = buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n            return (createElement(EventRoot, { seg: props.seg, timeText: timeText, defaultContent: renderInnerContent$2, isDragging: props.isDragging, isResizing: false, isDateSelecting: false, isSelected: props.isSelected, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday }, function (rootElRef, classNames, innerElRef, innerContent) { return ( // we don't use styles!\n            createElement(\"a\", __assign({ className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '), ref: rootElRef }, getSegAnchorAttrs$1(props.seg)), innerContent)); }));\n        };\n        return TableListItemEvent;\n    }(BaseComponent));\n    function renderInnerContent$2(innerProps) {\n        return (createElement(Fragment, null,\n            createElement(\"div\", { className: \"fc-daygrid-event-dot\", style: { borderColor: innerProps.borderColor || innerProps.backgroundColor } }),\n            innerProps.timeText && (createElement(\"div\", { className: \"fc-event-time\" }, innerProps.timeText)),\n            createElement(\"div\", { className: \"fc-event-title\" }, innerProps.event.title || createElement(Fragment, null, \"\\u00A0\"))));\n    }\n    function getSegAnchorAttrs$1(seg) {\n        var url = seg.eventRange.def.url;\n        return url ? { href: url } : {};\n    }\n\n    var TableBlockEvent = /** @class */ (function (_super) {\n        __extends(TableBlockEvent, _super);\n        function TableBlockEvent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TableBlockEvent.prototype.render = function () {\n            var props = this.props;\n            return (createElement(StandardEvent, __assign({}, props, { extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'], defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT, defaultDisplayEventEnd: props.defaultDisplayEventEnd, disableResizing: !props.seg.eventRange.def.allDay })));\n        };\n        return TableBlockEvent;\n    }(BaseComponent));\n\n    function computeFgSegPlacement(// for one row. TODO: print mode?\n    cellModels, segs, dayMaxEvents, dayMaxEventRows, eventHeights, maxContentHeight, colCnt, eventOrderSpecs) {\n        var colPlacements = []; // if event spans multiple cols, its present in each col\n        var moreCnts = []; // by-col\n        var segIsHidden = {};\n        var segTops = {}; // always populated for each seg\n        var segMarginTops = {}; // simetimes populated for each seg\n        var moreTops = {};\n        var paddingBottoms = {}; // for each cell's inner-wrapper div\n        for (var i = 0; i < colCnt; i += 1) {\n            colPlacements.push([]);\n            moreCnts.push(0);\n        }\n        segs = sortEventSegs(segs, eventOrderSpecs);\n        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n            var seg = segs_1[_i];\n            var instanceId = seg.eventRange.instance.instanceId;\n            var eventHeight = eventHeights[instanceId + ':' + seg.firstCol];\n            placeSeg(seg, eventHeight || 0); // will keep colPlacements sorted by top\n        }\n        if (dayMaxEvents === true || dayMaxEventRows === true) {\n            limitByMaxHeight(moreCnts, segIsHidden, colPlacements, maxContentHeight); // populates moreCnts/segIsHidden\n        }\n        else if (typeof dayMaxEvents === 'number') {\n            limitByMaxEvents(moreCnts, segIsHidden, colPlacements, dayMaxEvents); // populates moreCnts/segIsHidden\n        }\n        else if (typeof dayMaxEventRows === 'number') {\n            limitByMaxRows(moreCnts, segIsHidden, colPlacements, dayMaxEventRows); // populates moreCnts/segIsHidden\n        }\n        // computes segTops/segMarginTops/moreTops/paddingBottoms\n        for (var col = 0; col < colCnt; col += 1) {\n            var placements = colPlacements[col];\n            var currentNonAbsBottom = 0;\n            var currentAbsHeight = 0;\n            for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {\n                var placement = placements_1[_a];\n                var seg = placement.seg;\n                if (!segIsHidden[seg.eventRange.instance.instanceId]) {\n                    segTops[seg.eventRange.instance.instanceId] = placement.top; // from top of container\n                    if (seg.firstCol === seg.lastCol && seg.isStart && seg.isEnd) { // TODO: simpler way? NOT DRY\n                        segMarginTops[seg.eventRange.instance.instanceId] =\n                            placement.top - currentNonAbsBottom; // from previous seg bottom\n                        currentAbsHeight = 0;\n                        currentNonAbsBottom = placement.bottom;\n                    }\n                    else { // multi-col event, abs positioned\n                        currentAbsHeight = placement.bottom - currentNonAbsBottom;\n                    }\n                }\n            }\n            if (currentAbsHeight) {\n                if (moreCnts[col]) {\n                    moreTops[col] = currentAbsHeight;\n                }\n                else {\n                    paddingBottoms[col] = currentAbsHeight;\n                }\n            }\n        }\n        function placeSeg(seg, segHeight) {\n            if (!tryPlaceSegAt(seg, segHeight, 0)) {\n                for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n                    for (var _i = 0, _a = colPlacements[col]; _i < _a.length; _i++) { // will repeat multi-day segs!!!!!!! bad!!!!!!\n                        var placement = _a[_i];\n                        if (tryPlaceSegAt(seg, segHeight, placement.bottom)) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        function tryPlaceSegAt(seg, segHeight, top) {\n            if (canPlaceSegAt(seg, segHeight, top)) {\n                for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n                    var placements = colPlacements[col];\n                    var insertionIndex = 0;\n                    while (insertionIndex < placements.length &&\n                        top >= placements[insertionIndex].top) {\n                        insertionIndex += 1;\n                    }\n                    placements.splice(insertionIndex, 0, {\n                        seg: seg,\n                        top: top,\n                        bottom: top + segHeight,\n                    });\n                }\n                return true;\n            }\n            return false;\n        }\n        function canPlaceSegAt(seg, segHeight, top) {\n            for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n                for (var _i = 0, _a = colPlacements[col]; _i < _a.length; _i++) {\n                    var placement = _a[_i];\n                    if (top < placement.bottom && top + segHeight > placement.top) { // collide?\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        // what does this do!?\n        for (var instanceIdAndFirstCol in eventHeights) {\n            if (!eventHeights[instanceIdAndFirstCol]) {\n                segIsHidden[instanceIdAndFirstCol.split(':')[0]] = true;\n            }\n        }\n        var segsByFirstCol = colPlacements.map(extractFirstColSegs); // operates on the sorted cols\n        var segsByEachCol = colPlacements.map(function (placements, col) {\n            var segsForCols = extractAllColSegs(placements);\n            segsForCols = resliceDaySegs(segsForCols, cellModels[col].date, col);\n            return segsForCols;\n        });\n        return {\n            segsByFirstCol: segsByFirstCol,\n            segsByEachCol: segsByEachCol,\n            segIsHidden: segIsHidden,\n            segTops: segTops,\n            segMarginTops: segMarginTops,\n            moreCnts: moreCnts,\n            moreTops: moreTops,\n            paddingBottoms: paddingBottoms,\n        };\n    }\n    function extractFirstColSegs(oneColPlacements, col) {\n        var segs = [];\n        for (var _i = 0, oneColPlacements_1 = oneColPlacements; _i < oneColPlacements_1.length; _i++) {\n            var placement = oneColPlacements_1[_i];\n            if (placement.seg.firstCol === col) {\n                segs.push(placement.seg);\n            }\n        }\n        return segs;\n    }\n    function extractAllColSegs(oneColPlacements) {\n        var segs = [];\n        for (var _i = 0, oneColPlacements_2 = oneColPlacements; _i < oneColPlacements_2.length; _i++) {\n            var placement = oneColPlacements_2[_i];\n            segs.push(placement.seg);\n        }\n        return segs;\n    }\n    function limitByMaxHeight(hiddenCnts, segIsHidden, colPlacements, maxContentHeight) {\n        limitEvents(hiddenCnts, segIsHidden, colPlacements, true, function (placement) { return placement.bottom <= maxContentHeight; });\n    }\n    function limitByMaxEvents(hiddenCnts, segIsHidden, colPlacements, dayMaxEvents) {\n        limitEvents(hiddenCnts, segIsHidden, colPlacements, false, function (placement, levelIndex) { return levelIndex < dayMaxEvents; });\n    }\n    function limitByMaxRows(hiddenCnts, segIsHidden, colPlacements, dayMaxEventRows) {\n        limitEvents(hiddenCnts, segIsHidden, colPlacements, true, function (placement, levelIndex) { return levelIndex < dayMaxEventRows; });\n    }\n    /*\n    populates the given hiddenCnts/segIsHidden, which are supplied empty.\n    TODO: return them instead\n    */\n    function limitEvents(hiddenCnts, segIsHidden, colPlacements, _moreLinkConsumesLevel, isPlacementInBounds) {\n        var colCnt = hiddenCnts.length;\n        var segIsVisible = {}; // TODO: instead, use segIsHidden with true/false?\n        var visibleColPlacements = []; // will mirror colPlacements\n        for (var col = 0; col < colCnt; col += 1) {\n            visibleColPlacements.push([]);\n        }\n        for (var col = 0; col < colCnt; col += 1) {\n            var placements = colPlacements[col];\n            var level = 0;\n            for (var _i = 0, placements_2 = placements; _i < placements_2.length; _i++) {\n                var placement = placements_2[_i];\n                if (isPlacementInBounds(placement, level)) {\n                    recordVisible(placement);\n                }\n                else {\n                    recordHidden(placement, level, _moreLinkConsumesLevel);\n                }\n                // only considered a level if the seg had height\n                if (placement.top !== placement.bottom) {\n                    level += 1;\n                }\n            }\n        }\n        function recordVisible(placement) {\n            var seg = placement.seg;\n            var instanceId = seg.eventRange.instance.instanceId;\n            if (!segIsVisible[instanceId]) {\n                segIsVisible[instanceId] = true;\n                for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n                    visibleColPlacements[col].push(placement);\n                }\n            }\n        }\n        function recordHidden(placement, currentLevel, moreLinkConsumesLevel) {\n            var seg = placement.seg;\n            var instanceId = seg.eventRange.instance.instanceId;\n            if (!segIsHidden[instanceId]) {\n                segIsHidden[instanceId] = true;\n                for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n                    hiddenCnts[col] += 1;\n                    var hiddenCnt = hiddenCnts[col];\n                    if (moreLinkConsumesLevel && hiddenCnt === 1 && currentLevel > 0) {\n                        var doomedLevel = currentLevel - 1;\n                        while (visibleColPlacements[col].length > doomedLevel) {\n                            recordHidden(visibleColPlacements[col].pop(), // removes\n                            visibleColPlacements[col].length, // will execute after the pop. will be the index of the removed placement\n                            false);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Given the events within an array of segment objects, reslice them to be in a single day\n    function resliceDaySegs(segs, dayDate, colIndex) {\n        var dayStart = dayDate;\n        var dayEnd = addDays(dayStart, 1);\n        var dayRange = { start: dayStart, end: dayEnd };\n        var newSegs = [];\n        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n            var seg = segs_2[_i];\n            var eventRange = seg.eventRange;\n            var origRange = eventRange.range;\n            var slicedRange = intersectRanges(origRange, dayRange);\n            if (slicedRange) {\n                newSegs.push(__assign(__assign({}, seg), { firstCol: colIndex, lastCol: colIndex, eventRange: {\n                        def: eventRange.def,\n                        ui: __assign(__assign({}, eventRange.ui), { durationEditable: false }),\n                        instance: eventRange.instance,\n                        range: slicedRange,\n                    }, isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(), isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf() }));\n            }\n        }\n        return newSegs;\n    }\n\n    var TableRow = /** @class */ (function (_super) {\n        __extends(TableRow, _super);\n        function TableRow() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.cellElRefs = new RefMap(); // the <td>\n            _this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame\n            _this.fgElRefs = new RefMap(); // the fc-daygrid-day-events\n            _this.segHarnessRefs = new RefMap(); // indexed by \"instanceId:firstCol\"\n            _this.rootElRef = createRef();\n            _this.state = {\n                framePositions: null,\n                maxContentHeight: null,\n                segHeights: {},\n            };\n            return _this;\n        }\n        TableRow.prototype.render = function () {\n            var _this = this;\n            var _a = this, props = _a.props, state = _a.state, context = _a.context;\n            var colCnt = props.cells.length;\n            var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n            var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n            var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n            var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n            var _b = computeFgSegPlacement(props.cells, props.fgEventSegs, props.dayMaxEvents, props.dayMaxEventRows, state.segHeights, state.maxContentHeight, colCnt, context.options.eventOrder), paddingBottoms = _b.paddingBottoms, segsByFirstCol = _b.segsByFirstCol, segsByEachCol = _b.segsByEachCol, segIsHidden = _b.segIsHidden, segTops = _b.segTops, segMarginTops = _b.segMarginTops, moreCnts = _b.moreCnts, moreTops = _b.moreTops;\n            var selectedInstanceHash = // TODO: messy way to compute this\n             (props.eventDrag && props.eventDrag.affectedInstances) ||\n                (props.eventResize && props.eventResize.affectedInstances) ||\n                {};\n            return (createElement(\"tr\", { ref: this.rootElRef },\n                props.renderIntro && props.renderIntro(),\n                props.cells.map(function (cell, col) {\n                    var normalFgNodes = _this.renderFgSegs(segsByFirstCol[col], segIsHidden, segTops, segMarginTops, selectedInstanceHash, props.todayRange);\n                    var mirrorFgNodes = _this.renderFgSegs(mirrorSegsByCol[col], {}, segTops, // use same tops as real rendering\n                    {}, {}, props.todayRange, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n                    return (createElement(TableCell, { key: cell.key, elRef: _this.cellElRefs.createRef(cell.key), innerElRef: _this.frameElRefs.createRef(cell.key) /* FF <td> problem, but okay to use for left/right. TODO: rename prop */, dateProfile: props.dateProfile, date: cell.date, showDayNumber: props.showDayNumbers, showWeekNumber: props.showWeekNumbers && col === 0, forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */, todayRange: props.todayRange, extraHookProps: cell.extraHookProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, moreCnt: moreCnts[col], buildMoreLinkText: props.buildMoreLinkText, onMoreClick: props.onMoreClick, segIsHidden: segIsHidden, moreMarginTop: moreTops[col] /* rename */, segsByEachCol: segsByEachCol[col], fgPaddingBottom: paddingBottoms[col], fgContentElRef: _this.fgElRefs.createRef(cell.key), fgContent: ( // Fragment scopes the keys\n                        createElement(Fragment, null,\n                            createElement(Fragment, null, normalFgNodes),\n                            createElement(Fragment, null, mirrorFgNodes))), bgContent: ( // Fragment scopes the keys\n                        createElement(Fragment, null,\n                            _this.renderFillSegs(highlightSegsByCol[col], 'highlight'),\n                            _this.renderFillSegs(businessHoursByCol[col], 'non-business'),\n                            _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))) }));\n                })));\n        };\n        TableRow.prototype.componentDidMount = function () {\n            this.updateSizing(true);\n        };\n        TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {\n            var currentProps = this.props;\n            this.updateSizing(!isPropsEqual(prevProps, currentProps));\n        };\n        TableRow.prototype.getHighlightSegs = function () {\n            var props = this.props;\n            if (props.eventDrag && props.eventDrag.segs.length) { // messy check\n                return props.eventDrag.segs;\n            }\n            if (props.eventResize && props.eventResize.segs.length) { // messy check\n                return props.eventResize.segs;\n            }\n            return props.dateSelectionSegs;\n        };\n        TableRow.prototype.getMirrorSegs = function () {\n            var props = this.props;\n            if (props.eventResize && props.eventResize.segs.length) { // messy check\n                return props.eventResize.segs;\n            }\n            return [];\n        };\n        TableRow.prototype.renderFgSegs = function (segs, segIsHidden, // does NOT mean display:hidden\n        segTops, segMarginTops, selectedInstanceHash, todayRange, isDragging, isResizing, isDateSelecting) {\n            var context = this.context;\n            var eventSelection = this.props.eventSelection;\n            var framePositions = this.state.framePositions;\n            var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n            var nodes = [];\n            if (framePositions) {\n                for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n                    var seg = segs_1[_i];\n                    var instanceId = seg.eventRange.instance.instanceId;\n                    var isMirror = isDragging || isResizing || isDateSelecting;\n                    var isSelected = selectedInstanceHash[instanceId];\n                    var isInvisible = segIsHidden[instanceId] || isSelected;\n                    // TODO: simpler way? NOT DRY\n                    var isAbsolute = segIsHidden[instanceId] || isMirror || seg.firstCol !== seg.lastCol || !seg.isStart || !seg.isEnd;\n                    var marginTop = void 0;\n                    var top_1 = void 0;\n                    var left = void 0;\n                    var right = void 0;\n                    if (isAbsolute) {\n                        top_1 = segTops[instanceId];\n                        if (context.isRtl) {\n                            right = 0;\n                            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                        }\n                        else {\n                            left = 0;\n                            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                        }\n                    }\n                    else {\n                        marginTop = segMarginTops[instanceId];\n                    }\n                    /*\n                    known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                    */\n                    nodes.push(createElement(\"div\", { className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''), key: instanceId, \n                        // in print mode when in mult cols, could collide\n                        ref: isMirror ? null : this.segHarnessRefs.createRef(instanceId + ':' + seg.firstCol), style: {\n                            visibility: isInvisible ? 'hidden' : '',\n                            marginTop: marginTop || '',\n                            top: top_1 || '',\n                            left: left || '',\n                            right: right || '',\n                        } }, hasListItemDisplay(seg) ? (createElement(TableListItemEvent, __assign({ seg: seg, isDragging: isDragging, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, getSegMeta(seg, todayRange)))) : (createElement(TableBlockEvent, __assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === eventSelection, defaultDisplayEventEnd: defaultDisplayEventEnd }, getSegMeta(seg, todayRange))))));\n                }\n            }\n            return nodes;\n        };\n        TableRow.prototype.renderFillSegs = function (segs, fillType) {\n            var isRtl = this.context.isRtl;\n            var todayRange = this.props.todayRange;\n            var framePositions = this.state.framePositions;\n            var nodes = [];\n            if (framePositions) {\n                for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n                    var seg = segs_2[_i];\n                    var leftRightCss = isRtl ? {\n                        right: 0,\n                        left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol],\n                    } : {\n                        left: 0,\n                        right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol],\n                    };\n                    nodes.push(createElement(\"div\", { key: buildEventRangeKey(seg.eventRange), className: \"fc-daygrid-bg-harness\", style: leftRightCss }, fillType === 'bg-event' ?\n                        createElement(BgEvent, __assign({ seg: seg }, getSegMeta(seg, todayRange))) :\n                        renderFill(fillType)));\n                }\n            }\n            return createElement.apply(void 0, __spreadArrays([Fragment, {}], nodes));\n        };\n        TableRow.prototype.updateSizing = function (isExternalSizingChange) {\n            var _a = this, props = _a.props, frameElRefs = _a.frameElRefs;\n            if (props.clientWidth !== null) { // positioning ready?\n                if (isExternalSizingChange) {\n                    var frameEls = props.cells.map(function (cell) { return frameElRefs.currentMap[cell.key]; });\n                    if (frameEls.length) {\n                        var originEl = this.rootElRef.current;\n                        this.setState({\n                            framePositions: new PositionCache(originEl, frameEls, true, // isHorizontal\n                            false),\n                        });\n                    }\n                }\n                var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n                this.setState({\n                    segHeights: this.computeSegHeights(),\n                    maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null,\n                });\n            }\n        };\n        TableRow.prototype.computeSegHeights = function () {\n            return mapHash(this.segHarnessRefs.currentMap, function (eventHarnessEl) { return (eventHarnessEl.getBoundingClientRect().height); });\n        };\n        TableRow.prototype.computeMaxContentHeight = function () {\n            var firstKey = this.props.cells[0].key;\n            var cellEl = this.cellElRefs.currentMap[firstKey];\n            var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n            return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n        };\n        TableRow.prototype.getCellEls = function () {\n            var elMap = this.cellElRefs.currentMap;\n            return this.props.cells.map(function (cell) { return elMap[cell.key]; });\n        };\n        return TableRow;\n    }(DateComponent));\n    TableRow.addStateEquality({\n        segHeights: isPropsEqual,\n    });\n\n    var PADDING_FROM_VIEWPORT = 10;\n    var SCROLL_DEBOUNCE = 10;\n    var Popover = /** @class */ (function (_super) {\n        __extends(Popover, _super);\n        function Popover() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.repositioner = new DelayedRunner(_this.updateSize.bind(_this));\n            _this.handleRootEl = function (el) {\n                _this.rootEl = el;\n                if (_this.props.elRef) {\n                    setRef(_this.props.elRef, el);\n                }\n            };\n            // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n            _this.handleDocumentMousedown = function (ev) {\n                var onClose = _this.props.onClose;\n                // only hide the popover if the click happened outside the popover\n                if (onClose && !_this.rootEl.contains(ev.target)) {\n                    onClose();\n                }\n            };\n            _this.handleDocumentScroll = function () {\n                _this.repositioner.request(SCROLL_DEBOUNCE);\n            };\n            _this.handleCloseClick = function () {\n                var onClose = _this.props.onClose;\n                if (onClose) {\n                    onClose();\n                }\n            };\n            return _this;\n        }\n        Popover.prototype.render = function () {\n            var theme = this.context.theme;\n            var props = this.props;\n            var classNames = [\n                'fc-popover',\n                theme.getClass('popover'),\n            ].concat(props.extraClassNames || []);\n            return (createElement(\"div\", __assign({ className: classNames.join(' ') }, props.extraAttrs, { ref: this.handleRootEl }),\n                createElement(\"div\", { className: 'fc-popover-header ' + theme.getClass('popoverHeader') },\n                    createElement(\"span\", { className: \"fc-popover-title\" }, props.title),\n                    createElement(\"span\", { className: 'fc-popover-close ' + theme.getIconClass('close'), onClick: this.handleCloseClick })),\n                createElement(\"div\", { className: 'fc-popover-body ' + theme.getClass('popoverContent') }, props.children)));\n        };\n        Popover.prototype.componentDidMount = function () {\n            document.addEventListener('mousedown', this.handleDocumentMousedown);\n            document.addEventListener('scroll', this.handleDocumentScroll);\n            this.updateSize();\n        };\n        Popover.prototype.componentWillUnmount = function () {\n            document.removeEventListener('mousedown', this.handleDocumentMousedown);\n            document.removeEventListener('scroll', this.handleDocumentScroll);\n        };\n        // TODO: adjust on window resize\n        /*\n        NOTE: the popover is position:fixed, so coordinates are relative to the viewport\n        NOTE: the PARENT calls this as well, on window resize. we would have wanted to use the repositioner,\n              but need to ensure that all other components have updated size first (for alignmentEl)\n        */\n        Popover.prototype.updateSize = function () {\n            var _a = this.props, alignmentEl = _a.alignmentEl, topAlignmentEl = _a.topAlignmentEl;\n            var rootEl = this.rootEl;\n            if (!rootEl) {\n                return; // not sure why this was null, but we shouldn't let external components call updateSize() anyway\n            }\n            var dims = rootEl.getBoundingClientRect(); // only used for width,height\n            var alignment = alignmentEl.getBoundingClientRect();\n            var top = topAlignmentEl ? topAlignmentEl.getBoundingClientRect().top : alignment.top;\n            top = Math.min(top, window.innerHeight - dims.height - PADDING_FROM_VIEWPORT);\n            top = Math.max(top, PADDING_FROM_VIEWPORT);\n            var left;\n            if (this.context.isRtl) {\n                left = alignment.right - dims.width;\n            }\n            else {\n                left = alignment.left;\n            }\n            left = Math.min(left, window.innerWidth - dims.width - PADDING_FROM_VIEWPORT);\n            left = Math.max(left, PADDING_FROM_VIEWPORT);\n            applyStyle(rootEl, { top: top, left: left });\n        };\n        return Popover;\n    }(BaseComponent));\n\n    var MorePopover = /** @class */ (function (_super) {\n        __extends(MorePopover, _super);\n        function MorePopover() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.handlePopoverEl = function (popoverEl) {\n                _this.popoverEl = popoverEl;\n                if (popoverEl) {\n                    _this.context.registerInteractiveComponent(_this, {\n                        el: popoverEl,\n                        useEventCenter: false,\n                    });\n                }\n                else {\n                    _this.context.unregisterInteractiveComponent(_this);\n                }\n            };\n            return _this;\n        }\n        MorePopover.prototype.render = function () {\n            var _a = this.context, options = _a.options, dateEnv = _a.dateEnv;\n            var props = this.props;\n            var date = props.date, hiddenInstances = props.hiddenInstances, todayRange = props.todayRange, dateProfile = props.dateProfile, selectedInstanceId = props.selectedInstanceId;\n            var title = dateEnv.format(date, options.dayPopoverFormat);\n            return (createElement(DayCellRoot, { date: date, dateProfile: dateProfile, todayRange: todayRange, elRef: this.handlePopoverEl }, function (rootElRef, dayClassNames, dataAttrs) { return (createElement(Popover, { elRef: rootElRef, title: title, extraClassNames: ['fc-more-popover'].concat(dayClassNames), extraAttrs: dataAttrs, onClose: props.onCloseClick, alignmentEl: props.alignmentEl, topAlignmentEl: props.topAlignmentEl },\n                createElement(DayCellContent, { date: date, dateProfile: dateProfile, todayRange: todayRange }, function (innerElRef, innerContent) { return (innerContent &&\n                    createElement(\"div\", { className: \"fc-more-popover-misc\", ref: innerElRef }, innerContent)); }),\n                props.segs.map(function (seg) {\n                    var instanceId = seg.eventRange.instance.instanceId;\n                    return (createElement(\"div\", { className: \"fc-daygrid-event-harness\", key: instanceId, style: {\n                            visibility: hiddenInstances[instanceId] ? 'hidden' : '',\n                        } }, hasListItemDisplay(seg) ? (createElement(TableListItemEvent, __assign({ seg: seg, isDragging: false, isSelected: instanceId === selectedInstanceId, defaultDisplayEventEnd: false }, getSegMeta(seg, todayRange)))) : (createElement(TableBlockEvent, __assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: instanceId === selectedInstanceId, defaultDisplayEventEnd: false }, getSegMeta(seg, todayRange))))));\n                }))); }));\n        };\n        MorePopover.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n            var date = this.props.date;\n            if (positionLeft < elWidth && positionTop < elHeight) {\n                return {\n                    component: this,\n                    dateSpan: {\n                        allDay: true,\n                        range: { start: date, end: addDays(date, 1) },\n                    },\n                    dayEl: this.popoverEl,\n                    rect: {\n                        left: 0,\n                        top: 0,\n                        right: elWidth,\n                        bottom: elHeight,\n                    },\n                    layer: 1,\n                };\n            }\n            return null;\n        };\n        MorePopover.prototype.isPopover = function () {\n            return true; // gross\n        };\n        return MorePopover;\n    }(DateComponent));\n\n    var Table = /** @class */ (function (_super) {\n        __extends(Table, _super);\n        function Table() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.splitBusinessHourSegs = memoize(splitSegsByRow);\n            _this.splitBgEventSegs = memoize(splitSegsByRow);\n            _this.splitFgEventSegs = memoize(splitSegsByRow);\n            _this.splitDateSelectionSegs = memoize(splitSegsByRow);\n            _this.splitEventDrag = memoize(splitInteractionByRow);\n            _this.splitEventResize = memoize(splitInteractionByRow);\n            _this.buildBuildMoreLinkText = memoize(buildBuildMoreLinkText);\n            _this.rowRefs = new RefMap();\n            _this.state = {\n                morePopoverState: null,\n            };\n            _this.handleRootEl = function (rootEl) {\n                _this.rootEl = rootEl;\n                setRef(_this.props.elRef, rootEl);\n            };\n            _this.handleMoreLinkClick = function (arg) {\n                var context = _this.context;\n                var dateEnv = context.dateEnv;\n                var clickOption = context.options.moreLinkClick;\n                function segForPublic(seg) {\n                    var _a = seg.eventRange, def = _a.def, instance = _a.instance, range = _a.range;\n                    return {\n                        event: new EventApi(context, def, instance),\n                        start: dateEnv.toDate(range.start),\n                        end: dateEnv.toDate(range.end),\n                        isStart: seg.isStart,\n                        isEnd: seg.isEnd,\n                    };\n                }\n                if (typeof clickOption === 'function') {\n                    clickOption = clickOption({\n                        date: dateEnv.toDate(arg.date),\n                        allDay: true,\n                        allSegs: arg.allSegs.map(segForPublic),\n                        hiddenSegs: arg.hiddenSegs.map(segForPublic),\n                        jsEvent: arg.ev,\n                        view: context.viewApi,\n                    }); // hack to handle void\n                }\n                if (!clickOption || clickOption === 'popover') {\n                    _this.setState({\n                        morePopoverState: __assign(__assign({}, arg), { currentFgEventSegs: _this.props.fgEventSegs }),\n                    });\n                }\n                else if (typeof clickOption === 'string') { // a view name\n                    context.calendarApi.zoomTo(arg.date, clickOption);\n                }\n            };\n            _this.handleMorePopoverClose = function () {\n                _this.setState({\n                    morePopoverState: null,\n                });\n            };\n            return _this;\n        }\n        Table.prototype.render = function () {\n            var _this = this;\n            var props = this.props;\n            var dateProfile = props.dateProfile, dayMaxEventRows = props.dayMaxEventRows, dayMaxEvents = props.dayMaxEvents, expandRows = props.expandRows;\n            var morePopoverState = this.state.morePopoverState;\n            var rowCnt = props.cells.length;\n            var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n            var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n            var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n            var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n            var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n            var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n            var buildMoreLinkText = this.buildBuildMoreLinkText(this.context.options.moreLinkText);\n            var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n            // if rows can't expand to fill fixed height, can't do balanced-height event limit\n            // TODO: best place to normalize these options?\n            if (limitViaBalanced && !expandRows) {\n                limitViaBalanced = false;\n                dayMaxEventRows = null;\n                dayMaxEvents = null;\n            }\n            var classNames = [\n                'fc-daygrid-body',\n                limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced',\n                expandRows ? '' : 'fc-daygrid-body-natural',\n            ];\n            return (createElement(\"div\", { className: classNames.join(' '), ref: this.handleRootEl, style: {\n                    // these props are important to give this wrapper correct dimensions for interactions\n                    // TODO: if we set it here, can we avoid giving to inner tables?\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                } },\n                createElement(NowTimer, { unit: \"day\" }, function (nowDate, todayRange) { return (createElement(Fragment, null,\n                    createElement(\"table\", { className: \"fc-scrollgrid-sync-table\", style: {\n                            width: props.clientWidth,\n                            minWidth: props.tableMinWidth,\n                            height: expandRows ? props.clientHeight : '',\n                        } },\n                        props.colGroupNode,\n                        createElement(\"tbody\", null, props.cells.map(function (cells, row) { return (createElement(TableRow, { ref: _this.rowRefs.createRef(row), key: cells.length\n                                ? cells[0].date.toISOString() /* best? or put key on cell? or use diff formatter? */\n                                : row // in case there are no cells (like when resource view is loading)\n                            , showDayNumbers: rowCnt > 1, showWeekNumbers: props.showWeekNumbers, todayRange: todayRange, dateProfile: dateProfile, cells: cells, renderIntro: props.renderRowIntro, businessHourSegs: businessHourSegsByRow[row], eventSelection: props.eventSelection, bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay) /* hack */, fgEventSegs: fgEventSegsByRow[row], dateSelectionSegs: dateSelectionSegsByRow[row], eventDrag: eventDragByRow[row], eventResize: eventResizeByRow[row], dayMaxEvents: dayMaxEvents, dayMaxEventRows: dayMaxEventRows, clientWidth: props.clientWidth, clientHeight: props.clientHeight, buildMoreLinkText: buildMoreLinkText, onMoreClick: _this.handleMoreLinkClick })); }))),\n                    (!props.forPrint && morePopoverState && morePopoverState.currentFgEventSegs === props.fgEventSegs) && (createElement(MorePopover, { date: morePopoverState.date, dateProfile: dateProfile, segs: morePopoverState.allSegs, alignmentEl: morePopoverState.dayEl, topAlignmentEl: rowCnt === 1 ? props.headerAlignElRef.current : null, onCloseClick: _this.handleMorePopoverClose, selectedInstanceId: props.eventSelection, hiddenInstances: // yuck\n                        (props.eventDrag ? props.eventDrag.affectedInstances : null) ||\n                            (props.eventResize ? props.eventResize.affectedInstances : null) ||\n                            {}, todayRange: todayRange })))); })));\n        };\n        // Hit System\n        // ----------------------------------------------------------------------------------------------------\n        Table.prototype.prepareHits = function () {\n            this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) { return rowObj.getCellEls()[0]; }), // first cell el in each row. TODO: not optimal\n            false, true);\n            this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n            true, // horizontal\n            false);\n        };\n        Table.prototype.positionToHit = function (leftPosition, topPosition) {\n            var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;\n            var col = colPositions.leftToIndex(leftPosition);\n            var row = rowPositions.topToIndex(topPosition);\n            if (row != null && col != null) {\n                return {\n                    row: row,\n                    col: col,\n                    dateSpan: {\n                        range: this.getCellRange(row, col),\n                        allDay: true,\n                    },\n                    dayEl: this.getCellEl(row, col),\n                    relativeRect: {\n                        left: colPositions.lefts[col],\n                        right: colPositions.rights[col],\n                        top: rowPositions.tops[row],\n                        bottom: rowPositions.bottoms[row],\n                    },\n                };\n            }\n            return null;\n        };\n        Table.prototype.getCellEl = function (row, col) {\n            return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n        };\n        Table.prototype.getCellRange = function (row, col) {\n            var start = this.props.cells[row][col].date;\n            var end = addDays(start, 1);\n            return { start: start, end: end };\n        };\n        return Table;\n    }(DateComponent));\n    function buildBuildMoreLinkText(moreLinkTextInput) {\n        if (typeof moreLinkTextInput === 'function') {\n            return moreLinkTextInput;\n        }\n        return function (num) { return \"+\" + num + \" \" + moreLinkTextInput; };\n    }\n    function isSegAllDay(seg) {\n        return seg.eventRange.def.allDay;\n    }\n\n    var DayTableSlicer = /** @class */ (function (_super) {\n        __extends(DayTableSlicer, _super);\n        function DayTableSlicer() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.forceDayIfListItem = true;\n            return _this;\n        }\n        DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {\n            return dayTableModel.sliceRange(dateRange);\n        };\n        return DayTableSlicer;\n    }(Slicer));\n\n    var DayTable = /** @class */ (function (_super) {\n        __extends(DayTable, _super);\n        function DayTable() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.slicer = new DayTableSlicer();\n            _this.tableRef = createRef();\n            _this.handleRootEl = function (rootEl) {\n                if (rootEl) {\n                    _this.context.registerInteractiveComponent(_this, { el: rootEl });\n                }\n                else {\n                    _this.context.unregisterInteractiveComponent(_this);\n                }\n            };\n            return _this;\n        }\n        DayTable.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            return (createElement(Table, __assign({ ref: this.tableRef, elRef: this.handleRootEl }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), { dateProfile: props.dateProfile, cells: props.dayTableModel.cells, colGroupNode: props.colGroupNode, tableMinWidth: props.tableMinWidth, renderRowIntro: props.renderRowIntro, dayMaxEvents: props.dayMaxEvents, dayMaxEventRows: props.dayMaxEventRows, showWeekNumbers: props.showWeekNumbers, expandRows: props.expandRows, headerAlignElRef: props.headerAlignElRef, clientWidth: props.clientWidth, clientHeight: props.clientHeight, forPrint: props.forPrint })));\n        };\n        DayTable.prototype.prepareHits = function () {\n            this.tableRef.current.prepareHits();\n        };\n        DayTable.prototype.queryHit = function (positionLeft, positionTop) {\n            var rawHit = this.tableRef.current.positionToHit(positionLeft, positionTop);\n            if (rawHit) {\n                return {\n                    component: this,\n                    dateSpan: rawHit.dateSpan,\n                    dayEl: rawHit.dayEl,\n                    rect: {\n                        left: rawHit.relativeRect.left,\n                        right: rawHit.relativeRect.right,\n                        top: rawHit.relativeRect.top,\n                        bottom: rawHit.relativeRect.bottom,\n                    },\n                    layer: 0,\n                };\n            }\n            return null;\n        };\n        return DayTable;\n    }(DateComponent));\n\n    var DayTableView = /** @class */ (function (_super) {\n        __extends(DayTableView, _super);\n        function DayTableView() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.buildDayTableModel = memoize(buildDayTableModel);\n            _this.headerRef = createRef();\n            _this.tableRef = createRef();\n            return _this;\n        }\n        DayTableView.prototype.render = function () {\n            var _this = this;\n            var _a = this.context, options = _a.options, dateProfileGenerator = _a.dateProfileGenerator;\n            var props = this.props;\n            var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n            var headerContent = options.dayHeaders && (createElement(DayHeader, { ref: this.headerRef, dateProfile: props.dateProfile, dates: dayTableModel.headerDates, datesRepDistinctDays: dayTableModel.rowCnt === 1 }));\n            var bodyContent = function (contentArg) { return (createElement(DayTable, { ref: _this.tableRef, dateProfile: props.dateProfile, dayTableModel: dayTableModel, businessHours: props.businessHours, dateSelection: props.dateSelection, eventStore: props.eventStore, eventUiBases: props.eventUiBases, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, nextDayThreshold: options.nextDayThreshold, colGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, dayMaxEvents: options.dayMaxEvents, dayMaxEventRows: options.dayMaxEventRows, showWeekNumbers: options.weekNumbers, expandRows: !props.isHeightAuto, headerAlignElRef: _this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint })); };\n            return options.dayMinWidth\n                ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth)\n                : this.renderSimpleLayout(headerContent, bodyContent);\n        };\n        return DayTableView;\n    }(TableView));\n    function buildDayTableModel(dateProfile, dateProfileGenerator) {\n        var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n        return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n    }\n\n    var TableDateProfileGenerator = /** @class */ (function (_super) {\n        __extends(TableDateProfileGenerator, _super);\n        function TableDateProfileGenerator() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        // Computes the date range that will be rendered.\n        TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n            var dateEnv = this.props.dateEnv;\n            var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n            var start = renderRange.start;\n            var end = renderRange.end;\n            var endOfWeek;\n            // year and month views should be aligned with weeks. this is already done for week\n            if (/^(year|month)$/.test(currentRangeUnit)) {\n                start = dateEnv.startOfWeek(start);\n                // make end-of-week if not already\n                endOfWeek = dateEnv.startOfWeek(end);\n                if (endOfWeek.valueOf() !== end.valueOf()) {\n                    end = addWeeks(endOfWeek, 1);\n                }\n            }\n            // ensure 6 weeks\n            if (this.props.monthMode &&\n                this.props.fixedWeekCount) {\n                var rowCnt = Math.ceil(// could be partial weeks due to hiddenDays\n                diffWeeks(start, end));\n                end = addWeeks(end, 6 - rowCnt);\n            }\n            return { start: start, end: end };\n        };\n        return TableDateProfileGenerator;\n    }(DateProfileGenerator));\n\n    var OPTION_REFINERS$1 = {\n        moreLinkClick: identity,\n        moreLinkClassNames: identity,\n        moreLinkContent: identity,\n        moreLinkDidMount: identity,\n        moreLinkWillUnmount: identity,\n    };\n\n    var dayGridPlugin = createPlugin({\n        initialView: 'dayGridMonth',\n        optionRefiners: OPTION_REFINERS$1,\n        views: {\n            dayGrid: {\n                component: DayTableView,\n                dateProfileGeneratorClass: TableDateProfileGenerator,\n            },\n            dayGridDay: {\n                type: 'dayGrid',\n                duration: { days: 1 },\n            },\n            dayGridWeek: {\n                type: 'dayGrid',\n                duration: { weeks: 1 },\n            },\n            dayGridMonth: {\n                type: 'dayGrid',\n                duration: { months: 1 },\n                monthMode: true,\n                fixedWeekCount: true,\n            },\n        },\n    });\n\n    var AllDaySplitter = /** @class */ (function (_super) {\n        __extends(AllDaySplitter, _super);\n        function AllDaySplitter() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        AllDaySplitter.prototype.getKeyInfo = function () {\n            return {\n                allDay: {},\n                timed: {},\n            };\n        };\n        AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n            if (dateSpan.allDay) {\n                return ['allDay'];\n            }\n            return ['timed'];\n        };\n        AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n            if (!eventDef.allDay) {\n                return ['timed'];\n            }\n            if (hasBgRendering(eventDef)) {\n                return ['timed', 'allDay'];\n            }\n            return ['allDay'];\n        };\n        return AllDaySplitter;\n    }(Splitter));\n\n    var DEFAULT_SLAT_LABEL_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'short',\n    });\n    function TimeColsAxisCell(props) {\n        var classNames = [\n            'fc-timegrid-slot',\n            'fc-timegrid-slot-label',\n            props.isLabeled ? 'fc-scrollgrid-shrink' : 'fc-timegrid-slot-minor',\n        ];\n        return (createElement(ViewContextType.Consumer, null, function (context) {\n            if (!props.isLabeled) {\n                return (createElement(\"td\", { className: classNames.join(' '), \"data-time\": props.isoTimeStr }));\n            }\n            var dateEnv = context.dateEnv, options = context.options, viewApi = context.viewApi;\n            var labelFormat = // TODO: fully pre-parse\n             options.slotLabelFormat == null ? DEFAULT_SLAT_LABEL_FORMAT :\n                Array.isArray(options.slotLabelFormat) ? createFormatter(options.slotLabelFormat[0]) :\n                    createFormatter(options.slotLabelFormat);\n            var hookProps = {\n                level: 0,\n                time: props.time,\n                date: dateEnv.toDate(props.date),\n                view: viewApi,\n                text: dateEnv.format(props.date, labelFormat),\n            };\n            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.slotLabelClassNames, content: options.slotLabelContent, defaultContent: renderInnerContent$3, didMount: options.slotLabelDidMount, willUnmount: options.slotLabelWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement(\"td\", { ref: rootElRef, className: classNames.concat(customClassNames).join(' '), \"data-time\": props.isoTimeStr },\n                createElement(\"div\", { className: \"fc-timegrid-slot-label-frame fc-scrollgrid-shrink-frame\" },\n                    createElement(\"div\", { className: \"fc-timegrid-slot-label-cushion fc-scrollgrid-shrink-cushion\", ref: innerElRef }, innerContent)))); }));\n        }));\n    }\n    function renderInnerContent$3(props) {\n        return props.text;\n    }\n\n    var TimeBodyAxis = /** @class */ (function (_super) {\n        __extends(TimeBodyAxis, _super);\n        function TimeBodyAxis() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TimeBodyAxis.prototype.render = function () {\n            return this.props.slatMetas.map(function (slatMeta) { return (createElement(\"tr\", { key: slatMeta.key },\n                createElement(TimeColsAxisCell, __assign({}, slatMeta)))); });\n        };\n        return TimeBodyAxis;\n    }(BaseComponent));\n\n    var DEFAULT_WEEK_NUM_FORMAT$1 = createFormatter({ week: 'short' });\n    var AUTO_ALL_DAY_MAX_EVENT_ROWS = 5;\n    var TimeColsView = /** @class */ (function (_super) {\n        __extends(TimeColsView, _super);\n        function TimeColsView() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.allDaySplitter = new AllDaySplitter(); // for use by subclasses\n            _this.headerElRef = createRef();\n            _this.rootElRef = createRef();\n            _this.scrollerElRef = createRef();\n            _this.state = {\n                slatCoords: null,\n            };\n            _this.handleScrollTopRequest = function (scrollTop) {\n                var scrollerEl = _this.scrollerElRef.current;\n                if (scrollerEl) { // TODO: not sure how this could ever be null. weirdness with the reducer\n                    scrollerEl.scrollTop = scrollTop;\n                }\n            };\n            /* Header Render Methods\n            ------------------------------------------------------------------------------------------------------------------*/\n            _this.renderHeadAxis = function (frameHeight) {\n                if (frameHeight === void 0) { frameHeight = ''; }\n                var options = _this.context.options;\n                var dateProfile = _this.props.dateProfile;\n                var range = dateProfile.renderRange;\n                var dayCnt = diffDays(range.start, range.end);\n                var navLinkAttrs = (options.navLinks && dayCnt === 1) // only do in day views (to avoid doing in week views that dont need it)\n                    ? { 'data-navlink': buildNavLinkData(range.start, 'week'), tabIndex: 0 }\n                    : {};\n                if (options.weekNumbers) {\n                    return (createElement(WeekNumberRoot, { date: range.start, defaultFormat: DEFAULT_WEEK_NUM_FORMAT$1 }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"th\", { ref: rootElRef, className: [\n                            'fc-timegrid-axis',\n                            'fc-scrollgrid-shrink',\n                        ].concat(classNames).join(' ') },\n                        createElement(\"div\", { className: \"fc-timegrid-axis-frame fc-scrollgrid-shrink-frame fc-timegrid-axis-frame-liquid\", style: { height: frameHeight } },\n                            createElement(\"a\", __assign({ ref: innerElRef, className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\" }, navLinkAttrs), innerContent)))); }));\n                }\n                return (createElement(\"th\", { className: \"fc-timegrid-axis\" },\n                    createElement(\"div\", { className: \"fc-timegrid-axis-frame\", style: { height: frameHeight } })));\n            };\n            /* Table Component Render Methods\n            ------------------------------------------------------------------------------------------------------------------*/\n            // only a one-way height sync. we don't send the axis inner-content height to the DayGrid,\n            // but DayGrid still needs to have classNames on inner elements in order to measure.\n            _this.renderTableRowAxis = function (rowHeight) {\n                var _a = _this.context, options = _a.options, viewApi = _a.viewApi;\n                var hookProps = {\n                    text: options.allDayText,\n                    view: viewApi,\n                };\n                return (\n                // TODO: make reusable hook. used in list view too\n                createElement(RenderHook, { hookProps: hookProps, classNames: options.allDayClassNames, content: options.allDayContent, defaultContent: renderAllDayInner, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"td\", { ref: rootElRef, className: [\n                        'fc-timegrid-axis',\n                        'fc-scrollgrid-shrink',\n                    ].concat(classNames).join(' ') },\n                    createElement(\"div\", { className: 'fc-timegrid-axis-frame fc-scrollgrid-shrink-frame' + (rowHeight == null ? ' fc-timegrid-axis-frame-liquid' : ''), style: { height: rowHeight } },\n                        createElement(\"span\", { className: \"fc-timegrid-axis-cushion fc-scrollgrid-shrink-cushion fc-scrollgrid-sync-inner\", ref: innerElRef }, innerContent)))); }));\n            };\n            _this.handleSlatCoords = function (slatCoords) {\n                _this.setState({ slatCoords: slatCoords });\n            };\n            return _this;\n        }\n        // rendering\n        // ----------------------------------------------------------------------------------------------------\n        TimeColsView.prototype.renderSimpleLayout = function (headerRowContent, allDayContent, timeContent) {\n            var _a = this, context = _a.context, props = _a.props;\n            var sections = [];\n            var stickyHeaderDates = getStickyHeaderDates(context.options);\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    chunk: {\n                        elRef: this.headerElRef,\n                        tableClassName: 'fc-col-header',\n                        rowContent: headerRowContent,\n                    },\n                });\n            }\n            if (allDayContent) {\n                sections.push({\n                    type: 'body',\n                    key: 'all-day',\n                    chunk: { content: allDayContent },\n                });\n                sections.push({\n                    type: 'body',\n                    key: 'all-day-divider',\n                    outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n                    createElement(\"tr\", { className: \"fc-scrollgrid-section\" },\n                        createElement(\"td\", { className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),\n                });\n            }\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                expandRows: Boolean(context.options.expandRows),\n                chunk: {\n                    scrollerElRef: this.scrollerElRef,\n                    content: timeContent,\n                },\n            });\n            return (createElement(ViewRoot, { viewSpec: context.viewSpec, elRef: this.rootElRef }, function (rootElRef, classNames) { return (createElement(\"div\", { className: ['fc-timegrid'].concat(classNames).join(' '), ref: rootElRef },\n                createElement(SimpleScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, cols: [{ width: 'shrink' }], sections: sections }))); }));\n        };\n        TimeColsView.prototype.renderHScrollLayout = function (headerRowContent, allDayContent, timeContent, colCnt, dayMinWidth, slatMetas, slatCoords) {\n            var _this = this;\n            var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n            if (!ScrollGrid) {\n                throw new Error('No ScrollGrid implementation');\n            }\n            var _a = this, context = _a.context, props = _a.props;\n            var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n            var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n            var sections = [];\n            if (headerRowContent) {\n                sections.push({\n                    type: 'header',\n                    key: 'header',\n                    isSticky: stickyHeaderDates,\n                    syncRowHeights: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            rowContent: function (arg) { return (createElement(\"tr\", null, _this.renderHeadAxis(arg.rowSyncHeights[0]))); },\n                        },\n                        {\n                            key: 'cols',\n                            elRef: this.headerElRef,\n                            tableClassName: 'fc-col-header',\n                            rowContent: headerRowContent,\n                        },\n                    ],\n                });\n            }\n            if (allDayContent) {\n                sections.push({\n                    type: 'body',\n                    key: 'all-day',\n                    syncRowHeights: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            rowContent: function (contentArg) { return (createElement(\"tr\", null, _this.renderTableRowAxis(contentArg.rowSyncHeights[0]))); },\n                        },\n                        {\n                            key: 'cols',\n                            content: allDayContent,\n                        },\n                    ],\n                });\n                sections.push({\n                    key: 'all-day-divider',\n                    type: 'body',\n                    outerContent: ( // TODO: rename to cellContent so don't need to define <tr>?\n                    createElement(\"tr\", { className: \"fc-scrollgrid-section\" },\n                        createElement(\"td\", { colSpan: 2, className: 'fc-timegrid-divider ' + context.theme.getClass('tableCellShaded') }))),\n                });\n            }\n            var isNowIndicator = context.options.nowIndicator;\n            sections.push({\n                type: 'body',\n                key: 'body',\n                liquid: true,\n                expandRows: Boolean(context.options.expandRows),\n                chunks: [\n                    {\n                        key: 'axis',\n                        content: function (arg) { return (\n                        // TODO: make this now-indicator arrow more DRY with TimeColsContent\n                        createElement(\"div\", { className: \"fc-timegrid-axis-chunk\" },\n                            createElement(\"table\", { style: { height: arg.expandRows ? arg.clientHeight : '' } },\n                                arg.tableColGroupNode,\n                                createElement(\"tbody\", null,\n                                    createElement(TimeBodyAxis, { slatMetas: slatMetas }))),\n                            createElement(\"div\", { className: \"fc-timegrid-now-indicator-container\" },\n                                createElement(NowTimer, { unit: isNowIndicator ? 'minute' : 'day' /* hacky */ }, function (nowDate) {\n                                    var nowIndicatorTop = isNowIndicator &&\n                                        slatCoords &&\n                                        slatCoords.safeComputeTop(nowDate); // might return void\n                                    if (typeof nowIndicatorTop === 'number') {\n                                        return (createElement(NowIndicatorRoot, { isAxis: true, date: nowDate }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"div\", { ref: rootElRef, className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '), style: { top: nowIndicatorTop } }, innerContent)); }));\n                                    }\n                                    return null;\n                                })))); },\n                    },\n                    {\n                        key: 'cols',\n                        scrollerElRef: this.scrollerElRef,\n                        content: timeContent,\n                    },\n                ],\n            });\n            if (stickyFooterScrollbar) {\n                sections.push({\n                    key: 'footer',\n                    type: 'footer',\n                    isSticky: true,\n                    chunks: [\n                        {\n                            key: 'axis',\n                            content: renderScrollShim,\n                        },\n                        {\n                            key: 'cols',\n                            content: renderScrollShim,\n                        },\n                    ],\n                });\n            }\n            return (createElement(ViewRoot, { viewSpec: context.viewSpec, elRef: this.rootElRef }, function (rootElRef, classNames) { return (createElement(\"div\", { className: ['fc-timegrid'].concat(classNames).join(' '), ref: rootElRef },\n                createElement(ScrollGrid, { liquid: !props.isHeightAuto && !props.forPrint, colGroups: [\n                        { width: 'shrink', cols: [{ width: 'shrink' }] },\n                        { cols: [{ span: colCnt, minWidth: dayMinWidth }] },\n                    ], sections: sections }))); }));\n        };\n        /* Dimensions\n        ------------------------------------------------------------------------------------------------------------------*/\n        TimeColsView.prototype.getAllDayMaxEventProps = function () {\n            var _a = this.context.options, dayMaxEvents = _a.dayMaxEvents, dayMaxEventRows = _a.dayMaxEventRows;\n            if (dayMaxEvents === true || dayMaxEventRows === true) { // is auto?\n                dayMaxEvents = undefined;\n                dayMaxEventRows = AUTO_ALL_DAY_MAX_EVENT_ROWS; // make sure \"auto\" goes to a real number\n            }\n            return { dayMaxEvents: dayMaxEvents, dayMaxEventRows: dayMaxEventRows };\n        };\n        return TimeColsView;\n    }(DateComponent));\n    function renderAllDayInner(hookProps) {\n        return hookProps.text;\n    }\n\n    var TimeColsSlatsCoords = /** @class */ (function () {\n        function TimeColsSlatsCoords(positions, dateProfile, slatMetas) {\n            this.positions = positions;\n            this.dateProfile = dateProfile;\n            this.slatMetas = slatMetas;\n        }\n        TimeColsSlatsCoords.prototype.safeComputeTop = function (date) {\n            var dateProfile = this.dateProfile;\n            if (rangeContainsMarker(dateProfile.currentRange, date)) {\n                var startOfDayDate = startOfDay(date);\n                var timeMs = date.valueOf() - startOfDayDate.valueOf();\n                if (timeMs >= asRoughMs(dateProfile.slotMinTime) &&\n                    timeMs < asRoughMs(dateProfile.slotMaxTime)) {\n                    return this.computeTimeTop(createDuration(timeMs));\n                }\n            }\n            return null;\n        };\n        // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n        // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n        TimeColsSlatsCoords.prototype.computeDateTop = function (when, startOfDayDate) {\n            if (!startOfDayDate) {\n                startOfDayDate = startOfDay(when);\n            }\n            return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n        };\n        // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n        // This is a makeshify way to compute the time-top. Assumes all slatMetas dates are uniform.\n        // Eventually allow computation with arbirary slat dates.\n        TimeColsSlatsCoords.prototype.computeTimeTop = function (duration) {\n            var _a = this, positions = _a.positions, dateProfile = _a.dateProfile, slatMetas = _a.slatMetas;\n            var len = positions.els.length;\n            // we assume dates are uniform\n            var slotDurationMs = slatMetas[1].date.valueOf() - slatMetas[0].date.valueOf();\n            // floating-point value of # of slots covered\n            var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.slotMinTime)) / slotDurationMs;\n            var slatIndex;\n            var slatRemainder;\n            // compute a floating-point number for how many slats should be progressed through.\n            // from 0 to number of slats (inclusive)\n            // constrained because slotMinTime/slotMaxTime might be customized.\n            slatCoverage = Math.max(0, slatCoverage);\n            slatCoverage = Math.min(len, slatCoverage);\n            // an integer index of the furthest whole slat\n            // from 0 to number slats (*exclusive*, so len-1)\n            slatIndex = Math.floor(slatCoverage);\n            slatIndex = Math.min(slatIndex, len - 1);\n            // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n            // could be 1.0 if slatCoverage is covering *all* the slots\n            slatRemainder = slatCoverage - slatIndex;\n            return positions.tops[slatIndex] +\n                positions.getHeight(slatIndex) * slatRemainder;\n        };\n        return TimeColsSlatsCoords;\n    }());\n\n    var TimeColsSlatsBody = /** @class */ (function (_super) {\n        __extends(TimeColsSlatsBody, _super);\n        function TimeColsSlatsBody() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TimeColsSlatsBody.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var options = context.options;\n            var slatElRefs = props.slatElRefs;\n            return (createElement(\"tbody\", null, props.slatMetas.map(function (slatMeta, i) {\n                var hookProps = {\n                    time: slatMeta.time,\n                    date: context.dateEnv.toDate(slatMeta.date),\n                    view: context.viewApi,\n                };\n                var classNames = [\n                    'fc-timegrid-slot',\n                    'fc-timegrid-slot-lane',\n                    slatMeta.isLabeled ? '' : 'fc-timegrid-slot-minor',\n                ];\n                return (createElement(\"tr\", { key: slatMeta.key, ref: slatElRefs.createRef(slatMeta.key) },\n                    props.axis && (createElement(TimeColsAxisCell, __assign({}, slatMeta))),\n                    createElement(RenderHook, { hookProps: hookProps, classNames: options.slotLaneClassNames, content: options.slotLaneContent, didMount: options.slotLaneDidMount, willUnmount: options.slotLaneWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement(\"td\", { ref: rootElRef, className: classNames.concat(customClassNames).join(' '), \"data-time\": slatMeta.isoTimeStr }, innerContent)); })));\n            })));\n        };\n        return TimeColsSlatsBody;\n    }(BaseComponent));\n\n    /*\n    for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n    */\n    var TimeColsSlats = /** @class */ (function (_super) {\n        __extends(TimeColsSlats, _super);\n        function TimeColsSlats() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.rootElRef = createRef();\n            _this.slatElRefs = new RefMap();\n            return _this;\n        }\n        TimeColsSlats.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            return (createElement(\"div\", { className: \"fc-timegrid-slots\", ref: this.rootElRef },\n                createElement(\"table\", { className: context.theme.getClass('table'), style: {\n                        minWidth: props.tableMinWidth,\n                        width: props.clientWidth,\n                        height: props.minHeight,\n                    } },\n                    props.tableColGroupNode /* relies on there only being a single <col> for the axis */,\n                    createElement(TimeColsSlatsBody, { slatElRefs: this.slatElRefs, axis: props.axis, slatMetas: props.slatMetas }))));\n        };\n        TimeColsSlats.prototype.componentDidMount = function () {\n            this.updateSizing();\n        };\n        TimeColsSlats.prototype.componentDidUpdate = function () {\n            this.updateSizing();\n        };\n        TimeColsSlats.prototype.componentWillUnmount = function () {\n            if (this.props.onCoords) {\n                this.props.onCoords(null);\n            }\n        };\n        TimeColsSlats.prototype.updateSizing = function () {\n            var props = this.props;\n            if (props.onCoords &&\n                props.clientWidth !== null // means sizing has stabilized\n            ) {\n                var rootEl = this.rootElRef.current;\n                if (rootEl.offsetHeight) { // not hidden by css\n                    props.onCoords(new TimeColsSlatsCoords(new PositionCache(this.rootElRef.current, collectSlatEls(this.slatElRefs.currentMap, props.slatMetas), false, true), this.props.dateProfile, props.slatMetas));\n                }\n            }\n        };\n        return TimeColsSlats;\n    }(BaseComponent));\n    function collectSlatEls(elMap, slatMetas) {\n        return slatMetas.map(function (slatMeta) { return elMap[slatMeta.key]; });\n    }\n\n    function splitSegsByCol(segs, colCnt) {\n        var segsByCol = [];\n        var i;\n        for (i = 0; i < colCnt; i += 1) {\n            segsByCol.push([]);\n        }\n        if (segs) {\n            for (i = 0; i < segs.length; i += 1) {\n                segsByCol[segs[i].col].push(segs[i]);\n            }\n        }\n        return segsByCol;\n    }\n    function splitInteractionByCol(ui, colCnt) {\n        var byRow = [];\n        if (!ui) {\n            for (var i = 0; i < colCnt; i += 1) {\n                byRow[i] = null;\n            }\n        }\n        else {\n            for (var i = 0; i < colCnt; i += 1) {\n                byRow[i] = {\n                    affectedInstances: ui.affectedInstances,\n                    isEvent: ui.isEvent,\n                    segs: [],\n                };\n            }\n            for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n                var seg = _a[_i];\n                byRow[seg.col].segs.push(seg);\n            }\n        }\n        return byRow;\n    }\n\n    // UNFORTUNATELY, assigns results to the top/bottom/level/forwardCoord/backwardCoord props of the actual segs.\n    // TODO: return hash (by instanceId) of results\n    function computeSegCoords(segs, dayDate, slatCoords, eventMinHeight, eventOrderSpecs) {\n        computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight);\n        return computeSegHorizontals(segs, eventOrderSpecs); // requires top/bottom from computeSegVerticals\n    }\n    // For each segment in an array, computes and assigns its top and bottom properties\n    function computeSegVerticals(segs, dayDate, slatCoords, eventMinHeight) {\n        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n            var seg = segs_1[_i];\n            seg.top = slatCoords.computeDateTop(seg.start, dayDate);\n            seg.bottom = Math.max(seg.top + (eventMinHeight || 0), // yuck\n            slatCoords.computeDateTop(seg.end, dayDate));\n        }\n    }\n    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n    // Assumed the segs are already ordered.\n    // NOTE: Also reorders the given array by date!\n    function computeSegHorizontals(segs, eventOrderSpecs) {\n        // IMPORTANT TO CLEAR OLD RESULTS :(\n        for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n            var seg = segs_2[_i];\n            seg.level = null;\n            seg.forwardCoord = null;\n            seg.backwardCoord = null;\n            seg.forwardPressure = null;\n        }\n        segs = sortEventSegs(segs, eventOrderSpecs);\n        var level0;\n        var levels = buildSlotSegLevels(segs);\n        computeForwardSlotSegs(levels);\n        if ((level0 = levels[0])) {\n            for (var _a = 0, level0_1 = level0; _a < level0_1.length; _a++) {\n                var seg = level0_1[_a];\n                computeSlotSegPressures(seg);\n            }\n            for (var _b = 0, level0_2 = level0; _b < level0_2.length; _b++) {\n                var seg = level0_2[_b];\n                computeSegForwardBack(seg, 0, 0, eventOrderSpecs);\n            }\n        }\n        return segs;\n    }\n    // Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n    // left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\n    function buildSlotSegLevels(segs) {\n        var levels = [];\n        var i;\n        var seg;\n        var j;\n        for (i = 0; i < segs.length; i += 1) {\n            seg = segs[i];\n            // go through all the levels and stop on the first level where there are no collisions\n            for (j = 0; j < levels.length; j += 1) {\n                if (!computeSlotSegCollisions(seg, levels[j]).length) {\n                    break;\n                }\n            }\n            seg.level = j;\n            (levels[j] || (levels[j] = [])).push(seg);\n        }\n        return levels;\n    }\n    // Find all the segments in `otherSegs` that vertically collide with `seg`.\n    // Append into an optionally-supplied `results` array and return.\n    function computeSlotSegCollisions(seg, otherSegs, results) {\n        if (results === void 0) { results = []; }\n        for (var i = 0; i < otherSegs.length; i += 1) {\n            if (isSlotSegCollision(seg, otherSegs[i])) {\n                results.push(otherSegs[i]);\n            }\n        }\n        return results;\n    }\n    // Do these segments occupy the same vertical space?\n    function isSlotSegCollision(seg1, seg2) {\n        return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n    }\n    // For every segment, figure out the other segments that are in subsequent\n    // levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\n    function computeForwardSlotSegs(levels) {\n        var i;\n        var level;\n        var j;\n        var seg;\n        var k;\n        for (i = 0; i < levels.length; i += 1) {\n            level = levels[i];\n            for (j = 0; j < level.length; j += 1) {\n                seg = level[j];\n                seg.forwardSegs = [];\n                for (k = i + 1; k < levels.length; k += 1) {\n                    computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n                }\n            }\n        }\n    }\n    // Figure out which path forward (via seg.forwardSegs) results in the longest path until\n    // the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\n    function computeSlotSegPressures(seg) {\n        var forwardSegs = seg.forwardSegs;\n        var forwardPressure = 0;\n        var i;\n        var forwardSeg;\n        if (seg.forwardPressure == null) { // not already computed\n            for (i = 0; i < forwardSegs.length; i += 1) {\n                forwardSeg = forwardSegs[i];\n                // figure out the child's maximum forward path\n                computeSlotSegPressures(forwardSeg);\n                // either use the existing maximum, or use the child's forward pressure\n                // plus one (for the forwardSeg itself)\n                forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\n            }\n            seg.forwardPressure = forwardPressure;\n        }\n    }\n    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n    // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n    //\n    // The segment might be part of a \"series\", which means consecutive segments with the same pressure\n    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n    // coordinate of the first segment in the series.\n    function computeSegForwardBack(seg, seriesBackwardPressure, seriesBackwardCoord, eventOrderSpecs) {\n        var forwardSegs = seg.forwardSegs;\n        var i;\n        if (seg.forwardCoord == null) { // not already computed\n            if (!forwardSegs.length) {\n                // if there are no forward segments, this segment should butt up against the edge\n                seg.forwardCoord = 1;\n            }\n            else {\n                // sort highest pressure first\n                sortForwardSegs(forwardSegs, eventOrderSpecs);\n                // this segment's forwardCoord will be calculated from the backwardCoord of the\n                // highest-pressure forward segment.\n                computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord, eventOrderSpecs);\n                seg.forwardCoord = forwardSegs[0].backwardCoord;\n            }\n            // calculate the backwardCoord from the forwardCoord. consider the series\n            seg.backwardCoord = seg.forwardCoord -\n                (seg.forwardCoord - seriesBackwardCoord) / // available width for series\n                    (seriesBackwardPressure + 1); // # of segments in the series\n            // use this segment's coordinates to computed the coordinates of the less-pressurized\n            // forward segments\n            for (i = 0; i < forwardSegs.length; i += 1) {\n                computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord, eventOrderSpecs);\n            }\n        }\n    }\n    function sortForwardSegs(forwardSegs, eventOrderSpecs) {\n        var objs = forwardSegs.map(buildTimeGridSegCompareObj);\n        var specs = [\n            // put higher-pressure first\n            { field: 'forwardPressure', order: -1 },\n            // put segments that are closer to initial edge first (and favor ones with no coords yet)\n            { field: 'backwardCoord', order: 1 },\n        ].concat(eventOrderSpecs);\n        objs.sort(function (obj0, obj1) { return compareByFieldSpecs(obj0, obj1, specs); });\n        return objs.map(function (c) { return c._seg; });\n    }\n    function buildTimeGridSegCompareObj(seg) {\n        var obj = buildSegCompareObj(seg);\n        obj.forwardPressure = seg.forwardPressure;\n        obj.backwardCoord = seg.backwardCoord;\n        return obj;\n    }\n\n    var DEFAULT_TIME_FORMAT = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        meridiem: false,\n    });\n    var TimeColEvent = /** @class */ (function (_super) {\n        __extends(TimeColEvent, _super);\n        function TimeColEvent() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TimeColEvent.prototype.render = function () {\n            var classNames = [\n                'fc-timegrid-event',\n                'fc-v-event',\n            ];\n            if (this.props.isCondensed) {\n                classNames.push('fc-timegrid-event-condensed');\n            }\n            return (createElement(StandardEvent, __assign({}, this.props, { defaultTimeFormat: DEFAULT_TIME_FORMAT, extraClassNames: classNames })));\n        };\n        return TimeColEvent;\n    }(BaseComponent));\n\n    var TimeColMisc = /** @class */ (function (_super) {\n        __extends(TimeColMisc, _super);\n        function TimeColMisc() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TimeColMisc.prototype.render = function () {\n            var props = this.props;\n            return (createElement(DayCellContent, { date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraHookProps: props.extraHookProps }, function (innerElRef, innerContent) { return (innerContent &&\n                createElement(\"div\", { className: \"fc-timegrid-col-misc\", ref: innerElRef }, innerContent)); }));\n        };\n        return TimeColMisc;\n    }(BaseComponent));\n\n    config.timeGridEventCondensedHeight = 30;\n    var TimeCol = /** @class */ (function (_super) {\n        __extends(TimeCol, _super);\n        function TimeCol() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        TimeCol.prototype.render = function () {\n            var _this = this;\n            var _a = this, props = _a.props, context = _a.context;\n            var isSelectMirror = context.options.selectMirror;\n            var mirrorSegs = (props.eventDrag && props.eventDrag.segs) ||\n                (props.eventResize && props.eventResize.segs) ||\n                (isSelectMirror && props.dateSelectionSegs) ||\n                [];\n            var interactionAffectedInstances = // TODO: messy way to compute this\n             (props.eventDrag && props.eventDrag.affectedInstances) ||\n                (props.eventResize && props.eventResize.affectedInstances) ||\n                {};\n            return (createElement(DayCellRoot, { elRef: props.elRef, date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraHookProps: props.extraHookProps }, function (rootElRef, classNames, dataAttrs) { return (createElement(\"td\", __assign({ ref: rootElRef, className: ['fc-timegrid-col'].concat(classNames, props.extraClassNames || []).join(' ') }, dataAttrs, props.extraDataAttrs),\n                createElement(\"div\", { className: \"fc-timegrid-col-frame\" },\n                    createElement(\"div\", { className: \"fc-timegrid-col-bg\" },\n                        _this.renderFillSegs(props.businessHourSegs, 'non-business'),\n                        _this.renderFillSegs(props.bgEventSegs, 'bg-event'),\n                        _this.renderFillSegs(props.dateSelectionSegs, 'highlight')),\n                    createElement(\"div\", { className: \"fc-timegrid-col-events\" }, _this.renderFgSegs(props.fgEventSegs, interactionAffectedInstances)),\n                    createElement(\"div\", { className: \"fc-timegrid-col-events\" }, _this.renderFgSegs(mirrorSegs, {}, Boolean(props.eventDrag), Boolean(props.eventResize), Boolean(isSelectMirror))),\n                    createElement(\"div\", { className: \"fc-timegrid-now-indicator-container\" }, _this.renderNowIndicator(props.nowIndicatorSegs)),\n                    createElement(TimeColMisc, { date: props.date, dateProfile: props.dateProfile, todayRange: props.todayRange, extraHookProps: props.extraHookProps })))); }));\n        };\n        TimeCol.prototype.renderFgSegs = function (segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n            var props = this.props;\n            if (props.forPrint) {\n                return this.renderPrintFgSegs(segs);\n            }\n            if (props.slatCoords) {\n                return this.renderPositionedFgSegs(segs, segIsInvisible, isDragging, isResizing, isDateSelecting);\n            }\n            return null;\n        };\n        TimeCol.prototype.renderPrintFgSegs = function (segs) {\n            var _a = this, props = _a.props, context = _a.context;\n            // not DRY\n            segs = sortEventSegs(segs, context.options.eventOrder);\n            return segs.map(function (seg) { return (createElement(\"div\", { className: \"fc-timegrid-event-harness\", key: seg.eventRange.instance.instanceId },\n                createElement(TimeColEvent, __assign({ seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false, isCondensed: false }, getSegMeta(seg, props.todayRange, props.nowDate))))); });\n        };\n        TimeCol.prototype.renderPositionedFgSegs = function (segs, segIsInvisible, isDragging, isResizing, isDateSelecting) {\n            var _this = this;\n            var _a = this, context = _a.context, props = _a.props;\n            // assigns TO THE SEGS THEMSELVES\n            // also, receives resorted array\n            segs = computeSegCoords(segs, props.date, props.slatCoords, context.options.eventMinHeight, context.options.eventOrder);\n            return segs.map(function (seg) {\n                var instanceId = seg.eventRange.instance.instanceId;\n                var isMirror = isDragging || isResizing || isDateSelecting;\n                var positionCss = isMirror\n                    // will span entire column width\n                    // also, won't assign z-index, which is good, fc-event-mirror will overpower other harnesses\n                    ? __assign({ left: 0, right: 0 }, _this.computeSegTopBottomCss(seg)) : _this.computeFgSegPositionCss(seg);\n                return (createElement(\"div\", { className: 'fc-timegrid-event-harness' + (seg.level > 0 ? ' fc-timegrid-event-harness-inset' : ''), key: instanceId, style: __assign({ visibility: segIsInvisible[instanceId] ? 'hidden' : '' }, positionCss) },\n                    createElement(TimeColEvent, __assign({ seg: seg, isDragging: isDragging, isResizing: isResizing, isDateSelecting: isDateSelecting, isSelected: instanceId === props.eventSelection, isCondensed: (seg.bottom - seg.top) < config.timeGridEventCondensedHeight }, getSegMeta(seg, props.todayRange, props.nowDate)))));\n            });\n        };\n        TimeCol.prototype.renderFillSegs = function (segs, fillType) {\n            var _this = this;\n            var _a = this, context = _a.context, props = _a.props;\n            if (!props.slatCoords) {\n                return null;\n            }\n            // BAD: assigns TO THE SEGS THEMSELVES\n            computeSegVerticals(segs, props.date, props.slatCoords, context.options.eventMinHeight);\n            var children = segs.map(function (seg) { return (createElement(\"div\", { key: buildEventRangeKey(seg.eventRange), className: \"fc-timegrid-bg-harness\", style: _this.computeSegTopBottomCss(seg) }, fillType === 'bg-event' ?\n                createElement(BgEvent, __assign({ seg: seg }, getSegMeta(seg, props.todayRange, props.nowDate))) :\n                renderFill(fillType))); });\n            return createElement(Fragment, null, children);\n        };\n        TimeCol.prototype.renderNowIndicator = function (segs) {\n            var _a = this.props, slatCoords = _a.slatCoords, date = _a.date;\n            if (!slatCoords) {\n                return null;\n            }\n            return segs.map(function (seg, i) { return (createElement(NowIndicatorRoot, { isAxis: false, date: date, \n                // key doesn't matter. will only ever be one\n                key: i }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"div\", { ref: rootElRef, className: ['fc-timegrid-now-indicator-line'].concat(classNames).join(' '), style: { top: slatCoords.computeDateTop(seg.start, date) } }, innerContent)); })); });\n        };\n        TimeCol.prototype.computeFgSegPositionCss = function (seg) {\n            var _a = this.context, isRtl = _a.isRtl, options = _a.options;\n            var shouldOverlap = options.slotEventOverlap;\n            var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n            var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n            var left; // amount of space from left edge, a fraction of the total width\n            var right; // amount of space from right edge, a fraction of the total width\n            if (shouldOverlap) {\n                // double the width, but don't go beyond the maximum forward coordinate (1.0)\n                forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n            }\n            if (isRtl) {\n                left = 1 - forwardCoord;\n                right = backwardCoord;\n            }\n            else {\n                left = backwardCoord;\n                right = 1 - forwardCoord;\n            }\n            var props = {\n                zIndex: seg.level + 1,\n                left: left * 100 + '%',\n                right: right * 100 + '%',\n            };\n            if (shouldOverlap && seg.forwardPressure) {\n                // add padding to the edge so that forward stacked events don't cover the resizer's icon\n                props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n            }\n            return __assign(__assign({}, props), this.computeSegTopBottomCss(seg));\n        };\n        TimeCol.prototype.computeSegTopBottomCss = function (seg) {\n            return {\n                top: seg.top,\n                bottom: -seg.bottom,\n            };\n        };\n        return TimeCol;\n    }(BaseComponent));\n\n    var TimeColsContent = /** @class */ (function (_super) {\n        __extends(TimeColsContent, _super);\n        function TimeColsContent() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.splitFgEventSegs = memoize(splitSegsByCol);\n            _this.splitBgEventSegs = memoize(splitSegsByCol);\n            _this.splitBusinessHourSegs = memoize(splitSegsByCol);\n            _this.splitNowIndicatorSegs = memoize(splitSegsByCol);\n            _this.splitDateSelectionSegs = memoize(splitSegsByCol);\n            _this.splitEventDrag = memoize(splitInteractionByCol);\n            _this.splitEventResize = memoize(splitInteractionByCol);\n            _this.rootElRef = createRef();\n            _this.cellElRefs = new RefMap();\n            return _this;\n        }\n        TimeColsContent.prototype.render = function () {\n            var _this = this;\n            var _a = this, props = _a.props, context = _a.context;\n            var nowIndicatorTop = context.options.nowIndicator &&\n                props.slatCoords &&\n                props.slatCoords.safeComputeTop(props.nowDate); // might return void\n            var colCnt = props.cells.length;\n            var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, colCnt);\n            var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, colCnt);\n            var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, colCnt);\n            var nowIndicatorSegsByRow = this.splitNowIndicatorSegs(props.nowIndicatorSegs, colCnt);\n            var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, colCnt);\n            var eventDragByRow = this.splitEventDrag(props.eventDrag, colCnt);\n            var eventResizeByRow = this.splitEventResize(props.eventResize, colCnt);\n            return (createElement(\"div\", { className: \"fc-timegrid-cols\", ref: this.rootElRef },\n                createElement(\"table\", { style: {\n                        minWidth: props.tableMinWidth,\n                        width: props.clientWidth,\n                    } },\n                    props.tableColGroupNode,\n                    createElement(\"tbody\", null,\n                        createElement(\"tr\", null,\n                            props.axis && (createElement(\"td\", { className: \"fc-timegrid-col fc-timegrid-axis\" },\n                                createElement(\"div\", { className: \"fc-timegrid-col-frame\" },\n                                    createElement(\"div\", { className: \"fc-timegrid-now-indicator-container\" }, typeof nowIndicatorTop === 'number' && (createElement(NowIndicatorRoot, { isAxis: true, date: props.nowDate }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"div\", { ref: rootElRef, className: ['fc-timegrid-now-indicator-arrow'].concat(classNames).join(' '), style: { top: nowIndicatorTop } }, innerContent)); })))))),\n                            props.cells.map(function (cell, i) { return (createElement(TimeCol, { key: cell.key, elRef: _this.cellElRefs.createRef(cell.key), dateProfile: props.dateProfile, date: cell.date, nowDate: props.nowDate, todayRange: props.todayRange, extraHookProps: cell.extraHookProps, extraDataAttrs: cell.extraDataAttrs, extraClassNames: cell.extraClassNames, fgEventSegs: fgEventSegsByRow[i], bgEventSegs: bgEventSegsByRow[i], businessHourSegs: businessHourSegsByRow[i], nowIndicatorSegs: nowIndicatorSegsByRow[i], dateSelectionSegs: dateSelectionSegsByRow[i], eventDrag: eventDragByRow[i], eventResize: eventResizeByRow[i], slatCoords: props.slatCoords, eventSelection: props.eventSelection, forPrint: props.forPrint })); }))))));\n        };\n        TimeColsContent.prototype.componentDidMount = function () {\n            this.updateCoords();\n        };\n        TimeColsContent.prototype.componentDidUpdate = function () {\n            this.updateCoords();\n        };\n        TimeColsContent.prototype.updateCoords = function () {\n            var props = this.props;\n            if (props.onColCoords &&\n                props.clientWidth !== null // means sizing has stabilized\n            ) {\n                props.onColCoords(new PositionCache(this.rootElRef.current, collectCellEls(this.cellElRefs.currentMap, props.cells), true, // horizontal\n                false));\n            }\n        };\n        return TimeColsContent;\n    }(BaseComponent));\n    function collectCellEls(elMap, cells) {\n        return cells.map(function (cell) { return elMap[cell.key]; });\n    }\n\n    /* A component that renders one or more columns of vertical time slots\n    ----------------------------------------------------------------------------------------------------------------------*/\n    var TimeCols = /** @class */ (function (_super) {\n        __extends(TimeCols, _super);\n        function TimeCols() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.processSlotOptions = memoize(processSlotOptions);\n            _this.state = {\n                slatCoords: null,\n            };\n            _this.handleScrollRequest = function (request) {\n                var onScrollTopRequest = _this.props.onScrollTopRequest;\n                var slatCoords = _this.state.slatCoords;\n                if (onScrollTopRequest && slatCoords) {\n                    if (request.time) {\n                        var top_1 = slatCoords.computeTimeTop(request.time);\n                        top_1 = Math.ceil(top_1); // zoom can give weird floating-point values. rather scroll a little bit further\n                        if (top_1) {\n                            top_1 += 1; // to overcome top border that slots beyond the first have. looks better\n                        }\n                        onScrollTopRequest(top_1);\n                    }\n                    return true;\n                }\n                return false;\n            };\n            _this.handleColCoords = function (colCoords) {\n                _this.colCoords = colCoords;\n            };\n            _this.handleSlatCoords = function (slatCoords) {\n                _this.setState({ slatCoords: slatCoords });\n                if (_this.props.onSlatCoords) {\n                    _this.props.onSlatCoords(slatCoords);\n                }\n            };\n            return _this;\n        }\n        TimeCols.prototype.render = function () {\n            var _a = this, props = _a.props, state = _a.state;\n            return (createElement(\"div\", { className: \"fc-timegrid-body\", ref: props.rootElRef, style: {\n                    // these props are important to give this wrapper correct dimensions for interactions\n                    // TODO: if we set it here, can we avoid giving to inner tables?\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                } },\n                createElement(TimeColsSlats, { axis: props.axis, dateProfile: props.dateProfile, slatMetas: props.slatMetas, clientWidth: props.clientWidth, minHeight: props.expandRows ? props.clientHeight : '', tableMinWidth: props.tableMinWidth, tableColGroupNode: props.axis ? props.tableColGroupNode : null /* axis depends on the colgroup's shrinking */, onCoords: this.handleSlatCoords }),\n                createElement(TimeColsContent, { cells: props.cells, axis: props.axis, dateProfile: props.dateProfile, businessHourSegs: props.businessHourSegs, bgEventSegs: props.bgEventSegs, fgEventSegs: props.fgEventSegs, dateSelectionSegs: props.dateSelectionSegs, eventSelection: props.eventSelection, eventDrag: props.eventDrag, eventResize: props.eventResize, todayRange: props.todayRange, nowDate: props.nowDate, nowIndicatorSegs: props.nowIndicatorSegs, clientWidth: props.clientWidth, tableMinWidth: props.tableMinWidth, tableColGroupNode: props.tableColGroupNode, slatCoords: state.slatCoords, onColCoords: this.handleColCoords, forPrint: props.forPrint })));\n        };\n        TimeCols.prototype.componentDidMount = function () {\n            this.scrollResponder = this.context.createScrollResponder(this.handleScrollRequest);\n        };\n        TimeCols.prototype.componentDidUpdate = function (prevProps) {\n            this.scrollResponder.update(prevProps.dateProfile !== this.props.dateProfile);\n        };\n        TimeCols.prototype.componentWillUnmount = function () {\n            this.scrollResponder.detach();\n        };\n        TimeCols.prototype.positionToHit = function (positionLeft, positionTop) {\n            var _a = this.context, dateEnv = _a.dateEnv, options = _a.options;\n            var colCoords = this.colCoords;\n            var dateProfile = this.props.dateProfile;\n            var slatCoords = this.state.slatCoords;\n            var _b = this.processSlotOptions(this.props.slotDuration, options.snapDuration), snapDuration = _b.snapDuration, snapsPerSlot = _b.snapsPerSlot;\n            var colIndex = colCoords.leftToIndex(positionLeft);\n            var slatIndex = slatCoords.positions.topToIndex(positionTop);\n            if (colIndex != null && slatIndex != null) {\n                var slatTop = slatCoords.positions.tops[slatIndex];\n                var slatHeight = slatCoords.positions.getHeight(slatIndex);\n                var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n                var dayDate = this.props.cells[colIndex].date;\n                var time = addDurations(dateProfile.slotMinTime, multiplyDuration(snapDuration, snapIndex));\n                var start = dateEnv.add(dayDate, time);\n                var end = dateEnv.add(start, snapDuration);\n                return {\n                    col: colIndex,\n                    dateSpan: {\n                        range: { start: start, end: end },\n                        allDay: false,\n                    },\n                    dayEl: colCoords.els[colIndex],\n                    relativeRect: {\n                        left: colCoords.lefts[colIndex],\n                        right: colCoords.rights[colIndex],\n                        top: slatTop,\n                        bottom: slatTop + slatHeight,\n                    },\n                };\n            }\n            return null;\n        };\n        return TimeCols;\n    }(BaseComponent));\n    function processSlotOptions(slotDuration, snapDurationOverride) {\n        var snapDuration = snapDurationOverride || slotDuration;\n        var snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n        if (snapsPerSlot === null) {\n            snapDuration = slotDuration;\n            snapsPerSlot = 1;\n            // TODO: say warning?\n        }\n        return { snapDuration: snapDuration, snapsPerSlot: snapsPerSlot };\n    }\n\n    var DayTimeColsSlicer = /** @class */ (function (_super) {\n        __extends(DayTimeColsSlicer, _super);\n        function DayTimeColsSlicer() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        DayTimeColsSlicer.prototype.sliceRange = function (range, dayRanges) {\n            var segs = [];\n            for (var col = 0; col < dayRanges.length; col += 1) {\n                var segRange = intersectRanges(range, dayRanges[col]);\n                if (segRange) {\n                    segs.push({\n                        start: segRange.start,\n                        end: segRange.end,\n                        isStart: segRange.start.valueOf() === range.start.valueOf(),\n                        isEnd: segRange.end.valueOf() === range.end.valueOf(),\n                        col: col,\n                    });\n                }\n            }\n            return segs;\n        };\n        return DayTimeColsSlicer;\n    }(Slicer));\n\n    var DayTimeCols = /** @class */ (function (_super) {\n        __extends(DayTimeCols, _super);\n        function DayTimeCols() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.buildDayRanges = memoize(buildDayRanges);\n            _this.slicer = new DayTimeColsSlicer();\n            _this.timeColsRef = createRef();\n            _this.handleRootEl = function (rootEl) {\n                if (rootEl) {\n                    _this.context.registerInteractiveComponent(_this, { el: rootEl });\n                }\n                else {\n                    _this.context.unregisterInteractiveComponent(_this);\n                }\n            };\n            return _this;\n        }\n        DayTimeCols.prototype.render = function () {\n            var _this = this;\n            var _a = this, props = _a.props, context = _a.context;\n            var dateProfile = props.dateProfile, dayTableModel = props.dayTableModel;\n            var isNowIndicator = context.options.nowIndicator;\n            var dayRanges = this.buildDayRanges(dayTableModel, dateProfile, context.dateEnv);\n            // give it the first row of cells\n            // TODO: would move this further down hierarchy, but sliceNowDate needs it\n            return (createElement(NowTimer, { unit: isNowIndicator ? 'minute' : 'day' }, function (nowDate, todayRange) { return (createElement(TimeCols, __assign({ ref: _this.timeColsRef, rootElRef: _this.handleRootEl }, _this.slicer.sliceProps(props, dateProfile, null, context, dayRanges), { forPrint: props.forPrint, axis: props.axis, dateProfile: dateProfile, slatMetas: props.slatMetas, slotDuration: props.slotDuration, cells: dayTableModel.cells[0], tableColGroupNode: props.tableColGroupNode, tableMinWidth: props.tableMinWidth, clientWidth: props.clientWidth, clientHeight: props.clientHeight, expandRows: props.expandRows, nowDate: nowDate, nowIndicatorSegs: isNowIndicator && _this.slicer.sliceNowDate(nowDate, context, dayRanges), todayRange: todayRange, onScrollTopRequest: props.onScrollTopRequest, onSlatCoords: props.onSlatCoords }))); }));\n        };\n        DayTimeCols.prototype.queryHit = function (positionLeft, positionTop) {\n            var rawHit = this.timeColsRef.current.positionToHit(positionLeft, positionTop);\n            if (rawHit) {\n                return {\n                    component: this,\n                    dateSpan: rawHit.dateSpan,\n                    dayEl: rawHit.dayEl,\n                    rect: {\n                        left: rawHit.relativeRect.left,\n                        right: rawHit.relativeRect.right,\n                        top: rawHit.relativeRect.top,\n                        bottom: rawHit.relativeRect.bottom,\n                    },\n                    layer: 0,\n                };\n            }\n            return null;\n        };\n        return DayTimeCols;\n    }(DateComponent));\n    function buildDayRanges(dayTableModel, dateProfile, dateEnv) {\n        var ranges = [];\n        for (var _i = 0, _a = dayTableModel.headerDates; _i < _a.length; _i++) {\n            var date = _a[_i];\n            ranges.push({\n                start: dateEnv.add(date, dateProfile.slotMinTime),\n                end: dateEnv.add(date, dateProfile.slotMaxTime),\n            });\n        }\n        return ranges;\n    }\n\n    // potential nice values for the slot-duration and interval-duration\n    // from largest to smallest\n    var STOCK_SUB_DURATIONS = [\n        { hours: 1 },\n        { minutes: 30 },\n        { minutes: 15 },\n        { seconds: 30 },\n        { seconds: 15 },\n    ];\n    function buildSlatMetas(slotMinTime, slotMaxTime, explicitLabelInterval, slotDuration, dateEnv) {\n        var dayStart = new Date(0);\n        var slatTime = slotMinTime;\n        var slatIterator = createDuration(0);\n        var labelInterval = explicitLabelInterval || computeLabelInterval(slotDuration);\n        var metas = [];\n        while (asRoughMs(slatTime) < asRoughMs(slotMaxTime)) {\n            var date = dateEnv.add(dayStart, slatTime);\n            var isLabeled = wholeDivideDurations(slatIterator, labelInterval) !== null;\n            metas.push({\n                date: date,\n                time: slatTime,\n                key: date.toISOString(),\n                isoTimeStr: formatIsoTimeString(date),\n                isLabeled: isLabeled,\n            });\n            slatTime = addDurations(slatTime, slotDuration);\n            slatIterator = addDurations(slatIterator, slotDuration);\n        }\n        return metas;\n    }\n    // Computes an automatic value for slotLabelInterval\n    function computeLabelInterval(slotDuration) {\n        var i;\n        var labelInterval;\n        var slotsPerLabel;\n        // find the smallest stock label interval that results in more than one slots-per-label\n        for (i = STOCK_SUB_DURATIONS.length - 1; i >= 0; i -= 1) {\n            labelInterval = createDuration(STOCK_SUB_DURATIONS[i]);\n            slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n            if (slotsPerLabel !== null && slotsPerLabel > 1) {\n                return labelInterval;\n            }\n        }\n        return slotDuration; // fall back\n    }\n\n    var DayTimeColsView = /** @class */ (function (_super) {\n        __extends(DayTimeColsView, _super);\n        function DayTimeColsView() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.buildTimeColsModel = memoize(buildTimeColsModel);\n            _this.buildSlatMetas = memoize(buildSlatMetas);\n            return _this;\n        }\n        DayTimeColsView.prototype.render = function () {\n            var _this = this;\n            var _a = this.context, options = _a.options, dateEnv = _a.dateEnv, dateProfileGenerator = _a.dateProfileGenerator;\n            var props = this.props;\n            var dateProfile = props.dateProfile;\n            var dayTableModel = this.buildTimeColsModel(dateProfile, dateProfileGenerator);\n            var splitProps = this.allDaySplitter.splitProps(props);\n            var slatMetas = this.buildSlatMetas(dateProfile.slotMinTime, dateProfile.slotMaxTime, options.slotLabelInterval, options.slotDuration, dateEnv);\n            var dayMinWidth = options.dayMinWidth;\n            var hasAttachedAxis = !dayMinWidth;\n            var hasDetachedAxis = dayMinWidth;\n            var headerContent = options.dayHeaders && (createElement(DayHeader, { dates: dayTableModel.headerDates, dateProfile: dateProfile, datesRepDistinctDays: true, renderIntro: hasAttachedAxis ? this.renderHeadAxis : null }));\n            var allDayContent = (options.allDaySlot !== false) && (function (contentArg) { return (createElement(DayTable, __assign({}, splitProps.allDay, { dateProfile: dateProfile, dayTableModel: dayTableModel, nextDayThreshold: options.nextDayThreshold, tableMinWidth: contentArg.tableMinWidth, colGroupNode: contentArg.tableColGroupNode, renderRowIntro: hasAttachedAxis ? _this.renderTableRowAxis : null, showWeekNumbers: false, expandRows: false, headerAlignElRef: _this.headerElRef, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, forPrint: props.forPrint }, _this.getAllDayMaxEventProps()))); });\n            var timeGridContent = function (contentArg) { return (createElement(DayTimeCols, __assign({}, splitProps.timed, { dayTableModel: dayTableModel, dateProfile: dateProfile, axis: hasAttachedAxis, slotDuration: options.slotDuration, slatMetas: slatMetas, forPrint: props.forPrint, tableColGroupNode: contentArg.tableColGroupNode, tableMinWidth: contentArg.tableMinWidth, clientWidth: contentArg.clientWidth, clientHeight: contentArg.clientHeight, onSlatCoords: _this.handleSlatCoords, expandRows: contentArg.expandRows, onScrollTopRequest: _this.handleScrollTopRequest }))); };\n            return hasDetachedAxis\n                ? this.renderHScrollLayout(headerContent, allDayContent, timeGridContent, dayTableModel.colCnt, dayMinWidth, slatMetas, this.state.slatCoords)\n                : this.renderSimpleLayout(headerContent, allDayContent, timeGridContent);\n        };\n        return DayTimeColsView;\n    }(TimeColsView));\n    function buildTimeColsModel(dateProfile, dateProfileGenerator) {\n        var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n        return new DayTableModel(daySeries, false);\n    }\n\n    var OPTION_REFINERS$2 = {\n        allDaySlot: Boolean,\n    };\n\n    var timeGridPlugin = createPlugin({\n        initialView: 'timeGridWeek',\n        optionRefiners: OPTION_REFINERS$2,\n        views: {\n            timeGrid: {\n                component: DayTimeColsView,\n                usesMinMaxTime: true,\n                allDaySlot: true,\n                slotDuration: '00:30:00',\n                slotEventOverlap: true,\n            },\n            timeGridDay: {\n                type: 'timeGrid',\n                duration: { days: 1 },\n            },\n            timeGridWeek: {\n                type: 'timeGrid',\n                duration: { weeks: 1 },\n            },\n        },\n    });\n\n    var ListViewHeaderRow = /** @class */ (function (_super) {\n        __extends(ListViewHeaderRow, _super);\n        function ListViewHeaderRow() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ListViewHeaderRow.prototype.render = function () {\n            var _a = this.props, dayDate = _a.dayDate, todayRange = _a.todayRange;\n            var _b = this.context, theme = _b.theme, dateEnv = _b.dateEnv, options = _b.options, viewApi = _b.viewApi;\n            var dayMeta = getDateMeta(dayDate, todayRange);\n            // will ever be falsy?\n            var text = options.listDayFormat ? dateEnv.format(dayDate, options.listDayFormat) : '';\n            // will ever be falsy? also, BAD NAME \"alt\"\n            var sideText = options.listDaySideFormat ? dateEnv.format(dayDate, options.listDaySideFormat) : '';\n            var navLinkData = options.navLinks\n                ? buildNavLinkData(dayDate)\n                : null;\n            var hookProps = __assign({ date: dateEnv.toDate(dayDate), view: viewApi, text: text,\n                sideText: sideText,\n                navLinkData: navLinkData }, dayMeta);\n            var classNames = ['fc-list-day'].concat(getDayClassNames(dayMeta, theme));\n            // TODO: make a reusable HOC for dayHeader (used in daygrid/timegrid too)\n            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.dayHeaderClassNames, content: options.dayHeaderContent, defaultContent: renderInnerContent$4, didMount: options.dayHeaderDidMount, willUnmount: options.dayHeaderWillUnmount }, function (rootElRef, customClassNames, innerElRef, innerContent) { return (createElement(\"tr\", { ref: rootElRef, className: classNames.concat(customClassNames).join(' '), \"data-date\": formatDayString(dayDate) },\n                createElement(\"th\", { colSpan: 3 },\n                    createElement(\"div\", { className: 'fc-list-day-cushion ' + theme.getClass('tableCellShaded'), ref: innerElRef }, innerContent)))); }));\n        };\n        return ListViewHeaderRow;\n    }(BaseComponent));\n    function renderInnerContent$4(props) {\n        var navLinkAttrs = props.navLinkData // is there a type for this?\n            ? { 'data-navlink': props.navLinkData, tabIndex: 0 }\n            : {};\n        return (createElement(Fragment, null,\n            props.text && (createElement(\"a\", __assign({ className: \"fc-list-day-text\" }, navLinkAttrs), props.text)),\n            props.sideText && (createElement(\"a\", __assign({ className: \"fc-list-day-side-text\" }, navLinkAttrs), props.sideText))));\n    }\n\n    var DEFAULT_TIME_FORMAT$1 = createFormatter({\n        hour: 'numeric',\n        minute: '2-digit',\n        meridiem: 'short',\n    });\n    var ListViewEventRow = /** @class */ (function (_super) {\n        __extends(ListViewEventRow, _super);\n        function ListViewEventRow() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        ListViewEventRow.prototype.render = function () {\n            var _a = this, props = _a.props, context = _a.context;\n            var seg = props.seg;\n            var timeFormat = context.options.eventTimeFormat || DEFAULT_TIME_FORMAT$1;\n            return (createElement(EventRoot, { seg: seg, timeText: \"\" // BAD. because of all-day content\n                , disableDragging: true, disableResizing: true, defaultContent: renderEventInnerContent, isPast: props.isPast, isFuture: props.isFuture, isToday: props.isToday, isSelected: props.isSelected, isDragging: props.isDragging, isResizing: props.isResizing, isDateSelecting: props.isDateSelecting }, function (rootElRef, classNames, innerElRef, innerContent, hookProps) { return (createElement(\"tr\", { className: ['fc-list-event', hookProps.event.url ? 'fc-event-forced-url' : ''].concat(classNames).join(' '), ref: rootElRef },\n                buildTimeContent(seg, timeFormat, context),\n                createElement(\"td\", { className: \"fc-list-event-graphic\" },\n                    createElement(\"span\", { className: \"fc-list-event-dot\", style: { borderColor: hookProps.borderColor || hookProps.backgroundColor } })),\n                createElement(\"td\", { className: \"fc-list-event-title\", ref: innerElRef }, innerContent))); }));\n        };\n        return ListViewEventRow;\n    }(BaseComponent));\n    function renderEventInnerContent(props) {\n        var event = props.event;\n        var url = event.url;\n        var anchorAttrs = url ? { href: url } : {};\n        return (createElement(\"a\", __assign({}, anchorAttrs), event.title));\n    }\n    function buildTimeContent(seg, timeFormat, context) {\n        var options = context.options;\n        if (options.displayEventTime !== false) {\n            var eventDef = seg.eventRange.def;\n            var eventInstance = seg.eventRange.instance;\n            var doAllDay = false;\n            var timeText = void 0;\n            if (eventDef.allDay) {\n                doAllDay = true;\n            }\n            else if (isMultiDayRange(seg.eventRange.range)) { // TODO: use (!isStart || !isEnd) instead?\n                if (seg.isStart) {\n                    timeText = buildSegTimeText(seg, timeFormat, context, null, null, eventInstance.range.start, seg.end);\n                }\n                else if (seg.isEnd) {\n                    timeText = buildSegTimeText(seg, timeFormat, context, null, null, seg.start, eventInstance.range.end);\n                }\n                else {\n                    doAllDay = true;\n                }\n            }\n            else {\n                timeText = buildSegTimeText(seg, timeFormat, context);\n            }\n            if (doAllDay) {\n                var hookProps = {\n                    text: context.options.allDayText,\n                    view: context.viewApi,\n                };\n                return (createElement(RenderHook, { hookProps: hookProps, classNames: options.allDayClassNames, content: options.allDayContent, defaultContent: renderAllDayInner$1, didMount: options.allDayDidMount, willUnmount: options.allDayWillUnmount }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"td\", { className: ['fc-list-event-time'].concat(classNames).join(' '), ref: rootElRef }, innerContent)); }));\n            }\n            return (createElement(\"td\", { className: \"fc-list-event-time\" }, timeText));\n        }\n        return null;\n    }\n    function renderAllDayInner$1(hookProps) {\n        return hookProps.text;\n    }\n\n    /*\n    Responsible for the scroller, and forwarding event-related actions into the \"grid\".\n    */\n    var ListView = /** @class */ (function (_super) {\n        __extends(ListView, _super);\n        function ListView() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this.computeDateVars = memoize(computeDateVars);\n            _this.eventStoreToSegs = memoize(_this._eventStoreToSegs);\n            _this.setRootEl = function (rootEl) {\n                if (rootEl) {\n                    _this.context.registerInteractiveComponent(_this, {\n                        el: rootEl,\n                    });\n                }\n                else {\n                    _this.context.unregisterInteractiveComponent(_this);\n                }\n            };\n            return _this;\n        }\n        ListView.prototype.render = function () {\n            var _this = this;\n            var _a = this, props = _a.props, context = _a.context;\n            var extraClassNames = [\n                'fc-list',\n                context.theme.getClass('table'),\n                context.options.stickyHeaderDates !== false ? 'fc-list-sticky' : '',\n            ];\n            var _b = this.computeDateVars(props.dateProfile), dayDates = _b.dayDates, dayRanges = _b.dayRanges;\n            var eventSegs = this.eventStoreToSegs(props.eventStore, props.eventUiBases, dayRanges);\n            return (createElement(ViewRoot, { viewSpec: context.viewSpec, elRef: this.setRootEl }, function (rootElRef, classNames) { return (createElement(\"div\", { ref: rootElRef, className: extraClassNames.concat(classNames).join(' ') },\n                createElement(Scroller, { liquid: !props.isHeightAuto, overflowX: props.isHeightAuto ? 'visible' : 'hidden', overflowY: props.isHeightAuto ? 'visible' : 'auto' }, eventSegs.length > 0 ?\n                    _this.renderSegList(eventSegs, dayDates) :\n                    _this.renderEmptyMessage()))); }));\n        };\n        ListView.prototype.renderEmptyMessage = function () {\n            var _a = this.context, options = _a.options, viewApi = _a.viewApi;\n            var hookProps = {\n                text: options.noEventsText,\n                view: viewApi,\n            };\n            return (createElement(RenderHook, { hookProps: hookProps, classNames: options.noEventsClassNames, content: options.noEventsContent, defaultContent: renderNoEventsInner, didMount: options.noEventsDidMount, willUnmount: options.noEventsWillUnmount }, function (rootElRef, classNames, innerElRef, innerContent) { return (createElement(\"div\", { className: ['fc-list-empty'].concat(classNames).join(' '), ref: rootElRef },\n                createElement(\"div\", { className: \"fc-list-empty-cushion\", ref: innerElRef }, innerContent))); }));\n        };\n        ListView.prototype.renderSegList = function (allSegs, dayDates) {\n            var _a = this.context, theme = _a.theme, options = _a.options;\n            var segsByDay = groupSegsByDay(allSegs); // sparse array\n            return (createElement(NowTimer, { unit: \"day\" }, function (nowDate, todayRange) {\n                var innerNodes = [];\n                for (var dayIndex = 0; dayIndex < segsByDay.length; dayIndex += 1) {\n                    var daySegs = segsByDay[dayIndex];\n                    if (daySegs) { // sparse array, so might be undefined\n                        var dayStr = dayDates[dayIndex].toISOString();\n                        // append a day header\n                        innerNodes.push(createElement(ListViewHeaderRow, { key: dayStr, dayDate: dayDates[dayIndex], todayRange: todayRange }));\n                        daySegs = sortEventSegs(daySegs, options.eventOrder);\n                        for (var _i = 0, daySegs_1 = daySegs; _i < daySegs_1.length; _i++) {\n                            var seg = daySegs_1[_i];\n                            innerNodes.push(createElement(ListViewEventRow, __assign({ key: dayStr + ':' + seg.eventRange.instance.instanceId /* are multiple segs for an instanceId */, seg: seg, isDragging: false, isResizing: false, isDateSelecting: false, isSelected: false }, getSegMeta(seg, todayRange, nowDate))));\n                        }\n                    }\n                }\n                return (createElement(\"table\", { className: 'fc-list-table ' + theme.getClass('table') },\n                    createElement(\"tbody\", null, innerNodes)));\n            }));\n        };\n        ListView.prototype._eventStoreToSegs = function (eventStore, eventUiBases, dayRanges) {\n            return this.eventRangesToSegs(sliceEventStore(eventStore, eventUiBases, this.props.dateProfile.activeRange, this.context.options.nextDayThreshold).fg, dayRanges);\n        };\n        ListView.prototype.eventRangesToSegs = function (eventRanges, dayRanges) {\n            var segs = [];\n            for (var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++) {\n                var eventRange = eventRanges_1[_i];\n                segs.push.apply(segs, this.eventRangeToSegs(eventRange, dayRanges));\n            }\n            return segs;\n        };\n        ListView.prototype.eventRangeToSegs = function (eventRange, dayRanges) {\n            var dateEnv = this.context.dateEnv;\n            var nextDayThreshold = this.context.options.nextDayThreshold;\n            var range = eventRange.range;\n            var allDay = eventRange.def.allDay;\n            var dayIndex;\n            var segRange;\n            var seg;\n            var segs = [];\n            for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex += 1) {\n                segRange = intersectRanges(range, dayRanges[dayIndex]);\n                if (segRange) {\n                    seg = {\n                        component: this,\n                        eventRange: eventRange,\n                        start: segRange.start,\n                        end: segRange.end,\n                        isStart: eventRange.isStart && segRange.start.valueOf() === range.start.valueOf(),\n                        isEnd: eventRange.isEnd && segRange.end.valueOf() === range.end.valueOf(),\n                        dayIndex: dayIndex,\n                    };\n                    segs.push(seg);\n                    // detect when range won't go fully into the next day,\n                    // and mutate the latest seg to the be the end.\n                    if (!seg.isEnd && !allDay &&\n                        dayIndex + 1 < dayRanges.length &&\n                        range.end <\n                            dateEnv.add(dayRanges[dayIndex + 1].start, nextDayThreshold)) {\n                        seg.end = range.end;\n                        seg.isEnd = true;\n                        break;\n                    }\n                }\n            }\n            return segs;\n        };\n        return ListView;\n    }(DateComponent));\n    function renderNoEventsInner(hookProps) {\n        return hookProps.text;\n    }\n    function computeDateVars(dateProfile) {\n        var dayStart = startOfDay(dateProfile.renderRange.start);\n        var viewEnd = dateProfile.renderRange.end;\n        var dayDates = [];\n        var dayRanges = [];\n        while (dayStart < viewEnd) {\n            dayDates.push(dayStart);\n            dayRanges.push({\n                start: dayStart,\n                end: addDays(dayStart, 1),\n            });\n            dayStart = addDays(dayStart, 1);\n        }\n        return { dayDates: dayDates, dayRanges: dayRanges };\n    }\n    // Returns a sparse array of arrays, segs grouped by their dayIndex\n    function groupSegsByDay(segs) {\n        var segsByDay = []; // sparse array\n        var i;\n        var seg;\n        for (i = 0; i < segs.length; i += 1) {\n            seg = segs[i];\n            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))\n                .push(seg);\n        }\n        return segsByDay;\n    }\n\n    var OPTION_REFINERS$3 = {\n        listDayFormat: createFalsableFormatter,\n        listDaySideFormat: createFalsableFormatter,\n        noEventsClassNames: identity,\n        noEventsContent: identity,\n        noEventsDidMount: identity,\n        noEventsWillUnmount: identity,\n    };\n    function createFalsableFormatter(input) {\n        return input === false ? null : createFormatter(input);\n    }\n\n    var listPlugin = createPlugin({\n        optionRefiners: OPTION_REFINERS$3,\n        views: {\n            list: {\n                component: ListView,\n                buttonTextKey: 'list',\n                listDayFormat: { month: 'long', day: 'numeric', year: 'numeric' },\n            },\n            listDay: {\n                type: 'list',\n                duration: { days: 1 },\n                listDayFormat: { weekday: 'long' },\n            },\n            listWeek: {\n                type: 'list',\n                duration: { weeks: 1 },\n                listDayFormat: { weekday: 'long' },\n                listDaySideFormat: { month: 'long', day: 'numeric', year: 'numeric' },\n            },\n            listMonth: {\n                type: 'list',\n                duration: { month: 1 },\n                listDaySideFormat: { weekday: 'long' },\n            },\n            listYear: {\n                type: 'list',\n                duration: { year: 1 },\n                listDaySideFormat: { weekday: 'long' },\n            },\n        },\n    });\n\n    var BootstrapTheme = /** @class */ (function (_super) {\n        __extends(BootstrapTheme, _super);\n        function BootstrapTheme() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        return BootstrapTheme;\n    }(Theme));\n    BootstrapTheme.prototype.classes = {\n        root: 'fc-theme-bootstrap',\n        table: 'table-bordered',\n        tableCellShaded: 'table-active',\n        buttonGroup: 'btn-group',\n        button: 'btn btn-primary',\n        buttonActive: 'active',\n        popover: 'popover',\n        popoverHeader: 'popover-header',\n        popoverContent: 'popover-body',\n    };\n    BootstrapTheme.prototype.baseIconClass = 'fa';\n    BootstrapTheme.prototype.iconClasses = {\n        close: 'fa-times',\n        prev: 'fa-chevron-left',\n        next: 'fa-chevron-right',\n        prevYear: 'fa-angle-double-left',\n        nextYear: 'fa-angle-double-right',\n    };\n    BootstrapTheme.prototype.rtlIconClasses = {\n        prev: 'fa-chevron-right',\n        next: 'fa-chevron-left',\n        prevYear: 'fa-angle-double-right',\n        nextYear: 'fa-angle-double-left',\n    };\n    BootstrapTheme.prototype.iconOverrideOption = 'bootstrapFontAwesome'; // TODO: make TS-friendly. move the option-processing into this plugin\n    BootstrapTheme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';\n    BootstrapTheme.prototype.iconOverridePrefix = 'fa-';\n    var plugin = createPlugin({\n        themeClasses: {\n            bootstrap: BootstrapTheme,\n        },\n    });\n\n    // rename this file to options.ts like other packages?\n    var OPTION_REFINERS$4 = {\n        googleCalendarApiKey: String,\n    };\n\n    var EVENT_SOURCE_REFINERS$1 = {\n        googleCalendarApiKey: String,\n        googleCalendarId: String,\n        googleCalendarApiBase: String,\n        extraParams: identity,\n    };\n\n    // TODO: expose somehow\n    var API_BASE = 'https://www.googleapis.com/calendar/v3/calendars';\n    var eventSourceDef$3 = {\n        parseMeta: function (refined) {\n            var googleCalendarId = refined.googleCalendarId;\n            if (!googleCalendarId && refined.url) {\n                googleCalendarId = parseGoogleCalendarId(refined.url);\n            }\n            if (googleCalendarId) {\n                return {\n                    googleCalendarId: googleCalendarId,\n                    googleCalendarApiKey: refined.googleCalendarApiKey,\n                    googleCalendarApiBase: refined.googleCalendarApiBase,\n                    extraParams: refined.extraParams,\n                };\n            }\n            return null;\n        },\n        fetch: function (arg, onSuccess, onFailure) {\n            var _a = arg.context, dateEnv = _a.dateEnv, options = _a.options;\n            var meta = arg.eventSource.meta;\n            var apiKey = meta.googleCalendarApiKey || options.googleCalendarApiKey;\n            if (!apiKey) {\n                onFailure({\n                    message: 'Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/',\n                });\n            }\n            else {\n                var url = buildUrl(meta);\n                // TODO: make DRY with json-feed-event-source\n                var extraParams = meta.extraParams;\n                var extraParamsObj = typeof extraParams === 'function' ? extraParams() : extraParams;\n                var requestParams_1 = buildRequestParams$1(arg.range, apiKey, extraParamsObj, dateEnv);\n                requestJson('GET', url, requestParams_1, function (body, xhr) {\n                    if (body.error) {\n                        onFailure({\n                            message: 'Google Calendar API: ' + body.error.message,\n                            errors: body.error.errors,\n                            xhr: xhr,\n                        });\n                    }\n                    else {\n                        onSuccess({\n                            rawEvents: gcalItemsToRawEventDefs(body.items, requestParams_1.timeZone),\n                            xhr: xhr,\n                        });\n                    }\n                }, function (message, xhr) {\n                    onFailure({ message: message, xhr: xhr });\n                });\n            }\n        },\n    };\n    function parseGoogleCalendarId(url) {\n        var match;\n        // detect if the ID was specified as a single string.\n        // will match calendars like \"asdf1234@calendar.google.com\" in addition to person email calendars.\n        if (/^[^/]+@([^/.]+\\.)*(google|googlemail|gmail)\\.com$/.test(url)) {\n            return url;\n        }\n        if ((match = /^https:\\/\\/www.googleapis.com\\/calendar\\/v3\\/calendars\\/([^/]*)/.exec(url)) ||\n            (match = /^https?:\\/\\/www.google.com\\/calendar\\/feeds\\/([^/]*)/.exec(url))) {\n            return decodeURIComponent(match[1]);\n        }\n        return null;\n    }\n    function buildUrl(meta) {\n        var apiBase = meta.googleCalendarApiBase;\n        if (!apiBase) {\n            apiBase = API_BASE;\n        }\n        return apiBase + '/' + encodeURIComponent(meta.googleCalendarId) + '/events';\n    }\n    function buildRequestParams$1(range, apiKey, extraParams, dateEnv) {\n        var params;\n        var startStr;\n        var endStr;\n        if (dateEnv.canComputeOffset) {\n            // strings will naturally have offsets, which GCal needs\n            startStr = dateEnv.formatIso(range.start);\n            endStr = dateEnv.formatIso(range.end);\n        }\n        else {\n            // when timezone isn't known, we don't know what the UTC offset should be, so ask for +/- 1 day\n            // from the UTC day-start to guarantee we're getting all the events\n            // (start/end will be UTC-coerced dates, so toISOString is okay)\n            startStr = addDays(range.start, -1).toISOString();\n            endStr = addDays(range.end, 1).toISOString();\n        }\n        params = __assign(__assign({}, (extraParams || {})), { key: apiKey, timeMin: startStr, timeMax: endStr, singleEvents: true, maxResults: 9999 });\n        if (dateEnv.timeZone !== 'local') {\n            params.timeZone = dateEnv.timeZone;\n        }\n        return params;\n    }\n    function gcalItemsToRawEventDefs(items, gcalTimezone) {\n        return items.map(function (item) { return gcalItemToRawEventDef(item, gcalTimezone); });\n    }\n    function gcalItemToRawEventDef(item, gcalTimezone) {\n        var url = item.htmlLink || null;\n        // make the URLs for each event show times in the correct timezone\n        if (url && gcalTimezone) {\n            url = injectQsComponent(url, 'ctz=' + gcalTimezone);\n        }\n        return {\n            id: item.id,\n            title: item.summary,\n            start: item.start.dateTime || item.start.date,\n            end: item.end.dateTime || item.end.date,\n            url: url,\n            location: item.location,\n            description: item.description,\n        };\n    }\n    // Injects a string like \"arg=value\" into the querystring of a URL\n    // TODO: move to a general util file?\n    function injectQsComponent(url, component) {\n        // inject it after the querystring but before the fragment\n        return url.replace(/(\\?.*?)?(#|$)/, function (whole, qs, hash) { return (qs ? qs + '&' : '?') + component + hash; });\n    }\n    var googleCalendarPlugin = createPlugin({\n        eventSourceDefs: [eventSourceDef$3],\n        optionRefiners: OPTION_REFINERS$4,\n        eventSourceRefiners: EVENT_SOURCE_REFINERS$1,\n    });\n\n    globalPlugins.push(interactionPlugin, dayGridPlugin, timeGridPlugin, listPlugin, plugin, googleCalendarPlugin);\n\n    exports.BASE_OPTION_DEFAULTS = BASE_OPTION_DEFAULTS;\n    exports.BASE_OPTION_REFINERS = BASE_OPTION_REFINERS;\n    exports.BaseComponent = BaseComponent;\n    exports.BgEvent = BgEvent;\n    exports.BootstrapTheme = BootstrapTheme;\n    exports.Calendar = Calendar;\n    exports.CalendarApi = CalendarApi;\n    exports.CalendarContent = CalendarContent;\n    exports.CalendarDataManager = CalendarDataManager;\n    exports.CalendarDataProvider = CalendarDataProvider;\n    exports.CalendarRoot = CalendarRoot;\n    exports.Component = Component;\n    exports.ContentHook = ContentHook;\n    exports.CustomContentRenderContext = CustomContentRenderContext;\n    exports.DateComponent = DateComponent;\n    exports.DateEnv = DateEnv;\n    exports.DateProfileGenerator = DateProfileGenerator;\n    exports.DayCellContent = DayCellContent;\n    exports.DayCellRoot = DayCellRoot;\n    exports.DayGridView = DayTableView;\n    exports.DayHeader = DayHeader;\n    exports.DaySeriesModel = DaySeriesModel;\n    exports.DayTable = DayTable;\n    exports.DayTableModel = DayTableModel;\n    exports.DayTableSlicer = DayTableSlicer;\n    exports.DayTimeCols = DayTimeCols;\n    exports.DayTimeColsSlicer = DayTimeColsSlicer;\n    exports.DayTimeColsView = DayTimeColsView;\n    exports.DelayedRunner = DelayedRunner;\n    exports.Draggable = ExternalDraggable;\n    exports.ElementDragging = ElementDragging;\n    exports.ElementScrollController = ElementScrollController;\n    exports.Emitter = Emitter;\n    exports.EventApi = EventApi;\n    exports.EventRoot = EventRoot;\n    exports.EventSourceApi = EventSourceApi;\n    exports.FeaturefulElementDragging = FeaturefulElementDragging;\n    exports.Fragment = Fragment;\n    exports.Interaction = Interaction;\n    exports.ListView = ListView;\n    exports.MountHook = MountHook;\n    exports.NamedTimeZoneImpl = NamedTimeZoneImpl;\n    exports.NowIndicatorRoot = NowIndicatorRoot;\n    exports.NowTimer = NowTimer;\n    exports.PointerDragging = PointerDragging;\n    exports.PositionCache = PositionCache;\n    exports.RefMap = RefMap;\n    exports.RenderHook = RenderHook;\n    exports.ScrollController = ScrollController;\n    exports.ScrollResponder = ScrollResponder;\n    exports.Scroller = Scroller;\n    exports.SimpleScrollGrid = SimpleScrollGrid;\n    exports.Slicer = Slicer;\n    exports.Splitter = Splitter;\n    exports.StandardEvent = StandardEvent;\n    exports.Table = Table;\n    exports.TableDateCell = TableDateCell;\n    exports.TableDowCell = TableDowCell;\n    exports.TableView = TableView;\n    exports.Theme = Theme;\n    exports.ThirdPartyDraggable = ThirdPartyDraggable;\n    exports.TimeCols = TimeCols;\n    exports.TimeColsSlatsCoords = TimeColsSlatsCoords;\n    exports.TimeColsView = TimeColsView;\n    exports.ViewApi = ViewApi;\n    exports.ViewContextType = ViewContextType;\n    exports.ViewRoot = ViewRoot;\n    exports.WeekNumberRoot = WeekNumberRoot;\n    exports.WindowScrollController = WindowScrollController;\n    exports.addDays = addDays;\n    exports.addDurations = addDurations;\n    exports.addMs = addMs;\n    exports.addWeeks = addWeeks;\n    exports.allowContextMenu = allowContextMenu;\n    exports.allowSelection = allowSelection;\n    exports.applyMutationToEventStore = applyMutationToEventStore;\n    exports.applyStyle = applyStyle;\n    exports.applyStyleProp = applyStyleProp;\n    exports.asCleanDays = asCleanDays;\n    exports.asRoughMinutes = asRoughMinutes;\n    exports.asRoughMs = asRoughMs;\n    exports.asRoughSeconds = asRoughSeconds;\n    exports.buildClassNameNormalizer = buildClassNameNormalizer;\n    exports.buildDayRanges = buildDayRanges;\n    exports.buildDayTableModel = buildDayTableModel;\n    exports.buildEventApis = buildEventApis;\n    exports.buildEventRangeKey = buildEventRangeKey;\n    exports.buildHashFromArray = buildHashFromArray;\n    exports.buildNavLinkData = buildNavLinkData;\n    exports.buildSegCompareObj = buildSegCompareObj;\n    exports.buildSegTimeText = buildSegTimeText;\n    exports.buildSlatMetas = buildSlatMetas;\n    exports.buildTimeColsModel = buildTimeColsModel;\n    exports.collectFromHash = collectFromHash;\n    exports.combineEventUis = combineEventUis;\n    exports.compareByFieldSpec = compareByFieldSpec;\n    exports.compareByFieldSpecs = compareByFieldSpecs;\n    exports.compareNumbers = compareNumbers;\n    exports.compareObjs = compareObjs;\n    exports.computeEdges = computeEdges;\n    exports.computeFallbackHeaderFormat = computeFallbackHeaderFormat;\n    exports.computeHeightAndMargins = computeHeightAndMargins;\n    exports.computeInnerRect = computeInnerRect;\n    exports.computeRect = computeRect;\n    exports.computeSegDraggable = computeSegDraggable;\n    exports.computeSegEndResizable = computeSegEndResizable;\n    exports.computeSegStartResizable = computeSegStartResizable;\n    exports.computeShrinkWidth = computeShrinkWidth;\n    exports.computeSmallestCellWidth = computeSmallestCellWidth;\n    exports.computeVisibleDayRange = computeVisibleDayRange;\n    exports.config = config;\n    exports.constrainPoint = constrainPoint;\n    exports.createContext = createContext$1;\n    exports.createDuration = createDuration;\n    exports.createElement = createElement;\n    exports.createEmptyEventStore = createEmptyEventStore;\n    exports.createEventInstance = createEventInstance;\n    exports.createEventUi = createEventUi;\n    exports.createFormatter = createFormatter;\n    exports.createPlugin = createPlugin;\n    exports.createRef = createRef;\n    exports.diffDates = diffDates;\n    exports.diffDayAndTime = diffDayAndTime;\n    exports.diffDays = diffDays;\n    exports.diffPoints = diffPoints;\n    exports.diffWeeks = diffWeeks;\n    exports.diffWholeDays = diffWholeDays;\n    exports.diffWholeWeeks = diffWholeWeeks;\n    exports.disableCursor = disableCursor;\n    exports.elementClosest = elementClosest;\n    exports.elementMatches = elementMatches;\n    exports.enableCursor = enableCursor;\n    exports.eventTupleToStore = eventTupleToStore;\n    exports.filterEventStoreDefs = filterEventStoreDefs;\n    exports.filterHash = filterHash;\n    exports.findDirectChildren = findDirectChildren;\n    exports.findElements = findElements;\n    exports.flexibleCompare = flexibleCompare;\n    exports.flushToDom = flushToDom$1;\n    exports.formatDate = formatDate;\n    exports.formatDayString = formatDayString;\n    exports.formatIsoTimeString = formatIsoTimeString;\n    exports.formatRange = formatRange;\n    exports.getAllowYScrolling = getAllowYScrolling;\n    exports.getCanVGrowWithinCell = getCanVGrowWithinCell;\n    exports.getClippingParents = getClippingParents;\n    exports.getDateMeta = getDateMeta;\n    exports.getDayClassNames = getDayClassNames;\n    exports.getDefaultEventEnd = getDefaultEventEnd;\n    exports.getElSeg = getElSeg;\n    exports.getEventClassNames = getEventClassNames;\n    exports.getIsRtlScrollbarOnLeft = getIsRtlScrollbarOnLeft;\n    exports.getRectCenter = getRectCenter;\n    exports.getRelevantEvents = getRelevantEvents;\n    exports.getScrollGridClassNames = getScrollGridClassNames;\n    exports.getScrollbarWidths = getScrollbarWidths;\n    exports.getSectionClassNames = getSectionClassNames;\n    exports.getSectionHasLiquidHeight = getSectionHasLiquidHeight;\n    exports.getSegMeta = getSegMeta;\n    exports.getSlotClassNames = getSlotClassNames;\n    exports.getStickyFooterScrollbar = getStickyFooterScrollbar;\n    exports.getStickyHeaderDates = getStickyHeaderDates;\n    exports.getUnequalProps = getUnequalProps;\n    exports.globalLocales = globalLocales;\n    exports.globalPlugins = globalPlugins;\n    exports.greatestDurationDenominator = greatestDurationDenominator;\n    exports.guid = guid;\n    exports.hasBgRendering = hasBgRendering;\n    exports.hasShrinkWidth = hasShrinkWidth;\n    exports.identity = identity;\n    exports.interactionSettingsStore = interactionSettingsStore;\n    exports.interactionSettingsToStore = interactionSettingsToStore;\n    exports.intersectRanges = intersectRanges;\n    exports.intersectRects = intersectRects;\n    exports.isArraysEqual = isArraysEqual;\n    exports.isColPropsEqual = isColPropsEqual;\n    exports.isDateSpansEqual = isDateSpansEqual;\n    exports.isInt = isInt;\n    exports.isInteractionValid = isInteractionValid;\n    exports.isMultiDayRange = isMultiDayRange;\n    exports.isPropsEqual = isPropsEqual;\n    exports.isPropsValid = isPropsValid;\n    exports.isValidDate = isValidDate;\n    exports.listenBySelector = listenBySelector;\n    exports.mapHash = mapHash;\n    exports.memoize = memoize;\n    exports.memoizeArraylike = memoizeArraylike;\n    exports.memoizeHashlike = memoizeHashlike;\n    exports.memoizeObjArg = memoizeObjArg;\n    exports.mergeEventStores = mergeEventStores;\n    exports.multiplyDuration = multiplyDuration;\n    exports.padStart = padStart;\n    exports.parseBusinessHours = parseBusinessHours;\n    exports.parseClassNames = parseClassNames;\n    exports.parseDragMeta = parseDragMeta;\n    exports.parseEventDef = parseEventDef;\n    exports.parseFieldSpecs = parseFieldSpecs;\n    exports.parseMarker = parse;\n    exports.pointInsideRect = pointInsideRect;\n    exports.preventContextMenu = preventContextMenu;\n    exports.preventDefault = preventDefault;\n    exports.preventSelection = preventSelection;\n    exports.rangeContainsMarker = rangeContainsMarker;\n    exports.rangeContainsRange = rangeContainsRange;\n    exports.rangesEqual = rangesEqual;\n    exports.rangesIntersect = rangesIntersect;\n    exports.refineEventDef = refineEventDef;\n    exports.refineProps = refineProps;\n    exports.removeElement = removeElement;\n    exports.removeExact = removeExact;\n    exports.render = render;\n    exports.renderChunkContent = renderChunkContent;\n    exports.renderFill = renderFill;\n    exports.renderMicroColGroup = renderMicroColGroup;\n    exports.renderScrollShim = renderScrollShim;\n    exports.requestJson = requestJson;\n    exports.sanitizeShrinkWidth = sanitizeShrinkWidth;\n    exports.setElSeg = setElSeg;\n    exports.setRef = setRef;\n    exports.sliceEventStore = sliceEventStore;\n    exports.sliceEvents = sliceEvents;\n    exports.sortEventSegs = sortEventSegs;\n    exports.startOfDay = startOfDay;\n    exports.translateRect = translateRect;\n    exports.triggerDateSelect = triggerDateSelect;\n    exports.unmountComponentAtNode = unmountComponentAtNode$1;\n    exports.unpromisify = unpromisify;\n    exports.version = version;\n    exports.whenTransitionDone = whenTransitionDone;\n    exports.wholeDivideDurations = wholeDivideDurations;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n    return exports;\n\n}({}));\n"
}, function (t, e, n) {
    (function (a, i) {
        var r, o, s, l = l || {};
        l.scope = {}, l.findInternal = function (t, e, n) {
            t instanceof String && (t = String(t));
            for (var a = t.length, i = 0; i < a; i++) {
                var r = t[i];
                if (e.call(n, r, i, t)) return {i: i, v: r}
            }
            return {i: -1, v: void 0}
        }, l.ASSUME_ES5 = !1, l.ASSUME_NO_NATIVE_MAP = !1, l.ASSUME_NO_NATIVE_SET = !1, l.SIMPLE_FROUND_POLYFILL = !1, l.defineProperty = l.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function (t, e, n) {
            t != Array.prototype && t != Object.prototype && (t[e] = n.value)
        }, l.getGlobal = function (t) {
            return "undefined" != typeof window && window === t ? t : void 0 !== a && null != a ? a : t
        }, l.global = l.getGlobal(this), l.polyfill = function (t, e, n, a) {
            if (e) {
                for (n = l.global, t = t.split("."), a = 0; a < t.length - 1; a++) {
                    var i = t[a];
                    i in n || (n[i] = {}), n = n[i]
                }
                (e = e(a = n[t = t[t.length - 1]])) != a && null != e && l.defineProperty(n, t, {
                    configurable: !0,
                    writable: !0,
                    value: e
                })
            }
        }, l.polyfill("Array.prototype.find", (function (t) {
            return t || function (t, e) {
                return l.findInternal(this, t, e).v
            }
        }), "es6", "es3"), window.Zepto, o = [n(16)], void 0 === (s = "function" == typeof (r = function (t) {
            var e = function (e, n, a) {
                var i = {
                    invalid: [], getCaret: function () {
                        try {
                            var t = 0, n = e.get(0), a = document.selection, r = n.selectionStart;
                            if (a && -1 === navigator.appVersion.indexOf("MSIE 10")) {
                                var o = a.createRange();
                                o.moveStart("character", -i.val().length), t = o.text.length
                            } else (r || "0" === r) && (t = r);
                            return t
                        } catch (t) {
                        }
                    }, setCaret: function (t) {
                        try {
                            if (e.is(":focus")) {
                                var n = e.get(0);
                                if (n.setSelectionRange) n.setSelectionRange(t, t); else {
                                    var a = n.createTextRange();
                                    a.collapse(!0), a.moveEnd("character", t), a.moveStart("character", t), a.select()
                                }
                            }
                        } catch (t) {
                        }
                    }, events: function () {
                        e.on("keydown.mask", (function (t) {
                            e.data("mask-keycode", t.keyCode || t.which), e.data("mask-previus-value", e.val()), e.data("mask-previus-caret-pos", i.getCaret()), i.maskDigitPosMapOld = i.maskDigitPosMap
                        })).on(t.jMaskGlobals.useInput ? "input.mask" : "keyup.mask", i.behaviour).on("paste.mask drop.mask", (function () {
                            setTimeout((function () {
                                e.keydown().keyup()
                            }), 100)
                        })).on("change.mask", (function () {
                            e.data("changed", !0)
                        })).on("blur.mask", (function () {
                            s === i.val() || e.data("changed") || e.trigger("change"), e.data("changed", !1)
                        })).on("blur.mask", (function () {
                            s = i.val()
                        })).on("focus.mask", (function (e) {
                            !0 === a.selectOnFocus && t(e.target).select()
                        })).on("focusout.mask", (function () {
                            a.clearIfNotMatch && !r.test(i.val()) && i.val("")
                        }))
                    }, getRegexMask: function () {
                        for (var t, e, a, i, r = [], s = 0; s < n.length; s++) (t = o.translation[n.charAt(s)]) ? (e = t.pattern.toString().replace(/.{1}$|^.{1}/g, ""), a = t.optional, (t = t.recursive) ? (r.push(n.charAt(s)), i = {
                            digit: n.charAt(s),
                            pattern: e
                        }) : r.push(a || t ? e + "?" : e)) : r.push(n.charAt(s).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
                        return r = r.join(""), i && (r = r.replace(new RegExp("(" + i.digit + "(.*" + i.digit + ")?)"), "($1)?").replace(new RegExp(i.digit, "g"), i.pattern)), new RegExp(r)
                    }, destroyEvents: function () {
                        e.off("input keydown keyup paste drop blur focusout ".split(" ").join(".mask "))
                    }, val: function (t) {
                        var n = e.is("input") ? "val" : "text";
                        return 0 < arguments.length ? (e[n]() !== t && e[n](t), n = e) : n = e[n](), n
                    }, calculateCaretPosition: function (t) {
                        var n = i.getMasked(), a = i.getCaret();
                        if (t !== n) {
                            var r = e.data("mask-previus-caret-pos") || 0;
                            n = n.length;
                            var o, s = t.length, l = t = 0, c = 0, d = 0;
                            for (o = a; o < n && i.maskDigitPosMap[o]; o++) l++;
                            for (o = a - 1; 0 <= o && i.maskDigitPosMap[o]; o--) t++;
                            for (o = a - 1; 0 <= o; o--) i.maskDigitPosMap[o] && c++;
                            for (o = r - 1; 0 <= o; o--) i.maskDigitPosMapOld[o] && d++;
                            a > s ? a = 10 * n : r >= a && r !== s ? i.maskDigitPosMapOld[a] || (r = a, a = a - (d - c) - t, i.maskDigitPosMap[a] && (a = r)) : a > r && (a = a + (c - d) + l)
                        }
                        return a
                    }, behaviour: function (n) {
                        n = n || window.event, i.invalid = [];
                        var a = e.data("mask-keycode");
                        if (-1 === t.inArray(a, o.byPassKeys)) {
                            a = i.getMasked();
                            var r = i.getCaret(), s = e.data("mask-previus-value") || "";
                            return setTimeout((function () {
                                i.setCaret(i.calculateCaretPosition(s))
                            }), t.jMaskGlobals.keyStrokeCompensation), i.val(a), i.setCaret(r), i.callbacks(n)
                        }
                    }, getMasked: function (t, e) {
                        var r, s = [], l = void 0 === e ? i.val() : e + "", c = 0, d = n.length, u = 0, h = l.length,
                            p = 1, f = "push", g = -1, m = 0;
                        if (e = [], a.reverse) {
                            f = "unshift", p = -1;
                            var v = 0;
                            c = d - 1, u = h - 1;
                            var b = function () {
                                return -1 < c && -1 < u
                            }
                        } else v = d - 1, b = function () {
                            return c < d && u < h
                        };
                        for (; b();) {
                            var y = n.charAt(c), x = l.charAt(u), _ = o.translation[y];
                            _ ? (x.match(_.pattern) ? (s[f](x), _.recursive && (-1 === g ? g = c : c === v && c !== g && (c = g - p), v === g && (c -= p)), c += p) : x === r ? (m--, r = void 0) : _.optional ? (c += p, u -= p) : _.fallback ? (s[f](_.fallback), c += p, u -= p) : i.invalid.push({
                                p: u,
                                v: x,
                                e: _.pattern
                            }), u += p) : (t || s[f](y), x === y ? (e.push(u), u += p) : (r = y, e.push(u + m), m++), c += p)
                        }
                        return t = n.charAt(v), d !== h + 1 || o.translation[t] || s.push(t), s = s.join(""), i.mapMaskdigitPositions(s, e, h), s
                    }, mapMaskdigitPositions: function (t, e, n) {
                        for (t = a.reverse ? t.length - n : 0, i.maskDigitPosMap = {}, n = 0; n < e.length; n++) i.maskDigitPosMap[e[n] + t] = 1
                    }, callbacks: function (t) {
                        var r = i.val(), o = r !== s, l = [r, t, e, a], c = function (t, e, n) {
                            "function" == typeof a[t] && e && a[t].apply(this, n)
                        };
                        c("onChange", !0 === o, l), c("onKeyPress", !0 === o, l), c("onComplete", r.length === n.length, l), c("onInvalid", 0 < i.invalid.length, [r, t, e, i.invalid, a])
                    }
                };
                e = t(e);
                var r, o = this, s = i.val();
                n = "function" == typeof n ? n(i.val(), void 0, e, a) : n, o.mask = n, o.options = a, o.remove = function () {
                    var t = i.getCaret();
                    return o.options.placeholder && e.removeAttr("placeholder"), e.data("mask-maxlength") && e.removeAttr("maxlength"), i.destroyEvents(), i.val(o.getCleanVal()), i.setCaret(t), e
                }, o.getCleanVal = function () {
                    return i.getMasked(!0)
                }, o.getMaskedVal = function (t) {
                    return i.getMasked(!1, t)
                }, o.init = function (s) {
                    if (s = s || !1, a = a || {}, o.clearIfNotMatch = t.jMaskGlobals.clearIfNotMatch, o.byPassKeys = t.jMaskGlobals.byPassKeys, o.translation = t.extend({}, t.jMaskGlobals.translation, a.translation), o = t.extend(!0, {}, o, a), r = i.getRegexMask(), s) i.events(), i.val(i.getMasked()); else {
                        a.placeholder && e.attr("placeholder", a.placeholder), e.data("mask") && e.attr("autocomplete", "off"), s = 0;
                        for (var l = !0; s < n.length; s++) {
                            var c = o.translation[n.charAt(s)];
                            if (c && c.recursive) {
                                l = !1;
                                break
                            }
                        }
                        l && e.attr("maxlength", n.length).data("mask-maxlength", !0), i.destroyEvents(), i.events(), s = i.getCaret(), i.val(i.getMasked()), i.setCaret(s)
                    }
                }, o.init(!e.is("input"))
            };
            t.maskWatchers = {};
            var n = function () {
                var n = t(this), i = {}, r = n.attr("data-mask");
                if (n.attr("data-mask-reverse") && (i.reverse = !0), n.attr("data-mask-clearifnotmatch") && (i.clearIfNotMatch = !0), "true" === n.attr("data-mask-selectonfocus") && (i.selectOnFocus = !0), a(n, r, i)) return n.data("mask", new e(this, r, i))
            }, a = function (e, n, a) {
                a = a || {};
                var i = t(e).data("mask"), r = JSON.stringify;
                e = t(e).val() || t(e).text();
                try {
                    return "function" == typeof n && (n = n(e)), "object" != typeof i || r(i.options) !== r(a) || i.mask !== n
                } catch (t) {
                }
            }, i = function (t) {
                var e = document.createElement("div"), n = (t = "on" + t) in e;
                return n || (e.setAttribute(t, "return;"), n = "function" == typeof e[t]), n
            };
            t.fn.mask = function (n, i) {
                i = i || {};
                var r = this.selector, o = t.jMaskGlobals, s = o.watchInterval;
                o = i.watchInputs || o.watchInputs;
                var l = function () {
                    if (a(this, n, i)) return t(this).data("mask", new e(this, n, i))
                };
                return t(this).each(l), r && "" !== r && o && (clearInterval(t.maskWatchers[r]), t.maskWatchers[r] = setInterval((function () {
                    t(document).find(r).each(l)
                }), s)), this
            }, t.fn.masked = function (t) {
                return this.data("mask").getMaskedVal(t)
            }, t.fn.unmask = function () {
                return clearInterval(t.maskWatchers[this.selector]), delete t.maskWatchers[this.selector], this.each((function () {
                    var e = t(this).data("mask");
                    e && e.remove().removeData("mask")
                }))
            }, t.fn.cleanVal = function () {
                return this.data("mask").getCleanVal()
            }, t.applyDataMask = function (e) {
                ((e = e || t.jMaskGlobals.maskElements) instanceof t ? e : t(e)).filter(t.jMaskGlobals.dataMaskAttr).each(n)
            }, i = {
                maskElements: "input,td,span,div",
                dataMaskAttr: "*[data-mask]",
                dataMask: !0,
                watchInterval: 300,
                watchInputs: !0,
                keyStrokeCompensation: 10,
                useInput: !/Chrome\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && i("input"),
                watchDataMask: !1,
                byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
                translation: {
                    0: {pattern: /\d/},
                    9: {pattern: /\d/, optional: !0},
                    "#": {pattern: /\d/, recursive: !0},
                    A: {pattern: /[a-zA-Z0-9]/},
                    S: {pattern: /[a-zA-Z]/}
                }
            }, t.jMaskGlobals = t.jMaskGlobals || {}, (i = t.jMaskGlobals = t.extend(!0, {}, i, t.jMaskGlobals)).dataMask && t.applyDataMask(), setInterval((function () {
                t.jMaskGlobals.watchDataMask && t.applyDataMask()
            }), i.watchInterval)
        }) ? r.apply(e, o) : r) || (t.exports = s)
    }).call(this, n(3), n(16))
}, function (t, e, n) {
    n(24)(n(232))
}, function (t, e) {
    t.exports = "/*!\n * Quill Editor v1.3.7\n * https://quilljs.com/\n * Copyright (c) 2014, Jason Chen\n * Copyright (c) 2013, salesforce.com\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Quill\"] = factory();\n\telse\n\t\troot[\"Quill\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 109);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar container_1 = __webpack_require__(17);\nvar format_1 = __webpack_require__(18);\nvar leaf_1 = __webpack_require__(19);\nvar scroll_1 = __webpack_require__(45);\nvar inline_1 = __webpack_require__(46);\nvar block_1 = __webpack_require__(47);\nvar embed_1 = __webpack_require__(48);\nvar text_1 = __webpack_require__(49);\nvar attributor_1 = __webpack_require__(12);\nvar class_1 = __webpack_require__(32);\nvar style_1 = __webpack_require__(33);\nvar store_1 = __webpack_require__(31);\nvar Registry = __webpack_require__(1);\nvar Parchment = {\n    Scope: Registry.Scope,\n    create: Registry.create,\n    find: Registry.find,\n    query: Registry.query,\n    register: Registry.register,\n    Container: container_1.default,\n    Format: format_1.default,\n    Leaf: leaf_1.default,\n    Embed: embed_1.default,\n    Scroll: scroll_1.default,\n    Block: block_1.default,\n    Inline: inline_1.default,\n    Text: text_1.default,\n    Attributor: {\n        Attribute: attributor_1.default,\n        Class: class_1.default,\n        Style: style_1.default,\n        Store: store_1.default,\n    },\n};\nexports.default = Parchment;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ParchmentError = /** @class */ (function (_super) {\n    __extends(ParchmentError, _super);\n    function ParchmentError(message) {\n        var _this = this;\n        message = '[Parchment] ' + message;\n        _this = _super.call(this, message) || this;\n        _this.message = message;\n        _this.name = _this.constructor.name;\n        return _this;\n    }\n    return ParchmentError;\n}(Error));\nexports.ParchmentError = ParchmentError;\nvar attributes = {};\nvar classes = {};\nvar tags = {};\nvar types = {};\nexports.DATA_KEY = '__blot';\nvar Scope;\n(function (Scope) {\n    Scope[Scope[\"TYPE\"] = 3] = \"TYPE\";\n    Scope[Scope[\"LEVEL\"] = 12] = \"LEVEL\";\n    Scope[Scope[\"ATTRIBUTE\"] = 13] = \"ATTRIBUTE\";\n    Scope[Scope[\"BLOT\"] = 14] = \"BLOT\";\n    Scope[Scope[\"INLINE\"] = 7] = \"INLINE\";\n    Scope[Scope[\"BLOCK\"] = 11] = \"BLOCK\";\n    Scope[Scope[\"BLOCK_BLOT\"] = 10] = \"BLOCK_BLOT\";\n    Scope[Scope[\"INLINE_BLOT\"] = 6] = \"INLINE_BLOT\";\n    Scope[Scope[\"BLOCK_ATTRIBUTE\"] = 9] = \"BLOCK_ATTRIBUTE\";\n    Scope[Scope[\"INLINE_ATTRIBUTE\"] = 5] = \"INLINE_ATTRIBUTE\";\n    Scope[Scope[\"ANY\"] = 15] = \"ANY\";\n})(Scope = exports.Scope || (exports.Scope = {}));\nfunction create(input, value) {\n    var match = query(input);\n    if (match == null) {\n        throw new ParchmentError(\"Unable to create \" + input + \" blot\");\n    }\n    var BlotClass = match;\n    var node = \n    // @ts-ignore\n    input instanceof Node || input['nodeType'] === Node.TEXT_NODE ? input : BlotClass.create(value);\n    return new BlotClass(node, value);\n}\nexports.create = create;\nfunction find(node, bubble) {\n    if (bubble === void 0) { bubble = false; }\n    if (node == null)\n        return null;\n    // @ts-ignore\n    if (node[exports.DATA_KEY] != null)\n        return node[exports.DATA_KEY].blot;\n    if (bubble)\n        return find(node.parentNode, bubble);\n    return null;\n}\nexports.find = find;\nfunction query(query, scope) {\n    if (scope === void 0) { scope = Scope.ANY; }\n    var match;\n    if (typeof query === 'string') {\n        match = types[query] || attributes[query];\n        // @ts-ignore\n    }\n    else if (query instanceof Text || query['nodeType'] === Node.TEXT_NODE) {\n        match = types['text'];\n    }\n    else if (typeof query === 'number') {\n        if (query & Scope.LEVEL & Scope.BLOCK) {\n            match = types['block'];\n        }\n        else if (query & Scope.LEVEL & Scope.INLINE) {\n            match = types['inline'];\n        }\n    }\n    else if (query instanceof HTMLElement) {\n        var names = (query.getAttribute('class') || '').split(/\\s+/);\n        for (var i in names) {\n            match = classes[names[i]];\n            if (match)\n                break;\n        }\n        match = match || tags[query.tagName];\n    }\n    if (match == null)\n        return null;\n    // @ts-ignore\n    if (scope & Scope.LEVEL & match.scope && scope & Scope.TYPE & match.scope)\n        return match;\n    return null;\n}\nexports.query = query;\nfunction register() {\n    var Definitions = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        Definitions[_i] = arguments[_i];\n    }\n    if (Definitions.length > 1) {\n        return Definitions.map(function (d) {\n            return register(d);\n        });\n    }\n    var Definition = Definitions[0];\n    if (typeof Definition.blotName !== 'string' && typeof Definition.attrName !== 'string') {\n        throw new ParchmentError('Invalid definition');\n    }\n    else if (Definition.blotName === 'abstract') {\n        throw new ParchmentError('Cannot register abstract class');\n    }\n    types[Definition.blotName || Definition.attrName] = Definition;\n    if (typeof Definition.keyName === 'string') {\n        attributes[Definition.keyName] = Definition;\n    }\n    else {\n        if (Definition.className != null) {\n            classes[Definition.className] = Definition;\n        }\n        if (Definition.tagName != null) {\n            if (Array.isArray(Definition.tagName)) {\n                Definition.tagName = Definition.tagName.map(function (tagName) {\n                    return tagName.toUpperCase();\n                });\n            }\n            else {\n                Definition.tagName = Definition.tagName.toUpperCase();\n            }\n            var tagNames = Array.isArray(Definition.tagName) ? Definition.tagName : [Definition.tagName];\n            tagNames.forEach(function (tag) {\n                if (tags[tag] == null || Definition.className == null) {\n                    tags[tag] = Definition;\n                }\n            });\n        }\n    }\n    return Definition;\n}\nexports.register = register;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar diff = __webpack_require__(51);\nvar equal = __webpack_require__(11);\nvar extend = __webpack_require__(3);\nvar op = __webpack_require__(20);\n\n\nvar NULL_CHARACTER = String.fromCharCode(0);  // Placeholder char for embed in diff()\n\n\nvar Delta = function (ops) {\n  // Assume we are given a well formed ops\n  if (Array.isArray(ops)) {\n    this.ops = ops;\n  } else if (ops != null && Array.isArray(ops.ops)) {\n    this.ops = ops.ops;\n  } else {\n    this.ops = [];\n  }\n};\n\n\nDelta.prototype.insert = function (text, attributes) {\n  var newOp = {};\n  if (text.length === 0) return this;\n  newOp.insert = text;\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\n\nDelta.prototype['delete'] = function (length) {\n  if (length <= 0) return this;\n  return this.push({ 'delete': length });\n};\n\nDelta.prototype.retain = function (length, attributes) {\n  if (length <= 0) return this;\n  var newOp = { retain: length };\n  if (attributes != null && typeof attributes === 'object' && Object.keys(attributes).length > 0) {\n    newOp.attributes = attributes;\n  }\n  return this.push(newOp);\n};\n\nDelta.prototype.push = function (newOp) {\n  var index = this.ops.length;\n  var lastOp = this.ops[index - 1];\n  newOp = extend(true, {}, newOp);\n  if (typeof lastOp === 'object') {\n    if (typeof newOp['delete'] === 'number' && typeof lastOp['delete'] === 'number') {\n      this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };\n      return this;\n    }\n    // Since it does not matter if we insert before or after deleting at the same index,\n    // always prefer to insert first\n    if (typeof lastOp['delete'] === 'number' && newOp.insert != null) {\n      index -= 1;\n      lastOp = this.ops[index - 1];\n      if (typeof lastOp !== 'object') {\n        this.ops.unshift(newOp);\n        return this;\n      }\n    }\n    if (equal(newOp.attributes, lastOp.attributes)) {\n      if (typeof newOp.insert === 'string' && typeof lastOp.insert === 'string') {\n        this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes\n        return this;\n      } else if (typeof newOp.retain === 'number' && typeof lastOp.retain === 'number') {\n        this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };\n        if (typeof newOp.attributes === 'object') this.ops[index - 1].attributes = newOp.attributes\n        return this;\n      }\n    }\n  }\n  if (index === this.ops.length) {\n    this.ops.push(newOp);\n  } else {\n    this.ops.splice(index, 0, newOp);\n  }\n  return this;\n};\n\nDelta.prototype.chop = function () {\n  var lastOp = this.ops[this.ops.length - 1];\n  if (lastOp && lastOp.retain && !lastOp.attributes) {\n    this.ops.pop();\n  }\n  return this;\n};\n\nDelta.prototype.filter = function (predicate) {\n  return this.ops.filter(predicate);\n};\n\nDelta.prototype.forEach = function (predicate) {\n  this.ops.forEach(predicate);\n};\n\nDelta.prototype.map = function (predicate) {\n  return this.ops.map(predicate);\n};\n\nDelta.prototype.partition = function (predicate) {\n  var passed = [], failed = [];\n  this.forEach(function(op) {\n    var target = predicate(op) ? passed : failed;\n    target.push(op);\n  });\n  return [passed, failed];\n};\n\nDelta.prototype.reduce = function (predicate, initial) {\n  return this.ops.reduce(predicate, initial);\n};\n\nDelta.prototype.changeLength = function () {\n  return this.reduce(function (length, elem) {\n    if (elem.insert) {\n      return length + op.length(elem);\n    } else if (elem.delete) {\n      return length - elem.delete;\n    }\n    return length;\n  }, 0);\n};\n\nDelta.prototype.length = function () {\n  return this.reduce(function (length, elem) {\n    return length + op.length(elem);\n  }, 0);\n};\n\nDelta.prototype.slice = function (start, end) {\n  start = start || 0;\n  if (typeof end !== 'number') end = Infinity;\n  var ops = [];\n  var iter = op.iterator(this.ops);\n  var index = 0;\n  while (index < end && iter.hasNext()) {\n    var nextOp;\n    if (index < start) {\n      nextOp = iter.next(start - index);\n    } else {\n      nextOp = iter.next(end - index);\n      ops.push(nextOp);\n    }\n    index += op.length(nextOp);\n  }\n  return new Delta(ops);\n};\n\n\nDelta.prototype.compose = function (other) {\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var ops = [];\n  var firstOther = otherIter.peek();\n  if (firstOther != null && typeof firstOther.retain === 'number' && firstOther.attributes == null) {\n    var firstLeft = firstOther.retain;\n    while (thisIter.peekType() === 'insert' && thisIter.peekLength() <= firstLeft) {\n      firstLeft -= thisIter.peekLength();\n      ops.push(thisIter.next());\n    }\n    if (firstOther.retain - firstLeft > 0) {\n      otherIter.next(firstOther.retain - firstLeft);\n    }\n  }\n  var delta = new Delta(ops);\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else if (thisIter.peekType() === 'delete') {\n      delta.push(thisIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (typeof otherOp.retain === 'number') {\n        var newOp = {};\n        if (typeof thisOp.retain === 'number') {\n          newOp.retain = length;\n        } else {\n          newOp.insert = thisOp.insert;\n        }\n        // Preserve null when composing with a retain, otherwise remove it for inserts\n        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, typeof thisOp.retain === 'number');\n        if (attributes) newOp.attributes = attributes;\n        delta.push(newOp);\n\n        // Optimization if rest of other is just retain\n        if (!otherIter.hasNext() && equal(delta.ops[delta.ops.length - 1], newOp)) {\n          var rest = new Delta(thisIter.rest());\n          return delta.concat(rest).chop();\n        }\n\n      // Other op should be delete, we could be an insert or retain\n      // Insert + delete cancels out\n      } else if (typeof otherOp['delete'] === 'number' && typeof thisOp.retain === 'number') {\n        delta.push(otherOp);\n      }\n    }\n  }\n  return delta.chop();\n};\n\nDelta.prototype.concat = function (other) {\n  var delta = new Delta(this.ops.slice());\n  if (other.ops.length > 0) {\n    delta.push(other.ops[0]);\n    delta.ops = delta.ops.concat(other.ops.slice(1));\n  }\n  return delta;\n};\n\nDelta.prototype.diff = function (other, index) {\n  if (this.ops === other.ops) {\n    return new Delta();\n  }\n  var strings = [this, other].map(function (delta) {\n    return delta.map(function (op) {\n      if (op.insert != null) {\n        return typeof op.insert === 'string' ? op.insert : NULL_CHARACTER;\n      }\n      var prep = (delta === other) ? 'on' : 'with';\n      throw new Error('diff() called ' + prep + ' non-document');\n    }).join('');\n  });\n  var delta = new Delta();\n  var diffResult = diff(strings[0], strings[1], index);\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  diffResult.forEach(function (component) {\n    var length = component[1].length;\n    while (length > 0) {\n      var opLength = 0;\n      switch (component[0]) {\n        case diff.INSERT:\n          opLength = Math.min(otherIter.peekLength(), length);\n          delta.push(otherIter.next(opLength));\n          break;\n        case diff.DELETE:\n          opLength = Math.min(length, thisIter.peekLength());\n          thisIter.next(opLength);\n          delta['delete'](opLength);\n          break;\n        case diff.EQUAL:\n          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);\n          var thisOp = thisIter.next(opLength);\n          var otherOp = otherIter.next(opLength);\n          if (equal(thisOp.insert, otherOp.insert)) {\n            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));\n          } else {\n            delta.push(otherOp)['delete'](opLength);\n          }\n          break;\n      }\n      length -= opLength;\n    }\n  });\n  return delta.chop();\n};\n\nDelta.prototype.eachLine = function (predicate, newline) {\n  newline = newline || '\\n';\n  var iter = op.iterator(this.ops);\n  var line = new Delta();\n  var i = 0;\n  while (iter.hasNext()) {\n    if (iter.peekType() !== 'insert') return;\n    var thisOp = iter.peek();\n    var start = op.length(thisOp) - iter.peekLength();\n    var index = typeof thisOp.insert === 'string' ?\n      thisOp.insert.indexOf(newline, start) - start : -1;\n    if (index < 0) {\n      line.push(iter.next());\n    } else if (index > 0) {\n      line.push(iter.next(index));\n    } else {\n      if (predicate(line, iter.next(1).attributes || {}, i) === false) {\n        return;\n      }\n      i += 1;\n      line = new Delta();\n    }\n  }\n  if (line.length() > 0) {\n    predicate(line, {}, i);\n  }\n};\n\nDelta.prototype.transform = function (other, priority) {\n  priority = !!priority;\n  if (typeof other === 'number') {\n    return this.transformPosition(other, priority);\n  }\n  var thisIter = op.iterator(this.ops);\n  var otherIter = op.iterator(other.ops);\n  var delta = new Delta();\n  while (thisIter.hasNext() || otherIter.hasNext()) {\n    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {\n      delta.retain(op.length(thisIter.next()));\n    } else if (otherIter.peekType() === 'insert') {\n      delta.push(otherIter.next());\n    } else {\n      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());\n      var thisOp = thisIter.next(length);\n      var otherOp = otherIter.next(length);\n      if (thisOp['delete']) {\n        // Our delete either makes their delete redundant or removes their retain\n        continue;\n      } else if (otherOp['delete']) {\n        delta.push(otherOp);\n      } else {\n        // We retain either their retain or insert\n        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));\n      }\n    }\n  }\n  return delta.chop();\n};\n\nDelta.prototype.transformPosition = function (index, priority) {\n  priority = !!priority;\n  var thisIter = op.iterator(this.ops);\n  var offset = 0;\n  while (thisIter.hasNext() && offset <= index) {\n    var length = thisIter.peekLength();\n    var nextType = thisIter.peekType();\n    thisIter.next();\n    if (nextType === 'delete') {\n      index -= Math.min(length, index - offset);\n      continue;\n    } else if (nextType === 'insert' && (offset < index || !priority)) {\n      index += length;\n    }\n    offset += length;\n  }\n  return index;\n};\n\n\nmodule.exports = Delta;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n'use strict';\n\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toStr = Object.prototype.toString;\nvar defineProperty = Object.defineProperty;\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nvar isArray = function isArray(arr) {\n\tif (typeof Array.isArray === 'function') {\n\t\treturn Array.isArray(arr);\n\t}\n\n\treturn toStr.call(arr) === '[object Array]';\n};\n\nvar isPlainObject = function isPlainObject(obj) {\n\tif (!obj || toStr.call(obj) !== '[object Object]') {\n\t\treturn false;\n\t}\n\n\tvar hasOwnConstructor = hasOwn.call(obj, 'constructor');\n\tvar hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');\n\t// Not own constructor property must be Object\n\tif (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {\n\t\treturn false;\n\t}\n\n\t// Own properties are enumerated firstly, so to speed up,\n\t// if last one is own, then all properties are own.\n\tvar key;\n\tfor (key in obj) { /**/ }\n\n\treturn typeof key === 'undefined' || hasOwn.call(obj, key);\n};\n\n// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target\nvar setProperty = function setProperty(target, options) {\n\tif (defineProperty && options.name === '__proto__') {\n\t\tdefineProperty(target, options.name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t\tvalue: options.newValue,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\ttarget[options.name] = options.newValue;\n\t}\n};\n\n// Return undefined instead of __proto__ if '__proto__' is not an own property\nvar getProperty = function getProperty(obj, name) {\n\tif (name === '__proto__') {\n\t\tif (!hasOwn.call(obj, name)) {\n\t\t\treturn void 0;\n\t\t} else if (gOPD) {\n\t\t\t// In early versions of node, obj['__proto__'] is buggy when obj has\n\t\t\t// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.\n\t\t\treturn gOPD(obj, name).value;\n\t\t}\n\t}\n\n\treturn obj[name];\n};\n\nmodule.exports = function extend() {\n\tvar options, name, src, copy, copyIsArray, clone;\n\tvar target = arguments[0];\n\tvar i = 1;\n\tvar length = arguments.length;\n\tvar deep = false;\n\n\t// Handle a deep copy situation\n\tif (typeof target === 'boolean') {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\tif (target == null || (typeof target !== 'object' && typeof target !== 'function')) {\n\t\ttarget = {};\n\t}\n\n\tfor (; i < length; ++i) {\n\t\toptions = arguments[i];\n\t\t// Only deal with non-null/undefined values\n\t\tif (options != null) {\n\t\t\t// Extend the base object\n\t\t\tfor (name in options) {\n\t\t\t\tsrc = getProperty(target, name);\n\t\t\t\tcopy = getProperty(options, name);\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif (target !== copy) {\n\t\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\t\tif (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n\t\t\t\t\t\tif (copyIsArray) {\n\t\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\t\tclone = src && isArray(src) ? src : [];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclone = src && isPlainObject(src) ? src : {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: extend(deep, clone, copy) });\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t\t} else if (typeof copy !== 'undefined') {\n\t\t\t\t\t\tsetProperty(target, { name: name, newValue: copy });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.BlockEmbed = exports.bubbleFormats = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _extend = __webpack_require__(3);\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _break = __webpack_require__(16);\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _inline = __webpack_require__(6);\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _text = __webpack_require__(7);\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar NEWLINE_LENGTH = 1;\n\nvar BlockEmbed = function (_Parchment$Embed) {\n  _inherits(BlockEmbed, _Parchment$Embed);\n\n  function BlockEmbed() {\n    _classCallCheck(this, BlockEmbed);\n\n    return _possibleConstructorReturn(this, (BlockEmbed.__proto__ || Object.getPrototypeOf(BlockEmbed)).apply(this, arguments));\n  }\n\n  _createClass(BlockEmbed, [{\n    key: 'attach',\n    value: function attach() {\n      _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'attach', this).call(this);\n      this.attributes = new _parchment2.default.Attributor.Store(this.domNode);\n    }\n  }, {\n    key: 'delta',\n    value: function delta() {\n      return new _quillDelta2.default().insert(this.value(), (0, _extend2.default)(this.formats(), this.attributes.values()));\n    }\n  }, {\n    key: 'format',\n    value: function format(name, value) {\n      var attribute = _parchment2.default.query(name, _parchment2.default.Scope.BLOCK_ATTRIBUTE);\n      if (attribute != null) {\n        this.attributes.attribute(attribute, value);\n      }\n    }\n  }, {\n    key: 'formatAt',\n    value: function formatAt(index, length, name, value) {\n      this.format(name, value);\n    }\n  }, {\n    key: 'insertAt',\n    value: function insertAt(index, value, def) {\n      if (typeof value === 'string' && value.endsWith('\\n')) {\n        var block = _parchment2.default.create(Block.blotName);\n        this.parent.insertBefore(block, index === 0 ? this : this.next);\n        block.insertAt(0, value.slice(0, -1));\n      } else {\n        _get(BlockEmbed.prototype.__proto__ || Object.getPrototypeOf(BlockEmbed.prototype), 'insertAt', this).call(this, index, value, def);\n      }\n    }\n  }]);\n\n  return BlockEmbed;\n}(_parchment2.default.Embed);\n\nBlockEmbed.scope = _parchment2.default.Scope.BLOCK_BLOT;\n// It is important for cursor behavior BlockEmbeds use tags that are block level elements\n\n\nvar Block = function (_Parchment$Block) {\n  _inherits(Block, _Parchment$Block);\n\n  function Block(domNode) {\n    _classCallCheck(this, Block);\n\n    var _this2 = _possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).call(this, domNode));\n\n    _this2.cache = {};\n    return _this2;\n  }\n\n  _createClass(Block, [{\n    key: 'delta',\n    value: function delta() {\n      if (this.cache.delta == null) {\n        this.cache.delta = this.descendants(_parchment2.default.Leaf).reduce(function (delta, leaf) {\n          if (leaf.length() === 0) {\n            return delta;\n          } else {\n            return delta.insert(leaf.value(), bubbleFormats(leaf));\n          }\n        }, new _quillDelta2.default()).insert('\\n', bubbleFormats(this));\n      }\n      return this.cache.delta;\n    }\n  }, {\n    key: 'deleteAt',\n    value: function deleteAt(index, length) {\n      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'deleteAt', this).call(this, index, length);\n      this.cache = {};\n    }\n  }, {\n    key: 'formatAt',\n    value: function formatAt(index, length, name, value) {\n      if (length <= 0) return;\n      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n        if (index + length === this.length()) {\n          this.format(name, value);\n        }\n      } else {\n        _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'formatAt', this).call(this, index, Math.min(length, this.length() - index - 1), name, value);\n      }\n      this.cache = {};\n    }\n  }, {\n    key: 'insertAt',\n    value: function insertAt(index, value, def) {\n      if (def != null) return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, index, value, def);\n      if (value.length === 0) return;\n      var lines = value.split('\\n');\n      var text = lines.shift();\n      if (text.length > 0) {\n        if (index < this.length() - 1 || this.children.tail == null) {\n          _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertAt', this).call(this, Math.min(index, this.length() - 1), text);\n        } else {\n          this.children.tail.insertAt(this.children.tail.length(), text);\n        }\n        this.cache = {};\n      }\n      var block = this;\n      lines.reduce(function (index, line) {\n        block = block.split(index, true);\n        block.insertAt(0, line);\n        return line.length;\n      }, index + text.length);\n    }\n  }, {\n    key: 'insertBefore',\n    value: function insertBefore(blot, ref) {\n      var head = this.children.head;\n      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'insertBefore', this).call(this, blot, ref);\n      if (head instanceof _break2.default) {\n        head.remove();\n      }\n      this.cache = {};\n    }\n  }, {\n    key: 'length',\n    value: function length() {\n      if (this.cache.length == null) {\n        this.cache.length = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'length', this).call(this) + NEWLINE_LENGTH;\n      }\n      return this.cache.length;\n    }\n  }, {\n    key: 'moveChildren',\n    value: function moveChildren(target, ref) {\n      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'moveChildren', this).call(this, target, ref);\n      this.cache = {};\n    }\n  }, {\n    key: 'optimize',\n    value: function optimize(context) {\n      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'optimize', this).call(this, context);\n      this.cache = {};\n    }\n  }, {\n    key: 'path',\n    value: function path(index) {\n      return _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'path', this).call(this, index, true);\n    }\n  }, {\n    key: 'removeChild',\n    value: function removeChild(child) {\n      _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'removeChild', this).call(this, child);\n      this.cache = {};\n    }\n  }, {\n    key: 'split',\n    value: function split(index) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (force && (index === 0 || index >= this.length() - NEWLINE_LENGTH)) {\n        var clone = this.clone();\n        if (index === 0) {\n          this.parent.insertBefore(clone, this);\n          return this;\n        } else {\n          this.parent.insertBefore(clone, this.next);\n          return clone;\n        }\n      } else {\n        var next = _get(Block.prototype.__proto__ || Object.getPrototypeOf(Block.prototype), 'split', this).call(this, index, force);\n        this.cache = {};\n        return next;\n      }\n    }\n  }]);\n\n  return Block;\n}(_parchment2.default.Block);\n\nBlock.blotName = 'block';\nBlock.tagName = 'P';\nBlock.defaultChild = 'break';\nBlock.allowedChildren = [_inline2.default, _parchment2.default.Embed, _text2.default];\n\nfunction bubbleFormats(blot) {\n  var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (blot == null) return formats;\n  if (typeof blot.formats === 'function') {\n    formats = (0, _extend2.default)(formats, blot.formats());\n  }\n  if (blot.parent == null || blot.parent.blotName == 'scroll' || blot.parent.statics.scope !== blot.statics.scope) {\n    return formats;\n  }\n  return bubbleFormats(blot.parent, formats);\n}\n\nexports.bubbleFormats = bubbleFormats;\nexports.BlockEmbed = BlockEmbed;\nexports.default = Block;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.overload = exports.expandConfig = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(50);\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _editor = __webpack_require__(14);\n\nvar _editor2 = _interopRequireDefault(_editor);\n\nvar _emitter3 = __webpack_require__(8);\n\nvar _emitter4 = _interopRequireDefault(_emitter3);\n\nvar _module = __webpack_require__(9);\n\nvar _module2 = _interopRequireDefault(_module);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _selection = __webpack_require__(15);\n\nvar _selection2 = _interopRequireDefault(_selection);\n\nvar _extend = __webpack_require__(3);\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _logger = __webpack_require__(10);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _theme = __webpack_require__(34);\n\nvar _theme2 = _interopRequireDefault(_theme);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar debug = (0, _logger2.default)('quill');\n\nvar Quill = function () {\n  _createClass(Quill, null, [{\n    key: 'debug',\n    value: function debug(limit) {\n      if (limit === true) {\n        limit = 'log';\n      }\n      _logger2.default.level(limit);\n    }\n  }, {\n    key: 'find',\n    value: function find(node) {\n      return node.__quill || _parchment2.default.find(node);\n    }\n  }, {\n    key: 'import',\n    value: function _import(name) {\n      if (this.imports[name] == null) {\n        debug.error('Cannot import ' + name + '. Are you sure it was registered?');\n      }\n      return this.imports[name];\n    }\n  }, {\n    key: 'register',\n    value: function register(path, target) {\n      var _this = this;\n\n      var overwrite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (typeof path !== 'string') {\n        var name = path.attrName || path.blotName;\n        if (typeof name === 'string') {\n          // register(Blot | Attributor, overwrite)\n          this.register('formats/' + name, path, target);\n        } else {\n          Object.keys(path).forEach(function (key) {\n            _this.register(key, path[key], target);\n          });\n        }\n      } else {\n        if (this.imports[path] != null && !overwrite) {\n          debug.warn('Overwriting ' + path + ' with', target);\n        }\n        this.imports[path] = target;\n        if ((path.startsWith('blots/') || path.startsWith('formats/')) && target.blotName !== 'abstract') {\n          _parchment2.default.register(target);\n        } else if (path.startsWith('modules') && typeof target.register === 'function') {\n          target.register();\n        }\n      }\n    }\n  }]);\n\n  function Quill(container) {\n    var _this2 = this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Quill);\n\n    this.options = expandConfig(container, options);\n    this.container = this.options.container;\n    if (this.container == null) {\n      return debug.error('Invalid Quill container', container);\n    }\n    if (this.options.debug) {\n      Quill.debug(this.options.debug);\n    }\n    var html = this.container.innerHTML.trim();\n    this.container.classList.add('ql-container');\n    this.container.innerHTML = '';\n    this.container.__quill = this;\n    this.root = this.addContainer('ql-editor');\n    this.root.classList.add('ql-blank');\n    this.root.setAttribute('data-gramm', false);\n    this.scrollingContainer = this.options.scrollingContainer || this.root;\n    this.emitter = new _emitter4.default();\n    this.scroll = _parchment2.default.create(this.root, {\n      emitter: this.emitter,\n      whitelist: this.options.formats\n    });\n    this.editor = new _editor2.default(this.scroll);\n    this.selection = new _selection2.default(this.scroll, this.emitter);\n    this.theme = new this.options.theme(this, this.options);\n    this.keyboard = this.theme.addModule('keyboard');\n    this.clipboard = this.theme.addModule('clipboard');\n    this.history = this.theme.addModule('history');\n    this.theme.init();\n    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type) {\n      if (type === _emitter4.default.events.TEXT_CHANGE) {\n        _this2.root.classList.toggle('ql-blank', _this2.editor.isBlank());\n      }\n    });\n    this.emitter.on(_emitter4.default.events.SCROLL_UPDATE, function (source, mutations) {\n      var range = _this2.selection.lastRange;\n      var index = range && range.length === 0 ? range.index : undefined;\n      modify.call(_this2, function () {\n        return _this2.editor.update(null, mutations, index);\n      }, source);\n    });\n    var contents = this.clipboard.convert('<div class=\\'ql-editor\\' style=\"white-space: normal;\">' + html + '<p><br></p></div>');\n    this.setContents(contents);\n    this.history.clear();\n    if (this.options.placeholder) {\n      this.root.setAttribute('data-placeholder', this.options.placeholder);\n    }\n    if (this.options.readOnly) {\n      this.disable();\n    }\n  }\n\n  _createClass(Quill, [{\n    key: 'addContainer',\n    value: function addContainer(container) {\n      var refNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (typeof container === 'string') {\n        var className = container;\n        container = document.createElement('div');\n        container.classList.add(className);\n      }\n      this.container.insertBefore(container, refNode);\n      return container;\n    }\n  }, {\n    key: 'blur',\n    value: function blur() {\n      this.selection.setRange(null);\n    }\n  }, {\n    key: 'deleteText',\n    value: function deleteText(index, length, source) {\n      var _this3 = this;\n\n      var _overload = overload(index, length, source);\n\n      var _overload2 = _slicedToArray(_overload, 4);\n\n      index = _overload2[0];\n      length = _overload2[1];\n      source = _overload2[3];\n\n      return modify.call(this, function () {\n        return _this3.editor.deleteText(index, length);\n      }, source, index, -1 * length);\n    }\n  }, {\n    key: 'disable',\n    value: function disable() {\n      this.enable(false);\n    }\n  }, {\n    key: 'enable',\n    value: function enable() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this.scroll.enable(enabled);\n      this.container.classList.toggle('ql-disabled', !enabled);\n    }\n  }, {\n    key: 'focus',\n    value: function focus() {\n      var scrollTop = this.scrollingContainer.scrollTop;\n      this.selection.focus();\n      this.scrollingContainer.scrollTop = scrollTop;\n      this.scrollIntoView();\n    }\n  }, {\n    key: 'format',\n    value: function format(name, value) {\n      var _this4 = this;\n\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n\n      return modify.call(this, function () {\n        var range = _this4.getSelection(true);\n        var change = new _quillDelta2.default();\n        if (range == null) {\n          return change;\n        } else if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK)) {\n          change = _this4.editor.formatLine(range.index, range.length, _defineProperty({}, name, value));\n        } else if (range.length === 0) {\n          _this4.selection.format(name, value);\n          return change;\n        } else {\n          change = _this4.editor.formatText(range.index, range.length, _defineProperty({}, name, value));\n        }\n        _this4.setSelection(range, _emitter4.default.sources.SILENT);\n        return change;\n      }, source);\n    }\n  }, {\n    key: 'formatLine',\n    value: function formatLine(index, length, name, value, source) {\n      var _this5 = this;\n\n      var formats = void 0;\n\n      var _overload3 = overload(index, length, name, value, source);\n\n      var _overload4 = _slicedToArray(_overload3, 4);\n\n      index = _overload4[0];\n      length = _overload4[1];\n      formats = _overload4[2];\n      source = _overload4[3];\n\n      return modify.call(this, function () {\n        return _this5.editor.formatLine(index, length, formats);\n      }, source, index, 0);\n    }\n  }, {\n    key: 'formatText',\n    value: function formatText(index, length, name, value, source) {\n      var _this6 = this;\n\n      var formats = void 0;\n\n      var _overload5 = overload(index, length, name, value, source);\n\n      var _overload6 = _slicedToArray(_overload5, 4);\n\n      index = _overload6[0];\n      length = _overload6[1];\n      formats = _overload6[2];\n      source = _overload6[3];\n\n      return modify.call(this, function () {\n        return _this6.editor.formatText(index, length, formats);\n      }, source, index, 0);\n    }\n  }, {\n    key: 'getBounds',\n    value: function getBounds(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      var bounds = void 0;\n      if (typeof index === 'number') {\n        bounds = this.selection.getBounds(index, length);\n      } else {\n        bounds = this.selection.getBounds(index.index, index.length);\n      }\n      var containerBounds = this.container.getBoundingClientRect();\n      return {\n        bottom: bounds.bottom - containerBounds.top,\n        height: bounds.height,\n        left: bounds.left - containerBounds.left,\n        right: bounds.right - containerBounds.left,\n        top: bounds.top - containerBounds.top,\n        width: bounds.width\n      };\n    }\n  }, {\n    key: 'getContents',\n    value: function getContents() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n\n      var _overload7 = overload(index, length);\n\n      var _overload8 = _slicedToArray(_overload7, 2);\n\n      index = _overload8[0];\n      length = _overload8[1];\n\n      return this.editor.getContents(index, length);\n    }\n  }, {\n    key: 'getFormat',\n    value: function getFormat() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getSelection(true);\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      if (typeof index === 'number') {\n        return this.editor.getFormat(index, length);\n      } else {\n        return this.editor.getFormat(index.index, index.length);\n      }\n    }\n  }, {\n    key: 'getIndex',\n    value: function getIndex(blot) {\n      return blot.offset(this.scroll);\n    }\n  }, {\n    key: 'getLength',\n    value: function getLength() {\n      return this.scroll.length();\n    }\n  }, {\n    key: 'getLeaf',\n    value: function getLeaf(index) {\n      return this.scroll.leaf(index);\n    }\n  }, {\n    key: 'getLine',\n    value: function getLine(index) {\n      return this.scroll.line(index);\n    }\n  }, {\n    key: 'getLines',\n    value: function getLines() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n\n      if (typeof index !== 'number') {\n        return this.scroll.lines(index.index, index.length);\n      } else {\n        return this.scroll.lines(index, length);\n      }\n    }\n  }, {\n    key: 'getModule',\n    value: function getModule(name) {\n      return this.theme.modules[name];\n    }\n  }, {\n    key: 'getSelection',\n    value: function getSelection() {\n      var focus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (focus) this.focus();\n      this.update(); // Make sure we access getRange with editor in consistent state\n      return this.selection.getRange()[0];\n    }\n  }, {\n    key: 'getText',\n    value: function getText() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getLength() - index;\n\n      var _overload9 = overload(index, length);\n\n      var _overload10 = _slicedToArray(_overload9, 2);\n\n      index = _overload10[0];\n      length = _overload10[1];\n\n      return this.editor.getText(index, length);\n    }\n  }, {\n    key: 'hasFocus',\n    value: function hasFocus() {\n      return this.selection.hasFocus();\n    }\n  }, {\n    key: 'insertEmbed',\n    value: function insertEmbed(index, embed, value) {\n      var _this7 = this;\n\n      var source = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Quill.sources.API;\n\n      return modify.call(this, function () {\n        return _this7.editor.insertEmbed(index, embed, value);\n      }, source, index);\n    }\n  }, {\n    key: 'insertText',\n    value: function insertText(index, text, name, value, source) {\n      var _this8 = this;\n\n      var formats = void 0;\n\n      var _overload11 = overload(index, 0, name, value, source);\n\n      var _overload12 = _slicedToArray(_overload11, 4);\n\n      index = _overload12[0];\n      formats = _overload12[2];\n      source = _overload12[3];\n\n      return modify.call(this, function () {\n        return _this8.editor.insertText(index, text, formats);\n      }, source, index, text.length);\n    }\n  }, {\n    key: 'isEnabled',\n    value: function isEnabled() {\n      return !this.container.classList.contains('ql-disabled');\n    }\n  }, {\n    key: 'off',\n    value: function off() {\n      return this.emitter.off.apply(this.emitter, arguments);\n    }\n  }, {\n    key: 'on',\n    value: function on() {\n      return this.emitter.on.apply(this.emitter, arguments);\n    }\n  }, {\n    key: 'once',\n    value: function once() {\n      return this.emitter.once.apply(this.emitter, arguments);\n    }\n  }, {\n    key: 'pasteHTML',\n    value: function pasteHTML(index, html, source) {\n      this.clipboard.dangerouslyPasteHTML(index, html, source);\n    }\n  }, {\n    key: 'removeFormat',\n    value: function removeFormat(index, length, source) {\n      var _this9 = this;\n\n      var _overload13 = overload(index, length, source);\n\n      var _overload14 = _slicedToArray(_overload13, 4);\n\n      index = _overload14[0];\n      length = _overload14[1];\n      source = _overload14[3];\n\n      return modify.call(this, function () {\n        return _this9.editor.removeFormat(index, length);\n      }, source, index);\n    }\n  }, {\n    key: 'scrollIntoView',\n    value: function scrollIntoView() {\n      this.selection.scrollIntoView(this.scrollingContainer);\n    }\n  }, {\n    key: 'setContents',\n    value: function setContents(delta) {\n      var _this10 = this;\n\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n\n      return modify.call(this, function () {\n        delta = new _quillDelta2.default(delta);\n        var length = _this10.getLength();\n        var deleted = _this10.editor.deleteText(0, length);\n        var applied = _this10.editor.applyDelta(delta);\n        var lastOp = applied.ops[applied.ops.length - 1];\n        if (lastOp != null && typeof lastOp.insert === 'string' && lastOp.insert[lastOp.insert.length - 1] === '\\n') {\n          _this10.editor.deleteText(_this10.getLength() - 1, 1);\n          applied.delete(1);\n        }\n        var ret = deleted.compose(applied);\n        return ret;\n      }, source);\n    }\n  }, {\n    key: 'setSelection',\n    value: function setSelection(index, length, source) {\n      if (index == null) {\n        this.selection.setRange(null, length || Quill.sources.API);\n      } else {\n        var _overload15 = overload(index, length, source);\n\n        var _overload16 = _slicedToArray(_overload15, 4);\n\n        index = _overload16[0];\n        length = _overload16[1];\n        source = _overload16[3];\n\n        this.selection.setRange(new _selection.Range(index, length), source);\n        if (source !== _emitter4.default.sources.SILENT) {\n          this.selection.scrollIntoView(this.scrollingContainer);\n        }\n      }\n    }\n  }, {\n    key: 'setText',\n    value: function setText(text) {\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n\n      var delta = new _quillDelta2.default().insert(text);\n      return this.setContents(delta, source);\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n\n      var change = this.scroll.update(source); // Will update selection before selection.update() does if text changes\n      this.selection.update(source);\n      return change;\n    }\n  }, {\n    key: 'updateContents',\n    value: function updateContents(delta) {\n      var _this11 = this;\n\n      var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _emitter4.default.sources.API;\n\n      return modify.call(this, function () {\n        delta = new _quillDelta2.default(delta);\n        return _this11.editor.applyDelta(delta, source);\n      }, source, true);\n    }\n  }]);\n\n  return Quill;\n}();\n\nQuill.DEFAULTS = {\n  bounds: null,\n  formats: null,\n  modules: {},\n  placeholder: '',\n  readOnly: false,\n  scrollingContainer: null,\n  strict: true,\n  theme: 'default'\n};\nQuill.events = _emitter4.default.events;\nQuill.sources = _emitter4.default.sources;\n// eslint-disable-next-line no-undef\nQuill.version =  false ? 'dev' : \"1.3.7\";\n\nQuill.imports = {\n  'delta': _quillDelta2.default,\n  'parchment': _parchment2.default,\n  'core/module': _module2.default,\n  'core/theme': _theme2.default\n};\n\nfunction expandConfig(container, userConfig) {\n  userConfig = (0, _extend2.default)(true, {\n    container: container,\n    modules: {\n      clipboard: true,\n      keyboard: true,\n      history: true\n    }\n  }, userConfig);\n  if (!userConfig.theme || userConfig.theme === Quill.DEFAULTS.theme) {\n    userConfig.theme = _theme2.default;\n  } else {\n    userConfig.theme = Quill.import('themes/' + userConfig.theme);\n    if (userConfig.theme == null) {\n      throw new Error('Invalid theme ' + userConfig.theme + '. Did you register it?');\n    }\n  }\n  var themeConfig = (0, _extend2.default)(true, {}, userConfig.theme.DEFAULTS);\n  [themeConfig, userConfig].forEach(function (config) {\n    config.modules = config.modules || {};\n    Object.keys(config.modules).forEach(function (module) {\n      if (config.modules[module] === true) {\n        config.modules[module] = {};\n      }\n    });\n  });\n  var moduleNames = Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));\n  var moduleConfig = moduleNames.reduce(function (config, name) {\n    var moduleClass = Quill.import('modules/' + name);\n    if (moduleClass == null) {\n      debug.error('Cannot load ' + name + ' module. Are you sure you registered it?');\n    } else {\n      config[name] = moduleClass.DEFAULTS || {};\n    }\n    return config;\n  }, {});\n  // Special case toolbar shorthand\n  if (userConfig.modules != null && userConfig.modules.toolbar && userConfig.modules.toolbar.constructor !== Object) {\n    userConfig.modules.toolbar = {\n      container: userConfig.modules.toolbar\n    };\n  }\n  userConfig = (0, _extend2.default)(true, {}, Quill.DEFAULTS, { modules: moduleConfig }, themeConfig, userConfig);\n  ['bounds', 'container', 'scrollingContainer'].forEach(function (key) {\n    if (typeof userConfig[key] === 'string') {\n      userConfig[key] = document.querySelector(userConfig[key]);\n    }\n  });\n  userConfig.modules = Object.keys(userConfig.modules).reduce(function (config, name) {\n    if (userConfig.modules[name]) {\n      config[name] = userConfig.modules[name];\n    }\n    return config;\n  }, {});\n  return userConfig;\n}\n\n// Handle selection preservation and TEXT_CHANGE emission\n// common to modification APIs\nfunction modify(modifier, source, index, shift) {\n  if (this.options.strict && !this.isEnabled() && source === _emitter4.default.sources.USER) {\n    return new _quillDelta2.default();\n  }\n  var range = index == null ? null : this.getSelection();\n  var oldDelta = this.editor.delta;\n  var change = modifier();\n  if (range != null) {\n    if (index === true) index = range.index;\n    if (shift == null) {\n      range = shiftRange(range, change, source);\n    } else if (shift !== 0) {\n      range = shiftRange(range, index, shift, source);\n    }\n    this.setSelection(range, _emitter4.default.sources.SILENT);\n  }\n  if (change.length() > 0) {\n    var _emitter;\n\n    var args = [_emitter4.default.events.TEXT_CHANGE, change, oldDelta, source];\n    (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));\n    if (source !== _emitter4.default.sources.SILENT) {\n      var _emitter2;\n\n      (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n    }\n  }\n  return change;\n}\n\nfunction overload(index, length, name, value, source) {\n  var formats = {};\n  if (typeof index.index === 'number' && typeof index.length === 'number') {\n    // Allow for throwaway end (used by insertText/insertEmbed)\n    if (typeof length !== 'number') {\n      source = value, value = name, name = length, length = index.length, index = index.index;\n    } else {\n      length = index.length, index = index.index;\n    }\n  } else if (typeof length !== 'number') {\n    source = value, value = name, name = length, length = 0;\n  }\n  // Handle format being object, two format name/value strings or excluded\n  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n    formats = name;\n    source = value;\n  } else if (typeof name === 'string') {\n    if (value != null) {\n      formats[name] = value;\n    } else {\n      source = name;\n    }\n  }\n  // Handle optional source\n  source = source || _emitter4.default.sources.API;\n  return [index, length, formats, source];\n}\n\nfunction shiftRange(range, index, length, source) {\n  if (range == null) return null;\n  var start = void 0,\n      end = void 0;\n  if (index instanceof _quillDelta2.default) {\n    var _map = [range.index, range.index + range.length].map(function (pos) {\n      return index.transformPosition(pos, source !== _emitter4.default.sources.USER);\n    });\n\n    var _map2 = _slicedToArray(_map, 2);\n\n    start = _map2[0];\n    end = _map2[1];\n  } else {\n    var _map3 = [range.index, range.index + range.length].map(function (pos) {\n      if (pos < index || pos === index && source === _emitter4.default.sources.USER) return pos;\n      if (length >= 0) {\n        return pos + length;\n      } else {\n        return Math.max(index, pos + length);\n      }\n    });\n\n    var _map4 = _slicedToArray(_map3, 2);\n\n    start = _map4[0];\n    end = _map4[1];\n  }\n  return new _selection.Range(start, end - start);\n}\n\nexports.expandConfig = expandConfig;\nexports.overload = overload;\nexports.default = Quill;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _text = __webpack_require__(7);\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Inline = function (_Parchment$Inline) {\n  _inherits(Inline, _Parchment$Inline);\n\n  function Inline() {\n    _classCallCheck(this, Inline);\n\n    return _possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  _createClass(Inline, [{\n    key: 'formatAt',\n    value: function formatAt(index, length, name, value) {\n      if (Inline.compare(this.statics.blotName, name) < 0 && _parchment2.default.query(name, _parchment2.default.Scope.BLOT)) {\n        var blot = this.isolate(index, length);\n        if (value) {\n          blot.wrap(name, value);\n        }\n      } else {\n        _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'formatAt', this).call(this, index, length, name, value);\n      }\n    }\n  }, {\n    key: 'optimize',\n    value: function optimize(context) {\n      _get(Inline.prototype.__proto__ || Object.getPrototypeOf(Inline.prototype), 'optimize', this).call(this, context);\n      if (this.parent instanceof Inline && Inline.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {\n        var parent = this.parent.isolate(this.offset(), this.length());\n        this.moveChildren(parent);\n        parent.wrap(this);\n      }\n    }\n  }], [{\n    key: 'compare',\n    value: function compare(self, other) {\n      var selfIndex = Inline.order.indexOf(self);\n      var otherIndex = Inline.order.indexOf(other);\n      if (selfIndex >= 0 || otherIndex >= 0) {\n        return selfIndex - otherIndex;\n      } else if (self === other) {\n        return 0;\n      } else if (self < other) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n  }]);\n\n  return Inline;\n}(_parchment2.default.Inline);\n\nInline.allowedChildren = [Inline, _parchment2.default.Embed, _text2.default];\n// Lower index means deeper in the DOM tree, since not found (-1) is for embeds\nInline.order = ['cursor', 'inline', // Must be lower\n'underline', 'strike', 'italic', 'bold', 'script', 'link', 'code' // Must be higher\n];\n\nexports.default = Inline;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TextBlot = function (_Parchment$Text) {\n  _inherits(TextBlot, _Parchment$Text);\n\n  function TextBlot() {\n    _classCallCheck(this, TextBlot);\n\n    return _possibleConstructorReturn(this, (TextBlot.__proto__ || Object.getPrototypeOf(TextBlot)).apply(this, arguments));\n  }\n\n  return TextBlot;\n}(_parchment2.default.Text);\n\nexports.default = TextBlot;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _eventemitter = __webpack_require__(54);\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nvar _logger = __webpack_require__(10);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar debug = (0, _logger2.default)('quill:events');\n\nvar EVENTS = ['selectionchange', 'mousedown', 'mouseup', 'click'];\n\nEVENTS.forEach(function (eventName) {\n  document.addEventListener(eventName, function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    [].slice.call(document.querySelectorAll('.ql-container')).forEach(function (node) {\n      // TODO use WeakMap\n      if (node.__quill && node.__quill.emitter) {\n        var _node$__quill$emitter;\n\n        (_node$__quill$emitter = node.__quill.emitter).handleDOM.apply(_node$__quill$emitter, args);\n      }\n    });\n  });\n});\n\nvar Emitter = function (_EventEmitter) {\n  _inherits(Emitter, _EventEmitter);\n\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n\n    var _this = _possibleConstructorReturn(this, (Emitter.__proto__ || Object.getPrototypeOf(Emitter)).call(this));\n\n    _this.listeners = {};\n    _this.on('error', debug.error);\n    return _this;\n  }\n\n  _createClass(Emitter, [{\n    key: 'emit',\n    value: function emit() {\n      debug.log.apply(debug, arguments);\n      _get(Emitter.prototype.__proto__ || Object.getPrototypeOf(Emitter.prototype), 'emit', this).apply(this, arguments);\n    }\n  }, {\n    key: 'handleDOM',\n    value: function handleDOM(event) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      (this.listeners[event.type] || []).forEach(function (_ref) {\n        var node = _ref.node,\n            handler = _ref.handler;\n\n        if (event.target === node || node.contains(event.target)) {\n          handler.apply(undefined, [event].concat(args));\n        }\n      });\n    }\n  }, {\n    key: 'listenDOM',\n    value: function listenDOM(eventName, node, handler) {\n      if (!this.listeners[eventName]) {\n        this.listeners[eventName] = [];\n      }\n      this.listeners[eventName].push({ node: node, handler: handler });\n    }\n  }]);\n\n  return Emitter;\n}(_eventemitter2.default);\n\nEmitter.events = {\n  EDITOR_CHANGE: 'editor-change',\n  SCROLL_BEFORE_UPDATE: 'scroll-before-update',\n  SCROLL_OPTIMIZE: 'scroll-optimize',\n  SCROLL_UPDATE: 'scroll-update',\n  SELECTION_CHANGE: 'selection-change',\n  TEXT_CHANGE: 'text-change'\n};\nEmitter.sources = {\n  API: 'api',\n  SILENT: 'silent',\n  USER: 'user'\n};\n\nexports.default = Emitter;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Module = function Module(quill) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  _classCallCheck(this, Module);\n\n  this.quill = quill;\n  this.options = options;\n};\n\nModule.DEFAULTS = {};\n\nexports.default = Module;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar levels = ['error', 'warn', 'log', 'info'];\nvar level = 'warn';\n\nfunction debug(method) {\n  if (levels.indexOf(method) <= levels.indexOf(level)) {\n    var _console;\n\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    (_console = console)[method].apply(_console, args); // eslint-disable-line no-console\n  }\n}\n\nfunction namespace(ns) {\n  return levels.reduce(function (logger, method) {\n    logger[method] = debug.bind(console, method, ns);\n    return logger;\n  }, {});\n}\n\ndebug.level = namespace.level = function (newLevel) {\n  level = newLevel;\n};\n\nexports.default = namespace;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar pSlice = Array.prototype.slice;\nvar objectKeys = __webpack_require__(52);\nvar isArguments = __webpack_require__(53);\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Registry = __webpack_require__(1);\nvar Attributor = /** @class */ (function () {\n    function Attributor(attrName, keyName, options) {\n        if (options === void 0) { options = {}; }\n        this.attrName = attrName;\n        this.keyName = keyName;\n        var attributeBit = Registry.Scope.TYPE & Registry.Scope.ATTRIBUTE;\n        if (options.scope != null) {\n            // Ignore type bits, force attribute bit\n            this.scope = (options.scope & Registry.Scope.LEVEL) | attributeBit;\n        }\n        else {\n            this.scope = Registry.Scope.ATTRIBUTE;\n        }\n        if (options.whitelist != null)\n            this.whitelist = options.whitelist;\n    }\n    Attributor.keys = function (node) {\n        return [].map.call(node.attributes, function (item) {\n            return item.name;\n        });\n    };\n    Attributor.prototype.add = function (node, value) {\n        if (!this.canAdd(node, value))\n            return false;\n        node.setAttribute(this.keyName, value);\n        return true;\n    };\n    Attributor.prototype.canAdd = function (node, value) {\n        var match = Registry.query(node, Registry.Scope.BLOT & (this.scope | Registry.Scope.TYPE));\n        if (match == null)\n            return false;\n        if (this.whitelist == null)\n            return true;\n        if (typeof value === 'string') {\n            return this.whitelist.indexOf(value.replace(/[\"']/g, '')) > -1;\n        }\n        else {\n            return this.whitelist.indexOf(value) > -1;\n        }\n    };\n    Attributor.prototype.remove = function (node) {\n        node.removeAttribute(this.keyName);\n    };\n    Attributor.prototype.value = function (node) {\n        var value = node.getAttribute(this.keyName);\n        if (this.canAdd(node, value) && value) {\n            return value;\n        }\n        return '';\n    };\n    return Attributor;\n}());\nexports.default = Attributor;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Code = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _block = __webpack_require__(4);\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _inline = __webpack_require__(6);\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _text = __webpack_require__(7);\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Code = function (_Inline) {\n  _inherits(Code, _Inline);\n\n  function Code() {\n    _classCallCheck(this, Code);\n\n    return _possibleConstructorReturn(this, (Code.__proto__ || Object.getPrototypeOf(Code)).apply(this, arguments));\n  }\n\n  return Code;\n}(_inline2.default);\n\nCode.blotName = 'code';\nCode.tagName = 'CODE';\n\nvar CodeBlock = function (_Block) {\n  _inherits(CodeBlock, _Block);\n\n  function CodeBlock() {\n    _classCallCheck(this, CodeBlock);\n\n    return _possibleConstructorReturn(this, (CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock)).apply(this, arguments));\n  }\n\n  _createClass(CodeBlock, [{\n    key: 'delta',\n    value: function delta() {\n      var _this3 = this;\n\n      var text = this.domNode.textContent;\n      if (text.endsWith('\\n')) {\n        // Should always be true\n        text = text.slice(0, -1);\n      }\n      return text.split('\\n').reduce(function (delta, frag) {\n        return delta.insert(frag).insert('\\n', _this3.formats());\n      }, new _quillDelta2.default());\n    }\n  }, {\n    key: 'format',\n    value: function format(name, value) {\n      if (name === this.statics.blotName && value) return;\n\n      var _descendant = this.descendant(_text2.default, this.length() - 1),\n          _descendant2 = _slicedToArray(_descendant, 1),\n          text = _descendant2[0];\n\n      if (text != null) {\n        text.deleteAt(text.length() - 1, 1);\n      }\n      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'format', this).call(this, name, value);\n    }\n  }, {\n    key: 'formatAt',\n    value: function formatAt(index, length, name, value) {\n      if (length === 0) return;\n      if (_parchment2.default.query(name, _parchment2.default.Scope.BLOCK) == null || name === this.statics.blotName && value === this.statics.formats(this.domNode)) {\n        return;\n      }\n      var nextNewline = this.newlineIndex(index);\n      if (nextNewline < 0 || nextNewline >= index + length) return;\n      var prevNewline = this.newlineIndex(index, true) + 1;\n      var isolateLength = nextNewline - prevNewline + 1;\n      var blot = this.isolate(prevNewline, isolateLength);\n      var next = blot.next;\n      blot.format(name, value);\n      if (next instanceof CodeBlock) {\n        next.formatAt(0, index - prevNewline + length - isolateLength, name, value);\n      }\n    }\n  }, {\n    key: 'insertAt',\n    value: function insertAt(index, value, def) {\n      if (def != null) return;\n\n      var _descendant3 = this.descendant(_text2.default, index),\n          _descendant4 = _slicedToArray(_descendant3, 2),\n          text = _descendant4[0],\n          offset = _descendant4[1];\n\n      text.insertAt(offset, value);\n    }\n  }, {\n    key: 'length',\n    value: function length() {\n      var length = this.domNode.textContent.length;\n      if (!this.domNode.textContent.endsWith('\\n')) {\n        return length + 1;\n      }\n      return length;\n    }\n  }, {\n    key: 'newlineIndex',\n    value: function newlineIndex(searchIndex) {\n      var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!reverse) {\n        var offset = this.domNode.textContent.slice(searchIndex).indexOf('\\n');\n        return offset > -1 ? searchIndex + offset : -1;\n      } else {\n        return this.domNode.textContent.slice(0, searchIndex).lastIndexOf('\\n');\n      }\n    }\n  }, {\n    key: 'optimize',\n    value: function optimize(context) {\n      if (!this.domNode.textContent.endsWith('\\n')) {\n        this.appendChild(_parchment2.default.create('text', '\\n'));\n      }\n      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'optimize', this).call(this, context);\n      var next = this.next;\n      if (next != null && next.prev === this && next.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === next.statics.formats(next.domNode)) {\n        next.optimize(context);\n        next.moveChildren(this);\n        next.remove();\n      }\n    }\n  }, {\n    key: 'replace',\n    value: function replace(target) {\n      _get(CodeBlock.prototype.__proto__ || Object.getPrototypeOf(CodeBlock.prototype), 'replace', this).call(this, target);\n      [].slice.call(this.domNode.querySelectorAll('*')).forEach(function (node) {\n        var blot = _parchment2.default.find(node);\n        if (blot == null) {\n          node.parentNode.removeChild(node);\n        } else if (blot instanceof _parchment2.default.Embed) {\n          blot.remove();\n        } else {\n          blot.unwrap();\n        }\n      });\n    }\n  }], [{\n    key: 'create',\n    value: function create(value) {\n      var domNode = _get(CodeBlock.__proto__ || Object.getPrototypeOf(CodeBlock), 'create', this).call(this, value);\n      domNode.setAttribute('spellcheck', false);\n      return domNode;\n    }\n  }, {\n    key: 'formats',\n    value: function formats() {\n      return true;\n    }\n  }]);\n\n  return CodeBlock;\n}(_block2.default);\n\nCodeBlock.blotName = 'code-block';\nCodeBlock.tagName = 'PRE';\nCodeBlock.TAB = '  ';\n\nexports.Code = Code;\nexports.default = CodeBlock;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _op = __webpack_require__(20);\n\nvar _op2 = _interopRequireDefault(_op);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _code = __webpack_require__(13);\n\nvar _code2 = _interopRequireDefault(_code);\n\nvar _cursor = __webpack_require__(24);\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _block = __webpack_require__(4);\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _break = __webpack_require__(16);\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _clone = __webpack_require__(21);\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _deepEqual = __webpack_require__(11);\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _extend = __webpack_require__(3);\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ASCII = /^[ -~]*$/;\n\nvar Editor = function () {\n  function Editor(scroll) {\n    _classCallCheck(this, Editor);\n\n    this.scroll = scroll;\n    this.delta = this.getDelta();\n  }\n\n  _createClass(Editor, [{\n    key: 'applyDelta',\n    value: function applyDelta(delta) {\n      var _this = this;\n\n      var consumeNextNewline = false;\n      this.scroll.update();\n      var scrollLength = this.scroll.length();\n      this.scroll.batchStart();\n      delta = normalizeDelta(delta);\n      delta.reduce(function (index, op) {\n        var length = op.retain || op.delete || op.insert.length || 1;\n        var attributes = op.attributes || {};\n        if (op.insert != null) {\n          if (typeof op.insert === 'string') {\n            var text = op.insert;\n            if (text.endsWith('\\n') && consumeNextNewline) {\n              consumeNextNewline = false;\n              text = text.slice(0, -1);\n            }\n            if (index >= scrollLength && !text.endsWith('\\n')) {\n              consumeNextNewline = true;\n            }\n            _this.scroll.insertAt(index, text);\n\n            var _scroll$line = _this.scroll.line(index),\n                _scroll$line2 = _slicedToArray(_scroll$line, 2),\n                line = _scroll$line2[0],\n                offset = _scroll$line2[1];\n\n            var formats = (0, _extend2.default)({}, (0, _block.bubbleFormats)(line));\n            if (line instanceof _block2.default) {\n              var _line$descendant = line.descendant(_parchment2.default.Leaf, offset),\n                  _line$descendant2 = _slicedToArray(_line$descendant, 1),\n                  leaf = _line$descendant2[0];\n\n              formats = (0, _extend2.default)(formats, (0, _block.bubbleFormats)(leaf));\n            }\n            attributes = _op2.default.attributes.diff(formats, attributes) || {};\n          } else if (_typeof(op.insert) === 'object') {\n            var key = Object.keys(op.insert)[0]; // There should only be one key\n            if (key == null) return index;\n            _this.scroll.insertAt(index, key, op.insert[key]);\n          }\n          scrollLength += length;\n        }\n        Object.keys(attributes).forEach(function (name) {\n          _this.scroll.formatAt(index, length, name, attributes[name]);\n        });\n        return index + length;\n      }, 0);\n      delta.reduce(function (index, op) {\n        if (typeof op.delete === 'number') {\n          _this.scroll.deleteAt(index, op.delete);\n          return index;\n        }\n        return index + (op.retain || op.insert.length || 1);\n      }, 0);\n      this.scroll.batchEnd();\n      return this.update(delta);\n    }\n  }, {\n    key: 'deleteText',\n    value: function deleteText(index, length) {\n      this.scroll.deleteAt(index, length);\n      return this.update(new _quillDelta2.default().retain(index).delete(length));\n    }\n  }, {\n    key: 'formatLine',\n    value: function formatLine(index, length) {\n      var _this2 = this;\n\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      this.scroll.update();\n      Object.keys(formats).forEach(function (format) {\n        if (_this2.scroll.whitelist != null && !_this2.scroll.whitelist[format]) return;\n        var lines = _this2.scroll.lines(index, Math.max(length, 1));\n        var lengthRemaining = length;\n        lines.forEach(function (line) {\n          var lineLength = line.length();\n          if (!(line instanceof _code2.default)) {\n            line.format(format, formats[format]);\n          } else {\n            var codeIndex = index - line.offset(_this2.scroll);\n            var codeLength = line.newlineIndex(codeIndex + lengthRemaining) - codeIndex + 1;\n            line.formatAt(codeIndex, codeLength, format, formats[format]);\n          }\n          lengthRemaining -= lineLength;\n        });\n      });\n      this.scroll.optimize();\n      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n    }\n  }, {\n    key: 'formatText',\n    value: function formatText(index, length) {\n      var _this3 = this;\n\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      Object.keys(formats).forEach(function (format) {\n        _this3.scroll.formatAt(index, length, format, formats[format]);\n      });\n      return this.update(new _quillDelta2.default().retain(index).retain(length, (0, _clone2.default)(formats)));\n    }\n  }, {\n    key: 'getContents',\n    value: function getContents(index, length) {\n      return this.delta.slice(index, index + length);\n    }\n  }, {\n    key: 'getDelta',\n    value: function getDelta() {\n      return this.scroll.lines().reduce(function (delta, line) {\n        return delta.concat(line.delta());\n      }, new _quillDelta2.default());\n    }\n  }, {\n    key: 'getFormat',\n    value: function getFormat(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      var lines = [],\n          leaves = [];\n      if (length === 0) {\n        this.scroll.path(index).forEach(function (path) {\n          var _path = _slicedToArray(path, 1),\n              blot = _path[0];\n\n          if (blot instanceof _block2.default) {\n            lines.push(blot);\n          } else if (blot instanceof _parchment2.default.Leaf) {\n            leaves.push(blot);\n          }\n        });\n      } else {\n        lines = this.scroll.lines(index, length);\n        leaves = this.scroll.descendants(_parchment2.default.Leaf, index, length);\n      }\n      var formatsArr = [lines, leaves].map(function (blots) {\n        if (blots.length === 0) return {};\n        var formats = (0, _block.bubbleFormats)(blots.shift());\n        while (Object.keys(formats).length > 0) {\n          var blot = blots.shift();\n          if (blot == null) return formats;\n          formats = combineFormats((0, _block.bubbleFormats)(blot), formats);\n        }\n        return formats;\n      });\n      return _extend2.default.apply(_extend2.default, formatsArr);\n    }\n  }, {\n    key: 'getText',\n    value: function getText(index, length) {\n      return this.getContents(index, length).filter(function (op) {\n        return typeof op.insert === 'string';\n      }).map(function (op) {\n        return op.insert;\n      }).join('');\n    }\n  }, {\n    key: 'insertEmbed',\n    value: function insertEmbed(index, embed, value) {\n      this.scroll.insertAt(index, embed, value);\n      return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({}, embed, value)));\n    }\n  }, {\n    key: 'insertText',\n    value: function insertText(index, text) {\n      var _this4 = this;\n\n      var formats = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      this.scroll.insertAt(index, text);\n      Object.keys(formats).forEach(function (format) {\n        _this4.scroll.formatAt(index, text.length, format, formats[format]);\n      });\n      return this.update(new _quillDelta2.default().retain(index).insert(text, (0, _clone2.default)(formats)));\n    }\n  }, {\n    key: 'isBlank',\n    value: function isBlank() {\n      if (this.scroll.children.length == 0) return true;\n      if (this.scroll.children.length > 1) return false;\n      var block = this.scroll.children.head;\n      if (block.statics.blotName !== _block2.default.blotName) return false;\n      if (block.children.length > 1) return false;\n      return block.children.head instanceof _break2.default;\n    }\n  }, {\n    key: 'removeFormat',\n    value: function removeFormat(index, length) {\n      var text = this.getText(index, length);\n\n      var _scroll$line3 = this.scroll.line(index + length),\n          _scroll$line4 = _slicedToArray(_scroll$line3, 2),\n          line = _scroll$line4[0],\n          offset = _scroll$line4[1];\n\n      var suffixLength = 0,\n          suffix = new _quillDelta2.default();\n      if (line != null) {\n        if (!(line instanceof _code2.default)) {\n          suffixLength = line.length() - offset;\n        } else {\n          suffixLength = line.newlineIndex(offset) - offset + 1;\n        }\n        suffix = line.delta().slice(offset, offset + suffixLength - 1).insert('\\n');\n      }\n      var contents = this.getContents(index, length + suffixLength);\n      var diff = contents.diff(new _quillDelta2.default().insert(text).concat(suffix));\n      var delta = new _quillDelta2.default().retain(index).concat(diff);\n      return this.applyDelta(delta);\n    }\n  }, {\n    key: 'update',\n    value: function update(change) {\n      var mutations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var cursorIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n      var oldDelta = this.delta;\n      if (mutations.length === 1 && mutations[0].type === 'characterData' && mutations[0].target.data.match(ASCII) && _parchment2.default.find(mutations[0].target)) {\n        // Optimization for character changes\n        var textBlot = _parchment2.default.find(mutations[0].target);\n        var formats = (0, _block.bubbleFormats)(textBlot);\n        var index = textBlot.offset(this.scroll);\n        var oldValue = mutations[0].oldValue.replace(_cursor2.default.CONTENTS, '');\n        var oldText = new _quillDelta2.default().insert(oldValue);\n        var newText = new _quillDelta2.default().insert(textBlot.value());\n        var diffDelta = new _quillDelta2.default().retain(index).concat(oldText.diff(newText, cursorIndex));\n        change = diffDelta.reduce(function (delta, op) {\n          if (op.insert) {\n            return delta.insert(op.insert, formats);\n          } else {\n            return delta.push(op);\n          }\n        }, new _quillDelta2.default());\n        this.delta = oldDelta.compose(change);\n      } else {\n        this.delta = this.getDelta();\n        if (!change || !(0, _deepEqual2.default)(oldDelta.compose(change), this.delta)) {\n          change = oldDelta.diff(this.delta, cursorIndex);\n        }\n      }\n      return change;\n    }\n  }]);\n\n  return Editor;\n}();\n\nfunction combineFormats(formats, combined) {\n  return Object.keys(combined).reduce(function (merged, name) {\n    if (formats[name] == null) return merged;\n    if (combined[name] === formats[name]) {\n      merged[name] = combined[name];\n    } else if (Array.isArray(combined[name])) {\n      if (combined[name].indexOf(formats[name]) < 0) {\n        merged[name] = combined[name].concat([formats[name]]);\n      }\n    } else {\n      merged[name] = [combined[name], formats[name]];\n    }\n    return merged;\n  }, {});\n}\n\nfunction normalizeDelta(delta) {\n  return delta.reduce(function (delta, op) {\n    if (op.insert === 1) {\n      var attributes = (0, _clone2.default)(op.attributes);\n      delete attributes['image'];\n      return delta.insert({ image: op.attributes.image }, attributes);\n    }\n    if (op.attributes != null && (op.attributes.list === true || op.attributes.bullet === true)) {\n      op = (0, _clone2.default)(op);\n      if (op.attributes.list) {\n        op.attributes.list = 'ordered';\n      } else {\n        op.attributes.list = 'bullet';\n        delete op.attributes.bullet;\n      }\n    }\n    if (typeof op.insert === 'string') {\n      var text = op.insert.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n      return delta.insert(text, op.attributes);\n    }\n    return delta.push(op);\n  }, new _quillDelta2.default());\n}\n\nexports.default = Editor;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.Range = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _clone = __webpack_require__(21);\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _deepEqual = __webpack_require__(11);\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _emitter3 = __webpack_require__(8);\n\nvar _emitter4 = _interopRequireDefault(_emitter3);\n\nvar _logger = __webpack_require__(10);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar debug = (0, _logger2.default)('quill:selection');\n\nvar Range = function Range(index) {\n  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n  _classCallCheck(this, Range);\n\n  this.index = index;\n  this.length = length;\n};\n\nvar Selection = function () {\n  function Selection(scroll, emitter) {\n    var _this = this;\n\n    _classCallCheck(this, Selection);\n\n    this.emitter = emitter;\n    this.scroll = scroll;\n    this.composing = false;\n    this.mouseDown = false;\n    this.root = this.scroll.domNode;\n    this.cursor = _parchment2.default.create('cursor', this);\n    // savedRange is last non-null range\n    this.lastRange = this.savedRange = new Range(0, 0);\n    this.handleComposition();\n    this.handleDragging();\n    this.emitter.listenDOM('selectionchange', document, function () {\n      if (!_this.mouseDown) {\n        setTimeout(_this.update.bind(_this, _emitter4.default.sources.USER), 1);\n      }\n    });\n    this.emitter.on(_emitter4.default.events.EDITOR_CHANGE, function (type, delta) {\n      if (type === _emitter4.default.events.TEXT_CHANGE && delta.length() > 0) {\n        _this.update(_emitter4.default.sources.SILENT);\n      }\n    });\n    this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE, function () {\n      if (!_this.hasFocus()) return;\n      var native = _this.getNativeRange();\n      if (native == null) return;\n      if (native.start.node === _this.cursor.textNode) return; // cursor.restore() will handle\n      // TODO unclear if this has negative side effects\n      _this.emitter.once(_emitter4.default.events.SCROLL_UPDATE, function () {\n        try {\n          _this.setNativeRange(native.start.node, native.start.offset, native.end.node, native.end.offset);\n        } catch (ignored) {}\n      });\n    });\n    this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE, function (mutations, context) {\n      if (context.range) {\n        var _context$range = context.range,\n            startNode = _context$range.startNode,\n            startOffset = _context$range.startOffset,\n            endNode = _context$range.endNode,\n            endOffset = _context$range.endOffset;\n\n        _this.setNativeRange(startNode, startOffset, endNode, endOffset);\n      }\n    });\n    this.update(_emitter4.default.sources.SILENT);\n  }\n\n  _createClass(Selection, [{\n    key: 'handleComposition',\n    value: function handleComposition() {\n      var _this2 = this;\n\n      this.root.addEventListener('compositionstart', function () {\n        _this2.composing = true;\n      });\n      this.root.addEventListener('compositionend', function () {\n        _this2.composing = false;\n        if (_this2.cursor.parent) {\n          var range = _this2.cursor.restore();\n          if (!range) return;\n          setTimeout(function () {\n            _this2.setNativeRange(range.startNode, range.startOffset, range.endNode, range.endOffset);\n          }, 1);\n        }\n      });\n    }\n  }, {\n    key: 'handleDragging',\n    value: function handleDragging() {\n      var _this3 = this;\n\n      this.emitter.listenDOM('mousedown', document.body, function () {\n        _this3.mouseDown = true;\n      });\n      this.emitter.listenDOM('mouseup', document.body, function () {\n        _this3.mouseDown = false;\n        _this3.update(_emitter4.default.sources.USER);\n      });\n    }\n  }, {\n    key: 'focus',\n    value: function focus() {\n      if (this.hasFocus()) return;\n      this.root.focus();\n      this.setRange(this.savedRange);\n    }\n  }, {\n    key: 'format',\n    value: function format(_format, value) {\n      if (this.scroll.whitelist != null && !this.scroll.whitelist[_format]) return;\n      this.scroll.update();\n      var nativeRange = this.getNativeRange();\n      if (nativeRange == null || !nativeRange.native.collapsed || _parchment2.default.query(_format, _parchment2.default.Scope.BLOCK)) return;\n      if (nativeRange.start.node !== this.cursor.textNode) {\n        var blot = _parchment2.default.find(nativeRange.start.node, false);\n        if (blot == null) return;\n        // TODO Give blot ability to not split\n        if (blot instanceof _parchment2.default.Leaf) {\n          var after = blot.split(nativeRange.start.offset);\n          blot.parent.insertBefore(this.cursor, after);\n        } else {\n          blot.insertBefore(this.cursor, nativeRange.start.node); // Should never happen\n        }\n        this.cursor.attach();\n      }\n      this.cursor.format(_format, value);\n      this.scroll.optimize();\n      this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length);\n      this.update();\n    }\n  }, {\n    key: 'getBounds',\n    value: function getBounds(index) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      var scrollLength = this.scroll.length();\n      index = Math.min(index, scrollLength - 1);\n      length = Math.min(index + length, scrollLength - 1) - index;\n      var node = void 0,\n          _scroll$leaf = this.scroll.leaf(index),\n          _scroll$leaf2 = _slicedToArray(_scroll$leaf, 2),\n          leaf = _scroll$leaf2[0],\n          offset = _scroll$leaf2[1];\n      if (leaf == null) return null;\n\n      var _leaf$position = leaf.position(offset, true);\n\n      var _leaf$position2 = _slicedToArray(_leaf$position, 2);\n\n      node = _leaf$position2[0];\n      offset = _leaf$position2[1];\n\n      var range = document.createRange();\n      if (length > 0) {\n        range.setStart(node, offset);\n\n        var _scroll$leaf3 = this.scroll.leaf(index + length);\n\n        var _scroll$leaf4 = _slicedToArray(_scroll$leaf3, 2);\n\n        leaf = _scroll$leaf4[0];\n        offset = _scroll$leaf4[1];\n\n        if (leaf == null) return null;\n\n        var _leaf$position3 = leaf.position(offset, true);\n\n        var _leaf$position4 = _slicedToArray(_leaf$position3, 2);\n\n        node = _leaf$position4[0];\n        offset = _leaf$position4[1];\n\n        range.setEnd(node, offset);\n        return range.getBoundingClientRect();\n      } else {\n        var side = 'left';\n        var rect = void 0;\n        if (node instanceof Text) {\n          if (offset < node.data.length) {\n            range.setStart(node, offset);\n            range.setEnd(node, offset + 1);\n          } else {\n            range.setStart(node, offset - 1);\n            range.setEnd(node, offset);\n            side = 'right';\n          }\n          rect = range.getBoundingClientRect();\n        } else {\n          rect = leaf.domNode.getBoundingClientRect();\n          if (offset > 0) side = 'right';\n        }\n        return {\n          bottom: rect.top + rect.height,\n          height: rect.height,\n          left: rect[side],\n          right: rect[side],\n          top: rect.top,\n          width: 0\n        };\n      }\n    }\n  }, {\n    key: 'getNativeRange',\n    value: function getNativeRange() {\n      var selection = document.getSelection();\n      if (selection == null || selection.rangeCount <= 0) return null;\n      var nativeRange = selection.getRangeAt(0);\n      if (nativeRange == null) return null;\n      var range = this.normalizeNative(nativeRange);\n      debug.info('getNativeRange', range);\n      return range;\n    }\n  }, {\n    key: 'getRange',\n    value: function getRange() {\n      var normalized = this.getNativeRange();\n      if (normalized == null) return [null, null];\n      var range = this.normalizedToRange(normalized);\n      return [range, normalized];\n    }\n  }, {\n    key: 'hasFocus',\n    value: function hasFocus() {\n      return document.activeElement === this.root;\n    }\n  }, {\n    key: 'normalizedToRange',\n    value: function normalizedToRange(range) {\n      var _this4 = this;\n\n      var positions = [[range.start.node, range.start.offset]];\n      if (!range.native.collapsed) {\n        positions.push([range.end.node, range.end.offset]);\n      }\n      var indexes = positions.map(function (position) {\n        var _position = _slicedToArray(position, 2),\n            node = _position[0],\n            offset = _position[1];\n\n        var blot = _parchment2.default.find(node, true);\n        var index = blot.offset(_this4.scroll);\n        if (offset === 0) {\n          return index;\n        } else if (blot instanceof _parchment2.default.Container) {\n          return index + blot.length();\n        } else {\n          return index + blot.index(node, offset);\n        }\n      });\n      var end = Math.min(Math.max.apply(Math, _toConsumableArray(indexes)), this.scroll.length() - 1);\n      var start = Math.min.apply(Math, [end].concat(_toConsumableArray(indexes)));\n      return new Range(start, end - start);\n    }\n  }, {\n    key: 'normalizeNative',\n    value: function normalizeNative(nativeRange) {\n      if (!contains(this.root, nativeRange.startContainer) || !nativeRange.collapsed && !contains(this.root, nativeRange.endContainer)) {\n        return null;\n      }\n      var range = {\n        start: { node: nativeRange.startContainer, offset: nativeRange.startOffset },\n        end: { node: nativeRange.endContainer, offset: nativeRange.endOffset },\n        native: nativeRange\n      };\n      [range.start, range.end].forEach(function (position) {\n        var node = position.node,\n            offset = position.offset;\n        while (!(node instanceof Text) && node.childNodes.length > 0) {\n          if (node.childNodes.length > offset) {\n            node = node.childNodes[offset];\n            offset = 0;\n          } else if (node.childNodes.length === offset) {\n            node = node.lastChild;\n            offset = node instanceof Text ? node.data.length : node.childNodes.length + 1;\n          } else {\n            break;\n          }\n        }\n        position.node = node, position.offset = offset;\n      });\n      return range;\n    }\n  }, {\n    key: 'rangeToNative',\n    value: function rangeToNative(range) {\n      var _this5 = this;\n\n      var indexes = range.collapsed ? [range.index] : [range.index, range.index + range.length];\n      var args = [];\n      var scrollLength = this.scroll.length();\n      indexes.forEach(function (index, i) {\n        index = Math.min(scrollLength - 1, index);\n        var node = void 0,\n            _scroll$leaf5 = _this5.scroll.leaf(index),\n            _scroll$leaf6 = _slicedToArray(_scroll$leaf5, 2),\n            leaf = _scroll$leaf6[0],\n            offset = _scroll$leaf6[1];\n        var _leaf$position5 = leaf.position(offset, i !== 0);\n\n        var _leaf$position6 = _slicedToArray(_leaf$position5, 2);\n\n        node = _leaf$position6[0];\n        offset = _leaf$position6[1];\n\n        args.push(node, offset);\n      });\n      if (args.length < 2) {\n        args = args.concat(args);\n      }\n      return args;\n    }\n  }, {\n    key: 'scrollIntoView',\n    value: function scrollIntoView(scrollingContainer) {\n      var range = this.lastRange;\n      if (range == null) return;\n      var bounds = this.getBounds(range.index, range.length);\n      if (bounds == null) return;\n      var limit = this.scroll.length() - 1;\n\n      var _scroll$line = this.scroll.line(Math.min(range.index, limit)),\n          _scroll$line2 = _slicedToArray(_scroll$line, 1),\n          first = _scroll$line2[0];\n\n      var last = first;\n      if (range.length > 0) {\n        var _scroll$line3 = this.scroll.line(Math.min(range.index + range.length, limit));\n\n        var _scroll$line4 = _slicedToArray(_scroll$line3, 1);\n\n        last = _scroll$line4[0];\n      }\n      if (first == null || last == null) return;\n      var scrollBounds = scrollingContainer.getBoundingClientRect();\n      if (bounds.top < scrollBounds.top) {\n        scrollingContainer.scrollTop -= scrollBounds.top - bounds.top;\n      } else if (bounds.bottom > scrollBounds.bottom) {\n        scrollingContainer.scrollTop += bounds.bottom - scrollBounds.bottom;\n      }\n    }\n  }, {\n    key: 'setNativeRange',\n    value: function setNativeRange(startNode, startOffset) {\n      var endNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : startNode;\n      var endOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : startOffset;\n      var force = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      debug.info('setNativeRange', startNode, startOffset, endNode, endOffset);\n      if (startNode != null && (this.root.parentNode == null || startNode.parentNode == null || endNode.parentNode == null)) {\n        return;\n      }\n      var selection = document.getSelection();\n      if (selection == null) return;\n      if (startNode != null) {\n        if (!this.hasFocus()) this.root.focus();\n        var native = (this.getNativeRange() || {}).native;\n        if (native == null || force || startNode !== native.startContainer || startOffset !== native.startOffset || endNode !== native.endContainer || endOffset !== native.endOffset) {\n\n          if (startNode.tagName == \"BR\") {\n            startOffset = [].indexOf.call(startNode.parentNode.childNodes, startNode);\n            startNode = startNode.parentNode;\n          }\n          if (endNode.tagName == \"BR\") {\n            endOffset = [].indexOf.call(endNode.parentNode.childNodes, endNode);\n            endNode = endNode.parentNode;\n          }\n          var range = document.createRange();\n          range.setStart(startNode, startOffset);\n          range.setEnd(endNode, endOffset);\n          selection.removeAllRanges();\n          selection.addRange(range);\n        }\n      } else {\n        selection.removeAllRanges();\n        this.root.blur();\n        document.body.focus(); // root.blur() not enough on IE11+Travis+SauceLabs (but not local VMs)\n      }\n    }\n  }, {\n    key: 'setRange',\n    value: function setRange(range) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _emitter4.default.sources.API;\n\n      if (typeof force === 'string') {\n        source = force;\n        force = false;\n      }\n      debug.info('setRange', range);\n      if (range != null) {\n        var args = this.rangeToNative(range);\n        this.setNativeRange.apply(this, _toConsumableArray(args).concat([force]));\n      } else {\n        this.setNativeRange(null);\n      }\n      this.update(source);\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _emitter4.default.sources.USER;\n\n      var oldRange = this.lastRange;\n\n      var _getRange = this.getRange(),\n          _getRange2 = _slicedToArray(_getRange, 2),\n          lastRange = _getRange2[0],\n          nativeRange = _getRange2[1];\n\n      this.lastRange = lastRange;\n      if (this.lastRange != null) {\n        this.savedRange = this.lastRange;\n      }\n      if (!(0, _deepEqual2.default)(oldRange, this.lastRange)) {\n        var _emitter;\n\n        if (!this.composing && nativeRange != null && nativeRange.native.collapsed && nativeRange.start.node !== this.cursor.textNode) {\n          this.cursor.restore();\n        }\n        var args = [_emitter4.default.events.SELECTION_CHANGE, (0, _clone2.default)(this.lastRange), (0, _clone2.default)(oldRange), source];\n        (_emitter = this.emitter).emit.apply(_emitter, [_emitter4.default.events.EDITOR_CHANGE].concat(args));\n        if (source !== _emitter4.default.sources.SILENT) {\n          var _emitter2;\n\n          (_emitter2 = this.emitter).emit.apply(_emitter2, args);\n        }\n      }\n    }\n  }]);\n\n  return Selection;\n}();\n\nfunction contains(parent, descendant) {\n  try {\n    // Firefox inserts inaccessible nodes around video elements\n    descendant.parentNode;\n  } catch (e) {\n    return false;\n  }\n  // IE11 has bug with Text nodes\n  // https://connect.microsoft.com/IE/feedback/details/780874/node-contains-is-incorrect\n  if (descendant instanceof Text) {\n    descendant = descendant.parentNode;\n  }\n  return parent.contains(descendant);\n}\n\nexports.Range = Range;\nexports.default = Selection;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Break = function (_Parchment$Embed) {\n  _inherits(Break, _Parchment$Embed);\n\n  function Break() {\n    _classCallCheck(this, Break);\n\n    return _possibleConstructorReturn(this, (Break.__proto__ || Object.getPrototypeOf(Break)).apply(this, arguments));\n  }\n\n  _createClass(Break, [{\n    key: 'insertInto',\n    value: function insertInto(parent, ref) {\n      if (parent.children.length === 0) {\n        _get(Break.prototype.__proto__ || Object.getPrototypeOf(Break.prototype), 'insertInto', this).call(this, parent, ref);\n      } else {\n        this.remove();\n      }\n    }\n  }, {\n    key: 'length',\n    value: function length() {\n      return 0;\n    }\n  }, {\n    key: 'value',\n    value: function value() {\n      return '';\n    }\n  }], [{\n    key: 'value',\n    value: function value() {\n      return undefined;\n    }\n  }]);\n\n  return Break;\n}(_parchment2.default.Embed);\n\nBreak.blotName = 'break';\nBreak.tagName = 'BR';\n\nexports.default = Break;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar linked_list_1 = __webpack_require__(44);\nvar shadow_1 = __webpack_require__(30);\nvar Registry = __webpack_require__(1);\nvar ContainerBlot = /** @class */ (function (_super) {\n    __extends(ContainerBlot, _super);\n    function ContainerBlot(domNode) {\n        var _this = _super.call(this, domNode) || this;\n        _this.build();\n        return _this;\n    }\n    ContainerBlot.prototype.appendChild = function (other) {\n        this.insertBefore(other);\n    };\n    ContainerBlot.prototype.attach = function () {\n        _super.prototype.attach.call(this);\n        this.children.forEach(function (child) {\n            child.attach();\n        });\n    };\n    ContainerBlot.prototype.build = function () {\n        var _this = this;\n        this.children = new linked_list_1.default();\n        // Need to be reversed for if DOM nodes already in order\n        [].slice\n            .call(this.domNode.childNodes)\n            .reverse()\n            .forEach(function (node) {\n            try {\n                var child = makeBlot(node);\n                _this.insertBefore(child, _this.children.head || undefined);\n            }\n            catch (err) {\n                if (err instanceof Registry.ParchmentError)\n                    return;\n                else\n                    throw err;\n            }\n        });\n    };\n    ContainerBlot.prototype.deleteAt = function (index, length) {\n        if (index === 0 && length === this.length()) {\n            return this.remove();\n        }\n        this.children.forEachAt(index, length, function (child, offset, length) {\n            child.deleteAt(offset, length);\n        });\n    };\n    ContainerBlot.prototype.descendant = function (criteria, index) {\n        var _a = this.children.find(index), child = _a[0], offset = _a[1];\n        if ((criteria.blotName == null && criteria(child)) ||\n            (criteria.blotName != null && child instanceof criteria)) {\n            return [child, offset];\n        }\n        else if (child instanceof ContainerBlot) {\n            return child.descendant(criteria, offset);\n        }\n        else {\n            return [null, -1];\n        }\n    };\n    ContainerBlot.prototype.descendants = function (criteria, index, length) {\n        if (index === void 0) { index = 0; }\n        if (length === void 0) { length = Number.MAX_VALUE; }\n        var descendants = [];\n        var lengthLeft = length;\n        this.children.forEachAt(index, length, function (child, index, length) {\n            if ((criteria.blotName == null && criteria(child)) ||\n                (criteria.blotName != null && child instanceof criteria)) {\n                descendants.push(child);\n            }\n            if (child instanceof ContainerBlot) {\n                descendants = descendants.concat(child.descendants(criteria, index, lengthLeft));\n            }\n            lengthLeft -= length;\n        });\n        return descendants;\n    };\n    ContainerBlot.prototype.detach = function () {\n        this.children.forEach(function (child) {\n            child.detach();\n        });\n        _super.prototype.detach.call(this);\n    };\n    ContainerBlot.prototype.formatAt = function (index, length, name, value) {\n        this.children.forEachAt(index, length, function (child, offset, length) {\n            child.formatAt(offset, length, name, value);\n        });\n    };\n    ContainerBlot.prototype.insertAt = function (index, value, def) {\n        var _a = this.children.find(index), child = _a[0], offset = _a[1];\n        if (child) {\n            child.insertAt(offset, value, def);\n        }\n        else {\n            var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);\n            this.appendChild(blot);\n        }\n    };\n    ContainerBlot.prototype.insertBefore = function (childBlot, refBlot) {\n        if (this.statics.allowedChildren != null &&\n            !this.statics.allowedChildren.some(function (child) {\n                return childBlot instanceof child;\n            })) {\n            throw new Registry.ParchmentError(\"Cannot insert \" + childBlot.statics.blotName + \" into \" + this.statics.blotName);\n        }\n        childBlot.insertInto(this, refBlot);\n    };\n    ContainerBlot.prototype.length = function () {\n        return this.children.reduce(function (memo, child) {\n            return memo + child.length();\n        }, 0);\n    };\n    ContainerBlot.prototype.moveChildren = function (targetParent, refNode) {\n        this.children.forEach(function (child) {\n            targetParent.insertBefore(child, refNode);\n        });\n    };\n    ContainerBlot.prototype.optimize = function (context) {\n        _super.prototype.optimize.call(this, context);\n        if (this.children.length === 0) {\n            if (this.statics.defaultChild != null) {\n                var child = Registry.create(this.statics.defaultChild);\n                this.appendChild(child);\n                child.optimize(context);\n            }\n            else {\n                this.remove();\n            }\n        }\n    };\n    ContainerBlot.prototype.path = function (index, inclusive) {\n        if (inclusive === void 0) { inclusive = false; }\n        var _a = this.children.find(index, inclusive), child = _a[0], offset = _a[1];\n        var position = [[this, index]];\n        if (child instanceof ContainerBlot) {\n            return position.concat(child.path(offset, inclusive));\n        }\n        else if (child != null) {\n            position.push([child, offset]);\n        }\n        return position;\n    };\n    ContainerBlot.prototype.removeChild = function (child) {\n        this.children.remove(child);\n    };\n    ContainerBlot.prototype.replace = function (target) {\n        if (target instanceof ContainerBlot) {\n            target.moveChildren(this);\n        }\n        _super.prototype.replace.call(this, target);\n    };\n    ContainerBlot.prototype.split = function (index, force) {\n        if (force === void 0) { force = false; }\n        if (!force) {\n            if (index === 0)\n                return this;\n            if (index === this.length())\n                return this.next;\n        }\n        var after = this.clone();\n        this.parent.insertBefore(after, this.next);\n        this.children.forEachAt(index, this.length(), function (child, offset, length) {\n            child = child.split(offset, force);\n            after.appendChild(child);\n        });\n        return after;\n    };\n    ContainerBlot.prototype.unwrap = function () {\n        this.moveChildren(this.parent, this.next);\n        this.remove();\n    };\n    ContainerBlot.prototype.update = function (mutations, context) {\n        var _this = this;\n        var addedNodes = [];\n        var removedNodes = [];\n        mutations.forEach(function (mutation) {\n            if (mutation.target === _this.domNode && mutation.type === 'childList') {\n                addedNodes.push.apply(addedNodes, mutation.addedNodes);\n                removedNodes.push.apply(removedNodes, mutation.removedNodes);\n            }\n        });\n        removedNodes.forEach(function (node) {\n            // Check node has actually been removed\n            // One exception is Chrome does not immediately remove IFRAMEs\n            // from DOM but MutationRecord is correct in its reported removal\n            if (node.parentNode != null &&\n                // @ts-ignore\n                node.tagName !== 'IFRAME' &&\n                document.body.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n                return;\n            }\n            var blot = Registry.find(node);\n            if (blot == null)\n                return;\n            if (blot.domNode.parentNode == null || blot.domNode.parentNode === _this.domNode) {\n                blot.detach();\n            }\n        });\n        addedNodes\n            .filter(function (node) {\n            return node.parentNode == _this.domNode;\n        })\n            .sort(function (a, b) {\n            if (a === b)\n                return 0;\n            if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_FOLLOWING) {\n                return 1;\n            }\n            return -1;\n        })\n            .forEach(function (node) {\n            var refBlot = null;\n            if (node.nextSibling != null) {\n                refBlot = Registry.find(node.nextSibling);\n            }\n            var blot = makeBlot(node);\n            if (blot.next != refBlot || blot.next == null) {\n                if (blot.parent != null) {\n                    blot.parent.removeChild(_this);\n                }\n                _this.insertBefore(blot, refBlot || undefined);\n            }\n        });\n    };\n    return ContainerBlot;\n}(shadow_1.default));\nfunction makeBlot(node) {\n    var blot = Registry.find(node);\n    if (blot == null) {\n        try {\n            blot = Registry.create(node);\n        }\n        catch (e) {\n            blot = Registry.create(Registry.Scope.INLINE);\n            [].slice.call(node.childNodes).forEach(function (child) {\n                // @ts-ignore\n                blot.domNode.appendChild(child);\n            });\n            if (node.parentNode) {\n                node.parentNode.replaceChild(blot.domNode, node);\n            }\n            blot.attach();\n        }\n    }\n    return blot;\n}\nexports.default = ContainerBlot;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar attributor_1 = __webpack_require__(12);\nvar store_1 = __webpack_require__(31);\nvar container_1 = __webpack_require__(17);\nvar Registry = __webpack_require__(1);\nvar FormatBlot = /** @class */ (function (_super) {\n    __extends(FormatBlot, _super);\n    function FormatBlot(domNode) {\n        var _this = _super.call(this, domNode) || this;\n        _this.attributes = new store_1.default(_this.domNode);\n        return _this;\n    }\n    FormatBlot.formats = function (domNode) {\n        if (typeof this.tagName === 'string') {\n            return true;\n        }\n        else if (Array.isArray(this.tagName)) {\n            return domNode.tagName.toLowerCase();\n        }\n        return undefined;\n    };\n    FormatBlot.prototype.format = function (name, value) {\n        var format = Registry.query(name);\n        if (format instanceof attributor_1.default) {\n            this.attributes.attribute(format, value);\n        }\n        else if (value) {\n            if (format != null && (name !== this.statics.blotName || this.formats()[name] !== value)) {\n                this.replaceWith(name, value);\n            }\n        }\n    };\n    FormatBlot.prototype.formats = function () {\n        var formats = this.attributes.values();\n        var format = this.statics.formats(this.domNode);\n        if (format != null) {\n            formats[this.statics.blotName] = format;\n        }\n        return formats;\n    };\n    FormatBlot.prototype.replaceWith = function (name, value) {\n        var replacement = _super.prototype.replaceWith.call(this, name, value);\n        this.attributes.copy(replacement);\n        return replacement;\n    };\n    FormatBlot.prototype.update = function (mutations, context) {\n        var _this = this;\n        _super.prototype.update.call(this, mutations, context);\n        if (mutations.some(function (mutation) {\n            return mutation.target === _this.domNode && mutation.type === 'attributes';\n        })) {\n            this.attributes.build();\n        }\n    };\n    FormatBlot.prototype.wrap = function (name, value) {\n        var wrapper = _super.prototype.wrap.call(this, name, value);\n        if (wrapper instanceof FormatBlot && wrapper.statics.scope === this.statics.scope) {\n            this.attributes.move(wrapper);\n        }\n        return wrapper;\n    };\n    return FormatBlot;\n}(container_1.default));\nexports.default = FormatBlot;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar shadow_1 = __webpack_require__(30);\nvar Registry = __webpack_require__(1);\nvar LeafBlot = /** @class */ (function (_super) {\n    __extends(LeafBlot, _super);\n    function LeafBlot() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    LeafBlot.value = function (domNode) {\n        return true;\n    };\n    LeafBlot.prototype.index = function (node, offset) {\n        if (this.domNode === node ||\n            this.domNode.compareDocumentPosition(node) & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n            return Math.min(offset, 1);\n        }\n        return -1;\n    };\n    LeafBlot.prototype.position = function (index, inclusive) {\n        var offset = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);\n        if (index > 0)\n            offset += 1;\n        return [this.parent.domNode, offset];\n    };\n    LeafBlot.prototype.value = function () {\n        var _a;\n        return _a = {}, _a[this.statics.blotName] = this.statics.value(this.domNode) || true, _a;\n    };\n    LeafBlot.scope = Registry.Scope.INLINE_BLOT;\n    return LeafBlot;\n}(shadow_1.default));\nexports.default = LeafBlot;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar equal = __webpack_require__(11);\nvar extend = __webpack_require__(3);\n\n\nvar lib = {\n  attributes: {\n    compose: function (a, b, keepNull) {\n      if (typeof a !== 'object') a = {};\n      if (typeof b !== 'object') b = {};\n      var attributes = extend(true, {}, b);\n      if (!keepNull) {\n        attributes = Object.keys(attributes).reduce(function (copy, key) {\n          if (attributes[key] != null) {\n            copy[key] = attributes[key];\n          }\n          return copy;\n        }, {});\n      }\n      for (var key in a) {\n        if (a[key] !== undefined && b[key] === undefined) {\n          attributes[key] = a[key];\n        }\n      }\n      return Object.keys(attributes).length > 0 ? attributes : undefined;\n    },\n\n    diff: function(a, b) {\n      if (typeof a !== 'object') a = {};\n      if (typeof b !== 'object') b = {};\n      var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {\n        if (!equal(a[key], b[key])) {\n          attributes[key] = b[key] === undefined ? null : b[key];\n        }\n        return attributes;\n      }, {});\n      return Object.keys(attributes).length > 0 ? attributes : undefined;\n    },\n\n    transform: function (a, b, priority) {\n      if (typeof a !== 'object') return b;\n      if (typeof b !== 'object') return undefined;\n      if (!priority) return b;  // b simply overwrites us without priority\n      var attributes = Object.keys(b).reduce(function (attributes, key) {\n        if (a[key] === undefined) attributes[key] = b[key];  // null is a valid value\n        return attributes;\n      }, {});\n      return Object.keys(attributes).length > 0 ? attributes : undefined;\n    }\n  },\n\n  iterator: function (ops) {\n    return new Iterator(ops);\n  },\n\n  length: function (op) {\n    if (typeof op['delete'] === 'number') {\n      return op['delete'];\n    } else if (typeof op.retain === 'number') {\n      return op.retain;\n    } else {\n      return typeof op.insert === 'string' ? op.insert.length : 1;\n    }\n  }\n};\n\n\nfunction Iterator(ops) {\n  this.ops = ops;\n  this.index = 0;\n  this.offset = 0;\n};\n\nIterator.prototype.hasNext = function () {\n  return this.peekLength() < Infinity;\n};\n\nIterator.prototype.next = function (length) {\n  if (!length) length = Infinity;\n  var nextOp = this.ops[this.index];\n  if (nextOp) {\n    var offset = this.offset;\n    var opLength = lib.length(nextOp)\n    if (length >= opLength - offset) {\n      length = opLength - offset;\n      this.index += 1;\n      this.offset = 0;\n    } else {\n      this.offset += length;\n    }\n    if (typeof nextOp['delete'] === 'number') {\n      return { 'delete': length };\n    } else {\n      var retOp = {};\n      if (nextOp.attributes) {\n        retOp.attributes = nextOp.attributes;\n      }\n      if (typeof nextOp.retain === 'number') {\n        retOp.retain = length;\n      } else if (typeof nextOp.insert === 'string') {\n        retOp.insert = nextOp.insert.substr(offset, length);\n      } else {\n        // offset should === 0, length should === 1\n        retOp.insert = nextOp.insert;\n      }\n      return retOp;\n    }\n  } else {\n    return { retain: Infinity };\n  }\n};\n\nIterator.prototype.peek = function () {\n  return this.ops[this.index];\n};\n\nIterator.prototype.peekLength = function () {\n  if (this.ops[this.index]) {\n    // Should never return 0 if our index is being managed correctly\n    return lib.length(this.ops[this.index]) - this.offset;\n  } else {\n    return Infinity;\n  }\n};\n\nIterator.prototype.peekType = function () {\n  if (this.ops[this.index]) {\n    if (typeof this.ops[this.index]['delete'] === 'number') {\n      return 'delete';\n    } else if (typeof this.ops[this.index].retain === 'number') {\n      return 'retain';\n    } else {\n      return 'insert';\n    }\n  }\n  return 'retain';\n};\n\nIterator.prototype.rest = function () {\n  if (!this.hasNext()) {\n    return [];\n  } else if (this.offset === 0) {\n    return this.ops.slice(this.index);\n  } else {\n    var offset = this.offset;\n    var index = this.index;\n    var next = this.next();\n    var rest = this.ops.slice(this.index);\n    this.offset = offset;\n    this.index = index;\n    return [next].concat(rest);\n  }\n};\n\n\nmodule.exports = lib;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports) {\n\nvar clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      if (Buffer.allocUnsafe) {\n        // Node.js >= 4.5.0\n        child = Buffer.allocUnsafe(parent.length);\n      } else {\n        // Older Node.js versions\n        child = new Buffer(parent.length);\n      }\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _emitter = __webpack_require__(8);\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _block = __webpack_require__(4);\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _break = __webpack_require__(16);\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _code = __webpack_require__(13);\n\nvar _code2 = _interopRequireDefault(_code);\n\nvar _container = __webpack_require__(25);\n\nvar _container2 = _interopRequireDefault(_container);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction isLine(blot) {\n  return blot instanceof _block2.default || blot instanceof _block.BlockEmbed;\n}\n\nvar Scroll = function (_Parchment$Scroll) {\n  _inherits(Scroll, _Parchment$Scroll);\n\n  function Scroll(domNode, config) {\n    _classCallCheck(this, Scroll);\n\n    var _this = _possibleConstructorReturn(this, (Scroll.__proto__ || Object.getPrototypeOf(Scroll)).call(this, domNode));\n\n    _this.emitter = config.emitter;\n    if (Array.isArray(config.whitelist)) {\n      _this.whitelist = config.whitelist.reduce(function (whitelist, format) {\n        whitelist[format] = true;\n        return whitelist;\n      }, {});\n    }\n    // Some reason fixes composition issues with character languages in Windows/Chrome, Safari\n    _this.domNode.addEventListener('DOMNodeInserted', function () {});\n    _this.optimize();\n    _this.enable();\n    return _this;\n  }\n\n  _createClass(Scroll, [{\n    key: 'batchStart',\n    value: function batchStart() {\n      this.batch = true;\n    }\n  }, {\n    key: 'batchEnd',\n    value: function batchEnd() {\n      this.batch = false;\n      this.optimize();\n    }\n  }, {\n    key: 'deleteAt',\n    value: function deleteAt(index, length) {\n      var _line = this.line(index),\n          _line2 = _slicedToArray(_line, 2),\n          first = _line2[0],\n          offset = _line2[1];\n\n      var _line3 = this.line(index + length),\n          _line4 = _slicedToArray(_line3, 1),\n          last = _line4[0];\n\n      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'deleteAt', this).call(this, index, length);\n      if (last != null && first !== last && offset > 0) {\n        if (first instanceof _block.BlockEmbed || last instanceof _block.BlockEmbed) {\n          this.optimize();\n          return;\n        }\n        if (first instanceof _code2.default) {\n          var newlineIndex = first.newlineIndex(first.length(), true);\n          if (newlineIndex > -1) {\n            first = first.split(newlineIndex + 1);\n            if (first === last) {\n              this.optimize();\n              return;\n            }\n          }\n        } else if (last instanceof _code2.default) {\n          var _newlineIndex = last.newlineIndex(0);\n          if (_newlineIndex > -1) {\n            last.split(_newlineIndex + 1);\n          }\n        }\n        var ref = last.children.head instanceof _break2.default ? null : last.children.head;\n        first.moveChildren(last, ref);\n        first.remove();\n      }\n      this.optimize();\n    }\n  }, {\n    key: 'enable',\n    value: function enable() {\n      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      this.domNode.setAttribute('contenteditable', enabled);\n    }\n  }, {\n    key: 'formatAt',\n    value: function formatAt(index, length, format, value) {\n      if (this.whitelist != null && !this.whitelist[format]) return;\n      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'formatAt', this).call(this, index, length, format, value);\n      this.optimize();\n    }\n  }, {\n    key: 'insertAt',\n    value: function insertAt(index, value, def) {\n      if (def != null && this.whitelist != null && !this.whitelist[value]) return;\n      if (index >= this.length()) {\n        if (def == null || _parchment2.default.query(value, _parchment2.default.Scope.BLOCK) == null) {\n          var blot = _parchment2.default.create(this.statics.defaultChild);\n          this.appendChild(blot);\n          if (def == null && value.endsWith('\\n')) {\n            value = value.slice(0, -1);\n          }\n          blot.insertAt(0, value, def);\n        } else {\n          var embed = _parchment2.default.create(value, def);\n          this.appendChild(embed);\n        }\n      } else {\n        _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertAt', this).call(this, index, value, def);\n      }\n      this.optimize();\n    }\n  }, {\n    key: 'insertBefore',\n    value: function insertBefore(blot, ref) {\n      if (blot.statics.scope === _parchment2.default.Scope.INLINE_BLOT) {\n        var wrapper = _parchment2.default.create(this.statics.defaultChild);\n        wrapper.appendChild(blot);\n        blot = wrapper;\n      }\n      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'insertBefore', this).call(this, blot, ref);\n    }\n  }, {\n    key: 'leaf',\n    value: function leaf(index) {\n      return this.path(index).pop() || [null, -1];\n    }\n  }, {\n    key: 'line',\n    value: function line(index) {\n      if (index === this.length()) {\n        return this.line(index - 1);\n      }\n      return this.descendant(isLine, index);\n    }\n  }, {\n    key: 'lines',\n    value: function lines() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.MAX_VALUE;\n\n      var getLines = function getLines(blot, index, length) {\n        var lines = [],\n            lengthLeft = length;\n        blot.children.forEachAt(index, length, function (child, index, length) {\n          if (isLine(child)) {\n            lines.push(child);\n          } else if (child instanceof _parchment2.default.Container) {\n            lines = lines.concat(getLines(child, index, lengthLeft));\n          }\n          lengthLeft -= length;\n        });\n        return lines;\n      };\n      return getLines(this, index, length);\n    }\n  }, {\n    key: 'optimize',\n    value: function optimize() {\n      var mutations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.batch === true) return;\n      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'optimize', this).call(this, mutations, context);\n      if (mutations.length > 0) {\n        this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE, mutations, context);\n      }\n    }\n  }, {\n    key: 'path',\n    value: function path(index) {\n      return _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'path', this).call(this, index).slice(1); // Exclude self\n    }\n  }, {\n    key: 'update',\n    value: function update(mutations) {\n      if (this.batch === true) return;\n      var source = _emitter2.default.sources.USER;\n      if (typeof mutations === 'string') {\n        source = mutations;\n      }\n      if (!Array.isArray(mutations)) {\n        mutations = this.observer.takeRecords();\n      }\n      if (mutations.length > 0) {\n        this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE, source, mutations);\n      }\n      _get(Scroll.prototype.__proto__ || Object.getPrototypeOf(Scroll.prototype), 'update', this).call(this, mutations.concat([])); // pass copy\n      if (mutations.length > 0) {\n        this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE, source, mutations);\n      }\n    }\n  }]);\n\n  return Scroll;\n}(_parchment2.default.Scroll);\n\nScroll.blotName = 'scroll';\nScroll.className = 'ql-editor';\nScroll.tagName = 'DIV';\nScroll.defaultChild = 'block';\nScroll.allowedChildren = [_block2.default, _block.BlockEmbed, _container2.default];\n\nexports.default = Scroll;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SHORTKEY = exports.default = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _clone = __webpack_require__(21);\n\nvar _clone2 = _interopRequireDefault(_clone);\n\nvar _deepEqual = __webpack_require__(11);\n\nvar _deepEqual2 = _interopRequireDefault(_deepEqual);\n\nvar _extend = __webpack_require__(3);\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _op = __webpack_require__(20);\n\nvar _op2 = _interopRequireDefault(_op);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _quill = __webpack_require__(5);\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _logger = __webpack_require__(10);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _module = __webpack_require__(9);\n\nvar _module2 = _interopRequireDefault(_module);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar debug = (0, _logger2.default)('quill:keyboard');\n\nvar SHORTKEY = /Mac/i.test(navigator.platform) ? 'metaKey' : 'ctrlKey';\n\nvar Keyboard = function (_Module) {\n  _inherits(Keyboard, _Module);\n\n  _createClass(Keyboard, null, [{\n    key: 'match',\n    value: function match(evt, binding) {\n      binding = normalize(binding);\n      if (['altKey', 'ctrlKey', 'metaKey', 'shiftKey'].some(function (key) {\n        return !!binding[key] !== evt[key] && binding[key] !== null;\n      })) {\n        return false;\n      }\n      return binding.key === (evt.which || evt.keyCode);\n    }\n  }]);\n\n  function Keyboard(quill, options) {\n    _classCallCheck(this, Keyboard);\n\n    var _this = _possibleConstructorReturn(this, (Keyboard.__proto__ || Object.getPrototypeOf(Keyboard)).call(this, quill, options));\n\n    _this.bindings = {};\n    Object.keys(_this.options.bindings).forEach(function (name) {\n      if (name === 'list autofill' && quill.scroll.whitelist != null && !quill.scroll.whitelist['list']) {\n        return;\n      }\n      if (_this.options.bindings[name]) {\n        _this.addBinding(_this.options.bindings[name]);\n      }\n    });\n    _this.addBinding({ key: Keyboard.keys.ENTER, shiftKey: null }, handleEnter);\n    _this.addBinding({ key: Keyboard.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function () {});\n    if (/Firefox/i.test(navigator.userAgent)) {\n      // Need to handle delete and backspace for Firefox in the general case #1171\n      _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true }, handleBackspace);\n      _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true }, handleDelete);\n    } else {\n      _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, handleBackspace);\n      _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, handleDelete);\n    }\n    _this.addBinding({ key: Keyboard.keys.BACKSPACE }, { collapsed: false }, handleDeleteRange);\n    _this.addBinding({ key: Keyboard.keys.DELETE }, { collapsed: false }, handleDeleteRange);\n    _this.addBinding({ key: Keyboard.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, handleBackspace);\n    _this.listen();\n    return _this;\n  }\n\n  _createClass(Keyboard, [{\n    key: 'addBinding',\n    value: function addBinding(key) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var binding = normalize(key);\n      if (binding == null || binding.key == null) {\n        return debug.warn('Attempted to add invalid keyboard binding', binding);\n      }\n      if (typeof context === 'function') {\n        context = { handler: context };\n      }\n      if (typeof handler === 'function') {\n        handler = { handler: handler };\n      }\n      binding = (0, _extend2.default)(binding, context, handler);\n      this.bindings[binding.key] = this.bindings[binding.key] || [];\n      this.bindings[binding.key].push(binding);\n    }\n  }, {\n    key: 'listen',\n    value: function listen() {\n      var _this2 = this;\n\n      this.quill.root.addEventListener('keydown', function (evt) {\n        if (evt.defaultPrevented) return;\n        var which = evt.which || evt.keyCode;\n        var bindings = (_this2.bindings[which] || []).filter(function (binding) {\n          return Keyboard.match(evt, binding);\n        });\n        if (bindings.length === 0) return;\n        var range = _this2.quill.getSelection();\n        if (range == null || !_this2.quill.hasFocus()) return;\n\n        var _quill$getLine = _this2.quill.getLine(range.index),\n            _quill$getLine2 = _slicedToArray(_quill$getLine, 2),\n            line = _quill$getLine2[0],\n            offset = _quill$getLine2[1];\n\n        var _quill$getLeaf = _this2.quill.getLeaf(range.index),\n            _quill$getLeaf2 = _slicedToArray(_quill$getLeaf, 2),\n            leafStart = _quill$getLeaf2[0],\n            offsetStart = _quill$getLeaf2[1];\n\n        var _ref = range.length === 0 ? [leafStart, offsetStart] : _this2.quill.getLeaf(range.index + range.length),\n            _ref2 = _slicedToArray(_ref, 2),\n            leafEnd = _ref2[0],\n            offsetEnd = _ref2[1];\n\n        var prefixText = leafStart instanceof _parchment2.default.Text ? leafStart.value().slice(0, offsetStart) : '';\n        var suffixText = leafEnd instanceof _parchment2.default.Text ? leafEnd.value().slice(offsetEnd) : '';\n        var curContext = {\n          collapsed: range.length === 0,\n          empty: range.length === 0 && line.length() <= 1,\n          format: _this2.quill.getFormat(range),\n          offset: offset,\n          prefix: prefixText,\n          suffix: suffixText\n        };\n        var prevented = bindings.some(function (binding) {\n          if (binding.collapsed != null && binding.collapsed !== curContext.collapsed) return false;\n          if (binding.empty != null && binding.empty !== curContext.empty) return false;\n          if (binding.offset != null && binding.offset !== curContext.offset) return false;\n          if (Array.isArray(binding.format)) {\n            // any format is present\n            if (binding.format.every(function (name) {\n              return curContext.format[name] == null;\n            })) {\n              return false;\n            }\n          } else if (_typeof(binding.format) === 'object') {\n            // all formats must match\n            if (!Object.keys(binding.format).every(function (name) {\n              if (binding.format[name] === true) return curContext.format[name] != null;\n              if (binding.format[name] === false) return curContext.format[name] == null;\n              return (0, _deepEqual2.default)(binding.format[name], curContext.format[name]);\n            })) {\n              return false;\n            }\n          }\n          if (binding.prefix != null && !binding.prefix.test(curContext.prefix)) return false;\n          if (binding.suffix != null && !binding.suffix.test(curContext.suffix)) return false;\n          return binding.handler.call(_this2, range, curContext) !== true;\n        });\n        if (prevented) {\n          evt.preventDefault();\n        }\n      });\n    }\n  }]);\n\n  return Keyboard;\n}(_module2.default);\n\nKeyboard.keys = {\n  BACKSPACE: 8,\n  TAB: 9,\n  ENTER: 13,\n  ESCAPE: 27,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  DELETE: 46\n};\n\nKeyboard.DEFAULTS = {\n  bindings: {\n    'bold': makeFormatHandler('bold'),\n    'italic': makeFormatHandler('italic'),\n    'underline': makeFormatHandler('underline'),\n    'indent': {\n      // highlight tab or tab at beginning of list, indent or blockquote\n      key: Keyboard.keys.TAB,\n      format: ['blockquote', 'indent', 'list'],\n      handler: function handler(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '+1', _quill2.default.sources.USER);\n      }\n    },\n    'outdent': {\n      key: Keyboard.keys.TAB,\n      shiftKey: true,\n      format: ['blockquote', 'indent', 'list'],\n      // highlight tab or tab at beginning of list, indent or blockquote\n      handler: function handler(range, context) {\n        if (context.collapsed && context.offset !== 0) return true;\n        this.quill.format('indent', '-1', _quill2.default.sources.USER);\n      }\n    },\n    'outdent backspace': {\n      key: Keyboard.keys.BACKSPACE,\n      collapsed: true,\n      shiftKey: null,\n      metaKey: null,\n      ctrlKey: null,\n      altKey: null,\n      format: ['indent', 'list'],\n      offset: 0,\n      handler: function handler(range, context) {\n        if (context.format.indent != null) {\n          this.quill.format('indent', '-1', _quill2.default.sources.USER);\n        } else if (context.format.list != null) {\n          this.quill.format('list', false, _quill2.default.sources.USER);\n        }\n      }\n    },\n    'indent code-block': makeCodeBlockHandler(true),\n    'outdent code-block': makeCodeBlockHandler(false),\n    'remove tab': {\n      key: Keyboard.keys.TAB,\n      shiftKey: true,\n      collapsed: true,\n      prefix: /\\t$/,\n      handler: function handler(range) {\n        this.quill.deleteText(range.index - 1, 1, _quill2.default.sources.USER);\n      }\n    },\n    'tab': {\n      key: Keyboard.keys.TAB,\n      handler: function handler(range) {\n        this.quill.history.cutoff();\n        var delta = new _quillDelta2.default().retain(range.index).delete(range.length).insert('\\t');\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n      }\n    },\n    'list empty enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['list'],\n      empty: true,\n      handler: function handler(range, context) {\n        this.quill.format('list', false, _quill2.default.sources.USER);\n        if (context.format.indent) {\n          this.quill.format('indent', false, _quill2.default.sources.USER);\n        }\n      }\n    },\n    'checklist enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: { list: 'checked' },\n      handler: function handler(range) {\n        var _quill$getLine3 = this.quill.getLine(range.index),\n            _quill$getLine4 = _slicedToArray(_quill$getLine3, 2),\n            line = _quill$getLine4[0],\n            offset = _quill$getLine4[1];\n\n        var formats = (0, _extend2.default)({}, line.formats(), { list: 'checked' });\n        var delta = new _quillDelta2.default().retain(range.index).insert('\\n', formats).retain(line.length() - offset - 1).retain(1, { list: 'unchecked' });\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'header enter': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['header'],\n      suffix: /^$/,\n      handler: function handler(range, context) {\n        var _quill$getLine5 = this.quill.getLine(range.index),\n            _quill$getLine6 = _slicedToArray(_quill$getLine5, 2),\n            line = _quill$getLine6[0],\n            offset = _quill$getLine6[1];\n\n        var delta = new _quillDelta2.default().retain(range.index).insert('\\n', context.format).retain(line.length() - offset - 1).retain(1, { header: null });\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n        this.quill.scrollIntoView();\n      }\n    },\n    'list autofill': {\n      key: ' ',\n      collapsed: true,\n      format: { list: false },\n      prefix: /^\\s*?(\\d+\\.|-|\\*|\\[ ?\\]|\\[x\\])$/,\n      handler: function handler(range, context) {\n        var length = context.prefix.length;\n\n        var _quill$getLine7 = this.quill.getLine(range.index),\n            _quill$getLine8 = _slicedToArray(_quill$getLine7, 2),\n            line = _quill$getLine8[0],\n            offset = _quill$getLine8[1];\n\n        if (offset > length) return true;\n        var value = void 0;\n        switch (context.prefix.trim()) {\n          case '[]':case '[ ]':\n            value = 'unchecked';\n            break;\n          case '[x]':\n            value = 'checked';\n            break;\n          case '-':case '*':\n            value = 'bullet';\n            break;\n          default:\n            value = 'ordered';\n        }\n        this.quill.insertText(range.index, ' ', _quill2.default.sources.USER);\n        this.quill.history.cutoff();\n        var delta = new _quillDelta2.default().retain(range.index - offset).delete(length + 1).retain(line.length() - 2 - offset).retain(1, { list: value });\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n        this.quill.history.cutoff();\n        this.quill.setSelection(range.index - length, _quill2.default.sources.SILENT);\n      }\n    },\n    'code exit': {\n      key: Keyboard.keys.ENTER,\n      collapsed: true,\n      format: ['code-block'],\n      prefix: /\\n\\n$/,\n      suffix: /^\\s+$/,\n      handler: function handler(range) {\n        var _quill$getLine9 = this.quill.getLine(range.index),\n            _quill$getLine10 = _slicedToArray(_quill$getLine9, 2),\n            line = _quill$getLine10[0],\n            offset = _quill$getLine10[1];\n\n        var delta = new _quillDelta2.default().retain(range.index + line.length() - offset - 2).retain(1, { 'code-block': null }).delete(1);\n        this.quill.updateContents(delta, _quill2.default.sources.USER);\n      }\n    },\n    'embed left': makeEmbedArrowHandler(Keyboard.keys.LEFT, false),\n    'embed left shift': makeEmbedArrowHandler(Keyboard.keys.LEFT, true),\n    'embed right': makeEmbedArrowHandler(Keyboard.keys.RIGHT, false),\n    'embed right shift': makeEmbedArrowHandler(Keyboard.keys.RIGHT, true)\n  }\n};\n\nfunction makeEmbedArrowHandler(key, shiftKey) {\n  var _ref3;\n\n  var where = key === Keyboard.keys.LEFT ? 'prefix' : 'suffix';\n  return _ref3 = {\n    key: key,\n    shiftKey: shiftKey,\n    altKey: null\n  }, _defineProperty(_ref3, where, /^$/), _defineProperty(_ref3, 'handler', function handler(range) {\n    var index = range.index;\n    if (key === Keyboard.keys.RIGHT) {\n      index += range.length + 1;\n    }\n\n    var _quill$getLeaf3 = this.quill.getLeaf(index),\n        _quill$getLeaf4 = _slicedToArray(_quill$getLeaf3, 1),\n        leaf = _quill$getLeaf4[0];\n\n    if (!(leaf instanceof _parchment2.default.Embed)) return true;\n    if (key === Keyboard.keys.LEFT) {\n      if (shiftKey) {\n        this.quill.setSelection(range.index - 1, range.length + 1, _quill2.default.sources.USER);\n      } else {\n        this.quill.setSelection(range.index - 1, _quill2.default.sources.USER);\n      }\n    } else {\n      if (shiftKey) {\n        this.quill.setSelection(range.index, range.length + 1, _quill2.default.sources.USER);\n      } else {\n        this.quill.setSelection(range.index + range.length + 1, _quill2.default.sources.USER);\n      }\n    }\n    return false;\n  }), _ref3;\n}\n\nfunction handleBackspace(range, context) {\n  if (range.index === 0 || this.quill.getLength() <= 1) return;\n\n  var _quill$getLine11 = this.quill.getLine(range.index),\n      _quill$getLine12 = _slicedToArray(_quill$getLine11, 1),\n      line = _quill$getLine12[0];\n\n  var formats = {};\n  if (context.offset === 0) {\n    var _quill$getLine13 = this.quill.getLine(range.index - 1),\n        _quill$getLine14 = _slicedToArray(_quill$getLine13, 1),\n        prev = _quill$getLine14[0];\n\n    if (prev != null && prev.length() > 1) {\n      var curFormats = line.formats();\n      var prevFormats = this.quill.getFormat(range.index - 1, 1);\n      formats = _op2.default.attributes.diff(curFormats, prevFormats) || {};\n    }\n  }\n  // Check for astral symbols\n  var length = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]$/.test(context.prefix) ? 2 : 1;\n  this.quill.deleteText(range.index - length, length, _quill2.default.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index - length, length, formats, _quill2.default.sources.USER);\n  }\n  this.quill.focus();\n}\n\nfunction handleDelete(range, context) {\n  // Check for astral symbols\n  var length = /^[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/.test(context.suffix) ? 2 : 1;\n  if (range.index >= this.quill.getLength() - length) return;\n  var formats = {},\n      nextLength = 0;\n\n  var _quill$getLine15 = this.quill.getLine(range.index),\n      _quill$getLine16 = _slicedToArray(_quill$getLine15, 1),\n      line = _quill$getLine16[0];\n\n  if (context.offset >= line.length() - 1) {\n    var _quill$getLine17 = this.quill.getLine(range.index + 1),\n        _quill$getLine18 = _slicedToArray(_quill$getLine17, 1),\n        next = _quill$getLine18[0];\n\n    if (next) {\n      var curFormats = line.formats();\n      var nextFormats = this.quill.getFormat(range.index, 1);\n      formats = _op2.default.attributes.diff(curFormats, nextFormats) || {};\n      nextLength = next.length();\n    }\n  }\n  this.quill.deleteText(range.index, length, _quill2.default.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index + nextLength - 1, length, formats, _quill2.default.sources.USER);\n  }\n}\n\nfunction handleDeleteRange(range) {\n  var lines = this.quill.getLines(range);\n  var formats = {};\n  if (lines.length > 1) {\n    var firstFormats = lines[0].formats();\n    var lastFormats = lines[lines.length - 1].formats();\n    formats = _op2.default.attributes.diff(lastFormats, firstFormats) || {};\n  }\n  this.quill.deleteText(range, _quill2.default.sources.USER);\n  if (Object.keys(formats).length > 0) {\n    this.quill.formatLine(range.index, 1, formats, _quill2.default.sources.USER);\n  }\n  this.quill.setSelection(range.index, _quill2.default.sources.SILENT);\n  this.quill.focus();\n}\n\nfunction handleEnter(range, context) {\n  var _this3 = this;\n\n  if (range.length > 0) {\n    this.quill.scroll.deleteAt(range.index, range.length); // So we do not trigger text-change\n  }\n  var lineFormats = Object.keys(context.format).reduce(function (lineFormats, format) {\n    if (_parchment2.default.query(format, _parchment2.default.Scope.BLOCK) && !Array.isArray(context.format[format])) {\n      lineFormats[format] = context.format[format];\n    }\n    return lineFormats;\n  }, {});\n  this.quill.insertText(range.index, '\\n', lineFormats, _quill2.default.sources.USER);\n  // Earlier scroll.deleteAt might have messed up our selection,\n  // so insertText's built in selection preservation is not reliable\n  this.quill.setSelection(range.index + 1, _quill2.default.sources.SILENT);\n  this.quill.focus();\n  Object.keys(context.format).forEach(function (name) {\n    if (lineFormats[name] != null) return;\n    if (Array.isArray(context.format[name])) return;\n    if (name === 'link') return;\n    _this3.quill.format(name, context.format[name], _quill2.default.sources.USER);\n  });\n}\n\nfunction makeCodeBlockHandler(indent) {\n  return {\n    key: Keyboard.keys.TAB,\n    shiftKey: !indent,\n    format: { 'code-block': true },\n    handler: function handler(range) {\n      var CodeBlock = _parchment2.default.query('code-block');\n      var index = range.index,\n          length = range.length;\n\n      var _quill$scroll$descend = this.quill.scroll.descendant(CodeBlock, index),\n          _quill$scroll$descend2 = _slicedToArray(_quill$scroll$descend, 2),\n          block = _quill$scroll$descend2[0],\n          offset = _quill$scroll$descend2[1];\n\n      if (block == null) return;\n      var scrollIndex = this.quill.getIndex(block);\n      var start = block.newlineIndex(offset, true) + 1;\n      var end = block.newlineIndex(scrollIndex + offset + length);\n      var lines = block.domNode.textContent.slice(start, end).split('\\n');\n      offset = 0;\n      lines.forEach(function (line, i) {\n        if (indent) {\n          block.insertAt(start + offset, CodeBlock.TAB);\n          offset += CodeBlock.TAB.length;\n          if (i === 0) {\n            index += CodeBlock.TAB.length;\n          } else {\n            length += CodeBlock.TAB.length;\n          }\n        } else if (line.startsWith(CodeBlock.TAB)) {\n          block.deleteAt(start + offset, CodeBlock.TAB.length);\n          offset -= CodeBlock.TAB.length;\n          if (i === 0) {\n            index -= CodeBlock.TAB.length;\n          } else {\n            length -= CodeBlock.TAB.length;\n          }\n        }\n        offset += line.length + 1;\n      });\n      this.quill.update(_quill2.default.sources.USER);\n      this.quill.setSelection(index, length, _quill2.default.sources.SILENT);\n    }\n  };\n}\n\nfunction makeFormatHandler(format) {\n  return {\n    key: format[0].toUpperCase(),\n    shortKey: true,\n    handler: function handler(range, context) {\n      this.quill.format(format, !context.format[format], _quill2.default.sources.USER);\n    }\n  };\n}\n\nfunction normalize(binding) {\n  if (typeof binding === 'string' || typeof binding === 'number') {\n    return normalize({ key: binding });\n  }\n  if ((typeof binding === 'undefined' ? 'undefined' : _typeof(binding)) === 'object') {\n    binding = (0, _clone2.default)(binding, false);\n  }\n  if (typeof binding.key === 'string') {\n    if (Keyboard.keys[binding.key.toUpperCase()] != null) {\n      binding.key = Keyboard.keys[binding.key.toUpperCase()];\n    } else if (binding.key.length === 1) {\n      binding.key = binding.key.toUpperCase().charCodeAt(0);\n    } else {\n      return null;\n    }\n  }\n  if (binding.shortKey) {\n    binding[SHORTKEY] = binding.shortKey;\n    delete binding.shortKey;\n  }\n  return binding;\n}\n\nexports.default = Keyboard;\nexports.SHORTKEY = SHORTKEY;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _text = __webpack_require__(7);\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Cursor = function (_Parchment$Embed) {\n  _inherits(Cursor, _Parchment$Embed);\n\n  _createClass(Cursor, null, [{\n    key: 'value',\n    value: function value() {\n      return undefined;\n    }\n  }]);\n\n  function Cursor(domNode, selection) {\n    _classCallCheck(this, Cursor);\n\n    var _this = _possibleConstructorReturn(this, (Cursor.__proto__ || Object.getPrototypeOf(Cursor)).call(this, domNode));\n\n    _this.selection = selection;\n    _this.textNode = document.createTextNode(Cursor.CONTENTS);\n    _this.domNode.appendChild(_this.textNode);\n    _this._length = 0;\n    return _this;\n  }\n\n  _createClass(Cursor, [{\n    key: 'detach',\n    value: function detach() {\n      // super.detach() will also clear domNode.__blot\n      if (this.parent != null) this.parent.removeChild(this);\n    }\n  }, {\n    key: 'format',\n    value: function format(name, value) {\n      if (this._length !== 0) {\n        return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'format', this).call(this, name, value);\n      }\n      var target = this,\n          index = 0;\n      while (target != null && target.statics.scope !== _parchment2.default.Scope.BLOCK_BLOT) {\n        index += target.offset(target.parent);\n        target = target.parent;\n      }\n      if (target != null) {\n        this._length = Cursor.CONTENTS.length;\n        target.optimize();\n        target.formatAt(index, Cursor.CONTENTS.length, name, value);\n        this._length = 0;\n      }\n    }\n  }, {\n    key: 'index',\n    value: function index(node, offset) {\n      if (node === this.textNode) return 0;\n      return _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'index', this).call(this, node, offset);\n    }\n  }, {\n    key: 'length',\n    value: function length() {\n      return this._length;\n    }\n  }, {\n    key: 'position',\n    value: function position() {\n      return [this.textNode, this.textNode.data.length];\n    }\n  }, {\n    key: 'remove',\n    value: function remove() {\n      _get(Cursor.prototype.__proto__ || Object.getPrototypeOf(Cursor.prototype), 'remove', this).call(this);\n      this.parent = null;\n    }\n  }, {\n    key: 'restore',\n    value: function restore() {\n      if (this.selection.composing || this.parent == null) return;\n      var textNode = this.textNode;\n      var range = this.selection.getNativeRange();\n      var restoreText = void 0,\n          start = void 0,\n          end = void 0;\n      if (range != null && range.start.node === textNode && range.end.node === textNode) {\n        var _ref = [textNode, range.start.offset, range.end.offset];\n        restoreText = _ref[0];\n        start = _ref[1];\n        end = _ref[2];\n      }\n      // Link format will insert text outside of anchor tag\n      while (this.domNode.lastChild != null && this.domNode.lastChild !== this.textNode) {\n        this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);\n      }\n      if (this.textNode.data !== Cursor.CONTENTS) {\n        var text = this.textNode.data.split(Cursor.CONTENTS).join('');\n        if (this.next instanceof _text2.default) {\n          restoreText = this.next.domNode;\n          this.next.insertAt(0, text);\n          this.textNode.data = Cursor.CONTENTS;\n        } else {\n          this.textNode.data = text;\n          this.parent.insertBefore(_parchment2.default.create(this.textNode), this);\n          this.textNode = document.createTextNode(Cursor.CONTENTS);\n          this.domNode.appendChild(this.textNode);\n        }\n      }\n      this.remove();\n      if (start != null) {\n        var _map = [start, end].map(function (offset) {\n          return Math.max(0, Math.min(restoreText.data.length, offset - 1));\n        });\n\n        var _map2 = _slicedToArray(_map, 2);\n\n        start = _map2[0];\n        end = _map2[1];\n\n        return {\n          startNode: restoreText,\n          startOffset: start,\n          endNode: restoreText,\n          endOffset: end\n        };\n      }\n    }\n  }, {\n    key: 'update',\n    value: function update(mutations, context) {\n      var _this2 = this;\n\n      if (mutations.some(function (mutation) {\n        return mutation.type === 'characterData' && mutation.target === _this2.textNode;\n      })) {\n        var range = this.restore();\n        if (range) context.range = range;\n      }\n    }\n  }, {\n    key: 'value',\n    value: function value() {\n      return '';\n    }\n  }]);\n\n  return Cursor;\n}(_parchment2.default.Embed);\n\nCursor.blotName = 'cursor';\nCursor.className = 'ql-cursor';\nCursor.tagName = 'span';\nCursor.CONTENTS = '\\uFEFF'; // Zero width no break space\n\n\nexports.default = Cursor;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _block = __webpack_require__(4);\n\nvar _block2 = _interopRequireDefault(_block);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Container = function (_Parchment$Container) {\n  _inherits(Container, _Parchment$Container);\n\n  function Container() {\n    _classCallCheck(this, Container);\n\n    return _possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).apply(this, arguments));\n  }\n\n  return Container;\n}(_parchment2.default.Container);\n\nContainer.allowedChildren = [_block2.default, _block.BlockEmbed, Container];\n\nexports.default = Container;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ColorStyle = exports.ColorClass = exports.ColorAttributor = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ColorAttributor = function (_Parchment$Attributor) {\n  _inherits(ColorAttributor, _Parchment$Attributor);\n\n  function ColorAttributor() {\n    _classCallCheck(this, ColorAttributor);\n\n    return _possibleConstructorReturn(this, (ColorAttributor.__proto__ || Object.getPrototypeOf(ColorAttributor)).apply(this, arguments));\n  }\n\n  _createClass(ColorAttributor, [{\n    key: 'value',\n    value: function value(domNode) {\n      var value = _get(ColorAttributor.prototype.__proto__ || Object.getPrototypeOf(ColorAttributor.prototype), 'value', this).call(this, domNode);\n      if (!value.startsWith('rgb(')) return value;\n      value = value.replace(/^[^\\d]+/, '').replace(/[^\\d]+$/, '');\n      return '#' + value.split(',').map(function (component) {\n        return ('00' + parseInt(component).toString(16)).slice(-2);\n      }).join('');\n    }\n  }]);\n\n  return ColorAttributor;\n}(_parchment2.default.Attributor.Style);\n\nvar ColorClass = new _parchment2.default.Attributor.Class('color', 'ql-color', {\n  scope: _parchment2.default.Scope.INLINE\n});\nvar ColorStyle = new ColorAttributor('color', 'color', {\n  scope: _parchment2.default.Scope.INLINE\n});\n\nexports.ColorAttributor = ColorAttributor;\nexports.ColorClass = ColorClass;\nexports.ColorStyle = ColorStyle;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.sanitize = exports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inline = __webpack_require__(6);\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Link = function (_Inline) {\n  _inherits(Link, _Inline);\n\n  function Link() {\n    _classCallCheck(this, Link);\n\n    return _possibleConstructorReturn(this, (Link.__proto__ || Object.getPrototypeOf(Link)).apply(this, arguments));\n  }\n\n  _createClass(Link, [{\n    key: 'format',\n    value: function format(name, value) {\n      if (name !== this.statics.blotName || !value) return _get(Link.prototype.__proto__ || Object.getPrototypeOf(Link.prototype), 'format', this).call(this, name, value);\n      value = this.constructor.sanitize(value);\n      this.domNode.setAttribute('href', value);\n    }\n  }], [{\n    key: 'create',\n    value: function create(value) {\n      var node = _get(Link.__proto__ || Object.getPrototypeOf(Link), 'create', this).call(this, value);\n      value = this.sanitize(value);\n      node.setAttribute('href', value);\n      node.setAttribute('rel', 'noopener noreferrer');\n      node.setAttribute('target', '_blank');\n      return node;\n    }\n  }, {\n    key: 'formats',\n    value: function formats(domNode) {\n      return domNode.getAttribute('href');\n    }\n  }, {\n    key: 'sanitize',\n    value: function sanitize(url) {\n      return _sanitize(url, this.PROTOCOL_WHITELIST) ? url : this.SANITIZED_URL;\n    }\n  }]);\n\n  return Link;\n}(_inline2.default);\n\nLink.blotName = 'link';\nLink.tagName = 'A';\nLink.SANITIZED_URL = 'about:blank';\nLink.PROTOCOL_WHITELIST = ['http', 'https', 'mailto', 'tel'];\n\nfunction _sanitize(url, protocols) {\n  var anchor = document.createElement('a');\n  anchor.href = url;\n  var protocol = anchor.href.slice(0, anchor.href.indexOf(':'));\n  return protocols.indexOf(protocol) > -1;\n}\n\nexports.default = Link;\nexports.sanitize = _sanitize;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _keyboard = __webpack_require__(23);\n\nvar _keyboard2 = _interopRequireDefault(_keyboard);\n\nvar _dropdown = __webpack_require__(107);\n\nvar _dropdown2 = _interopRequireDefault(_dropdown);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar optionsCounter = 0;\n\nfunction toggleAriaAttribute(element, attribute) {\n  element.setAttribute(attribute, !(element.getAttribute(attribute) === 'true'));\n}\n\nvar Picker = function () {\n  function Picker(select) {\n    var _this = this;\n\n    _classCallCheck(this, Picker);\n\n    this.select = select;\n    this.container = document.createElement('span');\n    this.buildPicker();\n    this.select.style.display = 'none';\n    this.select.parentNode.insertBefore(this.container, this.select);\n\n    this.label.addEventListener('mousedown', function () {\n      _this.togglePicker();\n    });\n    this.label.addEventListener('keydown', function (event) {\n      switch (event.keyCode) {\n        // Allows the \"Enter\" key to open the picker\n        case _keyboard2.default.keys.ENTER:\n          _this.togglePicker();\n          break;\n\n        // Allows the \"Escape\" key to close the picker\n        case _keyboard2.default.keys.ESCAPE:\n          _this.escape();\n          event.preventDefault();\n          break;\n        default:\n      }\n    });\n    this.select.addEventListener('change', this.update.bind(this));\n  }\n\n  _createClass(Picker, [{\n    key: 'togglePicker',\n    value: function togglePicker() {\n      this.container.classList.toggle('ql-expanded');\n      // Toggle aria-expanded and aria-hidden to make the picker accessible\n      toggleAriaAttribute(this.label, 'aria-expanded');\n      toggleAriaAttribute(this.options, 'aria-hidden');\n    }\n  }, {\n    key: 'buildItem',\n    value: function buildItem(option) {\n      var _this2 = this;\n\n      var item = document.createElement('span');\n      item.tabIndex = '0';\n      item.setAttribute('role', 'button');\n\n      item.classList.add('ql-picker-item');\n      if (option.hasAttribute('value')) {\n        item.setAttribute('data-value', option.getAttribute('value'));\n      }\n      if (option.textContent) {\n        item.setAttribute('data-label', option.textContent);\n      }\n      item.addEventListener('click', function () {\n        _this2.selectItem(item, true);\n      });\n      item.addEventListener('keydown', function (event) {\n        switch (event.keyCode) {\n          // Allows the \"Enter\" key to select an item\n          case _keyboard2.default.keys.ENTER:\n            _this2.selectItem(item, true);\n            event.preventDefault();\n            break;\n\n          // Allows the \"Escape\" key to close the picker\n          case _keyboard2.default.keys.ESCAPE:\n            _this2.escape();\n            event.preventDefault();\n            break;\n          default:\n        }\n      });\n\n      return item;\n    }\n  }, {\n    key: 'buildLabel',\n    value: function buildLabel() {\n      var label = document.createElement('span');\n      label.classList.add('ql-picker-label');\n      label.innerHTML = _dropdown2.default;\n      label.tabIndex = '0';\n      label.setAttribute('role', 'button');\n      label.setAttribute('aria-expanded', 'false');\n      this.container.appendChild(label);\n      return label;\n    }\n  }, {\n    key: 'buildOptions',\n    value: function buildOptions() {\n      var _this3 = this;\n\n      var options = document.createElement('span');\n      options.classList.add('ql-picker-options');\n\n      // Don't want screen readers to read this until options are visible\n      options.setAttribute('aria-hidden', 'true');\n      options.tabIndex = '-1';\n\n      // Need a unique id for aria-controls\n      options.id = 'ql-picker-options-' + optionsCounter;\n      optionsCounter += 1;\n      this.label.setAttribute('aria-controls', options.id);\n\n      this.options = options;\n\n      [].slice.call(this.select.options).forEach(function (option) {\n        var item = _this3.buildItem(option);\n        options.appendChild(item);\n        if (option.selected === true) {\n          _this3.selectItem(item);\n        }\n      });\n      this.container.appendChild(options);\n    }\n  }, {\n    key: 'buildPicker',\n    value: function buildPicker() {\n      var _this4 = this;\n\n      [].slice.call(this.select.attributes).forEach(function (item) {\n        _this4.container.setAttribute(item.name, item.value);\n      });\n      this.container.classList.add('ql-picker');\n      this.label = this.buildLabel();\n      this.buildOptions();\n    }\n  }, {\n    key: 'escape',\n    value: function escape() {\n      var _this5 = this;\n\n      // Close menu and return focus to trigger label\n      this.close();\n      // Need setTimeout for accessibility to ensure that the browser executes\n      // focus on the next process thread and after any DOM content changes\n      setTimeout(function () {\n        return _this5.label.focus();\n      }, 1);\n    }\n  }, {\n    key: 'close',\n    value: function close() {\n      this.container.classList.remove('ql-expanded');\n      this.label.setAttribute('aria-expanded', 'false');\n      this.options.setAttribute('aria-hidden', 'true');\n    }\n  }, {\n    key: 'selectItem',\n    value: function selectItem(item) {\n      var trigger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var selected = this.container.querySelector('.ql-selected');\n      if (item === selected) return;\n      if (selected != null) {\n        selected.classList.remove('ql-selected');\n      }\n      if (item == null) return;\n      item.classList.add('ql-selected');\n      this.select.selectedIndex = [].indexOf.call(item.parentNode.children, item);\n      if (item.hasAttribute('data-value')) {\n        this.label.setAttribute('data-value', item.getAttribute('data-value'));\n      } else {\n        this.label.removeAttribute('data-value');\n      }\n      if (item.hasAttribute('data-label')) {\n        this.label.setAttribute('data-label', item.getAttribute('data-label'));\n      } else {\n        this.label.removeAttribute('data-label');\n      }\n      if (trigger) {\n        if (typeof Event === 'function') {\n          this.select.dispatchEvent(new Event('change'));\n        } else if ((typeof Event === 'undefined' ? 'undefined' : _typeof(Event)) === 'object') {\n          // IE11\n          var event = document.createEvent('Event');\n          event.initEvent('change', true, true);\n          this.select.dispatchEvent(event);\n        }\n        this.close();\n      }\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var option = void 0;\n      if (this.select.selectedIndex > -1) {\n        var item = this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];\n        option = this.select.options[this.select.selectedIndex];\n        this.selectItem(item);\n      } else {\n        this.selectItem(null);\n      }\n      var isActive = option != null && option !== this.select.querySelector('option[selected]');\n      this.label.classList.toggle('ql-active', isActive);\n    }\n  }]);\n\n  return Picker;\n}();\n\nexports.default = Picker;\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _quill = __webpack_require__(5);\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _block = __webpack_require__(4);\n\nvar _block2 = _interopRequireDefault(_block);\n\nvar _break = __webpack_require__(16);\n\nvar _break2 = _interopRequireDefault(_break);\n\nvar _container = __webpack_require__(25);\n\nvar _container2 = _interopRequireDefault(_container);\n\nvar _cursor = __webpack_require__(24);\n\nvar _cursor2 = _interopRequireDefault(_cursor);\n\nvar _embed = __webpack_require__(35);\n\nvar _embed2 = _interopRequireDefault(_embed);\n\nvar _inline = __webpack_require__(6);\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nvar _scroll = __webpack_require__(22);\n\nvar _scroll2 = _interopRequireDefault(_scroll);\n\nvar _text = __webpack_require__(7);\n\nvar _text2 = _interopRequireDefault(_text);\n\nvar _clipboard = __webpack_require__(55);\n\nvar _clipboard2 = _interopRequireDefault(_clipboard);\n\nvar _history = __webpack_require__(42);\n\nvar _history2 = _interopRequireDefault(_history);\n\nvar _keyboard = __webpack_require__(23);\n\nvar _keyboard2 = _interopRequireDefault(_keyboard);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_quill2.default.register({\n  'blots/block': _block2.default,\n  'blots/block/embed': _block.BlockEmbed,\n  'blots/break': _break2.default,\n  'blots/container': _container2.default,\n  'blots/cursor': _cursor2.default,\n  'blots/embed': _embed2.default,\n  'blots/inline': _inline2.default,\n  'blots/scroll': _scroll2.default,\n  'blots/text': _text2.default,\n\n  'modules/clipboard': _clipboard2.default,\n  'modules/history': _history2.default,\n  'modules/keyboard': _keyboard2.default\n});\n\n_parchment2.default.register(_block2.default, _break2.default, _cursor2.default, _inline2.default, _scroll2.default, _text2.default);\n\nexports.default = _quill2.default;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Registry = __webpack_require__(1);\nvar ShadowBlot = /** @class */ (function () {\n    function ShadowBlot(domNode) {\n        this.domNode = domNode;\n        // @ts-ignore\n        this.domNode[Registry.DATA_KEY] = { blot: this };\n    }\n    Object.defineProperty(ShadowBlot.prototype, \"statics\", {\n        // Hack for accessing inherited static methods\n        get: function () {\n            return this.constructor;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ShadowBlot.create = function (value) {\n        if (this.tagName == null) {\n            throw new Registry.ParchmentError('Blot definition missing tagName');\n        }\n        var node;\n        if (Array.isArray(this.tagName)) {\n            if (typeof value === 'string') {\n                value = value.toUpperCase();\n                if (parseInt(value).toString() === value) {\n                    value = parseInt(value);\n                }\n            }\n            if (typeof value === 'number') {\n                node = document.createElement(this.tagName[value - 1]);\n            }\n            else if (this.tagName.indexOf(value) > -1) {\n                node = document.createElement(value);\n            }\n            else {\n                node = document.createElement(this.tagName[0]);\n            }\n        }\n        else {\n            node = document.createElement(this.tagName);\n        }\n        if (this.className) {\n            node.classList.add(this.className);\n        }\n        return node;\n    };\n    ShadowBlot.prototype.attach = function () {\n        if (this.parent != null) {\n            this.scroll = this.parent.scroll;\n        }\n    };\n    ShadowBlot.prototype.clone = function () {\n        var domNode = this.domNode.cloneNode(false);\n        return Registry.create(domNode);\n    };\n    ShadowBlot.prototype.detach = function () {\n        if (this.parent != null)\n            this.parent.removeChild(this);\n        // @ts-ignore\n        delete this.domNode[Registry.DATA_KEY];\n    };\n    ShadowBlot.prototype.deleteAt = function (index, length) {\n        var blot = this.isolate(index, length);\n        blot.remove();\n    };\n    ShadowBlot.prototype.formatAt = function (index, length, name, value) {\n        var blot = this.isolate(index, length);\n        if (Registry.query(name, Registry.Scope.BLOT) != null && value) {\n            blot.wrap(name, value);\n        }\n        else if (Registry.query(name, Registry.Scope.ATTRIBUTE) != null) {\n            var parent = Registry.create(this.statics.scope);\n            blot.wrap(parent);\n            parent.format(name, value);\n        }\n    };\n    ShadowBlot.prototype.insertAt = function (index, value, def) {\n        var blot = def == null ? Registry.create('text', value) : Registry.create(value, def);\n        var ref = this.split(index);\n        this.parent.insertBefore(blot, ref);\n    };\n    ShadowBlot.prototype.insertInto = function (parentBlot, refBlot) {\n        if (refBlot === void 0) { refBlot = null; }\n        if (this.parent != null) {\n            this.parent.children.remove(this);\n        }\n        var refDomNode = null;\n        parentBlot.children.insertBefore(this, refBlot);\n        if (refBlot != null) {\n            refDomNode = refBlot.domNode;\n        }\n        if (this.domNode.parentNode != parentBlot.domNode ||\n            this.domNode.nextSibling != refDomNode) {\n            parentBlot.domNode.insertBefore(this.domNode, refDomNode);\n        }\n        this.parent = parentBlot;\n        this.attach();\n    };\n    ShadowBlot.prototype.isolate = function (index, length) {\n        var target = this.split(index);\n        target.split(length);\n        return target;\n    };\n    ShadowBlot.prototype.length = function () {\n        return 1;\n    };\n    ShadowBlot.prototype.offset = function (root) {\n        if (root === void 0) { root = this.parent; }\n        if (this.parent == null || this == root)\n            return 0;\n        return this.parent.children.offset(this) + this.parent.offset(root);\n    };\n    ShadowBlot.prototype.optimize = function (context) {\n        // TODO clean up once we use WeakMap\n        // @ts-ignore\n        if (this.domNode[Registry.DATA_KEY] != null) {\n            // @ts-ignore\n            delete this.domNode[Registry.DATA_KEY].mutations;\n        }\n    };\n    ShadowBlot.prototype.remove = function () {\n        if (this.domNode.parentNode != null) {\n            this.domNode.parentNode.removeChild(this.domNode);\n        }\n        this.detach();\n    };\n    ShadowBlot.prototype.replace = function (target) {\n        if (target.parent == null)\n            return;\n        target.parent.insertBefore(this, target.next);\n        target.remove();\n    };\n    ShadowBlot.prototype.replaceWith = function (name, value) {\n        var replacement = typeof name === 'string' ? Registry.create(name, value) : name;\n        replacement.replace(this);\n        return replacement;\n    };\n    ShadowBlot.prototype.split = function (index, force) {\n        return index === 0 ? this : this.next;\n    };\n    ShadowBlot.prototype.update = function (mutations, context) {\n        // Nothing to do by default\n    };\n    ShadowBlot.prototype.wrap = function (name, value) {\n        var wrapper = typeof name === 'string' ? Registry.create(name, value) : name;\n        if (this.parent != null) {\n            this.parent.insertBefore(wrapper, this.next);\n        }\n        wrapper.appendChild(this);\n        return wrapper;\n    };\n    ShadowBlot.blotName = 'abstract';\n    return ShadowBlot;\n}());\nexports.default = ShadowBlot;\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar attributor_1 = __webpack_require__(12);\nvar class_1 = __webpack_require__(32);\nvar style_1 = __webpack_require__(33);\nvar Registry = __webpack_require__(1);\nvar AttributorStore = /** @class */ (function () {\n    function AttributorStore(domNode) {\n        this.attributes = {};\n        this.domNode = domNode;\n        this.build();\n    }\n    AttributorStore.prototype.attribute = function (attribute, value) {\n        // verb\n        if (value) {\n            if (attribute.add(this.domNode, value)) {\n                if (attribute.value(this.domNode) != null) {\n                    this.attributes[attribute.attrName] = attribute;\n                }\n                else {\n                    delete this.attributes[attribute.attrName];\n                }\n            }\n        }\n        else {\n            attribute.remove(this.domNode);\n            delete this.attributes[attribute.attrName];\n        }\n    };\n    AttributorStore.prototype.build = function () {\n        var _this = this;\n        this.attributes = {};\n        var attributes = attributor_1.default.keys(this.domNode);\n        var classes = class_1.default.keys(this.domNode);\n        var styles = style_1.default.keys(this.domNode);\n        attributes\n            .concat(classes)\n            .concat(styles)\n            .forEach(function (name) {\n            var attr = Registry.query(name, Registry.Scope.ATTRIBUTE);\n            if (attr instanceof attributor_1.default) {\n                _this.attributes[attr.attrName] = attr;\n            }\n        });\n    };\n    AttributorStore.prototype.copy = function (target) {\n        var _this = this;\n        Object.keys(this.attributes).forEach(function (key) {\n            var value = _this.attributes[key].value(_this.domNode);\n            target.format(key, value);\n        });\n    };\n    AttributorStore.prototype.move = function (target) {\n        var _this = this;\n        this.copy(target);\n        Object.keys(this.attributes).forEach(function (key) {\n            _this.attributes[key].remove(_this.domNode);\n        });\n        this.attributes = {};\n    };\n    AttributorStore.prototype.values = function () {\n        var _this = this;\n        return Object.keys(this.attributes).reduce(function (attributes, name) {\n            attributes[name] = _this.attributes[name].value(_this.domNode);\n            return attributes;\n        }, {});\n    };\n    return AttributorStore;\n}());\nexports.default = AttributorStore;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar attributor_1 = __webpack_require__(12);\nfunction match(node, prefix) {\n    var className = node.getAttribute('class') || '';\n    return className.split(/\\s+/).filter(function (name) {\n        return name.indexOf(prefix + \"-\") === 0;\n    });\n}\nvar ClassAttributor = /** @class */ (function (_super) {\n    __extends(ClassAttributor, _super);\n    function ClassAttributor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ClassAttributor.keys = function (node) {\n        return (node.getAttribute('class') || '').split(/\\s+/).map(function (name) {\n            return name\n                .split('-')\n                .slice(0, -1)\n                .join('-');\n        });\n    };\n    ClassAttributor.prototype.add = function (node, value) {\n        if (!this.canAdd(node, value))\n            return false;\n        this.remove(node);\n        node.classList.add(this.keyName + \"-\" + value);\n        return true;\n    };\n    ClassAttributor.prototype.remove = function (node) {\n        var matches = match(node, this.keyName);\n        matches.forEach(function (name) {\n            node.classList.remove(name);\n        });\n        if (node.classList.length === 0) {\n            node.removeAttribute('class');\n        }\n    };\n    ClassAttributor.prototype.value = function (node) {\n        var result = match(node, this.keyName)[0] || '';\n        var value = result.slice(this.keyName.length + 1); // +1 for hyphen\n        return this.canAdd(node, value) ? value : '';\n    };\n    return ClassAttributor;\n}(attributor_1.default));\nexports.default = ClassAttributor;\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar attributor_1 = __webpack_require__(12);\nfunction camelize(name) {\n    var parts = name.split('-');\n    var rest = parts\n        .slice(1)\n        .map(function (part) {\n        return part[0].toUpperCase() + part.slice(1);\n    })\n        .join('');\n    return parts[0] + rest;\n}\nvar StyleAttributor = /** @class */ (function (_super) {\n    __extends(StyleAttributor, _super);\n    function StyleAttributor() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StyleAttributor.keys = function (node) {\n        return (node.getAttribute('style') || '').split(';').map(function (value) {\n            var arr = value.split(':');\n            return arr[0].trim();\n        });\n    };\n    StyleAttributor.prototype.add = function (node, value) {\n        if (!this.canAdd(node, value))\n            return false;\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = value;\n        return true;\n    };\n    StyleAttributor.prototype.remove = function (node) {\n        // @ts-ignore\n        node.style[camelize(this.keyName)] = '';\n        if (!node.getAttribute('style')) {\n            node.removeAttribute('style');\n        }\n    };\n    StyleAttributor.prototype.value = function (node) {\n        // @ts-ignore\n        var value = node.style[camelize(this.keyName)];\n        return this.canAdd(node, value) ? value : '';\n    };\n    return StyleAttributor;\n}(attributor_1.default));\nexports.default = StyleAttributor;\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Theme = function () {\n  function Theme(quill, options) {\n    _classCallCheck(this, Theme);\n\n    this.quill = quill;\n    this.options = options;\n    this.modules = {};\n  }\n\n  _createClass(Theme, [{\n    key: 'init',\n    value: function init() {\n      var _this = this;\n\n      Object.keys(this.options.modules).forEach(function (name) {\n        if (_this.modules[name] == null) {\n          _this.addModule(name);\n        }\n      });\n    }\n  }, {\n    key: 'addModule',\n    value: function addModule(name) {\n      var moduleClass = this.quill.constructor.import('modules/' + name);\n      this.modules[name] = new moduleClass(this.quill, this.options.modules[name] || {});\n      return this.modules[name];\n    }\n  }]);\n\n  return Theme;\n}();\n\nTheme.DEFAULTS = {\n  modules: {}\n};\nTheme.themes = {\n  'default': Theme\n};\n\nexports.default = Theme;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _text = __webpack_require__(7);\n\nvar _text2 = _interopRequireDefault(_text);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar GUARD_TEXT = '\\uFEFF';\n\nvar Embed = function (_Parchment$Embed) {\n  _inherits(Embed, _Parchment$Embed);\n\n  function Embed(node) {\n    _classCallCheck(this, Embed);\n\n    var _this = _possibleConstructorReturn(this, (Embed.__proto__ || Object.getPrototypeOf(Embed)).call(this, node));\n\n    _this.contentNode = document.createElement('span');\n    _this.contentNode.setAttribute('contenteditable', false);\n    [].slice.call(_this.domNode.childNodes).forEach(function (childNode) {\n      _this.contentNode.appendChild(childNode);\n    });\n    _this.leftGuard = document.createTextNode(GUARD_TEXT);\n    _this.rightGuard = document.createTextNode(GUARD_TEXT);\n    _this.domNode.appendChild(_this.leftGuard);\n    _this.domNode.appendChild(_this.contentNode);\n    _this.domNode.appendChild(_this.rightGuard);\n    return _this;\n  }\n\n  _createClass(Embed, [{\n    key: 'index',\n    value: function index(node, offset) {\n      if (node === this.leftGuard) return 0;\n      if (node === this.rightGuard) return 1;\n      return _get(Embed.prototype.__proto__ || Object.getPrototypeOf(Embed.prototype), 'index', this).call(this, node, offset);\n    }\n  }, {\n    key: 'restore',\n    value: function restore(node) {\n      var range = void 0,\n          textNode = void 0;\n      var text = node.data.split(GUARD_TEXT).join('');\n      if (node === this.leftGuard) {\n        if (this.prev instanceof _text2.default) {\n          var prevLength = this.prev.length();\n          this.prev.insertAt(prevLength, text);\n          range = {\n            startNode: this.prev.domNode,\n            startOffset: prevLength + text.length\n          };\n        } else {\n          textNode = document.createTextNode(text);\n          this.parent.insertBefore(_parchment2.default.create(textNode), this);\n          range = {\n            startNode: textNode,\n            startOffset: text.length\n          };\n        }\n      } else if (node === this.rightGuard) {\n        if (this.next instanceof _text2.default) {\n          this.next.insertAt(0, text);\n          range = {\n            startNode: this.next.domNode,\n            startOffset: text.length\n          };\n        } else {\n          textNode = document.createTextNode(text);\n          this.parent.insertBefore(_parchment2.default.create(textNode), this.next);\n          range = {\n            startNode: textNode,\n            startOffset: text.length\n          };\n        }\n      }\n      node.data = GUARD_TEXT;\n      return range;\n    }\n  }, {\n    key: 'update',\n    value: function update(mutations, context) {\n      var _this2 = this;\n\n      mutations.forEach(function (mutation) {\n        if (mutation.type === 'characterData' && (mutation.target === _this2.leftGuard || mutation.target === _this2.rightGuard)) {\n          var range = _this2.restore(mutation.target);\n          if (range) context.range = range;\n        }\n      });\n    }\n  }]);\n\n  return Embed;\n}(_parchment2.default.Embed);\n\nexports.default = Embed;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AlignStyle = exports.AlignClass = exports.AlignAttribute = undefined;\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar config = {\n  scope: _parchment2.default.Scope.BLOCK,\n  whitelist: ['right', 'center', 'justify']\n};\n\nvar AlignAttribute = new _parchment2.default.Attributor.Attribute('align', 'align', config);\nvar AlignClass = new _parchment2.default.Attributor.Class('align', 'ql-align', config);\nvar AlignStyle = new _parchment2.default.Attributor.Style('align', 'text-align', config);\n\nexports.AlignAttribute = AlignAttribute;\nexports.AlignClass = AlignClass;\nexports.AlignStyle = AlignStyle;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BackgroundStyle = exports.BackgroundClass = undefined;\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _color = __webpack_require__(26);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar BackgroundClass = new _parchment2.default.Attributor.Class('background', 'ql-bg', {\n  scope: _parchment2.default.Scope.INLINE\n});\nvar BackgroundStyle = new _color.ColorAttributor('background', 'background-color', {\n  scope: _parchment2.default.Scope.INLINE\n});\n\nexports.BackgroundClass = BackgroundClass;\nexports.BackgroundStyle = BackgroundStyle;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectionStyle = exports.DirectionClass = exports.DirectionAttribute = undefined;\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar config = {\n  scope: _parchment2.default.Scope.BLOCK,\n  whitelist: ['rtl']\n};\n\nvar DirectionAttribute = new _parchment2.default.Attributor.Attribute('direction', 'dir', config);\nvar DirectionClass = new _parchment2.default.Attributor.Class('direction', 'ql-direction', config);\nvar DirectionStyle = new _parchment2.default.Attributor.Style('direction', 'direction', config);\n\nexports.DirectionAttribute = DirectionAttribute;\nexports.DirectionClass = DirectionClass;\nexports.DirectionStyle = DirectionStyle;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FontClass = exports.FontStyle = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar config = {\n  scope: _parchment2.default.Scope.INLINE,\n  whitelist: ['serif', 'monospace']\n};\n\nvar FontClass = new _parchment2.default.Attributor.Class('font', 'ql-font', config);\n\nvar FontStyleAttributor = function (_Parchment$Attributor) {\n  _inherits(FontStyleAttributor, _Parchment$Attributor);\n\n  function FontStyleAttributor() {\n    _classCallCheck(this, FontStyleAttributor);\n\n    return _possibleConstructorReturn(this, (FontStyleAttributor.__proto__ || Object.getPrototypeOf(FontStyleAttributor)).apply(this, arguments));\n  }\n\n  _createClass(FontStyleAttributor, [{\n    key: 'value',\n    value: function value(node) {\n      return _get(FontStyleAttributor.prototype.__proto__ || Object.getPrototypeOf(FontStyleAttributor.prototype), 'value', this).call(this, node).replace(/[\"']/g, '');\n    }\n  }]);\n\n  return FontStyleAttributor;\n}(_parchment2.default.Attributor.Style);\n\nvar FontStyle = new FontStyleAttributor('font', 'font-family', config);\n\nexports.FontStyle = FontStyle;\nexports.FontClass = FontClass;\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SizeStyle = exports.SizeClass = undefined;\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar SizeClass = new _parchment2.default.Attributor.Class('size', 'ql-size', {\n  scope: _parchment2.default.Scope.INLINE,\n  whitelist: ['small', 'large', 'huge']\n});\nvar SizeStyle = new _parchment2.default.Attributor.Style('size', 'font-size', {\n  scope: _parchment2.default.Scope.INLINE,\n  whitelist: ['10px', '18px', '32px']\n});\n\nexports.SizeClass = SizeClass;\nexports.SizeStyle = SizeStyle;\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  'align': {\n    '': __webpack_require__(76),\n    'center': __webpack_require__(77),\n    'right': __webpack_require__(78),\n    'justify': __webpack_require__(79)\n  },\n  'background': __webpack_require__(80),\n  'blockquote': __webpack_require__(81),\n  'bold': __webpack_require__(82),\n  'clean': __webpack_require__(83),\n  'code': __webpack_require__(58),\n  'code-block': __webpack_require__(58),\n  'color': __webpack_require__(84),\n  'direction': {\n    '': __webpack_require__(85),\n    'rtl': __webpack_require__(86)\n  },\n  'float': {\n    'center': __webpack_require__(87),\n    'full': __webpack_require__(88),\n    'left': __webpack_require__(89),\n    'right': __webpack_require__(90)\n  },\n  'formula': __webpack_require__(91),\n  'header': {\n    '1': __webpack_require__(92),\n    '2': __webpack_require__(93)\n  },\n  'italic': __webpack_require__(94),\n  'image': __webpack_require__(95),\n  'indent': {\n    '+1': __webpack_require__(96),\n    '-1': __webpack_require__(97)\n  },\n  'link': __webpack_require__(98),\n  'list': {\n    'ordered': __webpack_require__(99),\n    'bullet': __webpack_require__(100),\n    'check': __webpack_require__(101)\n  },\n  'script': {\n    'sub': __webpack_require__(102),\n    'super': __webpack_require__(103)\n  },\n  'strike': __webpack_require__(104),\n  'underline': __webpack_require__(105),\n  'video': __webpack_require__(106)\n};\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getLastChangeIndex = exports.default = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _quill = __webpack_require__(5);\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _module = __webpack_require__(9);\n\nvar _module2 = _interopRequireDefault(_module);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar History = function (_Module) {\n  _inherits(History, _Module);\n\n  function History(quill, options) {\n    _classCallCheck(this, History);\n\n    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, quill, options));\n\n    _this.lastRecorded = 0;\n    _this.ignoreChange = false;\n    _this.clear();\n    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (eventName, delta, oldDelta, source) {\n      if (eventName !== _quill2.default.events.TEXT_CHANGE || _this.ignoreChange) return;\n      if (!_this.options.userOnly || source === _quill2.default.sources.USER) {\n        _this.record(delta, oldDelta);\n      } else {\n        _this.transform(delta);\n      }\n    });\n    _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true }, _this.undo.bind(_this));\n    _this.quill.keyboard.addBinding({ key: 'Z', shortKey: true, shiftKey: true }, _this.redo.bind(_this));\n    if (/Win/i.test(navigator.platform)) {\n      _this.quill.keyboard.addBinding({ key: 'Y', shortKey: true }, _this.redo.bind(_this));\n    }\n    return _this;\n  }\n\n  _createClass(History, [{\n    key: 'change',\n    value: function change(source, dest) {\n      if (this.stack[source].length === 0) return;\n      var delta = this.stack[source].pop();\n      this.stack[dest].push(delta);\n      this.lastRecorded = 0;\n      this.ignoreChange = true;\n      this.quill.updateContents(delta[source], _quill2.default.sources.USER);\n      this.ignoreChange = false;\n      var index = getLastChangeIndex(delta[source]);\n      this.quill.setSelection(index);\n    }\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.stack = { undo: [], redo: [] };\n    }\n  }, {\n    key: 'cutoff',\n    value: function cutoff() {\n      this.lastRecorded = 0;\n    }\n  }, {\n    key: 'record',\n    value: function record(changeDelta, oldDelta) {\n      if (changeDelta.ops.length === 0) return;\n      this.stack.redo = [];\n      var undoDelta = this.quill.getContents().diff(oldDelta);\n      var timestamp = Date.now();\n      if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {\n        var delta = this.stack.undo.pop();\n        undoDelta = undoDelta.compose(delta.undo);\n        changeDelta = delta.redo.compose(changeDelta);\n      } else {\n        this.lastRecorded = timestamp;\n      }\n      this.stack.undo.push({\n        redo: changeDelta,\n        undo: undoDelta\n      });\n      if (this.stack.undo.length > this.options.maxStack) {\n        this.stack.undo.shift();\n      }\n    }\n  }, {\n    key: 'redo',\n    value: function redo() {\n      this.change('redo', 'undo');\n    }\n  }, {\n    key: 'transform',\n    value: function transform(delta) {\n      this.stack.undo.forEach(function (change) {\n        change.undo = delta.transform(change.undo, true);\n        change.redo = delta.transform(change.redo, true);\n      });\n      this.stack.redo.forEach(function (change) {\n        change.undo = delta.transform(change.undo, true);\n        change.redo = delta.transform(change.redo, true);\n      });\n    }\n  }, {\n    key: 'undo',\n    value: function undo() {\n      this.change('undo', 'redo');\n    }\n  }]);\n\n  return History;\n}(_module2.default);\n\nHistory.DEFAULTS = {\n  delay: 1000,\n  maxStack: 100,\n  userOnly: false\n};\n\nfunction endsWithNewlineChange(delta) {\n  var lastOp = delta.ops[delta.ops.length - 1];\n  if (lastOp == null) return false;\n  if (lastOp.insert != null) {\n    return typeof lastOp.insert === 'string' && lastOp.insert.endsWith('\\n');\n  }\n  if (lastOp.attributes != null) {\n    return Object.keys(lastOp.attributes).some(function (attr) {\n      return _parchment2.default.query(attr, _parchment2.default.Scope.BLOCK) != null;\n    });\n  }\n  return false;\n}\n\nfunction getLastChangeIndex(delta) {\n  var deleteLength = delta.reduce(function (length, op) {\n    length += op.delete || 0;\n    return length;\n  }, 0);\n  var changeIndex = delta.length() - deleteLength;\n  if (endsWithNewlineChange(delta)) {\n    changeIndex -= 1;\n  }\n  return changeIndex;\n}\n\nexports.default = History;\nexports.getLastChangeIndex = getLastChangeIndex;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.BaseTooltip = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _extend = __webpack_require__(3);\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _emitter = __webpack_require__(8);\n\nvar _emitter2 = _interopRequireDefault(_emitter);\n\nvar _keyboard = __webpack_require__(23);\n\nvar _keyboard2 = _interopRequireDefault(_keyboard);\n\nvar _theme = __webpack_require__(34);\n\nvar _theme2 = _interopRequireDefault(_theme);\n\nvar _colorPicker = __webpack_require__(59);\n\nvar _colorPicker2 = _interopRequireDefault(_colorPicker);\n\nvar _iconPicker = __webpack_require__(60);\n\nvar _iconPicker2 = _interopRequireDefault(_iconPicker);\n\nvar _picker = __webpack_require__(28);\n\nvar _picker2 = _interopRequireDefault(_picker);\n\nvar _tooltip = __webpack_require__(61);\n\nvar _tooltip2 = _interopRequireDefault(_tooltip);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ALIGNS = [false, 'center', 'right', 'justify'];\n\nvar COLORS = [\"#000000\", \"#e60000\", \"#ff9900\", \"#ffff00\", \"#008a00\", \"#0066cc\", \"#9933ff\", \"#ffffff\", \"#facccc\", \"#ffebcc\", \"#ffffcc\", \"#cce8cc\", \"#cce0f5\", \"#ebd6ff\", \"#bbbbbb\", \"#f06666\", \"#ffc266\", \"#ffff66\", \"#66b966\", \"#66a3e0\", \"#c285ff\", \"#888888\", \"#a10000\", \"#b26b00\", \"#b2b200\", \"#006100\", \"#0047b2\", \"#6b24b2\", \"#444444\", \"#5c0000\", \"#663d00\", \"#666600\", \"#003700\", \"#002966\", \"#3d1466\"];\n\nvar FONTS = [false, 'serif', 'monospace'];\n\nvar HEADERS = ['1', '2', '3', false];\n\nvar SIZES = ['small', false, 'large', 'huge'];\n\nvar BaseTheme = function (_Theme) {\n  _inherits(BaseTheme, _Theme);\n\n  function BaseTheme(quill, options) {\n    _classCallCheck(this, BaseTheme);\n\n    var _this = _possibleConstructorReturn(this, (BaseTheme.__proto__ || Object.getPrototypeOf(BaseTheme)).call(this, quill, options));\n\n    var listener = function listener(e) {\n      if (!document.body.contains(quill.root)) {\n        return document.body.removeEventListener('click', listener);\n      }\n      if (_this.tooltip != null && !_this.tooltip.root.contains(e.target) && document.activeElement !== _this.tooltip.textbox && !_this.quill.hasFocus()) {\n        _this.tooltip.hide();\n      }\n      if (_this.pickers != null) {\n        _this.pickers.forEach(function (picker) {\n          if (!picker.container.contains(e.target)) {\n            picker.close();\n          }\n        });\n      }\n    };\n    quill.emitter.listenDOM('click', document.body, listener);\n    return _this;\n  }\n\n  _createClass(BaseTheme, [{\n    key: 'addModule',\n    value: function addModule(name) {\n      var module = _get(BaseTheme.prototype.__proto__ || Object.getPrototypeOf(BaseTheme.prototype), 'addModule', this).call(this, name);\n      if (name === 'toolbar') {\n        this.extendToolbar(module);\n      }\n      return module;\n    }\n  }, {\n    key: 'buildButtons',\n    value: function buildButtons(buttons, icons) {\n      buttons.forEach(function (button) {\n        var className = button.getAttribute('class') || '';\n        className.split(/\\s+/).forEach(function (name) {\n          if (!name.startsWith('ql-')) return;\n          name = name.slice('ql-'.length);\n          if (icons[name] == null) return;\n          if (name === 'direction') {\n            button.innerHTML = icons[name][''] + icons[name]['rtl'];\n          } else if (typeof icons[name] === 'string') {\n            button.innerHTML = icons[name];\n          } else {\n            var value = button.value || '';\n            if (value != null && icons[name][value]) {\n              button.innerHTML = icons[name][value];\n            }\n          }\n        });\n      });\n    }\n  }, {\n    key: 'buildPickers',\n    value: function buildPickers(selects, icons) {\n      var _this2 = this;\n\n      this.pickers = selects.map(function (select) {\n        if (select.classList.contains('ql-align')) {\n          if (select.querySelector('option') == null) {\n            fillSelect(select, ALIGNS);\n          }\n          return new _iconPicker2.default(select, icons.align);\n        } else if (select.classList.contains('ql-background') || select.classList.contains('ql-color')) {\n          var format = select.classList.contains('ql-background') ? 'background' : 'color';\n          if (select.querySelector('option') == null) {\n            fillSelect(select, COLORS, format === 'background' ? '#ffffff' : '#000000');\n          }\n          return new _colorPicker2.default(select, icons[format]);\n        } else {\n          if (select.querySelector('option') == null) {\n            if (select.classList.contains('ql-font')) {\n              fillSelect(select, FONTS);\n            } else if (select.classList.contains('ql-header')) {\n              fillSelect(select, HEADERS);\n            } else if (select.classList.contains('ql-size')) {\n              fillSelect(select, SIZES);\n            }\n          }\n          return new _picker2.default(select);\n        }\n      });\n      var update = function update() {\n        _this2.pickers.forEach(function (picker) {\n          picker.update();\n        });\n      };\n      this.quill.on(_emitter2.default.events.EDITOR_CHANGE, update);\n    }\n  }]);\n\n  return BaseTheme;\n}(_theme2.default);\n\nBaseTheme.DEFAULTS = (0, _extend2.default)(true, {}, _theme2.default.DEFAULTS, {\n  modules: {\n    toolbar: {\n      handlers: {\n        formula: function formula() {\n          this.quill.theme.tooltip.edit('formula');\n        },\n        image: function image() {\n          var _this3 = this;\n\n          var fileInput = this.container.querySelector('input.ql-image[type=file]');\n          if (fileInput == null) {\n            fileInput = document.createElement('input');\n            fileInput.setAttribute('type', 'file');\n            fileInput.setAttribute('accept', 'image/png, image/gif, image/jpeg, image/bmp, image/x-icon');\n            fileInput.classList.add('ql-image');\n            fileInput.addEventListener('change', function () {\n              if (fileInput.files != null && fileInput.files[0] != null) {\n                var reader = new FileReader();\n                reader.onload = function (e) {\n                  var range = _this3.quill.getSelection(true);\n                  _this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({ image: e.target.result }), _emitter2.default.sources.USER);\n                  _this3.quill.setSelection(range.index + 1, _emitter2.default.sources.SILENT);\n                  fileInput.value = \"\";\n                };\n                reader.readAsDataURL(fileInput.files[0]);\n              }\n            });\n            this.container.appendChild(fileInput);\n          }\n          fileInput.click();\n        },\n        video: function video() {\n          this.quill.theme.tooltip.edit('video');\n        }\n      }\n    }\n  }\n});\n\nvar BaseTooltip = function (_Tooltip) {\n  _inherits(BaseTooltip, _Tooltip);\n\n  function BaseTooltip(quill, boundsContainer) {\n    _classCallCheck(this, BaseTooltip);\n\n    var _this4 = _possibleConstructorReturn(this, (BaseTooltip.__proto__ || Object.getPrototypeOf(BaseTooltip)).call(this, quill, boundsContainer));\n\n    _this4.textbox = _this4.root.querySelector('input[type=\"text\"]');\n    _this4.listen();\n    return _this4;\n  }\n\n  _createClass(BaseTooltip, [{\n    key: 'listen',\n    value: function listen() {\n      var _this5 = this;\n\n      this.textbox.addEventListener('keydown', function (event) {\n        if (_keyboard2.default.match(event, 'enter')) {\n          _this5.save();\n          event.preventDefault();\n        } else if (_keyboard2.default.match(event, 'escape')) {\n          _this5.cancel();\n          event.preventDefault();\n        }\n      });\n    }\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      this.hide();\n    }\n  }, {\n    key: 'edit',\n    value: function edit() {\n      var mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'link';\n      var preview = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      this.root.classList.remove('ql-hidden');\n      this.root.classList.add('ql-editing');\n      if (preview != null) {\n        this.textbox.value = preview;\n      } else if (mode !== this.root.getAttribute('data-mode')) {\n        this.textbox.value = '';\n      }\n      this.position(this.quill.getBounds(this.quill.selection.savedRange));\n      this.textbox.select();\n      this.textbox.setAttribute('placeholder', this.textbox.getAttribute('data-' + mode) || '');\n      this.root.setAttribute('data-mode', mode);\n    }\n  }, {\n    key: 'restoreFocus',\n    value: function restoreFocus() {\n      var scrollTop = this.quill.scrollingContainer.scrollTop;\n      this.quill.focus();\n      this.quill.scrollingContainer.scrollTop = scrollTop;\n    }\n  }, {\n    key: 'save',\n    value: function save() {\n      var value = this.textbox.value;\n      switch (this.root.getAttribute('data-mode')) {\n        case 'link':\n          {\n            var scrollTop = this.quill.root.scrollTop;\n            if (this.linkRange) {\n              this.quill.formatText(this.linkRange, 'link', value, _emitter2.default.sources.USER);\n              delete this.linkRange;\n            } else {\n              this.restoreFocus();\n              this.quill.format('link', value, _emitter2.default.sources.USER);\n            }\n            this.quill.root.scrollTop = scrollTop;\n            break;\n          }\n        case 'video':\n          {\n            value = extractVideoUrl(value);\n          } // eslint-disable-next-line no-fallthrough\n        case 'formula':\n          {\n            if (!value) break;\n            var range = this.quill.getSelection(true);\n            if (range != null) {\n              var index = range.index + range.length;\n              this.quill.insertEmbed(index, this.root.getAttribute('data-mode'), value, _emitter2.default.sources.USER);\n              if (this.root.getAttribute('data-mode') === 'formula') {\n                this.quill.insertText(index + 1, ' ', _emitter2.default.sources.USER);\n              }\n              this.quill.setSelection(index + 2, _emitter2.default.sources.USER);\n            }\n            break;\n          }\n        default:\n      }\n      this.textbox.value = '';\n      this.hide();\n    }\n  }]);\n\n  return BaseTooltip;\n}(_tooltip2.default);\n\nfunction extractVideoUrl(url) {\n  var match = url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtube\\.com\\/watch.*v=([a-zA-Z0-9_-]+)/) || url.match(/^(?:(https?):\\/\\/)?(?:(?:www|m)\\.)?youtu\\.be\\/([a-zA-Z0-9_-]+)/);\n  if (match) {\n    return (match[1] || 'https') + '://www.youtube.com/embed/' + match[2] + '?showinfo=0';\n  }\n  if (match = url.match(/^(?:(https?):\\/\\/)?(?:www\\.)?vimeo\\.com\\/(\\d+)/)) {\n    // eslint-disable-line no-cond-assign\n    return (match[1] || 'https') + '://player.vimeo.com/video/' + match[2] + '/';\n  }\n  return url;\n}\n\nfunction fillSelect(select, values) {\n  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  values.forEach(function (value) {\n    var option = document.createElement('option');\n    if (value === defaultValue) {\n      option.setAttribute('selected', 'selected');\n    } else {\n      option.setAttribute('value', value);\n    }\n    select.appendChild(option);\n  });\n}\n\nexports.BaseTooltip = BaseTooltip;\nexports.default = BaseTheme;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar LinkedList = /** @class */ (function () {\n    function LinkedList() {\n        this.head = this.tail = null;\n        this.length = 0;\n    }\n    LinkedList.prototype.append = function () {\n        var nodes = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nodes[_i] = arguments[_i];\n        }\n        this.insertBefore(nodes[0], null);\n        if (nodes.length > 1) {\n            this.append.apply(this, nodes.slice(1));\n        }\n    };\n    LinkedList.prototype.contains = function (node) {\n        var cur, next = this.iterator();\n        while ((cur = next())) {\n            if (cur === node)\n                return true;\n        }\n        return false;\n    };\n    LinkedList.prototype.insertBefore = function (node, refNode) {\n        if (!node)\n            return;\n        node.next = refNode;\n        if (refNode != null) {\n            node.prev = refNode.prev;\n            if (refNode.prev != null) {\n                refNode.prev.next = node;\n            }\n            refNode.prev = node;\n            if (refNode === this.head) {\n                this.head = node;\n            }\n        }\n        else if (this.tail != null) {\n            this.tail.next = node;\n            node.prev = this.tail;\n            this.tail = node;\n        }\n        else {\n            node.prev = null;\n            this.head = this.tail = node;\n        }\n        this.length += 1;\n    };\n    LinkedList.prototype.offset = function (target) {\n        var index = 0, cur = this.head;\n        while (cur != null) {\n            if (cur === target)\n                return index;\n            index += cur.length();\n            cur = cur.next;\n        }\n        return -1;\n    };\n    LinkedList.prototype.remove = function (node) {\n        if (!this.contains(node))\n            return;\n        if (node.prev != null)\n            node.prev.next = node.next;\n        if (node.next != null)\n            node.next.prev = node.prev;\n        if (node === this.head)\n            this.head = node.next;\n        if (node === this.tail)\n            this.tail = node.prev;\n        this.length -= 1;\n    };\n    LinkedList.prototype.iterator = function (curNode) {\n        if (curNode === void 0) { curNode = this.head; }\n        // TODO use yield when we can\n        return function () {\n            var ret = curNode;\n            if (curNode != null)\n                curNode = curNode.next;\n            return ret;\n        };\n    };\n    LinkedList.prototype.find = function (index, inclusive) {\n        if (inclusive === void 0) { inclusive = false; }\n        var cur, next = this.iterator();\n        while ((cur = next())) {\n            var length = cur.length();\n            if (index < length ||\n                (inclusive && index === length && (cur.next == null || cur.next.length() !== 0))) {\n                return [cur, index];\n            }\n            index -= length;\n        }\n        return [null, 0];\n    };\n    LinkedList.prototype.forEach = function (callback) {\n        var cur, next = this.iterator();\n        while ((cur = next())) {\n            callback(cur);\n        }\n    };\n    LinkedList.prototype.forEachAt = function (index, length, callback) {\n        if (length <= 0)\n            return;\n        var _a = this.find(index), startNode = _a[0], offset = _a[1];\n        var cur, curIndex = index - offset, next = this.iterator(startNode);\n        while ((cur = next()) && curIndex < index + length) {\n            var curLength = cur.length();\n            if (index > curIndex) {\n                callback(cur, index - curIndex, Math.min(length, curIndex + curLength - index));\n            }\n            else {\n                callback(cur, 0, Math.min(curLength, index + length - curIndex));\n            }\n            curIndex += curLength;\n        }\n    };\n    LinkedList.prototype.map = function (callback) {\n        return this.reduce(function (memo, cur) {\n            memo.push(callback(cur));\n            return memo;\n        }, []);\n    };\n    LinkedList.prototype.reduce = function (callback, memo) {\n        var cur, next = this.iterator();\n        while ((cur = next())) {\n            memo = callback(memo, cur);\n        }\n        return memo;\n    };\n    return LinkedList;\n}());\nexports.default = LinkedList;\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar container_1 = __webpack_require__(17);\nvar Registry = __webpack_require__(1);\nvar OBSERVER_CONFIG = {\n    attributes: true,\n    characterData: true,\n    characterDataOldValue: true,\n    childList: true,\n    subtree: true,\n};\nvar MAX_OPTIMIZE_ITERATIONS = 100;\nvar ScrollBlot = /** @class */ (function (_super) {\n    __extends(ScrollBlot, _super);\n    function ScrollBlot(node) {\n        var _this = _super.call(this, node) || this;\n        _this.scroll = _this;\n        _this.observer = new MutationObserver(function (mutations) {\n            _this.update(mutations);\n        });\n        _this.observer.observe(_this.domNode, OBSERVER_CONFIG);\n        _this.attach();\n        return _this;\n    }\n    ScrollBlot.prototype.detach = function () {\n        _super.prototype.detach.call(this);\n        this.observer.disconnect();\n    };\n    ScrollBlot.prototype.deleteAt = function (index, length) {\n        this.update();\n        if (index === 0 && length === this.length()) {\n            this.children.forEach(function (child) {\n                child.remove();\n            });\n        }\n        else {\n            _super.prototype.deleteAt.call(this, index, length);\n        }\n    };\n    ScrollBlot.prototype.formatAt = function (index, length, name, value) {\n        this.update();\n        _super.prototype.formatAt.call(this, index, length, name, value);\n    };\n    ScrollBlot.prototype.insertAt = function (index, value, def) {\n        this.update();\n        _super.prototype.insertAt.call(this, index, value, def);\n    };\n    ScrollBlot.prototype.optimize = function (mutations, context) {\n        var _this = this;\n        if (mutations === void 0) { mutations = []; }\n        if (context === void 0) { context = {}; }\n        _super.prototype.optimize.call(this, context);\n        // We must modify mutations directly, cannot make copy and then modify\n        var records = [].slice.call(this.observer.takeRecords());\n        // Array.push currently seems to be implemented by a non-tail recursive function\n        // so we cannot just mutations.push.apply(mutations, this.observer.takeRecords());\n        while (records.length > 0)\n            mutations.push(records.pop());\n        // TODO use WeakMap\n        var mark = function (blot, markParent) {\n            if (markParent === void 0) { markParent = true; }\n            if (blot == null || blot === _this)\n                return;\n            if (blot.domNode.parentNode == null)\n                return;\n            // @ts-ignore\n            if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                // @ts-ignore\n                blot.domNode[Registry.DATA_KEY].mutations = [];\n            }\n            if (markParent)\n                mark(blot.parent);\n        };\n        var optimize = function (blot) {\n            // Post-order traversal\n            if (\n            // @ts-ignore\n            blot.domNode[Registry.DATA_KEY] == null ||\n                // @ts-ignore\n                blot.domNode[Registry.DATA_KEY].mutations == null) {\n                return;\n            }\n            if (blot instanceof container_1.default) {\n                blot.children.forEach(optimize);\n            }\n            blot.optimize(context);\n        };\n        var remaining = mutations;\n        for (var i = 0; remaining.length > 0; i += 1) {\n            if (i >= MAX_OPTIMIZE_ITERATIONS) {\n                throw new Error('[Parchment] Maximum optimize iterations reached');\n            }\n            remaining.forEach(function (mutation) {\n                var blot = Registry.find(mutation.target, true);\n                if (blot == null)\n                    return;\n                if (blot.domNode === mutation.target) {\n                    if (mutation.type === 'childList') {\n                        mark(Registry.find(mutation.previousSibling, false));\n                        [].forEach.call(mutation.addedNodes, function (node) {\n                            var child = Registry.find(node, false);\n                            mark(child, false);\n                            if (child instanceof container_1.default) {\n                                child.children.forEach(function (grandChild) {\n                                    mark(grandChild, false);\n                                });\n                            }\n                        });\n                    }\n                    else if (mutation.type === 'attributes') {\n                        mark(blot.prev);\n                    }\n                }\n                mark(blot);\n            });\n            this.children.forEach(optimize);\n            remaining = [].slice.call(this.observer.takeRecords());\n            records = remaining.slice();\n            while (records.length > 0)\n                mutations.push(records.pop());\n        }\n    };\n    ScrollBlot.prototype.update = function (mutations, context) {\n        var _this = this;\n        if (context === void 0) { context = {}; }\n        mutations = mutations || this.observer.takeRecords();\n        // TODO use WeakMap\n        mutations\n            .map(function (mutation) {\n            var blot = Registry.find(mutation.target, true);\n            if (blot == null)\n                return null;\n            // @ts-ignore\n            if (blot.domNode[Registry.DATA_KEY].mutations == null) {\n                // @ts-ignore\n                blot.domNode[Registry.DATA_KEY].mutations = [mutation];\n                return blot;\n            }\n            else {\n                // @ts-ignore\n                blot.domNode[Registry.DATA_KEY].mutations.push(mutation);\n                return null;\n            }\n        })\n            .forEach(function (blot) {\n            if (blot == null ||\n                blot === _this ||\n                //@ts-ignore\n                blot.domNode[Registry.DATA_KEY] == null)\n                return;\n            // @ts-ignore\n            blot.update(blot.domNode[Registry.DATA_KEY].mutations || [], context);\n        });\n        // @ts-ignore\n        if (this.domNode[Registry.DATA_KEY].mutations != null) {\n            // @ts-ignore\n            _super.prototype.update.call(this, this.domNode[Registry.DATA_KEY].mutations, context);\n        }\n        this.optimize(mutations, context);\n    };\n    ScrollBlot.blotName = 'scroll';\n    ScrollBlot.defaultChild = 'block';\n    ScrollBlot.scope = Registry.Scope.BLOCK_BLOT;\n    ScrollBlot.tagName = 'DIV';\n    return ScrollBlot;\n}(container_1.default));\nexports.default = ScrollBlot;\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar format_1 = __webpack_require__(18);\nvar Registry = __webpack_require__(1);\n// Shallow object comparison\nfunction isEqual(obj1, obj2) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length)\n        return false;\n    // @ts-ignore\n    for (var prop in obj1) {\n        // @ts-ignore\n        if (obj1[prop] !== obj2[prop])\n            return false;\n    }\n    return true;\n}\nvar InlineBlot = /** @class */ (function (_super) {\n    __extends(InlineBlot, _super);\n    function InlineBlot() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    InlineBlot.formats = function (domNode) {\n        if (domNode.tagName === InlineBlot.tagName)\n            return undefined;\n        return _super.formats.call(this, domNode);\n    };\n    InlineBlot.prototype.format = function (name, value) {\n        var _this = this;\n        if (name === this.statics.blotName && !value) {\n            this.children.forEach(function (child) {\n                if (!(child instanceof format_1.default)) {\n                    child = child.wrap(InlineBlot.blotName, true);\n                }\n                _this.attributes.copy(child);\n            });\n            this.unwrap();\n        }\n        else {\n            _super.prototype.format.call(this, name, value);\n        }\n    };\n    InlineBlot.prototype.formatAt = function (index, length, name, value) {\n        if (this.formats()[name] != null || Registry.query(name, Registry.Scope.ATTRIBUTE)) {\n            var blot = this.isolate(index, length);\n            blot.format(name, value);\n        }\n        else {\n            _super.prototype.formatAt.call(this, index, length, name, value);\n        }\n    };\n    InlineBlot.prototype.optimize = function (context) {\n        _super.prototype.optimize.call(this, context);\n        var formats = this.formats();\n        if (Object.keys(formats).length === 0) {\n            return this.unwrap(); // unformatted span\n        }\n        var next = this.next;\n        if (next instanceof InlineBlot && next.prev === this && isEqual(formats, next.formats())) {\n            next.moveChildren(this);\n            next.remove();\n        }\n    };\n    InlineBlot.blotName = 'inline';\n    InlineBlot.scope = Registry.Scope.INLINE_BLOT;\n    InlineBlot.tagName = 'SPAN';\n    return InlineBlot;\n}(format_1.default));\nexports.default = InlineBlot;\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar format_1 = __webpack_require__(18);\nvar Registry = __webpack_require__(1);\nvar BlockBlot = /** @class */ (function (_super) {\n    __extends(BlockBlot, _super);\n    function BlockBlot() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BlockBlot.formats = function (domNode) {\n        var tagName = Registry.query(BlockBlot.blotName).tagName;\n        if (domNode.tagName === tagName)\n            return undefined;\n        return _super.formats.call(this, domNode);\n    };\n    BlockBlot.prototype.format = function (name, value) {\n        if (Registry.query(name, Registry.Scope.BLOCK) == null) {\n            return;\n        }\n        else if (name === this.statics.blotName && !value) {\n            this.replaceWith(BlockBlot.blotName);\n        }\n        else {\n            _super.prototype.format.call(this, name, value);\n        }\n    };\n    BlockBlot.prototype.formatAt = function (index, length, name, value) {\n        if (Registry.query(name, Registry.Scope.BLOCK) != null) {\n            this.format(name, value);\n        }\n        else {\n            _super.prototype.formatAt.call(this, index, length, name, value);\n        }\n    };\n    BlockBlot.prototype.insertAt = function (index, value, def) {\n        if (def == null || Registry.query(value, Registry.Scope.INLINE) != null) {\n            // Insert text or inline\n            _super.prototype.insertAt.call(this, index, value, def);\n        }\n        else {\n            var after = this.split(index);\n            var blot = Registry.create(value, def);\n            after.parent.insertBefore(blot, after);\n        }\n    };\n    BlockBlot.prototype.update = function (mutations, context) {\n        if (navigator.userAgent.match(/Trident/)) {\n            this.build();\n        }\n        else {\n            _super.prototype.update.call(this, mutations, context);\n        }\n    };\n    BlockBlot.blotName = 'block';\n    BlockBlot.scope = Registry.Scope.BLOCK_BLOT;\n    BlockBlot.tagName = 'P';\n    return BlockBlot;\n}(format_1.default));\nexports.default = BlockBlot;\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar leaf_1 = __webpack_require__(19);\nvar EmbedBlot = /** @class */ (function (_super) {\n    __extends(EmbedBlot, _super);\n    function EmbedBlot() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    EmbedBlot.formats = function (domNode) {\n        return undefined;\n    };\n    EmbedBlot.prototype.format = function (name, value) {\n        // super.formatAt wraps, which is what we want in general,\n        // but this allows subclasses to overwrite for formats\n        // that just apply to particular embeds\n        _super.prototype.formatAt.call(this, 0, this.length(), name, value);\n    };\n    EmbedBlot.prototype.formatAt = function (index, length, name, value) {\n        if (index === 0 && length === this.length()) {\n            this.format(name, value);\n        }\n        else {\n            _super.prototype.formatAt.call(this, index, length, name, value);\n        }\n    };\n    EmbedBlot.prototype.formats = function () {\n        return this.statics.formats(this.domNode);\n    };\n    return EmbedBlot;\n}(leaf_1.default));\nexports.default = EmbedBlot;\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar leaf_1 = __webpack_require__(19);\nvar Registry = __webpack_require__(1);\nvar TextBlot = /** @class */ (function (_super) {\n    __extends(TextBlot, _super);\n    function TextBlot(node) {\n        var _this = _super.call(this, node) || this;\n        _this.text = _this.statics.value(_this.domNode);\n        return _this;\n    }\n    TextBlot.create = function (value) {\n        return document.createTextNode(value);\n    };\n    TextBlot.value = function (domNode) {\n        var text = domNode.data;\n        // @ts-ignore\n        if (text['normalize'])\n            text = text['normalize']();\n        return text;\n    };\n    TextBlot.prototype.deleteAt = function (index, length) {\n        this.domNode.data = this.text = this.text.slice(0, index) + this.text.slice(index + length);\n    };\n    TextBlot.prototype.index = function (node, offset) {\n        if (this.domNode === node) {\n            return offset;\n        }\n        return -1;\n    };\n    TextBlot.prototype.insertAt = function (index, value, def) {\n        if (def == null) {\n            this.text = this.text.slice(0, index) + value + this.text.slice(index);\n            this.domNode.data = this.text;\n        }\n        else {\n            _super.prototype.insertAt.call(this, index, value, def);\n        }\n    };\n    TextBlot.prototype.length = function () {\n        return this.text.length;\n    };\n    TextBlot.prototype.optimize = function (context) {\n        _super.prototype.optimize.call(this, context);\n        this.text = this.statics.value(this.domNode);\n        if (this.text.length === 0) {\n            this.remove();\n        }\n        else if (this.next instanceof TextBlot && this.next.prev === this) {\n            this.insertAt(this.length(), this.next.value());\n            this.next.remove();\n        }\n    };\n    TextBlot.prototype.position = function (index, inclusive) {\n        if (inclusive === void 0) { inclusive = false; }\n        return [this.domNode, index];\n    };\n    TextBlot.prototype.split = function (index, force) {\n        if (force === void 0) { force = false; }\n        if (!force) {\n            if (index === 0)\n                return this;\n            if (index === this.length())\n                return this.next;\n        }\n        var after = Registry.create(this.domNode.splitText(index));\n        this.parent.insertBefore(after, this.next);\n        this.text = this.statics.value(this.domNode);\n        return after;\n    };\n    TextBlot.prototype.update = function (mutations, context) {\n        var _this = this;\n        if (mutations.some(function (mutation) {\n            return mutation.type === 'characterData' && mutation.target === _this.domNode;\n        })) {\n            this.text = this.statics.value(this.domNode);\n        }\n    };\n    TextBlot.prototype.value = function () {\n        return this.text;\n    };\n    TextBlot.blotName = 'text';\n    TextBlot.scope = Registry.Scope.INLINE_BLOT;\n    return TextBlot;\n}(leaf_1.default));\nexports.default = TextBlot;\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar elem = document.createElement('div');\nelem.classList.toggle('test-class', false);\nif (elem.classList.contains('test-class')) {\n  var _toggle = DOMTokenList.prototype.toggle;\n  DOMTokenList.prototype.toggle = function (token, force) {\n    if (arguments.length > 1 && !this.contains(token) === !force) {\n      return force;\n    } else {\n      return _toggle.call(this, token);\n    }\n  };\n}\n\nif (!String.prototype.startsWith) {\n  String.prototype.startsWith = function (searchString, position) {\n    position = position || 0;\n    return this.substr(position, searchString.length) === searchString;\n  };\n}\n\nif (!String.prototype.endsWith) {\n  String.prototype.endsWith = function (searchString, position) {\n    var subjectString = this.toString();\n    if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\n      position = subjectString.length;\n    }\n    position -= searchString.length;\n    var lastIndex = subjectString.indexOf(searchString, position);\n    return lastIndex !== -1 && lastIndex === position;\n  };\n}\n\nif (!Array.prototype.find) {\n  Object.defineProperty(Array.prototype, \"find\", {\n    value: function value(predicate) {\n      if (this === null) {\n        throw new TypeError('Array.prototype.find called on null or undefined');\n      }\n      if (typeof predicate !== 'function') {\n        throw new TypeError('predicate must be a function');\n      }\n      var list = Object(this);\n      var length = list.length >>> 0;\n      var thisArg = arguments[1];\n      var value;\n\n      for (var i = 0; i < length; i++) {\n        value = list[i];\n        if (predicate.call(thisArg, value, i, list)) {\n          return value;\n        }\n      }\n      return undefined;\n    }\n  });\n}\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  // Disable resizing in Firefox\n  document.execCommand(\"enableObjectResizing\", false, false);\n  // Disable automatic linkifying in IE11\n  document.execCommand(\"autoUrlDetect\", false, false);\n});\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\n/**\n * This library modifies the diff-patch-match library by Neil Fraser\n * by removing the patch and match functionality and certain advanced\n * options in the diff function. The original license is as follows:\n *\n * ===\n *\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {Int} cursor_pos Expected edit position in text1 (optional)\n * @return {Array} Array of diff tuples.\n */\nfunction diff_main(text1, text2, cursor_pos) {\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  // Check cursor_pos within bounds\n  if (cursor_pos < 0 || text1.length < cursor_pos) {\n    cursor_pos = null;\n  }\n\n  // Trim off common prefix (speedup).\n  var commonlength = diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = diff_compute_(text1, text2);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  diff_cleanupMerge(diffs);\n  if (cursor_pos != null) {\n    diffs = fix_cursor(diffs, cursor_pos);\n  }\n  diffs = fix_emoji(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_compute_(text1, text2) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n\n  // Check to see if the problem can be split in two.\n  var hm = diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = diff_main(text1_a, text2_a);\n    var diffs_b = diff_main(text1_b, text2_b);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  return diff_bisect_(text1, text2);\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @return {Array} Array of diff tuples.\n * @private\n */\nfunction diff_bisect_(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return diff_bisectSplit_(text1, text2, x1, y1);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @return {Array} Array of diff tuples.\n */\nfunction diff_bisectSplit_(text1, text2, x, y) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = diff_main(text1a, text2a);\n  var diffsb = diff_main(text1b, text2b);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\nfunction diff_commonPrefix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\nfunction diff_commonSuffix(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n */\nfunction diff_halfMatch_(text1, text2) {\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = diff_commonPrefix(longtext.substring(i),\n                                           shorttext.substring(j));\n      var suffixLength = diff_commonSuffix(longtext.substring(0, i),\n                                           shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {Array} diffs Array of diff tuples.\n */\nfunction diff_cleanupMerge(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    diff_cleanupMerge(diffs);\n  }\n};\n\n\nvar diff = diff_main;\ndiff.INSERT = DIFF_INSERT;\ndiff.DELETE = DIFF_DELETE;\ndiff.EQUAL = DIFF_EQUAL;\n\nmodule.exports = diff;\n\n/*\n * Modify a diff such that the cursor position points to the start of a change:\n * E.g.\n *   cursor_normalize_diff([[DIFF_EQUAL, 'abc']], 1)\n *     => [1, [[DIFF_EQUAL, 'a'], [DIFF_EQUAL, 'bc']]]\n *   cursor_normalize_diff([[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xyz']], 2)\n *     => [2, [[DIFF_INSERT, 'new'], [DIFF_DELETE, 'xy'], [DIFF_DELETE, 'z']]]\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} A tuple [cursor location in the modified diff, modified diff]\n */\nfunction cursor_normalize_diff (diffs, cursor_pos) {\n  if (cursor_pos === 0) {\n    return [DIFF_EQUAL, diffs];\n  }\n  for (var current_pos = 0, i = 0; i < diffs.length; i++) {\n    var d = diffs[i];\n    if (d[0] === DIFF_DELETE || d[0] === DIFF_EQUAL) {\n      var next_pos = current_pos + d[1].length;\n      if (cursor_pos === next_pos) {\n        return [i + 1, diffs];\n      } else if (cursor_pos < next_pos) {\n        // copy to prevent side effects\n        diffs = diffs.slice();\n        // split d into two diff changes\n        var split_pos = cursor_pos - current_pos;\n        var d_left = [d[0], d[1].slice(0, split_pos)];\n        var d_right = [d[0], d[1].slice(split_pos)];\n        diffs.splice(i, 1, d_left, d_right);\n        return [i + 1, diffs];\n      } else {\n        current_pos = next_pos;\n      }\n    }\n  }\n  throw new Error('cursor_pos is out of bounds!')\n}\n\n/*\n * Modify a diff such that the edit position is \"shifted\" to the proposed edit location (cursor_position).\n *\n * Case 1)\n *   Check if a naive shift is possible:\n *     [0, X], [ 1, Y] -> [ 1, Y], [0, X]    (if X + Y === Y + X)\n *     [0, X], [-1, Y] -> [-1, Y], [0, X]    (if X + Y === Y + X) - holds same result\n * Case 2)\n *   Check if the following shifts are possible:\n *     [0, 'pre'], [ 1, 'prefix'] -> [ 1, 'pre'], [0, 'pre'], [ 1, 'fix']\n *     [0, 'pre'], [-1, 'prefix'] -> [-1, 'pre'], [0, 'pre'], [-1, 'fix']\n *         ^            ^\n *         d          d_next\n *\n * @param {Array} diffs Array of diff tuples\n * @param {Int} cursor_pos Suggested edit position. Must not be out of bounds!\n * @return {Array} Array of diff tuples\n */\nfunction fix_cursor (diffs, cursor_pos) {\n  var norm = cursor_normalize_diff(diffs, cursor_pos);\n  var ndiffs = norm[1];\n  var cursor_pointer = norm[0];\n  var d = ndiffs[cursor_pointer];\n  var d_next = ndiffs[cursor_pointer + 1];\n\n  if (d == null) {\n    // Text was deleted from end of original string,\n    // cursor is now out of bounds in new string\n    return diffs;\n  } else if (d[0] !== DIFF_EQUAL) {\n    // A modification happened at the cursor location.\n    // This is the expected outcome, so we can return the original diff.\n    return diffs;\n  } else {\n    if (d_next != null && d[1] + d_next[1] === d_next[1] + d[1]) {\n      // Case 1)\n      // It is possible to perform a naive shift\n      ndiffs.splice(cursor_pointer, 2, d_next, d)\n      return merge_tuples(ndiffs, cursor_pointer, 2)\n    } else if (d_next != null && d_next[1].indexOf(d[1]) === 0) {\n      // Case 2)\n      // d[1] is a prefix of d_next[1]\n      // We can assume that d_next[0] !== 0, since d[0] === 0\n      // Shift edit locations..\n      ndiffs.splice(cursor_pointer, 2, [d_next[0], d[1]], [0, d[1]]);\n      var suffix = d_next[1].slice(d[1].length);\n      if (suffix.length > 0) {\n        ndiffs.splice(cursor_pointer + 2, 0, [d_next[0], suffix]);\n      }\n      return merge_tuples(ndiffs, cursor_pointer, 3)\n    } else {\n      // Not possible to perform any modification\n      return diffs;\n    }\n  }\n}\n\n/*\n * Check diff did not split surrogate pairs.\n * Ex. [0, '\\uD83D'], [-1, '\\uDC36'], [1, '\\uDC2F'] -> [-1, '\\uD83D\\uDC36'], [1, '\\uD83D\\uDC2F']\n *     '\\uD83D\\uDC36' === 'ðŸ¶', '\\uD83D\\uDC2F' === 'ðŸ¯'\n *\n * @param {Array} diffs Array of diff tuples\n * @return {Array} Array of diff tuples\n */\nfunction fix_emoji (diffs) {\n  var compact = false;\n  var starts_with_pair_end = function(str) {\n    return str.charCodeAt(0) >= 0xDC00 && str.charCodeAt(0) <= 0xDFFF;\n  }\n  var ends_with_pair_start = function(str) {\n    return str.charCodeAt(str.length-1) >= 0xD800 && str.charCodeAt(str.length-1) <= 0xDBFF;\n  }\n  for (var i = 2; i < diffs.length; i += 1) {\n    if (diffs[i-2][0] === DIFF_EQUAL && ends_with_pair_start(diffs[i-2][1]) &&\n        diffs[i-1][0] === DIFF_DELETE && starts_with_pair_end(diffs[i-1][1]) &&\n        diffs[i][0] === DIFF_INSERT && starts_with_pair_end(diffs[i][1])) {\n      compact = true;\n\n      diffs[i-1][1] = diffs[i-2][1].slice(-1) + diffs[i-1][1];\n      diffs[i][1] = diffs[i-2][1].slice(-1) + diffs[i][1];\n\n      diffs[i-2][1] = diffs[i-2][1].slice(0, -1);\n    }\n  }\n  if (!compact) {\n    return diffs;\n  }\n  var fixed_diffs = [];\n  for (var i = 0; i < diffs.length; i += 1) {\n    if (diffs[i][1].length > 0) {\n      fixed_diffs.push(diffs[i]);\n    }\n  }\n  return fixed_diffs;\n}\n\n/*\n * Try to merge tuples with their neigbors in a given range.\n * E.g. [0, 'a'], [0, 'b'] -> [0, 'ab']\n *\n * @param {Array} diffs Array of diff tuples.\n * @param {Int} start Position of the first element to merge (diffs[start] is also merged with diffs[start - 1]).\n * @param {Int} length Number of consecutive elements to check.\n * @return {Array} Array of merged diff tuples.\n */\nfunction merge_tuples (diffs, start, length) {\n  // Check from (start-1) to (start+length).\n  for (var i = start + length - 1; i >= 0 && i >= start - 1; i--) {\n    if (i + 1 < diffs.length) {\n      var left_d = diffs[i];\n      var right_d = diffs[i+1];\n      if (left_d[0] === right_d[1]) {\n        diffs.splice(i, 2, [left_d[0], left_d[1] + right_d[1]]);\n      }\n    }\n  }\n  return diffs;\n}\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports) {\n\nexports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports) {\n\nvar supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports) {\n\n'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @api private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {Mixed} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @api private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @api public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @api public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Boolean} exists Only check if there are listeners.\n * @returns {Array|Boolean}\n * @api public\n */\nEventEmitter.prototype.listeners = function listeners(event, exists) {\n  var evt = prefix ? prefix + event : event\n    , available = this._events[evt];\n\n  if (exists) return !!available;\n  if (!available) return [];\n  if (available.fn) return [available.fn];\n\n  for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n    ee[i] = available[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @api public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  var listener = new EE(fn, context || this)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn The listener function.\n * @param {Mixed} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  var listener = new EE(fn, context || this, true)\n    , evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;\n  else if (!this._events[evt].fn) this._events[evt].push(listener);\n  else this._events[evt] = [this._events[evt], listener];\n\n  return this;\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {String|Symbol} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {Mixed} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n         listeners.fn === fn\n      && (!once || listeners.once)\n      && (!context || listeners.context === context)\n    ) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n           listeners[i].fn !== fn\n        || (once && !listeners[i].once)\n        || (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else if (--this._eventsCount === 0) this._events = new Events();\n    else delete this._events[evt];\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {String|Symbol} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @api public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) {\n      if (--this._eventsCount === 0) this._events = new Events();\n      else delete this._events[evt];\n    }\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// This function doesn't apply anymore.\n//\nEventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n  return this;\n};\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchText = exports.matchSpacing = exports.matchNewline = exports.matchBlot = exports.matchAttributor = exports.default = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _extend2 = __webpack_require__(3);\n\nvar _extend3 = _interopRequireDefault(_extend2);\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _quill = __webpack_require__(5);\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _logger = __webpack_require__(10);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _module = __webpack_require__(9);\n\nvar _module2 = _interopRequireDefault(_module);\n\nvar _align = __webpack_require__(36);\n\nvar _background = __webpack_require__(37);\n\nvar _code = __webpack_require__(13);\n\nvar _code2 = _interopRequireDefault(_code);\n\nvar _color = __webpack_require__(26);\n\nvar _direction = __webpack_require__(38);\n\nvar _font = __webpack_require__(39);\n\nvar _size = __webpack_require__(40);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar debug = (0, _logger2.default)('quill:clipboard');\n\nvar DOM_KEY = '__ql-matcher';\n\nvar CLIPBOARD_CONFIG = [[Node.TEXT_NODE, matchText], [Node.TEXT_NODE, matchNewline], ['br', matchBreak], [Node.ELEMENT_NODE, matchNewline], [Node.ELEMENT_NODE, matchBlot], [Node.ELEMENT_NODE, matchSpacing], [Node.ELEMENT_NODE, matchAttributor], [Node.ELEMENT_NODE, matchStyles], ['li', matchIndent], ['b', matchAlias.bind(matchAlias, 'bold')], ['i', matchAlias.bind(matchAlias, 'italic')], ['style', matchIgnore]];\n\nvar ATTRIBUTE_ATTRIBUTORS = [_align.AlignAttribute, _direction.DirectionAttribute].reduce(function (memo, attr) {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\n\nvar STYLE_ATTRIBUTORS = [_align.AlignStyle, _background.BackgroundStyle, _color.ColorStyle, _direction.DirectionStyle, _font.FontStyle, _size.SizeStyle].reduce(function (memo, attr) {\n  memo[attr.keyName] = attr;\n  return memo;\n}, {});\n\nvar Clipboard = function (_Module) {\n  _inherits(Clipboard, _Module);\n\n  function Clipboard(quill, options) {\n    _classCallCheck(this, Clipboard);\n\n    var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this, quill, options));\n\n    _this.quill.root.addEventListener('paste', _this.onPaste.bind(_this));\n    _this.container = _this.quill.addContainer('ql-clipboard');\n    _this.container.setAttribute('contenteditable', true);\n    _this.container.setAttribute('tabindex', -1);\n    _this.matchers = [];\n    CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          selector = _ref2[0],\n          matcher = _ref2[1];\n\n      if (!options.matchVisual && matcher === matchSpacing) return;\n      _this.addMatcher(selector, matcher);\n    });\n    return _this;\n  }\n\n  _createClass(Clipboard, [{\n    key: 'addMatcher',\n    value: function addMatcher(selector, matcher) {\n      this.matchers.push([selector, matcher]);\n    }\n  }, {\n    key: 'convert',\n    value: function convert(html) {\n      if (typeof html === 'string') {\n        this.container.innerHTML = html.replace(/\\>\\r?\\n +\\</g, '><'); // Remove spaces between tags\n        return this.convert();\n      }\n      var formats = this.quill.getFormat(this.quill.selection.savedRange.index);\n      if (formats[_code2.default.blotName]) {\n        var text = this.container.innerText;\n        this.container.innerHTML = '';\n        return new _quillDelta2.default().insert(text, _defineProperty({}, _code2.default.blotName, formats[_code2.default.blotName]));\n      }\n\n      var _prepareMatching = this.prepareMatching(),\n          _prepareMatching2 = _slicedToArray(_prepareMatching, 2),\n          elementMatchers = _prepareMatching2[0],\n          textMatchers = _prepareMatching2[1];\n\n      var delta = traverse(this.container, elementMatchers, textMatchers);\n      // Remove trailing newline\n      if (deltaEndsWith(delta, '\\n') && delta.ops[delta.ops.length - 1].attributes == null) {\n        delta = delta.compose(new _quillDelta2.default().retain(delta.length() - 1).delete(1));\n      }\n      debug.log('convert', this.container.innerHTML, delta);\n      this.container.innerHTML = '';\n      return delta;\n    }\n  }, {\n    key: 'dangerouslyPasteHTML',\n    value: function dangerouslyPasteHTML(index, html) {\n      var source = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _quill2.default.sources.API;\n\n      if (typeof index === 'string') {\n        this.quill.setContents(this.convert(index), html);\n        this.quill.setSelection(0, _quill2.default.sources.SILENT);\n      } else {\n        var paste = this.convert(html);\n        this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste), source);\n        this.quill.setSelection(index + paste.length(), _quill2.default.sources.SILENT);\n      }\n    }\n  }, {\n    key: 'onPaste',\n    value: function onPaste(e) {\n      var _this2 = this;\n\n      if (e.defaultPrevented || !this.quill.isEnabled()) return;\n      var range = this.quill.getSelection();\n      var delta = new _quillDelta2.default().retain(range.index);\n      var scrollTop = this.quill.scrollingContainer.scrollTop;\n      this.container.focus();\n      this.quill.selection.update(_quill2.default.sources.SILENT);\n      setTimeout(function () {\n        delta = delta.concat(_this2.convert()).delete(range.length);\n        _this2.quill.updateContents(delta, _quill2.default.sources.USER);\n        // range.length contributes to delta.length()\n        _this2.quill.setSelection(delta.length() - range.length, _quill2.default.sources.SILENT);\n        _this2.quill.scrollingContainer.scrollTop = scrollTop;\n        _this2.quill.focus();\n      }, 1);\n    }\n  }, {\n    key: 'prepareMatching',\n    value: function prepareMatching() {\n      var _this3 = this;\n\n      var elementMatchers = [],\n          textMatchers = [];\n      this.matchers.forEach(function (pair) {\n        var _pair = _slicedToArray(pair, 2),\n            selector = _pair[0],\n            matcher = _pair[1];\n\n        switch (selector) {\n          case Node.TEXT_NODE:\n            textMatchers.push(matcher);\n            break;\n          case Node.ELEMENT_NODE:\n            elementMatchers.push(matcher);\n            break;\n          default:\n            [].forEach.call(_this3.container.querySelectorAll(selector), function (node) {\n              // TODO use weakmap\n              node[DOM_KEY] = node[DOM_KEY] || [];\n              node[DOM_KEY].push(matcher);\n            });\n            break;\n        }\n      });\n      return [elementMatchers, textMatchers];\n    }\n  }]);\n\n  return Clipboard;\n}(_module2.default);\n\nClipboard.DEFAULTS = {\n  matchers: [],\n  matchVisual: true\n};\n\nfunction applyFormat(delta, format, value) {\n  if ((typeof format === 'undefined' ? 'undefined' : _typeof(format)) === 'object') {\n    return Object.keys(format).reduce(function (delta, key) {\n      return applyFormat(delta, key, format[key]);\n    }, delta);\n  } else {\n    return delta.reduce(function (delta, op) {\n      if (op.attributes && op.attributes[format]) {\n        return delta.push(op);\n      } else {\n        return delta.insert(op.insert, (0, _extend3.default)({}, _defineProperty({}, format, value), op.attributes));\n      }\n    }, new _quillDelta2.default());\n  }\n}\n\nfunction computeStyle(node) {\n  if (node.nodeType !== Node.ELEMENT_NODE) return {};\n  var DOM_KEY = '__ql-computed-style';\n  return node[DOM_KEY] || (node[DOM_KEY] = window.getComputedStyle(node));\n}\n\nfunction deltaEndsWith(delta, text) {\n  var endText = \"\";\n  for (var i = delta.ops.length - 1; i >= 0 && endText.length < text.length; --i) {\n    var op = delta.ops[i];\n    if (typeof op.insert !== 'string') break;\n    endText = op.insert + endText;\n  }\n  return endText.slice(-1 * text.length) === text;\n}\n\nfunction isLine(node) {\n  if (node.childNodes.length === 0) return false; // Exclude embed blocks\n  var style = computeStyle(node);\n  return ['block', 'list-item'].indexOf(style.display) > -1;\n}\n\nfunction traverse(node, elementMatchers, textMatchers) {\n  // Post-order\n  if (node.nodeType === node.TEXT_NODE) {\n    return textMatchers.reduce(function (delta, matcher) {\n      return matcher(node, delta);\n    }, new _quillDelta2.default());\n  } else if (node.nodeType === node.ELEMENT_NODE) {\n    return [].reduce.call(node.childNodes || [], function (delta, childNode) {\n      var childrenDelta = traverse(childNode, elementMatchers, textMatchers);\n      if (childNode.nodeType === node.ELEMENT_NODE) {\n        childrenDelta = elementMatchers.reduce(function (childrenDelta, matcher) {\n          return matcher(childNode, childrenDelta);\n        }, childrenDelta);\n        childrenDelta = (childNode[DOM_KEY] || []).reduce(function (childrenDelta, matcher) {\n          return matcher(childNode, childrenDelta);\n        }, childrenDelta);\n      }\n      return delta.concat(childrenDelta);\n    }, new _quillDelta2.default());\n  } else {\n    return new _quillDelta2.default();\n  }\n}\n\nfunction matchAlias(format, node, delta) {\n  return applyFormat(delta, format, true);\n}\n\nfunction matchAttributor(node, delta) {\n  var attributes = _parchment2.default.Attributor.Attribute.keys(node);\n  var classes = _parchment2.default.Attributor.Class.keys(node);\n  var styles = _parchment2.default.Attributor.Style.keys(node);\n  var formats = {};\n  attributes.concat(classes).concat(styles).forEach(function (name) {\n    var attr = _parchment2.default.query(name, _parchment2.default.Scope.ATTRIBUTE);\n    if (attr != null) {\n      formats[attr.attrName] = attr.value(node);\n      if (formats[attr.attrName]) return;\n    }\n    attr = ATTRIBUTE_ATTRIBUTORS[name];\n    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n      formats[attr.attrName] = attr.value(node) || undefined;\n    }\n    attr = STYLE_ATTRIBUTORS[name];\n    if (attr != null && (attr.attrName === name || attr.keyName === name)) {\n      attr = STYLE_ATTRIBUTORS[name];\n      formats[attr.attrName] = attr.value(node) || undefined;\n    }\n  });\n  if (Object.keys(formats).length > 0) {\n    delta = applyFormat(delta, formats);\n  }\n  return delta;\n}\n\nfunction matchBlot(node, delta) {\n  var match = _parchment2.default.query(node);\n  if (match == null) return delta;\n  if (match.prototype instanceof _parchment2.default.Embed) {\n    var embed = {};\n    var value = match.value(node);\n    if (value != null) {\n      embed[match.blotName] = value;\n      delta = new _quillDelta2.default().insert(embed, match.formats(node));\n    }\n  } else if (typeof match.formats === 'function') {\n    delta = applyFormat(delta, match.blotName, match.formats(node));\n  }\n  return delta;\n}\n\nfunction matchBreak(node, delta) {\n  if (!deltaEndsWith(delta, '\\n')) {\n    delta.insert('\\n');\n  }\n  return delta;\n}\n\nfunction matchIgnore() {\n  return new _quillDelta2.default();\n}\n\nfunction matchIndent(node, delta) {\n  var match = _parchment2.default.query(node);\n  if (match == null || match.blotName !== 'list-item' || !deltaEndsWith(delta, '\\n')) {\n    return delta;\n  }\n  var indent = -1,\n      parent = node.parentNode;\n  while (!parent.classList.contains('ql-clipboard')) {\n    if ((_parchment2.default.query(parent) || {}).blotName === 'list') {\n      indent += 1;\n    }\n    parent = parent.parentNode;\n  }\n  if (indent <= 0) return delta;\n  return delta.compose(new _quillDelta2.default().retain(delta.length() - 1).retain(1, { indent: indent }));\n}\n\nfunction matchNewline(node, delta) {\n  if (!deltaEndsWith(delta, '\\n')) {\n    if (isLine(node) || delta.length() > 0 && node.nextSibling && isLine(node.nextSibling)) {\n      delta.insert('\\n');\n    }\n  }\n  return delta;\n}\n\nfunction matchSpacing(node, delta) {\n  if (isLine(node) && node.nextElementSibling != null && !deltaEndsWith(delta, '\\n\\n')) {\n    var nodeHeight = node.offsetHeight + parseFloat(computeStyle(node).marginTop) + parseFloat(computeStyle(node).marginBottom);\n    if (node.nextElementSibling.offsetTop > node.offsetTop + nodeHeight * 1.5) {\n      delta.insert('\\n');\n    }\n  }\n  return delta;\n}\n\nfunction matchStyles(node, delta) {\n  var formats = {};\n  var style = node.style || {};\n  if (style.fontStyle && computeStyle(node).fontStyle === 'italic') {\n    formats.italic = true;\n  }\n  if (style.fontWeight && (computeStyle(node).fontWeight.startsWith('bold') || parseInt(computeStyle(node).fontWeight) >= 700)) {\n    formats.bold = true;\n  }\n  if (Object.keys(formats).length > 0) {\n    delta = applyFormat(delta, formats);\n  }\n  if (parseFloat(style.textIndent || 0) > 0) {\n    // Could be 0.5in\n    delta = new _quillDelta2.default().insert('\\t').concat(delta);\n  }\n  return delta;\n}\n\nfunction matchText(node, delta) {\n  var text = node.data;\n  // Word represents empty line with <o:p>&nbsp;</o:p>\n  if (node.parentNode.tagName === 'O:P') {\n    return delta.insert(text.trim());\n  }\n  if (text.trim().length === 0 && node.parentNode.classList.contains('ql-clipboard')) {\n    return delta;\n  }\n  if (!computeStyle(node.parentNode).whiteSpace.startsWith('pre')) {\n    // eslint-disable-next-line func-style\n    var replacer = function replacer(collapse, match) {\n      match = match.replace(/[^\\u00a0]/g, ''); // \\u00a0 is nbsp;\n      return match.length < 1 && collapse ? ' ' : match;\n    };\n    text = text.replace(/\\r\\n/g, ' ').replace(/\\n/g, ' ');\n    text = text.replace(/\\s\\s+/g, replacer.bind(replacer, true)); // collapse whitespace\n    if (node.previousSibling == null && isLine(node.parentNode) || node.previousSibling != null && isLine(node.previousSibling)) {\n      text = text.replace(/^\\s+/, replacer.bind(replacer, false));\n    }\n    if (node.nextSibling == null && isLine(node.parentNode) || node.nextSibling != null && isLine(node.nextSibling)) {\n      text = text.replace(/\\s+$/, replacer.bind(replacer, false));\n    }\n  }\n  return delta.insert(text);\n}\n\nexports.default = Clipboard;\nexports.matchAttributor = matchAttributor;\nexports.matchBlot = matchBlot;\nexports.matchNewline = matchNewline;\nexports.matchSpacing = matchSpacing;\nexports.matchText = matchText;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _inline = __webpack_require__(6);\n\nvar _inline2 = _interopRequireDefault(_inline);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Bold = function (_Inline) {\n  _inherits(Bold, _Inline);\n\n  function Bold() {\n    _classCallCheck(this, Bold);\n\n    return _possibleConstructorReturn(this, (Bold.__proto__ || Object.getPrototypeOf(Bold)).apply(this, arguments));\n  }\n\n  _createClass(Bold, [{\n    key: 'optimize',\n    value: function optimize(context) {\n      _get(Bold.prototype.__proto__ || Object.getPrototypeOf(Bold.prototype), 'optimize', this).call(this, context);\n      if (this.domNode.tagName !== this.statics.tagName[0]) {\n        this.replaceWith(this.statics.blotName);\n      }\n    }\n  }], [{\n    key: 'create',\n    value: function create() {\n      return _get(Bold.__proto__ || Object.getPrototypeOf(Bold), 'create', this).call(this);\n    }\n  }, {\n    key: 'formats',\n    value: function formats() {\n      return true;\n    }\n  }]);\n\n  return Bold;\n}(_inline2.default);\n\nBold.blotName = 'bold';\nBold.tagName = ['STRONG', 'B'];\n\nexports.default = Bold;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addControls = exports.default = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _quillDelta = __webpack_require__(2);\n\nvar _quillDelta2 = _interopRequireDefault(_quillDelta);\n\nvar _parchment = __webpack_require__(0);\n\nvar _parchment2 = _interopRequireDefault(_parchment);\n\nvar _quill = __webpack_require__(5);\n\nvar _quill2 = _interopRequireDefault(_quill);\n\nvar _logger = __webpack_require__(10);\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _module = __webpack_require__(9);\n\nvar _module2 = _interopRequireDefault(_module);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar debug = (0, _logger2.default)('quill:toolbar');\n\nvar Toolbar = function (_Module) {\n  _inherits(Toolbar, _Module);\n\n  function Toolbar(quill, options) {\n    _classCallCheck(this, Toolbar);\n\n    var _this = _possibleConstructorReturn(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, quill, options));\n\n    if (Array.isArray(_this.options.container)) {\n      var container = document.createElement('div');\n      addControls(container, _this.options.container);\n      quill.container.parentNode.insertBefore(container, quill.container);\n      _this.container = container;\n    } else if (typeof _this.options.container === 'string') {\n      _this.container = document.querySelector(_this.options.container);\n    } else {\n      _this.container = _this.options.container;\n    }\n    if (!(_this.container instanceof HTMLElement)) {\n      var _ret;\n\n      return _ret = debug.error('Container required for toolbar', _this.options), _possibleConstructorReturn(_this, _ret);\n    }\n    _this.container.classList.add('ql-toolbar');\n    _this.controls = [];\n    _this.handlers = {};\n    Object.keys(_this.options.handlers).forEach(function (format) {\n      _this.addHandler(format, _this.options.handlers[format]);\n    });\n    [].forEach.call(_this.container.querySelectorAll('button, select'), function (input) {\n      _this.attach(input);\n    });\n    _this.quill.on(_quill2.default.events.EDITOR_CHANGE, function (type, range) {\n      if (type === _quill2.default.events.SELECTION_CHANGE) {\n        _this.update(range);\n      }\n    });\n    _this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE, function () {\n      var _this$quill$selection = _this.quill.selection.getRange(),\n          _this$quill$selection2 = _slicedToArray(_this$quill$selection, 1),\n          range = _this$quill$selection2[0]; // quill.getSelection triggers update\n\n\n      _this.update(range);\n    });\n    return _this;\n  }\n\n  _createClass(Toolbar, [{\n    key: 'addHandler',\n    value: function addHandler(format, handler) {\n      this.handlers[format] = handler;\n    }\n  }, {\n    key: 'attach',\n    value: function attach(input) {\n      var _this2 = this;\n\n      var format = [].find.call(input.classList, function (className) {\n        return className.indexOf('ql-') === 0;\n      });\n      if (!format) return;\n      format = format.slice('ql-'.length);\n      if (input.tagName === 'BUTTON') {\n        input.setAttribute('type', 'button');\n      }\n      if (this.handlers[format] == null) {\n        if (this.quill.scroll.whitelist != null && this.quill.scroll.whitelist[format] == null) {\n          debug.warn('ignoring attaching to disabled format', format, input);\n          return;\n        }\n        if (_parchment2.default.query(format) == null) {\n          debug.warn('ignoring attaching to nonexistent format', format, input);\n          return;\n        }\n      }\n      var eventName = input.tagName === 'SELECT' ? 'change' : 'click';\n      input.addEventListener(eventName, function (e) {\n        var value = void 0;\n        if (input.tagName === 'SELECT') {\n          if (input.selectedIndex < 0) return;\n          var selected = input.options[input.selectedIndex];\n          if (selected.hasAttribute('selected')) {\n            value = false;\n          } else {\n            value = selected.value || false;\n          }\n        } else {\n          if (input.classList.contains('ql-active')) {\n            value = false;\n          } else {\n            value = input.value || !input.hasAttribute('value');\n          }\n          e.preventDefault();\n        }\n        _this2.quill.focus();\n\n        var _quill$selection$getR = _this2.quill.selection.getRange(),\n            _quill$selection$getR2 = _slicedToArray(_quill$selection$getR, 1),\n            range = _quill$selection$getR2[0];\n\n        if (_this2.handlers[format] != null) {\n          _this2.handlers[format].call(_this2, value);\n        } else if (_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed) {\n          value = prompt('Enter ' + format);\n          if (!value) return;\n          _this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({}, format, value)), _quill2.default.sources.USER);\n        } else {\n          _this2.quill.format(format, value, _quill2.default.sources.USER);\n        }\n        _this2.update(range);\n      });\n      // TODO use weakmap\n      this.controls.push([format, input]);\n    }\n  }, {\n    key: 'update',\n    value: function update(range) {\n      var formats = range == null ? {} : this.quill.getFormat(range);\n      this.controls.forEach(function (pair) {\n        var _pair = _slicedToArray(pair, 2),\n            format = _pair[0],\n            input = _pair[1];\n\n        if (input.tagName === 'SELECT') {\n          var option = void 0;\n          if (range == null) {\n            option = null;\n          } else if (formats[format] == null) {\n            option = input.querySelector('option[selected]');\n          } else if (!Array.isArray(formats[format])) {\n            var value = formats[format];\n            if (typeof value === 'string') {\n              value = value.replace(/\\\"/g, '\\\\\"');\n            }\n            option = input.querySelector('option[value=\"' + value + '\"]');\n          }\n          if (option == null) {\n            input.value = ''; // TODO make configurable?\n            input.selectedIndex = -1;\n          } else {\n            option.selected = true;\n          }\n        } else {\n          if (range == null) {\n            input.classList.remove('ql-active');\n          } else if (input.hasAttribute('value')) {\n            // both being null should match (default values)\n            // '1' should match with 1 (headers)\n            var isActive = formats[format] === input.getAttribute('value') || formats[format] != null && formats[format].toString() === input.getAttribute('value') || formats[format] == null && !input.getAttribute('value');\n            input.classList.toggle('ql-active', isActive);\n          } else {\n            input.classList.toggle('ql-active', formats[format] != null);\n          }\n        }\n      });\n    }\n  }]);\n\n  return Toolbar;\n}(_module2.default);\n\nToolbar.DEFAULTS = {};\n\nfunction addButton(container, format, value) {\n  var input = document.createElement('button');\n  input.setAttribute('type', 'button');\n  input.classList.add('ql-' + format);\n  if (value != null) {\n    input.value = value;\n  }\n  container.appendChild(input);\n}\n\nfunction addControls(container, groups) {\n  if (!Array.isArray(groups[0])) {\n    groups = [groups];\n  }\n  groups.forEach(function (controls) {\n    var group = document.createElement('span');\n    group.classList.add('ql-formats');\n    controls.forEach(function (control) {\n      if (typeof control === 'string') {\n        addButton(group, control);\n      } else {\n        var format = Object.keys(control)[0];\n        var value = control[format];\n        if (Array.isArray(value)) {\n          addSelect(group, format, value);\n        } else {\n          addButton(group, format, value);\n        }\n      }\n    });\n    container.appendChild(group);\n  });\n}\n\nfunction addSelect(container, format, values) {\n  var input = document.createElement('select');\n  input.classList.add('ql-' + format);\n  values.forEach(function (value) {\n    var option = document.createElement('option');\n    if (value !== false) {\n      option.setAttribute('value', value);\n    } else {\n      option.setAttribute('selected', 'selected');\n    }\n    input.appendChild(option);\n  });\n  container.appendChild(input);\n}\n\nToolbar.DEFAULTS = {\n  container: null,\n  handlers: {\n    clean: function clean() {\n      var _this3 = this;\n\n      var range = this.quill.getSelection();\n      if (range == null) return;\n      if (range.length == 0) {\n        var formats = this.quill.getFormat();\n        Object.keys(formats).forEach(function (name) {\n          // Clean functionality in existing apps only clean inline formats\n          if (_parchment2.default.query(name, _parchment2.default.Scope.INLINE) != null) {\n            _this3.quill.format(name, false);\n          }\n        });\n      } else {\n        this.quill.removeFormat(range, _quill2.default.sources.USER);\n      }\n    },\n    direction: function direction(value) {\n      var align = this.quill.getFormat()['align'];\n      if (value === 'rtl' && align == null) {\n        this.quill.format('align', 'right', _quill2.default.sources.USER);\n      } else if (!value && align === 'right') {\n        this.quill.format('align', false, _quill2.default.sources.USER);\n      }\n      this.quill.format('direction', value, _quill2.default.sources.USER);\n    },\n    indent: function indent(value) {\n      var range = this.quill.getSelection();\n      var formats = this.quill.getFormat(range);\n      var indent = parseInt(formats.indent || 0);\n      if (value === '+1' || value === '-1') {\n        var modifier = value === '+1' ? 1 : -1;\n        if (formats.direction === 'rtl') modifier *= -1;\n        this.quill.format('indent', indent + modifier, _quill2.default.sources.USER);\n      }\n    },\n    link: function link(value) {\n      if (value === true) {\n        value = prompt('Enter link URL:');\n      }\n      this.quill.format('link', value, _quill2.default.sources.USER);\n    },\n    list: function list(value) {\n      var range = this.quill.getSelection();\n      var formats = this.quill.getFormat(range);\n      if (value === 'check') {\n        if (formats['list'] === 'checked' || formats['list'] === 'unchecked') {\n          this.quill.format('list', false, _quill2.default.sources.USER);\n        } else {\n          this.quill.format('list', 'unchecked', _quill2.default.sources.USER);\n        }\n      } else {\n        this.quill.format('list', value, _quill2.default.sources.USER);\n      }\n    }\n  }\n};\n\nexports.default = Toolbar;\nexports.addControls = addControls;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports) {\n\nmodule.exports = \"<svg viewbox=\\\"0 0 18 18\\\"> <polyline class=\\\"ql-even ql-stroke\\\" points=\\\"5 7 3 9 5 11\\\"></polyline> <polyline class=\\\"ql-even ql-stroke\\\" points=\\\"13 7 15 9 13 11\\\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>\";\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _picker = __webpack_require__(28);\n\nvar _picker2 = _interopRequireDefault(_picker);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ColorPicker = function (_Picker) {\n  _inherits(ColorPicker, _Picker);\n\n  function ColorPicker(select, label) {\n    _classCallCheck(this, ColorPicker);\n\n    var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this, select));\n\n    _this.label.innerHTML = label;\n    _this.container.classList.add('ql-color-picker');\n    [].slice.call(_this.container.querySelectorAll('.ql-picker-item'), 0, 7).forEach(function (item) {\n      item.classList.add('ql-primary');\n    });\n    return _this;\n  }\n\n  _createClass(ColorPicker, [{\n    key: 'buildItem',\n    value: function buildItem(option) {\n      var item = _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'buildItem', this).call(this, option);\n      item.style.backgroundColor = option.getAttribute('value') || '';\n      return item;\n    }\n  }, {\n    key: 'selectItem',\n    value: function selectItem(item, trigger) {\n      _get(ColorPicker.prototype.__proto__ || Object.getPrototypeOf(ColorPicker.prototype), 'selectItem', this).call(this, item, trigger);\n      var colorLabel = this.label.querySelector('.ql-color-label');\n      var value = item ? item.getAttribute('data-value') || '' : '';\n      if (colorLabel) {\n        if (colorLabel.tagName === 'line') {\n          colorLabel.style.stroke = value;\n        } else {\n          colorLabel.style.fill = value;\n        }\n      }\n    }\n  }]);\n\n  return ColorPicker;\n}(_picker2.default);\n\nexports.default = ColorPicker;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _picker = __webpack_require__(28);\n\nvar _picker2 = _interopRequireDefault(_picker);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar IconPicker = function (_Picker) {\n  _inherits(IconPicker, _Picker);\n\n  function IconPicker(select, icons) {\n    _classCallCheck(this, IconPicker);\n\n    var _this = _possibleConstructorReturn(this, (IconPicker.__proto__ || Object.getPrototypeOf(IconPicker)).call(this, select));\n\n    _this.container.classList.add('ql-icon-picker');\n    [].forEach.call(_this.container.querySelectorAll('.ql-picker-item'), function (item) {\n      item.innerHTML = icons[item.getAttribute('data-value') || ''];\n    });\n    _this.defaultItem = _this.container.querySelector('.ql-selected');\n    _this.selectItem(_this.defaultItem);\n    return _this;\n  }\n\n  _createClass(IconPicker, [{\n    key: 'selectItem',\n    value: function selectItem(item, trigger) {\n      _get(IconPicker.prototype.__proto__ || Object.getPrototypeOf(IconPicker.prototype), 'selectItem', this).call(this, item, trigger);\n      item = item || this.defaultItem;\n      this.label.innerHTML = item.innerHTML;\n    }\n  }]);\n\n  return IconPicker;\n}(_picker2.default);\n\nexports.default = IconPicker;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Tooltip = function () {\n  function Tooltip(quill, boundsContainer) {\n    var _this = this;\n\n    _classCallCheck(this, Tooltip);\n\n    this.quill = quill;\n    this.boundsContainer = boundsContainer || document.body;\n    this.root = quill.addContainer('ql-tooltip');\n    this.root.innerHTML = this.constructor.TEMPLATE;\n    if (this.quill.root === this.quill.scrollingContainer) {\n      this.quill.root.addEventListener('scroll', function () {\n        _this.root.style.marginTop = -1 * _this.quill.root.scrollTop + 'px';\n      });\n    }\n    this.hide();\n  }\n\n  _createClass(Tooltip, [{\n    key: 'hide',\n    value: function hide() {\n      this.root.classList.add('ql-hidden');\n    }\n  }, {\n    key: 'position',\n    value: function position(reference) {\n      var left = reference.left + reference.width / 2 - this.root.offsetWidth / 2;\n      // root.scrollTop should be 0 if scrollContainer !== root\n      var top = reference.bottom + this.quill.root.scrollTop;\n      this.root.style.left = left + 'px';\n      this.root.style.top = top + 'px';\n      this.root.classList.remove('ql-flip');\n      var containerBounds = this.boundsContainer.getBoundingClientRect();\n      var rootBounds = this.root.getBoundingClientRect();\n      var shift = 0;\n      if (rootBounds.right > containerBounds.right) {\n        shift = containerBounds.right - rootBounds.right;\n        this.root.style.left = left + shift + 'px';\n      }\n      if (rootBounds.left < containerBounds.left) {\n        shift = containerBounds.left - rootBounds.left;\n        this.root.style.left = left + shift + 'px';\n      }\n      if (rootBounds.bottom > containerBounds.bottom) {\n        var height = rootBounds.bottom - rootBounds.top;\n        var verticalShift = reference.bottom - reference.top + height;\n        this.root.style.top = top - verticalShift + 'px';\n        this.root.classList.add('ql-flip');\n      }\n      return shift;\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      this.root.classList.remove('ql-editing');\n      this.root.classList.remove('ql-hidden');\n    }\n  }]);\n\n  return Tooltip;\n}();\n\nexports.default = Tooltip;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps)
